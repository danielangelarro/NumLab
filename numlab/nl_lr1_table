0
arith_expr
1
0
try
2
0
modopt
3
0
compound_stmt
4
0
test
5
0
servmod
6
0
while
7
0
and_expr
8
0
power
9
0
STRING
10
0
decorated
11
0
cli_serv_model
12
0
@
13
0
try_stmt
14
0
lambdef
15
0
(
16
0
factor
17
0
[
18
0
class
19
0
small_stmt
20
0
{
21
0
term
22
0
def
23
0
server
24
0
while_stmt
25
0
-
26
0
+
27
0
for
28
0
lambda
29
0
decorators
30
0
atom_expr
31
0
not_test
32
0
if_stmt
33
0
yield
34
0
conf
35
0
test_list
36
0
~
37
0
True
38
0
False
39
0
funcdef
40
0
xor_expr
41
0
with
42
0
if
43
0
for_stmt
44
0
sim_stmt
45
0
and_test
46
0
expr
47
0
shift_expr
48
0
comparison
49
0
with_stmt
50
0
simple_stmt
51
0
NAME
52
0
or_test
53
0
confdef
54
0
None
55
0
classdef
56
0
atom
57
0
NUMBER
58
0
return
59
0
break_stmt
60
0
return_stmt
61
0
not
62
0
break
63
0
raise
64
0
expr_stmt
65
0
stat_stmt
66
0
decorator
67
0
assert_stmt
68
0
begsim
69
0
global
70
0
assert
71
0
nonlocal
72
0
$
program -> 
0
nonlocal_stmt
73
0
raise_stmt
74
0
yield_stmt
75
0
stmt
76
0
continue
77
0
endsim
78
0
program
79
0
del
80
0
pass_stmt
81
0
flow_stmt
82
0
NEWLINE
83
0
resetstats
84
0
del_stmt
85
0
continue_stmt
86
0
global_stmt
87
0
pass
88
1
>>
89
1
<<
90
1
|
shift_expr -> arith_expr
1
+=
shift_expr -> arith_expr
1
==
shift_expr -> arith_expr
1
<
shift_expr -> arith_expr
1
%=
shift_expr -> arith_expr
1
<=
shift_expr -> arith_expr
1
,
shift_expr -> arith_expr
1
|=
shift_expr -> arith_expr
1
is
shift_expr -> arith_expr
1
or
shift_expr -> arith_expr
1
>
shift_expr -> arith_expr
1
!=
shift_expr -> arith_expr
1
**=
shift_expr -> arith_expr
1
:
shift_expr -> arith_expr
1
not
shift_expr -> arith_expr
1
&
shift_expr -> arith_expr
1
>>=
shift_expr -> arith_expr
1
//=
shift_expr -> arith_expr
1
<<=
shift_expr -> arith_expr
1
in
shift_expr -> arith_expr
1
*=
shift_expr -> arith_expr
1
^
shift_expr -> arith_expr
1
^=
shift_expr -> arith_expr
1
if
shift_expr -> arith_expr
1
-=
shift_expr -> arith_expr
1
=
shift_expr -> arith_expr
1
NEWLINE
shift_expr -> arith_expr
1
&=
shift_expr -> arith_expr
1
>=
shift_expr -> arith_expr
1
@=
shift_expr -> arith_expr
1
/=
shift_expr -> arith_expr
1
and
shift_expr -> arith_expr
2
:
91
3
NAME
92
4
yield
stmt -> compound_stmt
4
modopt
stmt -> compound_stmt
4
try
stmt -> compound_stmt
4
-
stmt -> compound_stmt
4
STRING
stmt -> compound_stmt
4
begsim
stmt -> compound_stmt
4
{
stmt -> compound_stmt
4
True
stmt -> compound_stmt
4
nonlocal
stmt -> compound_stmt
4
resetstats
stmt -> compound_stmt
4
NAME
stmt -> compound_stmt
4
~
stmt -> compound_stmt
4
server
stmt -> compound_stmt
4
lambda
stmt -> compound_stmt
4
def
stmt -> compound_stmt
4
servmod
stmt -> compound_stmt
4
not
stmt -> compound_stmt
4
NUMBER
stmt -> compound_stmt
4
NEWLINE
stmt -> compound_stmt
4
global
stmt -> compound_stmt
4
conf
stmt -> compound_stmt
4
break
stmt -> compound_stmt
4
if
stmt -> compound_stmt
4
(
stmt -> compound_stmt
4
assert
stmt -> compound_stmt
4
class
stmt -> compound_stmt
4
del
stmt -> compound_stmt
4
pass
stmt -> compound_stmt
4
False
stmt -> compound_stmt
4
continue
stmt -> compound_stmt
4
raise
stmt -> compound_stmt
4
[
stmt -> compound_stmt
4
return
stmt -> compound_stmt
4
for
stmt -> compound_stmt
4
with
stmt -> compound_stmt
4
while
stmt -> compound_stmt
4
$
stmt -> compound_stmt
4
None
stmt -> compound_stmt
4
@
stmt -> compound_stmt
4
+
stmt -> compound_stmt
4
endsim
stmt -> compound_stmt
5
*=
test_list -> test
5
,
93
5
&=
test_list -> test
5
%=
test_list -> test
5
**=
test_list -> test
5
//=
test_list -> test
5
|=
test_list -> test
5
^=
test_list -> test
5
<<=
test_list -> test
5
=
test_list -> test
5
-=
test_list -> test
5
@=
test_list -> test
5
+=
test_list -> test
5
:
test_list -> test
5
>>=
test_list -> test
5
NEWLINE
test_list -> test
5
/=
test_list -> test
6
NAME
94
7
[
95
7
factor
96
7
True
97
7
atom_expr
98
7
~
99
7
and_expr
100
7
-
101
7
atom
102
7
{
103
7
or_test
104
7
arith_expr
105
7
power
106
7
STRING
107
7
NAME
108
7
(
109
7
and_test
110
7
term
111
7
+
112
7
xor_expr
113
7
test
114
7
shift_expr
115
7
NUMBER
116
7
not
117
7
False
118
7
expr
119
7
not_test
120
7
comparison
121
7
None
122
7
lambdef
123
7
lambda
124
8
NEWLINE
xor_expr -> and_expr
8
^
125
8
+=
xor_expr -> and_expr
8
>
xor_expr -> and_expr
8
<=
xor_expr -> and_expr
8
//=
xor_expr -> and_expr
8
not
xor_expr -> and_expr
8
|
xor_expr -> and_expr
8
==
xor_expr -> and_expr
8
>>=
xor_expr -> and_expr
8
*=
xor_expr -> and_expr
8
/=
xor_expr -> and_expr
8
,
xor_expr -> and_expr
8
<<=
xor_expr -> and_expr
8
|=
xor_expr -> and_expr
8
in
xor_expr -> and_expr
8
^=
xor_expr -> and_expr
8
%=
xor_expr -> and_expr
8
!=
xor_expr -> and_expr
8
:
xor_expr -> and_expr
8
if
xor_expr -> and_expr
8
is
xor_expr -> and_expr
8
<
xor_expr -> and_expr
8
**=
xor_expr -> and_expr
8
=
xor_expr -> and_expr
8
or
xor_expr -> and_expr
8
-=
xor_expr -> and_expr
8
&=
xor_expr -> and_expr
8
@=
xor_expr -> and_expr
8
>=
xor_expr -> and_expr
8
and
xor_expr -> and_expr
9
/=
factor -> power
9
+=
factor -> power
9
%
factor -> power
9
+
factor -> power
9
:
factor -> power
9
=
factor -> power
9
<<=
factor -> power
9
^=
factor -> power
9
,
factor -> power
9
*=
factor -> power
9
<
factor -> power
9
<<
factor -> power
9
!=
factor -> power
9
<=
factor -> power
9
and
factor -> power
9
/
factor -> power
9
^
factor -> power
9
|=
factor -> power
9
@
factor -> power
9
>=
factor -> power
9
&=
factor -> power
9
@=
factor -> power
9
not
factor -> power
9
//
factor -> power
9
or
factor -> power
9
>>=
factor -> power
9
//=
factor -> power
9
==
factor -> power
9
is
factor -> power
9
-=
factor -> power
9
NEWLINE
factor -> power
9
|
factor -> power
9
*
factor -> power
9
-
factor -> power
9
%=
factor -> power
9
**=
factor -> power
9
if
factor -> power
9
>>
factor -> power
9
in
factor -> power
9
>
factor -> power
9
&
factor -> power
10
>
atom -> STRING
10
%
atom -> STRING
10
*=
atom -> STRING
10
@
atom -> STRING
10
|=
atom -> STRING
10
<<
atom -> STRING
10
in
atom -> STRING
10
[
atom -> STRING
10
**=
atom -> STRING
10
%=
atom -> STRING
10
<<=
atom -> STRING
10
-
atom -> STRING
10
==
atom -> STRING
10
&=
atom -> STRING
10
>=
atom -> STRING
10
not
atom -> STRING
10
/
atom -> STRING
10
+
atom -> STRING
10
=
atom -> STRING
10
NEWLINE
atom -> STRING
10
*
atom -> STRING
10
(
atom -> STRING
10
//
atom -> STRING
10
if
atom -> STRING
10
.
atom -> STRING
10
<
atom -> STRING
10
,
atom -> STRING
10
^=
atom -> STRING
10
&
atom -> STRING
10
@=
atom -> STRING
10
<=
atom -> STRING
10
-=
atom -> STRING
10
>>=
atom -> STRING
10
/=
atom -> STRING
10
!=
atom -> STRING
10
//=
atom -> STRING
10
^
atom -> STRING
10
**
atom -> STRING
10
:
atom -> STRING
10
and
atom -> STRING
10
+=
atom -> STRING
10
is
atom -> STRING
10
|
atom -> STRING
10
or
atom -> STRING
10
>>
atom -> STRING
11
$
compound_stmt -> decorated
11
assert
compound_stmt -> decorated
11
global
compound_stmt -> decorated
11
conf
compound_stmt -> decorated
11
nonlocal
compound_stmt -> decorated
11
modopt
compound_stmt -> decorated
11
servmod
compound_stmt -> decorated
11
@
compound_stmt -> decorated
11
STRING
compound_stmt -> decorated
11
while
compound_stmt -> decorated
11
return
compound_stmt -> decorated
11
del
compound_stmt -> decorated
11
def
compound_stmt -> decorated
11
server
compound_stmt -> decorated
11
resetstats
compound_stmt -> decorated
11
True
compound_stmt -> decorated
11
[
compound_stmt -> decorated
11
(
compound_stmt -> decorated
11
NAME
compound_stmt -> decorated
11
raise
compound_stmt -> decorated
11
try
compound_stmt -> decorated
11
~
compound_stmt -> decorated
11
with
compound_stmt -> decorated
11
{
compound_stmt -> decorated
11
-
compound_stmt -> decorated
11
begsim
compound_stmt -> decorated
11
NUMBER
compound_stmt -> decorated
11
None
compound_stmt -> decorated
11
+
compound_stmt -> decorated
11
continue
compound_stmt -> decorated
11
False
compound_stmt -> decorated
11
endsim
compound_stmt -> decorated
11
not
compound_stmt -> decorated
11
pass
compound_stmt -> decorated
11
if
compound_stmt -> decorated
11
break
compound_stmt -> decorated
11
yield
compound_stmt -> decorated
11
for
compound_stmt -> decorated
11
lambda
compound_stmt -> decorated
11
class
compound_stmt -> decorated
11
NEWLINE
compound_stmt -> decorated
12
conf
compound_stmt -> cli_serv_model
12
NUMBER
compound_stmt -> cli_serv_model
12
{
compound_stmt -> cli_serv_model
12
+
compound_stmt -> cli_serv_model
12
NEWLINE
compound_stmt -> cli_serv_model
12
modopt
compound_stmt -> cli_serv_model
12
servmod
compound_stmt -> cli_serv_model
12
continue
compound_stmt -> cli_serv_model
12
lambda
compound_stmt -> cli_serv_model
12
NAME
compound_stmt -> cli_serv_model
12
endsim
compound_stmt -> cli_serv_model
12
raise
compound_stmt -> cli_serv_model
12
assert
compound_stmt -> cli_serv_model
12
begsim
compound_stmt -> cli_serv_model
12
pass
compound_stmt -> cli_serv_model
12
nonlocal
compound_stmt -> cli_serv_model
12
False
compound_stmt -> cli_serv_model
12
yield
compound_stmt -> cli_serv_model
12
global
compound_stmt -> cli_serv_model
12
~
compound_stmt -> cli_serv_model
12
del
compound_stmt -> cli_serv_model
12
(
compound_stmt -> cli_serv_model
12
resetstats
compound_stmt -> cli_serv_model
12
$
compound_stmt -> cli_serv_model
12
True
compound_stmt -> cli_serv_model
12
STRING
compound_stmt -> cli_serv_model
12
@
compound_stmt -> cli_serv_model
12
not
compound_stmt -> cli_serv_model
12
with
compound_stmt -> cli_serv_model
12
None
compound_stmt -> cli_serv_model
12
server
compound_stmt -> cli_serv_model
12
return
compound_stmt -> cli_serv_model
12
while
compound_stmt -> cli_serv_model
12
if
compound_stmt -> cli_serv_model
12
[
compound_stmt -> cli_serv_model
12
-
compound_stmt -> cli_serv_model
12
class
compound_stmt -> cli_serv_model
12
for
compound_stmt -> cli_serv_model
12
try
compound_stmt -> cli_serv_model
12
break
compound_stmt -> cli_serv_model
12
def
compound_stmt -> cli_serv_model
13
NAME
126
13
dotted_name
127
14
NUMBER
compound_stmt -> try_stmt
14
for
compound_stmt -> try_stmt
14
{
compound_stmt -> try_stmt
14
NAME
compound_stmt -> try_stmt
14
if
compound_stmt -> try_stmt
14
yield
compound_stmt -> try_stmt
14
def
compound_stmt -> try_stmt
14
del
compound_stmt -> try_stmt
14
assert
compound_stmt -> try_stmt
14
@
compound_stmt -> try_stmt
14
True
compound_stmt -> try_stmt
14
servmod
compound_stmt -> try_stmt
14
raise
compound_stmt -> try_stmt
14
continue
compound_stmt -> try_stmt
14
[
compound_stmt -> try_stmt
14
not
compound_stmt -> try_stmt
14
with
compound_stmt -> try_stmt
14
begsim
compound_stmt -> try_stmt
14
class
compound_stmt -> try_stmt
14
resetstats
compound_stmt -> try_stmt
14
STRING
compound_stmt -> try_stmt
14
~
compound_stmt -> try_stmt
14
break
compound_stmt -> try_stmt
14
server
compound_stmt -> try_stmt
14
pass
compound_stmt -> try_stmt
14
NEWLINE
compound_stmt -> try_stmt
14
nonlocal
compound_stmt -> try_stmt
14
try
compound_stmt -> try_stmt
14
$
compound_stmt -> try_stmt
14
False
compound_stmt -> try_stmt
14
+
compound_stmt -> try_stmt
14
None
compound_stmt -> try_stmt
14
(
compound_stmt -> try_stmt
14
modopt
compound_stmt -> try_stmt
14
global
compound_stmt -> try_stmt
14
lambda
compound_stmt -> try_stmt
14
endsim
compound_stmt -> try_stmt
14
-
compound_stmt -> try_stmt
14
return
compound_stmt -> try_stmt
14
conf
compound_stmt -> try_stmt
14
while
compound_stmt -> try_stmt
15
-=
test -> lambdef
15
+=
test -> lambdef
15
=
test -> lambdef
15
//=
test -> lambdef
15
@=
test -> lambdef
15
>>=
test -> lambdef
15
|=
test -> lambdef
15
^=
test -> lambdef
15
,
test -> lambdef
15
*=
test -> lambdef
15
:
test -> lambdef
15
&=
test -> lambdef
15
**=
test -> lambdef
15
/=
test -> lambdef
15
<<=
test -> lambdef
15
NEWLINE
test -> lambdef
15
%=
test -> lambdef
16
[
128
16
factor
129
16
True
130
16
atom_expr
131
16
~
132
16
and_expr
133
16
-
134
16
{
135
16
test_list_comp
136
16
shift_expr
137
16
atom
138
16
)
139
16
comparison
140
16
arith_expr
141
16
power
142
16
STRING
143
16
NAME
144
16
(
145
16
and_test
146
16
term
147
16
+
148
16
xor_expr
149
16
or_test
150
16
NUMBER
151
16
not
152
16
False
153
16
expr
154
16
not_test
155
16
None
156
16
lambdef
157
16
lambda
158
16
test
159
16
test_list
160
17
|=
term -> factor
17
not
term -> factor
17
@
161
17
/
162
17
%
163
17
*
164
17
@=
term -> factor
17
//
165
17
<=
term -> factor
17
&=
term -> factor
17
//=
term -> factor
17
NEWLINE
term -> factor
17
^=
term -> factor
17
>
term -> factor
17
==
term -> factor
17
is
term -> factor
17
or
term -> factor
17
<
term -> factor
17
and
term -> factor
17
<<
term -> factor
17
^
term -> factor
17
<<=
term -> factor
17
**=
term -> factor
17
:
term -> factor
17
!=
term -> factor
17
-
term -> factor
17
&
term -> factor
17
|
term -> factor
17
>>=
term -> factor
17
*=
term -> factor
17
,
term -> factor
17
>=
term -> factor
17
if
term -> factor
17
=
term -> factor
17
+
term -> factor
17
in
term -> factor
17
+=
term -> factor
17
>>
term -> factor
17
/=
term -> factor
17
%=
term -> factor
17
-=
term -> factor
18
[
166
18
factor
167
18
True
168
18
atom_expr
169
18
~
170
18
not
171
18
and_expr
172
18
-
173
18
{
174
18
shift_expr
175
18
atom
176
18
]
177
18
comparison
178
18
(
179
18
arith_expr
180
18
power
181
18
STRING
182
18
NAME
183
18
test
184
18
and_test
185
18
term
186
18
+
187
18
xor_expr
188
18
test_list_comp
189
18
NUMBER
190
18
False
191
18
expr
192
18
not_test
193
18
None
194
18
lambdef
195
18
lambda
196
18
or_test
197
18
test_list
198
19
NAME
199
20
NEWLINE
200
21
}
201
22
+=
arith_expr -> term
22
+
202
22
,
arith_expr -> term
22
-
203
22
-=
arith_expr -> term
22
<<=
arith_expr -> term
22
>>
arith_expr -> term
22
**=
arith_expr -> term
22
=
arith_expr -> term
22
and
arith_expr -> term
22
<
arith_expr -> term
22
//=
arith_expr -> term
22
^=
arith_expr -> term
22
in
arith_expr -> term
22
>
arith_expr -> term
22
:
arith_expr -> term
22
%=
arith_expr -> term
22
@=
arith_expr -> term
22
*=
arith_expr -> term
22
>=
arith_expr -> term
22
<=
arith_expr -> term
22
not
arith_expr -> term
22
==
arith_expr -> term
22
/=
arith_expr -> term
22
>>=
arith_expr -> term
22
NEWLINE
arith_expr -> term
22
<<
arith_expr -> term
22
&
arith_expr -> term
22
|
arith_expr -> term
22
&=
arith_expr -> term
22
is
arith_expr -> term
22
if
arith_expr -> term
22
or
arith_expr -> term
22
!=
arith_expr -> term
22
|=
arith_expr -> term
22
^
arith_expr -> term
23
NAME
204
24
NAME
205
25
global
compound_stmt -> while_stmt
25
modopt
compound_stmt -> while_stmt
25
[
compound_stmt -> while_stmt
25
servmod
compound_stmt -> while_stmt
25
NUMBER
compound_stmt -> while_stmt
25
True
compound_stmt -> while_stmt
25
try
compound_stmt -> while_stmt
25
pass
compound_stmt -> while_stmt
25
break
compound_stmt -> while_stmt
25
{
compound_stmt -> while_stmt
25
False
compound_stmt -> while_stmt
25
return
compound_stmt -> while_stmt
25
conf
compound_stmt -> while_stmt
25
def
compound_stmt -> while_stmt
25
if
compound_stmt -> while_stmt
25
yield
compound_stmt -> while_stmt
25
raise
compound_stmt -> while_stmt
25
NEWLINE
compound_stmt -> while_stmt
25
STRING
compound_stmt -> while_stmt
25
NAME
compound_stmt -> while_stmt
25
lambda
compound_stmt -> while_stmt
25
for
compound_stmt -> while_stmt
25
-
compound_stmt -> while_stmt
25
not
compound_stmt -> while_stmt
25
@
compound_stmt -> while_stmt
25
endsim
compound_stmt -> while_stmt
25
$
compound_stmt -> while_stmt
25
(
compound_stmt -> while_stmt
25
assert
compound_stmt -> while_stmt
25
while
compound_stmt -> while_stmt
25
begsim
compound_stmt -> while_stmt
25
del
compound_stmt -> while_stmt
25
class
compound_stmt -> while_stmt
25
with
compound_stmt -> while_stmt
25
~
compound_stmt -> while_stmt
25
continue
compound_stmt -> while_stmt
25
server
compound_stmt -> while_stmt
25
None
compound_stmt -> while_stmt
25
resetstats
compound_stmt -> while_stmt
25
nonlocal
compound_stmt -> while_stmt
25
+
compound_stmt -> while_stmt
26
[
18
26
True
38
26
atom_expr
31
26
~
37
26
-
26
26
None
55
26
atom
57
26
{
21
26
power
9
26
STRING
10
26
NAME
52
26
(
16
26
NUMBER
58
26
factor
206
26
+
27
26
False
39
27
[
18
27
True
38
27
atom_expr
31
27
-
26
27
~
37
27
None
55
27
atom
57
27
{
21
27
power
9
27
STRING
10
27
NAME
52
27
(
16
27
NUMBER
58
27
factor
207
27
+
27
27
False
39
28
[
208
28
{
209
28
factor
210
28
expr_list
211
28
True
212
28
~
213
28
and_expr
214
28
arith_expr
215
28
shift_expr
216
28
atom
217
28
STRING
218
28
power
219
28
NAME
220
28
(
221
28
+
222
28
term
223
28
None
224
28
False
225
28
atom_expr
226
28
-
227
28
expr
228
28
NUMBER
229
28
xor_expr
230
29
:
231
29
varargslist
232
29
NAME
233
29
vfpdef
234
30
def
23
30
class
19
30
funcdef
235
30
classdef
236
31
=
power -> atom_expr
31
/
power -> atom_expr
31
%
power -> atom_expr
31
**
237
31
<
power -> atom_expr
31
is
power -> atom_expr
31
>>=
power -> atom_expr
31
-=
power -> atom_expr
31
:
power -> atom_expr
31
in
power -> atom_expr
31
<=
power -> atom_expr
31
|
power -> atom_expr
31
@=
power -> atom_expr
31
&=
power -> atom_expr
31
+
power -> atom_expr
31
,
power -> atom_expr
31
!=
power -> atom_expr
31
/=
power -> atom_expr
31
*=
power -> atom_expr
31
**=
power -> atom_expr
31
>
power -> atom_expr
31
@
power -> atom_expr
31
NEWLINE
power -> atom_expr
31
|=
power -> atom_expr
31
or
power -> atom_expr
31
>>
power -> atom_expr
31
and
power -> atom_expr
31
+=
power -> atom_expr
31
%=
power -> atom_expr
31
-
power -> atom_expr
31
<<
power -> atom_expr
31
not
power -> atom_expr
31
^=
power -> atom_expr
31
//=
power -> atom_expr
31
>=
power -> atom_expr
31
==
power -> atom_expr
31
^
power -> atom_expr
31
*
power -> atom_expr
31
<<=
power -> atom_expr
31
&
power -> atom_expr
31
if
power -> atom_expr
31
//
power -> atom_expr
32
and
238
32
-=
and_test -> not_test
32
:
and_test -> not_test
32
|=
and_test -> not_test
32
>>=
and_test -> not_test
32
if
and_test -> not_test
32
%=
and_test -> not_test
32
^=
and_test -> not_test
32
&=
and_test -> not_test
32
**=
and_test -> not_test
32
*=
and_test -> not_test
32
=
and_test -> not_test
32
<<=
and_test -> not_test
32
,
and_test -> not_test
32
NEWLINE
and_test -> not_test
32
/=
and_test -> not_test
32
or
and_test -> not_test
32
@=
and_test -> not_test
32
+=
and_test -> not_test
32
//=
and_test -> not_test
33
$
compound_stmt -> if_stmt
33
while
compound_stmt -> if_stmt
33
lambda
compound_stmt -> if_stmt
33
~
compound_stmt -> if_stmt
33
not
compound_stmt -> if_stmt
33
if
compound_stmt -> if_stmt
33
modopt
compound_stmt -> if_stmt
33
+
compound_stmt -> if_stmt
33
NAME
compound_stmt -> if_stmt
33
for
compound_stmt -> if_stmt
33
with
compound_stmt -> if_stmt
33
yield
compound_stmt -> if_stmt
33
continue
compound_stmt -> if_stmt
33
server
compound_stmt -> if_stmt
33
endsim
compound_stmt -> if_stmt
33
True
compound_stmt -> if_stmt
33
None
compound_stmt -> if_stmt
33
pass
compound_stmt -> if_stmt
33
{
compound_stmt -> if_stmt
33
raise
compound_stmt -> if_stmt
33
STRING
compound_stmt -> if_stmt
33
servmod
compound_stmt -> if_stmt
33
del
compound_stmt -> if_stmt
33
NUMBER
compound_stmt -> if_stmt
33
(
compound_stmt -> if_stmt
33
def
compound_stmt -> if_stmt
33
try
compound_stmt -> if_stmt
33
assert
compound_stmt -> if_stmt
33
break
compound_stmt -> if_stmt
33
[
compound_stmt -> if_stmt
33
@
compound_stmt -> if_stmt
33
begsim
compound_stmt -> if_stmt
33
return
compound_stmt -> if_stmt
33
nonlocal
compound_stmt -> if_stmt
33
-
compound_stmt -> if_stmt
33
class
compound_stmt -> if_stmt
33
conf
compound_stmt -> if_stmt
33
global
compound_stmt -> if_stmt
33
False
compound_stmt -> if_stmt
33
resetstats
compound_stmt -> if_stmt
33
NEWLINE
compound_stmt -> if_stmt
34
[
239
34
{
240
34
factor
241
34
True
242
34
~
243
34
and_expr
244
34
None
245
34
arith_expr
246
34
shift_expr
247
34
atom
248
34
STRING
249
34
power
250
34
NEWLINE
yield_stmt -> yield
34
NAME
251
34
(
252
34
NUMBER
253
34
+
254
34
term
255
34
False
256
34
atom_expr
257
34
-
258
34
expr_list
259
34
xor_expr
260
34
expr
261
35
NAME
262
36
//=
263
36
augassign
264
36
**=
265
36
-=
266
36
<<=
267
36
>>=
268
36
%=
269
36
*=
270
36
+=
271
36
|=
272
36
^=
273
36
assign
274
36
@=
275
36
=
276
36
/=
277
36
&=
278
36
:
279
36
NEWLINE
assign -> 
36
annassign
280
37
[
18
37
True
38
37
atom_expr
31
37
-
26
37
~
37
37
None
55
37
atom
57
37
{
21
37
power
9
37
STRING
10
37
NAME
52
37
(
16
37
NUMBER
58
37
+
27
37
False
39
37
factor
281
38
<<
atom -> True
38
//=
atom -> True
38
&
atom -> True
38
or
atom -> True
38
&=
atom -> True
38
[
atom -> True
38
if
atom -> True
38
|=
atom -> True
38
NEWLINE
atom -> True
38
:
atom -> True
38
-
atom -> True
38
*
atom -> True
38
^
atom -> True
38
>=
atom -> True
38
!=
atom -> True
38
=
atom -> True
38
(
atom -> True
38
not
atom -> True
38
|
atom -> True
38
>>=
atom -> True
38
%=
atom -> True
38
<<=
atom -> True
38
**=
atom -> True
38
/=
atom -> True
38
+
atom -> True
38
**
atom -> True
38
^=
atom -> True
38
@
atom -> True
38
.
atom -> True
38
is
atom -> True
38
//
atom -> True
38
-=
atom -> True
38
>
atom -> True
38
@=
atom -> True
38
%
atom -> True
38
<=
atom -> True
38
in
atom -> True
38
>>
atom -> True
38
and
atom -> True
38
==
atom -> True
38
/
atom -> True
38
*=
atom -> True
38
+=
atom -> True
38
<
atom -> True
38
,
atom -> True
39
(
atom -> False
39
%=
atom -> False
39
*
atom -> False
39
&=
atom -> False
39
>>=
atom -> False
39
==
atom -> False
39
+=
atom -> False
39
|
atom -> False
39
,
atom -> False
39
**=
atom -> False
39
|=
atom -> False
39
[
atom -> False
39
in
atom -> False
39
=
atom -> False
39
&
atom -> False
39
NEWLINE
atom -> False
39
not
atom -> False
39
is
atom -> False
39
if
atom -> False
39
^
atom -> False
39
+
atom -> False
39
-=
atom -> False
39
>
atom -> False
39
^=
atom -> False
39
<=
atom -> False
39
<<
atom -> False
39
<
atom -> False
39
>=
atom -> False
39
@=
atom -> False
39
:
atom -> False
39
@
atom -> False
39
%
atom -> False
39
//=
atom -> False
39
and
atom -> False
39
<<=
atom -> False
39
/=
atom -> False
39
!=
atom -> False
39
-
atom -> False
39
.
atom -> False
39
//
atom -> False
39
*=
atom -> False
39
/
atom -> False
39
**
atom -> False
39
>>
atom -> False
39
or
atom -> False
40
{
compound_stmt -> funcdef
40
$
compound_stmt -> funcdef
40
None
compound_stmt -> funcdef
40
del
compound_stmt -> funcdef
40
STRING
compound_stmt -> funcdef
40
lambda
compound_stmt -> funcdef
40
NUMBER
compound_stmt -> funcdef
40
NAME
compound_stmt -> funcdef
40
global
compound_stmt -> funcdef
40
server
compound_stmt -> funcdef
40
pass
compound_stmt -> funcdef
40
NEWLINE
compound_stmt -> funcdef
40
+
compound_stmt -> funcdef
40
while
compound_stmt -> funcdef
40
servmod
compound_stmt -> funcdef
40
False
compound_stmt -> funcdef
40
-
compound_stmt -> funcdef
40
for
compound_stmt -> funcdef
40
not
compound_stmt -> funcdef
40
break
compound_stmt -> funcdef
40
begsim
compound_stmt -> funcdef
40
resetstats
compound_stmt -> funcdef
40
endsim
compound_stmt -> funcdef
40
@
compound_stmt -> funcdef
40
with
compound_stmt -> funcdef
40
if
compound_stmt -> funcdef
40
nonlocal
compound_stmt -> funcdef
40
continue
compound_stmt -> funcdef
40
class
compound_stmt -> funcdef
40
assert
compound_stmt -> funcdef
40
True
compound_stmt -> funcdef
40
try
compound_stmt -> funcdef
40
~
compound_stmt -> funcdef
40
conf
compound_stmt -> funcdef
40
[
compound_stmt -> funcdef
40
(
compound_stmt -> funcdef
40
return
compound_stmt -> funcdef
40
def
compound_stmt -> funcdef
40
yield
compound_stmt -> funcdef
40
raise
compound_stmt -> funcdef
40
modopt
compound_stmt -> funcdef
41
|
282
41
|=
expr -> xor_expr
41
//=
expr -> xor_expr
41
**=
expr -> xor_expr
41
>>=
expr -> xor_expr
41
@=
expr -> xor_expr
41
<<=
expr -> xor_expr
41
>
expr -> xor_expr
41
%=
expr -> xor_expr
41
if
expr -> xor_expr
41
NEWLINE
expr -> xor_expr
41
is
expr -> xor_expr
41
and
expr -> xor_expr
41
=
expr -> xor_expr
41
^=
expr -> xor_expr
41
or
expr -> xor_expr
41
>=
expr -> xor_expr
41
==
expr -> xor_expr
41
not
expr -> xor_expr
41
,
expr -> xor_expr
41
:
expr -> xor_expr
41
+=
expr -> xor_expr
41
<
expr -> xor_expr
41
!=
expr -> xor_expr
41
<=
expr -> xor_expr
41
&=
expr -> xor_expr
41
in
expr -> xor_expr
41
*=
expr -> xor_expr
41
-=
expr -> xor_expr
41
/=
expr -> xor_expr
42
[
283
42
factor
284
42
True
285
42
atom_expr
286
42
~
287
42
and_expr
288
42
-
289
42
shift_expr
290
42
atom
291
42
{
292
42
comparison
293
42
or_test
294
42
arith_expr
295
42
power
296
42
STRING
297
42
NAME
298
42
(
299
42
with_items
300
42
and_test
301
42
term
302
42
+
303
42
xor_expr
304
42
NUMBER
305
42
not
306
42
False
307
42
expr
308
42
not_test
309
42
None
310
42
lambdef
311
42
test
312
42
with_item
313
42
lambda
314
43
[
95
43
factor
96
43
True
97
43
atom_expr
98
43
~
99
43
and_expr
100
43
-
101
43
atom
102
43
{
103
43
test
315
43
or_test
104
43
arith_expr
105
43
power
106
43
STRING
107
43
NAME
108
43
(
109
43
and_test
110
43
term
111
43
+
112
43
xor_expr
113
43
shift_expr
115
43
NUMBER
116
43
not
117
43
False
118
43
expr
119
43
not_test
120
43
comparison
121
43
None
122
43
lambdef
123
43
lambda
124
44
del
compound_stmt -> for_stmt
44
True
compound_stmt -> for_stmt
44
try
compound_stmt -> for_stmt
44
-
compound_stmt -> for_stmt
44
NAME
compound_stmt -> for_stmt
44
servmod
compound_stmt -> for_stmt
44
STRING
compound_stmt -> for_stmt
44
@
compound_stmt -> for_stmt
44
for
compound_stmt -> for_stmt
44
assert
compound_stmt -> for_stmt
44
$
compound_stmt -> for_stmt
44
False
compound_stmt -> for_stmt
44
nonlocal
compound_stmt -> for_stmt
44
~
compound_stmt -> for_stmt
44
resetstats
compound_stmt -> for_stmt
44
with
compound_stmt -> for_stmt
44
None
compound_stmt -> for_stmt
44
pass
compound_stmt -> for_stmt
44
break
compound_stmt -> for_stmt
44
if
compound_stmt -> for_stmt
44
endsim
compound_stmt -> for_stmt
44
continue
compound_stmt -> for_stmt
44
[
compound_stmt -> for_stmt
44
def
compound_stmt -> for_stmt
44
raise
compound_stmt -> for_stmt
44
NUMBER
compound_stmt -> for_stmt
44
yield
compound_stmt -> for_stmt
44
begsim
compound_stmt -> for_stmt
44
lambda
compound_stmt -> for_stmt
44
not
compound_stmt -> for_stmt
44
conf
compound_stmt -> for_stmt
44
while
compound_stmt -> for_stmt
44
global
compound_stmt -> for_stmt
44
(
compound_stmt -> for_stmt
44
NEWLINE
compound_stmt -> for_stmt
44
modopt
compound_stmt -> for_stmt
44
{
compound_stmt -> for_stmt
44
class
compound_stmt -> for_stmt
44
server
compound_stmt -> for_stmt
44
return
compound_stmt -> for_stmt
44
+
compound_stmt -> for_stmt
45
NEWLINE
small_stmt -> sim_stmt
46
/=
or_test -> and_test
46
or
316
46
:
or_test -> and_test
46
NEWLINE
or_test -> and_test
46
=
or_test -> and_test
46
<<=
or_test -> and_test
46
|=
or_test -> and_test
46
^=
or_test -> and_test
46
%=
or_test -> and_test
46
*=
or_test -> and_test
46
&=
or_test -> and_test
46
**=
or_test -> and_test
46
@=
or_test -> and_test
46
//=
or_test -> and_test
46
>>=
or_test -> and_test
46
+=
or_test -> and_test
46
-=
or_test -> and_test
46
,
or_test -> and_test
46
if
or_test -> and_test
47
>
317
47
is
318
47
in
319
47
<=
320
47
<
321
47
>=
322
47
-=
comparison -> expr
47
comp_op
323
47
+=
comparison -> expr
47
:
comparison -> expr
47
NEWLINE
comparison -> expr
47
!=
324
47
not
325
47
%=
comparison -> expr
47
==
326
47
@=
comparison -> expr
47
//=
comparison -> expr
47
*=
comparison -> expr
47
=
comparison -> expr
47
|=
comparison -> expr
47
>>=
comparison -> expr
47
or
comparison -> expr
47
&=
comparison -> expr
47
/=
comparison -> expr
47
^=
comparison -> expr
47
**=
comparison -> expr
47
if
comparison -> expr
47
<<=
comparison -> expr
47
and
comparison -> expr
47
,
comparison -> expr
48
^
and_expr -> shift_expr
48
<<=
and_expr -> shift_expr
48
in
and_expr -> shift_expr
48
|
and_expr -> shift_expr
48
&
327
48
<
and_expr -> shift_expr
48
not
and_expr -> shift_expr
48
>=
and_expr -> shift_expr
48
%=
and_expr -> shift_expr
48
**=
and_expr -> shift_expr
48
^=
and_expr -> shift_expr
48
+=
and_expr -> shift_expr
48
>>=
and_expr -> shift_expr
48
<=
and_expr -> shift_expr
48
|=
and_expr -> shift_expr
48
or
and_expr -> shift_expr
48
and
and_expr -> shift_expr
48
,
and_expr -> shift_expr
48
:
and_expr -> shift_expr
48
//=
and_expr -> shift_expr
48
!=
and_expr -> shift_expr
48
@=
and_expr -> shift_expr
48
*=
and_expr -> shift_expr
48
if
and_expr -> shift_expr
48
/=
and_expr -> shift_expr
48
is
and_expr -> shift_expr
48
==
and_expr -> shift_expr
48
&=
and_expr -> shift_expr
48
NEWLINE
and_expr -> shift_expr
48
>
and_expr -> shift_expr
48
-=
and_expr -> shift_expr
48
=
and_expr -> shift_expr
49
or
not_test -> comparison
49
|=
not_test -> comparison
49
**=
not_test -> comparison
49
+=
not_test -> comparison
49
and
not_test -> comparison
49
NEWLINE
not_test -> comparison
49
*=
not_test -> comparison
49
<<=
not_test -> comparison
49
=
not_test -> comparison
49
if
not_test -> comparison
49
/=
not_test -> comparison
49
-=
not_test -> comparison
49
,
not_test -> comparison
49
^=
not_test -> comparison
49
&=
not_test -> comparison
49
%=
not_test -> comparison
49
//=
not_test -> comparison
49
>>=
not_test -> comparison
49
:
not_test -> comparison
49
@=
not_test -> comparison
50
with
compound_stmt -> with_stmt
50
assert
compound_stmt -> with_stmt
50
lambda
compound_stmt -> with_stmt
50
NUMBER
compound_stmt -> with_stmt
50
~
compound_stmt -> with_stmt
50
del
compound_stmt -> with_stmt
50
[
compound_stmt -> with_stmt
50
resetstats
compound_stmt -> with_stmt
50
yield
compound_stmt -> with_stmt
50
None
compound_stmt -> with_stmt
50
endsim
compound_stmt -> with_stmt
50
begsim
compound_stmt -> with_stmt
50
True
compound_stmt -> with_stmt
50
(
compound_stmt -> with_stmt
50
STRING
compound_stmt -> with_stmt
50
nonlocal
compound_stmt -> with_stmt
50
server
compound_stmt -> with_stmt
50
modopt
compound_stmt -> with_stmt
50
conf
compound_stmt -> with_stmt
50
{
compound_stmt -> with_stmt
50
False
compound_stmt -> with_stmt
50
try
compound_stmt -> with_stmt
50
class
compound_stmt -> with_stmt
50
-
compound_stmt -> with_stmt
50
NEWLINE
compound_stmt -> with_stmt
50
return
compound_stmt -> with_stmt
50
$
compound_stmt -> with_stmt
50
pass
compound_stmt -> with_stmt
50
NAME
compound_stmt -> with_stmt
50
break
compound_stmt -> with_stmt
50
servmod
compound_stmt -> with_stmt
50
def
compound_stmt -> with_stmt
50
+
compound_stmt -> with_stmt
50
if
compound_stmt -> with_stmt
50
@
compound_stmt -> with_stmt
50
continue
compound_stmt -> with_stmt
50
while
compound_stmt -> with_stmt
50
not
compound_stmt -> with_stmt
50
for
compound_stmt -> with_stmt
50
raise
compound_stmt -> with_stmt
50
global
compound_stmt -> with_stmt
51
raise
stmt -> simple_stmt
51
(
stmt -> simple_stmt
51
nonlocal
stmt -> simple_stmt
51
NEWLINE
stmt -> simple_stmt
51
while
stmt -> simple_stmt
51
global
stmt -> simple_stmt
51
{
stmt -> simple_stmt
51
conf
stmt -> simple_stmt
51
-
stmt -> simple_stmt
51
server
stmt -> simple_stmt
51
@
stmt -> simple_stmt
51
def
stmt -> simple_stmt
51
del
stmt -> simple_stmt
51
endsim
stmt -> simple_stmt
51
NUMBER
stmt -> simple_stmt
51
False
stmt -> simple_stmt
51
begsim
stmt -> simple_stmt
51
NAME
stmt -> simple_stmt
51
if
stmt -> simple_stmt
51
class
stmt -> simple_stmt
51
pass
stmt -> simple_stmt
51
+
stmt -> simple_stmt
51
$
stmt -> simple_stmt
51
~
stmt -> simple_stmt
51
try
stmt -> simple_stmt
51
not
stmt -> simple_stmt
51
STRING
stmt -> simple_stmt
51
True
stmt -> simple_stmt
51
assert
stmt -> simple_stmt
51
[
stmt -> simple_stmt
51
modopt
stmt -> simple_stmt
51
yield
stmt -> simple_stmt
51
resetstats
stmt -> simple_stmt
51
continue
stmt -> simple_stmt
51
return
stmt -> simple_stmt
51
with
stmt -> simple_stmt
51
lambda
stmt -> simple_stmt
51
break
stmt -> simple_stmt
51
for
stmt -> simple_stmt
51
None
stmt -> simple_stmt
51
servmod
stmt -> simple_stmt
52
<
atom -> NAME
52
,
atom -> NAME
52
^
atom -> NAME
52
+
atom -> NAME
52
>=
atom -> NAME
52
-
atom -> NAME
52
@
atom -> NAME
52
-=
atom -> NAME
52
@=
atom -> NAME
52
!=
atom -> NAME
52
*
atom -> NAME
52
=
atom -> NAME
52
<=
atom -> NAME
52
//=
atom -> NAME
52
**
atom -> NAME
52
or
atom -> NAME
52
+=
atom -> NAME
52
NEWLINE
atom -> NAME
52
*=
atom -> NAME
52
not
atom -> NAME
52
==
atom -> NAME
52
&=
atom -> NAME
52
&
atom -> NAME
52
>>=
atom -> NAME
52
>
atom -> NAME
52
%=
atom -> NAME
52
%
atom -> NAME
52
.
atom -> NAME
52
>>
atom -> NAME
52
|
atom -> NAME
52
/=
atom -> NAME
52
is
atom -> NAME
52
and
atom -> NAME
52
//
atom -> NAME
52
[
atom -> NAME
52
<<=
atom -> NAME
52
/
atom -> NAME
52
**=
atom -> NAME
52
(
atom -> NAME
52
<<
atom -> NAME
52
if
atom -> NAME
52
in
atom -> NAME
52
^=
atom -> NAME
52
:
atom -> NAME
52
|=
atom -> NAME
53
if
328
53
=
test -> or_test
53
//=
test -> or_test
53
>>=
test -> or_test
53
,
test -> or_test
53
@=
test -> or_test
53
NEWLINE
test -> or_test
53
:
test -> or_test
53
%=
test -> or_test
53
<<=
test -> or_test
53
+=
test -> or_test
53
-=
test -> or_test
53
^=
test -> or_test
53
/=
test -> or_test
53
*=
test -> or_test
53
&=
test -> or_test
53
**=
test -> or_test
53
|=
test -> or_test
54
not
compound_stmt -> confdef
54
modopt
compound_stmt -> confdef
54
if
compound_stmt -> confdef
54
~
compound_stmt -> confdef
54
try
compound_stmt -> confdef
54
break
compound_stmt -> confdef
54
continue
compound_stmt -> confdef
54
endsim
compound_stmt -> confdef
54
raise
compound_stmt -> confdef
54
pass
compound_stmt -> confdef
54
global
compound_stmt -> confdef
54
True
compound_stmt -> confdef
54
servmod
compound_stmt -> confdef
54
STRING
compound_stmt -> confdef
54
def
compound_stmt -> confdef
54
-
compound_stmt -> confdef
54
False
compound_stmt -> confdef
54
NUMBER
compound_stmt -> confdef
54
NAME
compound_stmt -> confdef
54
resetstats
compound_stmt -> confdef
54
$
compound_stmt -> confdef
54
return
compound_stmt -> confdef
54
with
compound_stmt -> confdef
54
[
compound_stmt -> confdef
54
(
compound_stmt -> confdef
54
NEWLINE
compound_stmt -> confdef
54
for
compound_stmt -> confdef
54
lambda
compound_stmt -> confdef
54
begsim
compound_stmt -> confdef
54
assert
compound_stmt -> confdef
54
+
compound_stmt -> confdef
54
{
compound_stmt -> confdef
54
while
compound_stmt -> confdef
54
nonlocal
compound_stmt -> confdef
54
conf
compound_stmt -> confdef
54
None
compound_stmt -> confdef
54
@
compound_stmt -> confdef
54
class
compound_stmt -> confdef
54
del
compound_stmt -> confdef
54
server
compound_stmt -> confdef
54
yield
compound_stmt -> confdef
55
>>=
atom -> None
55
|=
atom -> None
55
@
atom -> None
55
NEWLINE
atom -> None
55
<=
atom -> None
55
in
atom -> None
55
and
atom -> None
55
&
atom -> None
55
|
atom -> None
55
>
atom -> None
55
&=
atom -> None
55
>=
atom -> None
55
/
atom -> None
55
^=
atom -> None
55
<<
atom -> None
55
-
atom -> None
55
!=
atom -> None
55
**
atom -> None
55
(
atom -> None
55
<<=
atom -> None
55
%=
atom -> None
55
*=
atom -> None
55
=
atom -> None
55
*
atom -> None
55
.
atom -> None
55
-=
atom -> None
55
>>
atom -> None
55
==
atom -> None
55
is
atom -> None
55
//=
atom -> None
55
/=
atom -> None
55
<
atom -> None
55
@=
atom -> None
55
if
atom -> None
55
^
atom -> None
55
+=
atom -> None
55
%
atom -> None
55
[
atom -> None
55
+
atom -> None
55
not
atom -> None
55
**=
atom -> None
55
,
atom -> None
55
:
atom -> None
55
or
atom -> None
55
//
atom -> None
56
with
compound_stmt -> classdef
56
endsim
compound_stmt -> classdef
56
(
compound_stmt -> classdef
56
begsim
compound_stmt -> classdef
56
if
compound_stmt -> classdef
56
[
compound_stmt -> classdef
56
not
compound_stmt -> classdef
56
pass
compound_stmt -> classdef
56
{
compound_stmt -> classdef
56
-
compound_stmt -> classdef
56
modopt
compound_stmt -> classdef
56
raise
compound_stmt -> classdef
56
yield
compound_stmt -> classdef
56
NAME
compound_stmt -> classdef
56
class
compound_stmt -> classdef
56
NEWLINE
compound_stmt -> classdef
56
for
compound_stmt -> classdef
56
conf
compound_stmt -> classdef
56
+
compound_stmt -> classdef
56
lambda
compound_stmt -> classdef
56
~
compound_stmt -> classdef
56
NUMBER
compound_stmt -> classdef
56
True
compound_stmt -> classdef
56
servmod
compound_stmt -> classdef
56
continue
compound_stmt -> classdef
56
break
compound_stmt -> classdef
56
@
compound_stmt -> classdef
56
try
compound_stmt -> classdef
56
return
compound_stmt -> classdef
56
STRING
compound_stmt -> classdef
56
None
compound_stmt -> classdef
56
global
compound_stmt -> classdef
56
del
compound_stmt -> classdef
56
nonlocal
compound_stmt -> classdef
56
assert
compound_stmt -> classdef
56
def
compound_stmt -> classdef
56
server
compound_stmt -> classdef
56
resetstats
compound_stmt -> classdef
56
False
compound_stmt -> classdef
56
while
compound_stmt -> classdef
56
$
compound_stmt -> classdef
57
.
329
57
>>
trailer_expr -> 
57
(
330
57
trailer
331
57
trailer_expr
332
57
+
trailer_expr -> 
57
[
333
57
//=
trailer_expr -> 
57
>
trailer_expr -> 
57
not
trailer_expr -> 
57
%=
trailer_expr -> 
57
|
trailer_expr -> 
57
=
trailer_expr -> 
57
NEWLINE
trailer_expr -> 
57
/=
trailer_expr -> 
57
/
trailer_expr -> 
57
@=
trailer_expr -> 
57
^
trailer_expr -> 
57
^=
trailer_expr -> 
57
<<
trailer_expr -> 
57
or
trailer_expr -> 
57
:
trailer_expr -> 
57
|=
trailer_expr -> 
57
<=
trailer_expr -> 
57
<
trailer_expr -> 
57
==
trailer_expr -> 
57
*=
trailer_expr -> 
57
*
trailer_expr -> 
57
&=
trailer_expr -> 
57
is
trailer_expr -> 
57
<<=
trailer_expr -> 
57
&
trailer_expr -> 
57
@
trailer_expr -> 
57
!=
trailer_expr -> 
57
**
trailer_expr -> 
57
>=
trailer_expr -> 
57
in
trailer_expr -> 
57
-=
trailer_expr -> 
57
and
trailer_expr -> 
57
if
trailer_expr -> 
57
>>=
trailer_expr -> 
57
**=
trailer_expr -> 
57
//
trailer_expr -> 
57
%
trailer_expr -> 
57
+=
trailer_expr -> 
57
,
trailer_expr -> 
57
-
trailer_expr -> 
58
+
atom -> NUMBER
58
>>=
atom -> NUMBER
58
*
atom -> NUMBER
58
>
atom -> NUMBER
58
<<
atom -> NUMBER
58
-
atom -> NUMBER
58
**
atom -> NUMBER
58
if
atom -> NUMBER
58
|=
atom -> NUMBER
58
+=
atom -> NUMBER
58
or
atom -> NUMBER
58
is
atom -> NUMBER
58
@=
atom -> NUMBER
58
=
atom -> NUMBER
58
[
atom -> NUMBER
58
(
atom -> NUMBER
58
not
atom -> NUMBER
58
&
atom -> NUMBER
58
**=
atom -> NUMBER
58
^
atom -> NUMBER
58
^=
atom -> NUMBER
58
in
atom -> NUMBER
58
==
atom -> NUMBER
58
//
atom -> NUMBER
58
*=
atom -> NUMBER
58
!=
atom -> NUMBER
58
and
atom -> NUMBER
58
//=
atom -> NUMBER
58
NEWLINE
atom -> NUMBER
58
<=
atom -> NUMBER
58
%
atom -> NUMBER
58
<<=
atom -> NUMBER
58
-=
atom -> NUMBER
58
.
atom -> NUMBER
58
<
atom -> NUMBER
58
/=
atom -> NUMBER
58
>>
atom -> NUMBER
58
,
atom -> NUMBER
58
/
atom -> NUMBER
58
%=
atom -> NUMBER
58
@
atom -> NUMBER
58
>=
atom -> NUMBER
58
|
atom -> NUMBER
58
&=
atom -> NUMBER
58
:
atom -> NUMBER
59
[
334
59
factor
335
59
True
336
59
atom_expr
337
59
~
338
59
and_expr
339
59
-
340
59
None
341
59
shift_expr
342
59
atom
343
59
{
344
59
comparison
345
59
arith_expr
346
59
power
347
59
STRING
348
59
NAME
349
59
(
350
59
NUMBER
351
59
and_test
352
59
term
353
59
+
354
59
xor_expr
355
59
not
356
59
False
357
59
lambda
358
59
not_test
359
59
test_list
360
59
NEWLINE
return_stmt -> return
59
lambdef
361
59
expr
362
59
or_test
363
59
test
364
60
NEWLINE
flow_stmt -> break_stmt
61
NEWLINE
flow_stmt -> return_stmt
62
arith_expr
1
62
factor
17
62
True
38
62
atom_expr
31
62
term
22
62
-
26
62
None
55
62
atom
57
62
comparison
49
62
and_expr
8
62
power
9
62
STRING
10
62
NAME
52
62
shift_expr
48
62
NUMBER
58
62
(
16
62
expr
47
62
[
18
62
{
21
62
+
27
62
xor_expr
41
62
not
62
62
~
37
62
False
39
62
not_test
365
63
NEWLINE
break_stmt -> break
64
[
366
64
atom_expr
367
64
factor
368
64
True
369
64
~
370
64
and_expr
371
64
-
372
64
None
373
64
atom
374
64
{
375
64
expr
376
64
arith_expr
377
64
power
378
64
STRING
379
64
NAME
380
64
(
381
64
NUMBER
382
64
and_test
383
64
comparison
384
64
term
385
64
+
386
64
xor_expr
387
64
shift_expr
388
64
lambda
389
64
test
390
64
not
391
64
False
392
64
not_test
393
64
lambdef
394
64
NEWLINE
raise_stmt -> raise
64
or_test
395
65
NEWLINE
small_stmt -> expr_stmt
66
NEWLINE
small_stmt -> stat_stmt
67
@
13
67
decorator
67
67
decorators
396
67
def
decorators -> decorator
67
class
decorators -> decorator
68
NEWLINE
small_stmt -> assert_stmt
69
[
397
69
factor
398
69
True
399
69
atom_expr
400
69
~
401
69
and_expr
402
69
-
403
69
None
404
69
atom
405
69
{
406
69
arith_expr
407
69
power
408
69
STRING
409
69
NAME
410
69
(
411
69
NUMBER
412
69
and_test
413
69
term
414
69
+
415
69
xor_expr
416
69
shift_expr
417
69
not
418
69
False
419
69
lambda
420
69
comparison
421
69
not_test
422
69
lambdef
423
69
expr
424
69
or_test
425
69
test
426
70
NAME
427
70
namelist
428
71
[
334
71
factor
335
71
True
336
71
atom_expr
337
71
~
338
71
and_expr
339
71
-
340
71
None
341
71
shift_expr
342
71
atom
343
71
{
344
71
comparison
345
71
arith_expr
346
71
power
347
71
STRING
348
71
NAME
349
71
(
350
71
NUMBER
351
71
and_test
352
71
term
353
71
+
354
71
xor_expr
355
71
not
356
71
False
357
71
lambda
358
71
not_test
359
71
lambdef
361
71
expr
362
71
or_test
363
71
test
364
71
test_list
429
72
NAME
427
72
namelist
430
73
NEWLINE
small_stmt -> nonlocal_stmt
74
NEWLINE
flow_stmt -> raise_stmt
75
NEWLINE
flow_stmt -> yield_stmt
76
arith_expr
1
76
try
2
76
modopt
3
76
compound_stmt
4
76
test
5
76
servmod
6
76
while
7
76
and_expr
8
76
power
9
76
STRING
10
76
decorated
11
76
cli_serv_model
12
76
@
13
76
try_stmt
14
76
lambdef
15
76
(
16
76
factor
17
76
[
18
76
class
19
76
small_stmt
20
76
{
21
76
term
22
76
def
23
76
server
24
76
while_stmt
25
76
-
26
76
+
27
76
for
28
76
lambda
29
76
decorators
30
76
atom_expr
31
76
not_test
32
76
if_stmt
33
76
yield
34
76
conf
35
76
test_list
36
76
~
37
76
True
38
76
False
39
76
funcdef
40
76
xor_expr
41
76
with
42
76
if
43
76
for_stmt
44
76
sim_stmt
45
76
and_test
46
76
expr
47
76
shift_expr
48
76
comparison
49
76
with_stmt
50
76
simple_stmt
51
76
NAME
52
76
or_test
53
76
confdef
54
76
None
55
76
classdef
56
76
atom
57
76
NUMBER
58
76
return
59
76
break_stmt
60
76
return_stmt
61
76
not
62
76
break
63
76
raise
64
76
expr_stmt
65
76
stat_stmt
66
76
decorator
67
76
assert_stmt
68
76
begsim
69
76
global
70
76
assert
71
76
nonlocal
72
76
$
program -> 
76
nonlocal_stmt
73
76
raise_stmt
74
76
yield_stmt
75
76
stmt
76
76
continue
77
76
program
431
76
endsim
78
76
del
80
76
pass_stmt
81
76
flow_stmt
82
76
NEWLINE
83
76
resetstats
84
76
del_stmt
85
76
continue_stmt
86
76
global_stmt
87
76
pass
88
77
NEWLINE
continue_stmt -> continue
78
NEWLINE
sim_stmt -> endsim
79
$
OK
80
[
239
80
{
240
80
factor
241
80
True
242
80
~
243
80
and_expr
244
80
None
245
80
arith_expr
246
80
shift_expr
247
80
atom
248
80
STRING
249
80
power
250
80
NAME
251
80
(
252
80
NUMBER
253
80
+
254
80
term
255
80
False
256
80
atom_expr
257
80
-
258
80
expr_list
432
80
xor_expr
260
80
expr
261
81
NEWLINE
small_stmt -> pass_stmt
82
NEWLINE
small_stmt -> flow_stmt
83
arith_expr
1
83
try
2
83
modopt
3
83
compound_stmt
4
83
test
5
83
servmod
6
83
while
7
83
and_expr
8
83
power
9
83
STRING
10
83
decorated
11
83
cli_serv_model
12
83
@
13
83
try_stmt
14
83
lambdef
15
83
(
16
83
factor
17
83
[
18
83
class
19
83
small_stmt
20
83
{
21
83
term
22
83
def
23
83
server
24
83
while_stmt
25
83
-
26
83
+
27
83
for
28
83
lambda
29
83
decorators
30
83
atom_expr
31
83
not_test
32
83
if_stmt
33
83
yield
34
83
conf
35
83
test_list
36
83
~
37
83
True
38
83
False
39
83
funcdef
40
83
xor_expr
41
83
with
42
83
if
43
83
for_stmt
44
83
sim_stmt
45
83
and_test
46
83
expr
47
83
shift_expr
48
83
comparison
49
83
with_stmt
50
83
simple_stmt
51
83
NAME
52
83
or_test
53
83
confdef
54
83
None
55
83
classdef
56
83
atom
57
83
NUMBER
58
83
return
59
83
break_stmt
60
83
return_stmt
61
83
not
62
83
break
63
83
raise
64
83
expr_stmt
65
83
stat_stmt
66
83
decorator
67
83
assert_stmt
68
83
begsim
69
83
global
70
83
assert
71
83
nonlocal
72
83
$
program -> 
83
nonlocal_stmt
73
83
raise_stmt
74
83
yield_stmt
75
83
stmt
76
83
program
433
83
continue
77
83
endsim
78
83
del
80
83
pass_stmt
81
83
flow_stmt
82
83
NEWLINE
83
83
resetstats
84
83
del_stmt
85
83
continue_stmt
86
83
global_stmt
87
83
pass
88
84
NEWLINE
stat_stmt -> resetstats
85
NEWLINE
small_stmt -> del_stmt
86
NEWLINE
flow_stmt -> continue_stmt
87
NEWLINE
small_stmt -> global_stmt
88
NEWLINE
pass_stmt -> pass
89
arith_expr
1
89
factor
17
89
True
38
89
atom_expr
31
89
term
22
89
-
26
89
None
55
89
atom
57
89
power
9
89
STRING
10
89
NAME
52
89
NUMBER
58
89
(
16
89
[
18
89
{
21
89
shift_expr
434
89
+
27
89
~
37
89
False
39
90
arith_expr
1
90
factor
17
90
True
38
90
atom_expr
31
90
term
22
90
-
26
90
None
55
90
atom
57
90
power
9
90
STRING
10
90
NAME
52
90
NUMBER
58
90
(
16
90
[
18
90
{
21
90
+
27
90
shift_expr
435
90
~
37
90
False
39
91
arith_expr
1
91
suite
436
91
factor
17
91
True
38
91
atom_expr
31
91
term
22
91
-
26
91
None
55
91
atom
57
91
test
5
91
comparison
49
91
and_expr
8
91
power
9
91
STRING
10
91
NAME
52
91
shift_expr
48
91
lambdef
15
91
NUMBER
58
91
(
16
91
expr
47
91
[
18
91
not_test
32
91
{
21
91
and_test
46
91
+
27
91
lambda
29
91
xor_expr
41
91
yield
34
91
not
62
91
test_list
36
91
~
37
91
or_test
53
91
False
39
91
sim_stmt
45
91
nonlocal
72
91
nonlocal_stmt
73
91
NEWLINE
437
91
return
59
91
break_stmt
60
91
return_stmt
61
91
raise_stmt
74
91
break
63
91
yield_stmt
75
91
raise
64
91
continue
77
91
expr_stmt
65
91
endsim
78
91
del
80
91
pass_stmt
81
91
flow_stmt
82
91
stat_stmt
66
91
simple_stmt
438
91
assert_stmt
68
91
resetstats
84
91
del_stmt
85
91
continue_stmt
86
91
small_stmt
439
91
begsim
69
91
global_stmt
87
91
pass
88
91
global
70
91
assert
71
92
:
440
93
arith_expr
1
93
factor
17
93
True
38
93
atom_expr
31
93
term
22
93
-
26
93
None
55
93
atom
57
93
test
5
93
comparison
49
93
and_expr
8
93
power
9
93
STRING
10
93
NAME
52
93
shift_expr
48
93
lambdef
15
93
NUMBER
58
93
(
16
93
expr
47
93
[
18
93
not_test
32
93
{
21
93
and_test
46
93
+
27
93
lambda
29
93
xor_expr
41
93
not
62
93
~
37
93
or_test
53
93
False
39
93
test_list
441
94
:
442
95
[
166
95
factor
167
95
True
168
95
atom_expr
169
95
~
170
95
not
171
95
and_expr
172
95
-
173
95
{
174
95
shift_expr
175
95
atom
176
95
]
443
95
comparison
178
95
(
179
95
arith_expr
180
95
power
181
95
STRING
182
95
NAME
183
95
test
184
95
and_test
185
95
term
186
95
+
187
95
xor_expr
188
95
NUMBER
190
95
test_list_comp
444
95
False
191
95
expr
192
95
not_test
193
95
None
194
95
lambdef
195
95
lambda
196
95
or_test
197
95
test_list
198
96
not
term -> factor
96
@
445
96
%
446
96
/
447
96
*
448
96
//
449
96
<=
term -> factor
96
>
term -> factor
96
==
term -> factor
96
is
term -> factor
96
or
term -> factor
96
<
term -> factor
96
and
term -> factor
96
<<
term -> factor
96
^
term -> factor
96
:
term -> factor
96
!=
term -> factor
96
-
term -> factor
96
&
term -> factor
96
|
term -> factor
96
>=
term -> factor
96
if
term -> factor
96
+
term -> factor
96
in
term -> factor
96
>>
term -> factor
97
<<
atom -> True
97
&
atom -> True
97
or
atom -> True
97
[
atom -> True
97
if
atom -> True
97
:
atom -> True
97
-
atom -> True
97
*
atom -> True
97
^
atom -> True
97
>=
atom -> True
97
!=
atom -> True
97
(
atom -> True
97
not
atom -> True
97
|
atom -> True
97
+
atom -> True
97
**
atom -> True
97
.
atom -> True
97
is
atom -> True
97
//
atom -> True
97
>
atom -> True
97
%
atom -> True
97
in
atom -> True
97
<=
atom -> True
97
>>
atom -> True
97
/
atom -> True
97
==
atom -> True
97
and
atom -> True
97
<
atom -> True
97
@
atom -> True
98
**
450
98
!=
power -> atom_expr
98
-
power -> atom_expr
98
<<
power -> atom_expr
98
:
power -> atom_expr
98
/
power -> atom_expr
98
<=
power -> atom_expr
98
in
power -> atom_expr
98
not
power -> atom_expr
98
%
power -> atom_expr
98
>
power -> atom_expr
98
@
power -> atom_expr
98
|
power -> atom_expr
98
<
power -> atom_expr
98
>>
power -> atom_expr
98
or
power -> atom_expr
98
and
power -> atom_expr
98
>=
power -> atom_expr
98
==
power -> atom_expr
98
^
power -> atom_expr
98
*
power -> atom_expr
98
&
power -> atom_expr
98
is
power -> atom_expr
98
+
power -> atom_expr
98
if
power -> atom_expr
98
//
power -> atom_expr
99
[
95
99
True
97
99
atom_expr
98
99
-
101
99
~
99
99
atom
102
99
{
103
99
power
106
99
STRING
107
99
NAME
108
99
(
109
99
+
112
99
NUMBER
116
99
False
118
99
factor
451
99
None
122
100
>
xor_expr -> and_expr
100
<=
xor_expr -> and_expr
100
not
xor_expr -> and_expr
100
|
xor_expr -> and_expr
100
^
452
100
==
xor_expr -> and_expr
100
in
xor_expr -> and_expr
100
!=
xor_expr -> and_expr
100
:
xor_expr -> and_expr
100
if
xor_expr -> and_expr
100
is
xor_expr -> and_expr
100
<
xor_expr -> and_expr
100
or
xor_expr -> and_expr
100
and
xor_expr -> and_expr
100
>=
xor_expr -> and_expr
101
[
95
101
True
97
101
atom_expr
98
101
~
99
101
-
101
101
atom
102
101
{
103
101
power
106
101
STRING
107
101
NAME
108
101
(
109
101
factor
453
101
+
112
101
NUMBER
116
101
False
118
101
None
122
102
>>
trailer_expr -> 
102
(
454
102
trailer
455
102
trailer_expr
456
102
.
457
102
+
trailer_expr -> 
102
is
trailer_expr -> 
102
>
trailer_expr -> 
102
not
trailer_expr -> 
102
|
trailer_expr -> 
102
[
458
102
&
trailer_expr -> 
102
/
trailer_expr -> 
102
@
trailer_expr -> 
102
!=
trailer_expr -> 
102
**
trailer_expr -> 
102
>=
trailer_expr -> 
102
^
trailer_expr -> 
102
in
trailer_expr -> 
102
<<
trailer_expr -> 
102
and
trailer_expr -> 
102
or
trailer_expr -> 
102
if
trailer_expr -> 
102
:
trailer_expr -> 
102
//
trailer_expr -> 
102
%
trailer_expr -> 
102
<=
trailer_expr -> 
102
<
trailer_expr -> 
102
==
trailer_expr -> 
102
-
trailer_expr -> 
102
*
trailer_expr -> 
103
}
459
104
if
460
104
:
test -> or_test
105
>>
461
105
if
shift_expr -> arith_expr
105
&
shift_expr -> arith_expr
105
<<
462
105
|
shift_expr -> arith_expr
105
is
shift_expr -> arith_expr
105
<
shift_expr -> arith_expr
105
==
shift_expr -> arith_expr
105
or
shift_expr -> arith_expr
105
>
shift_expr -> arith_expr
105
!=
shift_expr -> arith_expr
105
>=
shift_expr -> arith_expr
105
in
shift_expr -> arith_expr
105
<=
shift_expr -> arith_expr
105
:
shift_expr -> arith_expr
105
and
shift_expr -> arith_expr
105
^
shift_expr -> arith_expr
105
not
shift_expr -> arith_expr
106
+
factor -> power
106
%
factor -> power
106
:
factor -> power
106
<
factor -> power
106
<<
factor -> power
106
!=
factor -> power
106
<=
factor -> power
106
and
factor -> power
106
/
factor -> power
106
^
factor -> power
106
@
factor -> power
106
>=
factor -> power
106
not
factor -> power
106
//
factor -> power
106
or
factor -> power
106
==
factor -> power
106
is
factor -> power
106
|
factor -> power
106
*
factor -> power
106
-
factor -> power
106
if
factor -> power
106
>
factor -> power
106
in
factor -> power
106
>>
factor -> power
106
&
factor -> power
107
%
atom -> STRING
107
>
atom -> STRING
107
@
atom -> STRING
107
<<
atom -> STRING
107
in
atom -> STRING
107
[
atom -> STRING
107
-
atom -> STRING
107
==
atom -> STRING
107
>=
atom -> STRING
107
not
atom -> STRING
107
/
atom -> STRING
107
+
atom -> STRING
107
*
atom -> STRING
107
(
atom -> STRING
107
//
atom -> STRING
107
if
atom -> STRING
107
.
atom -> STRING
107
<
atom -> STRING
107
&
atom -> STRING
107
<=
atom -> STRING
107
!=
atom -> STRING
107
**
atom -> STRING
107
^
atom -> STRING
107
:
atom -> STRING
107
and
atom -> STRING
107
is
atom -> STRING
107
|
atom -> STRING
107
or
atom -> STRING
107
>>
atom -> STRING
108
<
atom -> NAME
108
^
atom -> NAME
108
+
atom -> NAME
108
-
atom -> NAME
108
>=
atom -> NAME
108
@
atom -> NAME
108
!=
atom -> NAME
108
*
atom -> NAME
108
<=
atom -> NAME
108
**
atom -> NAME
108
or
atom -> NAME
108
not
atom -> NAME
108
==
atom -> NAME
108
&
atom -> NAME
108
>
atom -> NAME
108
>>
atom -> NAME
108
%
atom -> NAME
108
.
atom -> NAME
108
|
atom -> NAME
108
is
atom -> NAME
108
and
atom -> NAME
108
//
atom -> NAME
108
[
atom -> NAME
108
/
atom -> NAME
108
(
atom -> NAME
108
<<
atom -> NAME
108
if
atom -> NAME
108
in
atom -> NAME
108
:
atom -> NAME
109
[
128
109
factor
129
109
True
130
109
atom_expr
131
109
~
132
109
and_expr
133
109
-
134
109
{
135
109
test_list_comp
463
109
shift_expr
137
109
atom
138
109
)
464
109
comparison
140
109
arith_expr
141
109
power
142
109
STRING
143
109
NAME
144
109
(
145
109
and_test
146
109
term
147
109
+
148
109
xor_expr
149
109
or_test
150
109
NUMBER
151
109
not
152
109
False
153
109
expr
154
109
not_test
155
109
None
156
109
lambdef
157
109
lambda
158
109
test
159
109
test_list
160
110
or
465
110
:
or_test -> and_test
110
if
or_test -> and_test
111
-
466
111
+
467
111
>=
arith_expr -> term
111
|
arith_expr -> term
111
<=
arith_expr -> term
111
not
arith_expr -> term
111
==
arith_expr -> term
111
in
arith_expr -> term
111
>>
arith_expr -> term
111
is
arith_expr -> term
111
if
arith_expr -> term
111
or
arith_expr -> term
111
!=
arith_expr -> term
111
>
arith_expr -> term
111
:
arith_expr -> term
111
and
arith_expr -> term
111
<<
arith_expr -> term
111
<
arith_expr -> term
111
^
arith_expr -> term
111
&
arith_expr -> term
112
[
95
112
True
97
112
atom_expr
98
112
-
101
112
~
99
112
atom
102
112
{
103
112
power
106
112
STRING
107
112
NAME
108
112
(
109
112
factor
468
112
+
112
112
NUMBER
116
112
False
118
112
None
122
113
|
469
113
>
expr -> xor_expr
113
if
expr -> xor_expr
113
is
expr -> xor_expr
113
and
expr -> xor_expr
113
not
expr -> xor_expr
113
or
expr -> xor_expr
113
>=
expr -> xor_expr
113
==
expr -> xor_expr
113
:
expr -> xor_expr
113
<
expr -> xor_expr
113
!=
expr -> xor_expr
113
<=
expr -> xor_expr
113
in
expr -> xor_expr
114
:
470
115
^
and_expr -> shift_expr
115
in
and_expr -> shift_expr
115
|
and_expr -> shift_expr
115
&
471
115
<
and_expr -> shift_expr
115
not
and_expr -> shift_expr
115
>=
and_expr -> shift_expr
115
<=
and_expr -> shift_expr
115
or
and_expr -> shift_expr
115
and
and_expr -> shift_expr
115
:
and_expr -> shift_expr
115
!=
and_expr -> shift_expr
115
if
and_expr -> shift_expr
115
is
and_expr -> shift_expr
115
==
and_expr -> shift_expr
115
>
and_expr -> shift_expr
116
+
atom -> NUMBER
116
*
atom -> NUMBER
116
>
atom -> NUMBER
116
<<
atom -> NUMBER
116
-
atom -> NUMBER
116
**
atom -> NUMBER
116
if
atom -> NUMBER
116
or
atom -> NUMBER
116
is
atom -> NUMBER
116
[
atom -> NUMBER
116
(
atom -> NUMBER
116
not
atom -> NUMBER
116
&
atom -> NUMBER
116
^
atom -> NUMBER
116
in
atom -> NUMBER
116
==
atom -> NUMBER
116
//
atom -> NUMBER
116
!=
atom -> NUMBER
116
and
atom -> NUMBER
116
%
atom -> NUMBER
116
<=
atom -> NUMBER
116
.
atom -> NUMBER
116
<
atom -> NUMBER
116
>>
atom -> NUMBER
116
/
atom -> NUMBER
116
@
atom -> NUMBER
116
>=
atom -> NUMBER
116
|
atom -> NUMBER
116
:
atom -> NUMBER
117
[
95
117
factor
96
117
True
97
117
atom_expr
98
117
~
99
117
and_expr
100
117
-
101
117
atom
102
117
{
103
117
arith_expr
105
117
power
106
117
STRING
107
117
NAME
108
117
(
109
117
term
111
117
+
112
117
xor_expr
113
117
shift_expr
115
117
NUMBER
116
117
not
117
117
False
118
117
expr
119
117
comparison
121
117
not_test
472
117
None
122
118
(
atom -> False
118
*
atom -> False
118
==
atom -> False
118
|
atom -> False
118
[
atom -> False
118
in
atom -> False
118
&
atom -> False
118
is
atom -> False
118
not
atom -> False
118
if
atom -> False
118
^
atom -> False
118
+
atom -> False
118
>
atom -> False
118
<=
atom -> False
118
<<
atom -> False
118
<
atom -> False
118
>=
atom -> False
118
:
atom -> False
118
%
atom -> False
118
@
atom -> False
118
and
atom -> False
118
!=
atom -> False
118
-
atom -> False
118
.
atom -> False
118
//
atom -> False
118
/
atom -> False
118
**
atom -> False
118
>>
atom -> False
118
or
atom -> False
119
>
317
119
is
318
119
in
319
119
<=
320
119
<
321
119
>=
322
119
:
comparison -> expr
119
!=
324
119
not
325
119
==
326
119
comp_op
473
119
or
comparison -> expr
119
if
comparison -> expr
119
and
comparison -> expr
120
and
474
120
:
and_test -> not_test
120
if
and_test -> not_test
120
or
and_test -> not_test
121
or
not_test -> comparison
121
if
not_test -> comparison
121
:
not_test -> comparison
121
and
not_test -> comparison
122
@
atom -> None
122
<=
atom -> None
122
in
atom -> None
122
and
atom -> None
122
&
atom -> None
122
|
atom -> None
122
>
atom -> None
122
>=
atom -> None
122
/
atom -> None
122
<<
atom -> None
122
-
atom -> None
122
!=
atom -> None
122
**
atom -> None
122
(
atom -> None
122
*
atom -> None
122
.
atom -> None
122
>>
atom -> None
122
==
atom -> None
122
is
atom -> None
122
<
atom -> None
122
if
atom -> None
122
^
atom -> None
122
[
atom -> None
122
%
atom -> None
122
+
atom -> None
122
not
atom -> None
122
:
atom -> None
122
or
atom -> None
122
//
atom -> None
123
:
test -> lambdef
124
vfpdef
234
124
NAME
233
124
varargslist
475
124
:
476
125
arith_expr
1
125
factor
17
125
True
38
125
atom_expr
31
125
term
22
125
-
26
125
None
55
125
atom
57
125
xor_expr
477
125
and_expr
8
125
power
9
125
STRING
10
125
NAME
52
125
shift_expr
48
125
NUMBER
58
125
(
16
125
[
18
125
{
21
125
+
27
125
~
37
125
False
39
126
.
478
126
(
dotted_name -> NAME
126
NEWLINE
dotted_name -> NAME
127
(
479
127
NEWLINE
480
128
[
166
128
factor
167
128
True
168
128
atom_expr
169
128
~
170
128
not
171
128
and_expr
172
128
-
173
128
{
174
128
shift_expr
175
128
atom
176
128
]
481
128
comparison
178
128
(
179
128
arith_expr
180
128
power
181
128
STRING
182
128
NAME
183
128
test
184
128
and_test
185
128
term
186
128
+
187
128
xor_expr
188
128
NUMBER
190
128
test_list_comp
482
128
False
191
128
expr
192
128
not_test
193
128
None
194
128
lambdef
195
128
lambda
196
128
or_test
197
128
test_list
198
129
not
term -> factor
129
@
483
129
%
484
129
/
485
129
*
486
129
//
487
129
<=
term -> factor
129
for
term -> factor
129
)
term -> factor
129
>
term -> factor
129
==
term -> factor
129
is
term -> factor
129
or
term -> factor
129
<
term -> factor
129
and
term -> factor
129
<<
term -> factor
129
^
term -> factor
129
!=
term -> factor
129
-
term -> factor
129
&
term -> factor
129
|
term -> factor
129
,
term -> factor
129
>=
term -> factor
129
if
term -> factor
129
+
term -> factor
129
in
term -> factor
129
>>
term -> factor
130
<<
atom -> True
130
&
atom -> True
130
or
atom -> True
130
[
atom -> True
130
if
atom -> True
130
-
atom -> True
130
*
atom -> True
130
^
atom -> True
130
,
atom -> True
130
>=
atom -> True
130
!=
atom -> True
130
(
atom -> True
130
not
atom -> True
130
for
atom -> True
130
|
atom -> True
130
)
atom -> True
130
+
atom -> True
130
**
atom -> True
130
.
atom -> True
130
is
atom -> True
130
//
atom -> True
130
>
atom -> True
130
%
atom -> True
130
in
atom -> True
130
<=
atom -> True
130
>>
atom -> True
130
/
atom -> True
130
==
atom -> True
130
and
atom -> True
130
<
atom -> True
130
@
atom -> True
131
**
488
131
,
power -> atom_expr
131
)
power -> atom_expr
131
!=
power -> atom_expr
131
-
power -> atom_expr
131
<<
power -> atom_expr
131
not
power -> atom_expr
131
/
power -> atom_expr
131
<=
power -> atom_expr
131
in
power -> atom_expr
131
%
power -> atom_expr
131
>
power -> atom_expr
131
@
power -> atom_expr
131
|
power -> atom_expr
131
<
power -> atom_expr
131
>>
power -> atom_expr
131
or
power -> atom_expr
131
and
power -> atom_expr
131
>=
power -> atom_expr
131
==
power -> atom_expr
131
^
power -> atom_expr
131
*
power -> atom_expr
131
for
power -> atom_expr
131
&
power -> atom_expr
131
is
power -> atom_expr
131
+
power -> atom_expr
131
if
power -> atom_expr
131
//
power -> atom_expr
132
[
128
132
True
130
132
atom_expr
131
132
-
134
132
~
132
132
{
135
132
atom
138
132
power
142
132
STRING
143
132
NAME
144
132
(
145
132
+
148
132
NUMBER
151
132
False
153
132
factor
489
132
None
156
133
>
xor_expr -> and_expr
133
^
490
133
<=
xor_expr -> and_expr
133
not
xor_expr -> and_expr
133
|
xor_expr -> and_expr
133
==
xor_expr -> and_expr
133
,
xor_expr -> and_expr
133
in
xor_expr -> and_expr
133
!=
xor_expr -> and_expr
133
if
xor_expr -> and_expr
133
for
xor_expr -> and_expr
133
is
xor_expr -> and_expr
133
<
xor_expr -> and_expr
133
or
xor_expr -> and_expr
133
)
xor_expr -> and_expr
133
and
xor_expr -> and_expr
133
>=
xor_expr -> and_expr
134
[
128
134
True
130
134
atom_expr
131
134
~
132
134
-
134
134
{
135
134
atom
138
134
power
142
134
STRING
143
134
NAME
144
134
(
145
134
factor
491
134
+
148
134
NUMBER
151
134
False
153
134
None
156
135
}
492
136
)
493
137
^
and_expr -> shift_expr
137
in
and_expr -> shift_expr
137
|
and_expr -> shift_expr
137
&
494
137
<
and_expr -> shift_expr
137
not
and_expr -> shift_expr
137
>=
and_expr -> shift_expr
137
for
and_expr -> shift_expr
137
<=
and_expr -> shift_expr
137
or
and_expr -> shift_expr
137
and
and_expr -> shift_expr
137
,
and_expr -> shift_expr
137
!=
and_expr -> shift_expr
137
if
and_expr -> shift_expr
137
is
and_expr -> shift_expr
137
==
and_expr -> shift_expr
137
>
and_expr -> shift_expr
137
)
and_expr -> shift_expr
138
>>
trailer_expr -> 
138
.
495
138
(
496
138
trailer
497
138
)
trailer_expr -> 
138
trailer_expr
498
138
+
trailer_expr -> 
138
[
499
138
is
trailer_expr -> 
138
>
trailer_expr -> 
138
not
trailer_expr -> 
138
|
trailer_expr -> 
138
&
trailer_expr -> 
138
/
trailer_expr -> 
138
@
trailer_expr -> 
138
!=
trailer_expr -> 
138
**
trailer_expr -> 
138
>=
trailer_expr -> 
138
^
trailer_expr -> 
138
in
trailer_expr -> 
138
<<
trailer_expr -> 
138
and
trailer_expr -> 
138
or
trailer_expr -> 
138
if
trailer_expr -> 
138
//
trailer_expr -> 
138
%
trailer_expr -> 
138
,
trailer_expr -> 
138
<=
trailer_expr -> 
138
<
trailer_expr -> 
138
==
trailer_expr -> 
138
for
trailer_expr -> 
138
-
trailer_expr -> 
138
*
trailer_expr -> 
139
or
atom -> ( )
139
<<=
atom -> ( )
139
>>
atom -> ( )
139
//=
atom -> ( )
139
&=
atom -> ( )
139
(
atom -> ( )
139
/=
atom -> ( )
139
<=
atom -> ( )
139
.
atom -> ( )
139
is
atom -> ( )
139
,
atom -> ( )
139
@
atom -> ( )
139
%
atom -> ( )
139
%=
atom -> ( )
139
*=
atom -> ( )
139
<<
atom -> ( )
139
**
atom -> ( )
139
^=
atom -> ( )
139
^
atom -> ( )
139
/
atom -> ( )
139
if
atom -> ( )
139
not
atom -> ( )
139
=
atom -> ( )
139
*
atom -> ( )
139
|=
atom -> ( )
139
!=
atom -> ( )
139
<
atom -> ( )
139
+=
atom -> ( )
139
NEWLINE
atom -> ( )
139
**=
atom -> ( )
139
&
atom -> ( )
139
-
atom -> ( )
139
>>=
atom -> ( )
139
>
atom -> ( )
139
@=
atom -> ( )
139
//
atom -> ( )
139
:
atom -> ( )
139
==
atom -> ( )
139
-=
atom -> ( )
139
in
atom -> ( )
139
+
atom -> ( )
139
[
atom -> ( )
139
>=
atom -> ( )
139
and
atom -> ( )
139
|
atom -> ( )
140
or
not_test -> comparison
140
)
not_test -> comparison
140
,
not_test -> comparison
140
for
not_test -> comparison
140
and
not_test -> comparison
140
if
not_test -> comparison
141
>>
500
141
if
shift_expr -> arith_expr
141
&
shift_expr -> arith_expr
141
<<
501
141
|
shift_expr -> arith_expr
141
is
shift_expr -> arith_expr
141
<
shift_expr -> arith_expr
141
==
shift_expr -> arith_expr
141
or
shift_expr -> arith_expr
141
>
shift_expr -> arith_expr
141
)
shift_expr -> arith_expr
141
!=
shift_expr -> arith_expr
141
for
shift_expr -> arith_expr
141
>=
shift_expr -> arith_expr
141
in
shift_expr -> arith_expr
141
,
shift_expr -> arith_expr
141
<=
shift_expr -> arith_expr
141
and
shift_expr -> arith_expr
141
^
shift_expr -> arith_expr
141
not
shift_expr -> arith_expr
142
+
factor -> power
142
%
factor -> power
142
,
factor -> power
142
<
factor -> power
142
<<
factor -> power
142
!=
factor -> power
142
<=
factor -> power
142
and
factor -> power
142
/
factor -> power
142
^
factor -> power
142
for
factor -> power
142
@
factor -> power
142
>=
factor -> power
142
not
factor -> power
142
//
factor -> power
142
or
factor -> power
142
==
factor -> power
142
is
factor -> power
142
|
factor -> power
142
)
factor -> power
142
*
factor -> power
142
-
factor -> power
142
if
factor -> power
142
>
factor -> power
142
in
factor -> power
142
>>
factor -> power
142
&
factor -> power
143
%
atom -> STRING
143
>
atom -> STRING
143
@
atom -> STRING
143
<<
atom -> STRING
143
in
atom -> STRING
143
[
atom -> STRING
143
-
atom -> STRING
143
==
atom -> STRING
143
>=
atom -> STRING
143
not
atom -> STRING
143
/
atom -> STRING
143
+
atom -> STRING
143
*
atom -> STRING
143
)
atom -> STRING
143
(
atom -> STRING
143
//
atom -> STRING
143
if
atom -> STRING
143
.
atom -> STRING
143
<
atom -> STRING
143
,
atom -> STRING
143
&
atom -> STRING
143
<=
atom -> STRING
143
for
atom -> STRING
143
!=
atom -> STRING
143
**
atom -> STRING
143
^
atom -> STRING
143
and
atom -> STRING
143
is
atom -> STRING
143
|
atom -> STRING
143
or
atom -> STRING
143
>>
atom -> STRING
144
)
atom -> NAME
144
<
atom -> NAME
144
,
atom -> NAME
144
^
atom -> NAME
144
+
atom -> NAME
144
-
atom -> NAME
144
>=
atom -> NAME
144
@
atom -> NAME
144
!=
atom -> NAME
144
for
atom -> NAME
144
*
atom -> NAME
144
<=
atom -> NAME
144
**
atom -> NAME
144
or
atom -> NAME
144
not
atom -> NAME
144
==
atom -> NAME
144
&
atom -> NAME
144
>
atom -> NAME
144
%
atom -> NAME
144
>>
atom -> NAME
144
.
atom -> NAME
144
|
atom -> NAME
144
is
atom -> NAME
144
and
atom -> NAME
144
//
atom -> NAME
144
[
atom -> NAME
144
/
atom -> NAME
144
(
atom -> NAME
144
<<
atom -> NAME
144
if
atom -> NAME
144
in
atom -> NAME
145
[
128
145
factor
129
145
True
130
145
atom_expr
131
145
~
132
145
and_expr
133
145
-
134
145
{
135
145
test_list_comp
502
145
shift_expr
137
145
atom
138
145
)
503
145
comparison
140
145
arith_expr
141
145
power
142
145
STRING
143
145
NAME
144
145
(
145
145
and_test
146
145
term
147
145
+
148
145
xor_expr
149
145
or_test
150
145
NUMBER
151
145
not
152
145
False
153
145
expr
154
145
not_test
155
145
None
156
145
lambdef
157
145
lambda
158
145
test
159
145
test_list
160
146
for
or_test -> and_test
146
or
504
146
,
or_test -> and_test
146
if
or_test -> and_test
146
)
or_test -> and_test
147
-
505
147
+
506
147
>=
arith_expr -> term
147
|
arith_expr -> term
147
<=
arith_expr -> term
147
not
arith_expr -> term
147
,
arith_expr -> term
147
==
arith_expr -> term
147
)
arith_expr -> term
147
for
arith_expr -> term
147
in
arith_expr -> term
147
>>
arith_expr -> term
147
is
arith_expr -> term
147
if
arith_expr -> term
147
or
arith_expr -> term
147
!=
arith_expr -> term
147
>
arith_expr -> term
147
and
arith_expr -> term
147
<<
arith_expr -> term
147
<
arith_expr -> term
147
^
arith_expr -> term
147
&
arith_expr -> term
148
[
128
148
True
130
148
atom_expr
131
148
-
134
148
~
132
148
{
135
148
atom
138
148
power
142
148
STRING
143
148
NAME
144
148
(
145
148
factor
507
148
+
148
148
NUMBER
151
148
False
153
148
None
156
149
|
508
149
>
expr -> xor_expr
149
if
expr -> xor_expr
149
for
expr -> xor_expr
149
is
expr -> xor_expr
149
and
expr -> xor_expr
149
)
expr -> xor_expr
149
not
expr -> xor_expr
149
or
expr -> xor_expr
149
>=
expr -> xor_expr
149
==
expr -> xor_expr
149
,
expr -> xor_expr
149
<
expr -> xor_expr
149
!=
expr -> xor_expr
149
<=
expr -> xor_expr
149
in
expr -> xor_expr
150
if
509
150
)
test -> or_test
150
for
test -> or_test
150
,
test -> or_test
151
+
atom -> NUMBER
151
*
atom -> NUMBER
151
>
atom -> NUMBER
151
<<
atom -> NUMBER
151
for
atom -> NUMBER
151
-
atom -> NUMBER
151
**
atom -> NUMBER
151
if
atom -> NUMBER
151
or
atom -> NUMBER
151
is
atom -> NUMBER
151
[
atom -> NUMBER
151
(
atom -> NUMBER
151
not
atom -> NUMBER
151
&
atom -> NUMBER
151
)
atom -> NUMBER
151
^
atom -> NUMBER
151
in
atom -> NUMBER
151
==
atom -> NUMBER
151
//
atom -> NUMBER
151
!=
atom -> NUMBER
151
and
atom -> NUMBER
151
%
atom -> NUMBER
151
<=
atom -> NUMBER
151
.
atom -> NUMBER
151
<
atom -> NUMBER
151
>>
atom -> NUMBER
151
,
atom -> NUMBER
151
/
atom -> NUMBER
151
@
atom -> NUMBER
151
>=
atom -> NUMBER
151
|
atom -> NUMBER
152
[
128
152
factor
129
152
True
130
152
atom_expr
131
152
~
132
152
and_expr
133
152
-
134
152
{
135
152
shift_expr
137
152
atom
138
152
comparison
140
152
arith_expr
141
152
power
142
152
STRING
143
152
NAME
144
152
(
145
152
term
147
152
+
148
152
xor_expr
149
152
NUMBER
151
152
not
152
152
False
153
152
expr
154
152
not_test
510
152
None
156
153
for
atom -> False
153
(
atom -> False
153
*
atom -> False
153
==
atom -> False
153
|
atom -> False
153
,
atom -> False
153
[
atom -> False
153
in
atom -> False
153
&
atom -> False
153
is
atom -> False
153
not
atom -> False
153
if
atom -> False
153
^
atom -> False
153
+
atom -> False
153
)
atom -> False
153
>
atom -> False
153
<=
atom -> False
153
<<
atom -> False
153
<
atom -> False
153
>=
atom -> False
153
%
atom -> False
153
@
atom -> False
153
and
atom -> False
153
!=
atom -> False
153
-
atom -> False
153
.
atom -> False
153
//
atom -> False
153
/
atom -> False
153
**
atom -> False
153
>>
atom -> False
153
or
atom -> False
154
>
317
154
is
318
154
in
319
154
<=
320
154
<
321
154
>=
322
154
!=
324
154
not
325
154
==
326
154
comp_op
511
154
for
comparison -> expr
154
or
comparison -> expr
154
if
comparison -> expr
154
)
comparison -> expr
154
and
comparison -> expr
154
,
comparison -> expr
155
and
512
155
,
and_test -> not_test
155
if
and_test -> not_test
155
)
and_test -> not_test
155
for
and_test -> not_test
155
or
and_test -> not_test
156
@
atom -> None
156
<=
atom -> None
156
in
atom -> None
156
and
atom -> None
156
for
atom -> None
156
&
atom -> None
156
|
atom -> None
156
>
atom -> None
156
)
atom -> None
156
>=
atom -> None
156
/
atom -> None
156
<<
atom -> None
156
-
atom -> None
156
!=
atom -> None
156
**
atom -> None
156
(
atom -> None
156
*
atom -> None
156
.
atom -> None
156
>>
atom -> None
156
==
atom -> None
156
is
atom -> None
156
<
atom -> None
156
if
atom -> None
156
^
atom -> None
156
[
atom -> None
156
%
atom -> None
156
+
atom -> None
156
not
atom -> None
156
,
atom -> None
156
or
atom -> None
156
//
atom -> None
157
,
test -> lambdef
157
for
test -> lambdef
157
)
test -> lambdef
158
varargslist
513
158
vfpdef
234
158
:
514
158
NAME
233
159
)
test_list -> test
159
,
515
159
comp_for
516
159
for
517
160
)
test_list_comp -> test_list
161
factor
17
161
True
38
161
atom_expr
31
161
-
26
161
None
55
161
atom
57
161
power
9
161
STRING
10
161
NAME
52
161
NUMBER
58
161
(
16
161
[
18
161
{
21
161
+
27
161
~
37
161
False
39
161
term
518
162
term
519
162
factor
17
162
True
38
162
atom_expr
31
162
-
26
162
None
55
162
atom
57
162
power
9
162
STRING
10
162
NAME
52
162
NUMBER
58
162
(
16
162
[
18
162
{
21
162
+
27
162
~
37
162
False
39
163
factor
17
163
True
38
163
term
520
163
-
26
163
atom_expr
31
163
None
55
163
atom
57
163
power
9
163
STRING
10
163
NAME
52
163
NUMBER
58
163
(
16
163
[
18
163
{
21
163
+
27
163
~
37
163
False
39
164
factor
17
164
True
38
164
atom_expr
31
164
-
26
164
None
55
164
atom
57
164
power
9
164
STRING
10
164
NAME
52
164
NUMBER
58
164
(
16
164
[
18
164
{
21
164
term
521
164
+
27
164
~
37
164
False
39
165
factor
17
165
True
38
165
atom_expr
31
165
-
26
165
None
55
165
atom
57
165
power
9
165
STRING
10
165
NAME
52
165
NUMBER
58
165
(
16
165
[
18
165
{
21
165
+
27
165
term
522
165
~
37
165
False
39
166
[
166
166
factor
167
166
True
168
166
atom_expr
169
166
~
170
166
not
171
166
and_expr
172
166
-
173
166
{
174
166
shift_expr
175
166
atom
176
166
]
523
166
comparison
178
166
(
179
166
arith_expr
180
166
power
181
166
STRING
182
166
NAME
183
166
test
184
166
and_test
185
166
term
186
166
+
187
166
xor_expr
188
166
NUMBER
190
166
test_list_comp
524
166
False
191
166
expr
192
166
not_test
193
166
None
194
166
lambdef
195
166
lambda
196
166
or_test
197
166
test_list
198
167
not
term -> factor
167
@
525
167
//
526
167
%
527
167
/
528
167
*
529
167
<=
term -> factor
167
for
term -> factor
167
>
term -> factor
167
==
term -> factor
167
is
term -> factor
167
or
term -> factor
167
<
term -> factor
167
and
term -> factor
167
<<
term -> factor
167
^
term -> factor
167
!=
term -> factor
167
-
term -> factor
167
&
term -> factor
167
|
term -> factor
167
,
term -> factor
167
>=
term -> factor
167
if
term -> factor
167
+
term -> factor
167
in
term -> factor
167
>>
term -> factor
167
]
term -> factor
168
<<
atom -> True
168
&
atom -> True
168
or
atom -> True
168
[
atom -> True
168
if
atom -> True
168
-
atom -> True
168
*
atom -> True
168
^
atom -> True
168
,
atom -> True
168
>=
atom -> True
168
!=
atom -> True
168
(
atom -> True
168
not
atom -> True
168
for
atom -> True
168
|
atom -> True
168
]
atom -> True
168
+
atom -> True
168
**
atom -> True
168
.
atom -> True
168
is
atom -> True
168
//
atom -> True
168
>
atom -> True
168
%
atom -> True
168
in
atom -> True
168
<=
atom -> True
168
>>
atom -> True
168
/
atom -> True
168
==
atom -> True
168
and
atom -> True
168
<
atom -> True
168
@
atom -> True
169
**
530
169
,
power -> atom_expr
169
!=
power -> atom_expr
169
-
power -> atom_expr
169
<<
power -> atom_expr
169
not
power -> atom_expr
169
/
power -> atom_expr
169
<=
power -> atom_expr
169
in
power -> atom_expr
169
%
power -> atom_expr
169
>
power -> atom_expr
169
@
power -> atom_expr
169
|
power -> atom_expr
169
<
power -> atom_expr
169
>>
power -> atom_expr
169
]
power -> atom_expr
169
or
power -> atom_expr
169
and
power -> atom_expr
169
>=
power -> atom_expr
169
==
power -> atom_expr
169
^
power -> atom_expr
169
*
power -> atom_expr
169
for
power -> atom_expr
169
&
power -> atom_expr
169
is
power -> atom_expr
169
+
power -> atom_expr
169
if
power -> atom_expr
169
//
power -> atom_expr
170
[
166
170
True
168
170
atom_expr
169
170
-
173
170
~
170
170
{
174
170
atom
176
170
(
179
170
power
181
170
STRING
182
170
NAME
183
170
+
187
170
NUMBER
190
170
False
191
170
factor
531
170
None
194
171
[
166
171
factor
167
171
True
168
171
atom_expr
169
171
~
170
171
not
171
171
and_expr
172
171
-
173
171
{
174
171
shift_expr
175
171
atom
176
171
comparison
178
171
(
179
171
arith_expr
180
171
power
181
171
STRING
182
171
NAME
183
171
term
186
171
+
187
171
xor_expr
188
171
NUMBER
190
171
False
191
171
expr
192
171
not_test
532
171
None
194
172
>
xor_expr -> and_expr
172
<=
xor_expr -> and_expr
172
not
xor_expr -> and_expr
172
|
xor_expr -> and_expr
172
^
533
172
==
xor_expr -> and_expr
172
,
xor_expr -> and_expr
172
in
xor_expr -> and_expr
172
!=
xor_expr -> and_expr
172
if
xor_expr -> and_expr
172
for
xor_expr -> and_expr
172
is
xor_expr -> and_expr
172
<
xor_expr -> and_expr
172
or
xor_expr -> and_expr
172
]
xor_expr -> and_expr
172
and
xor_expr -> and_expr
172
>=
xor_expr -> and_expr
173
[
166
173
True
168
173
atom_expr
169
173
~
170
173
-
173
173
{
174
173
atom
176
173
(
179
173
power
181
173
STRING
182
173
NAME
183
173
factor
534
173
+
187
173
NUMBER
190
173
False
191
173
None
194
174
}
535
175
^
and_expr -> shift_expr
175
in
and_expr -> shift_expr
175
|
and_expr -> shift_expr
175
&
536
175
<
and_expr -> shift_expr
175
not
and_expr -> shift_expr
175
>=
and_expr -> shift_expr
175
]
and_expr -> shift_expr
175
for
and_expr -> shift_expr
175
<=
and_expr -> shift_expr
175
or
and_expr -> shift_expr
175
and
and_expr -> shift_expr
175
,
and_expr -> shift_expr
175
!=
and_expr -> shift_expr
175
if
and_expr -> shift_expr
175
is
and_expr -> shift_expr
175
==
and_expr -> shift_expr
175
>
and_expr -> shift_expr
176
>>
trailer_expr -> 
176
(
537
176
trailer
538
176
trailer_expr
539
176
.
540
176
+
trailer_expr -> 
176
[
541
176
is
trailer_expr -> 
176
>
trailer_expr -> 
176
not
trailer_expr -> 
176
|
trailer_expr -> 
176
&
trailer_expr -> 
176
/
trailer_expr -> 
176
@
trailer_expr -> 
176
!=
trailer_expr -> 
176
**
trailer_expr -> 
176
>=
trailer_expr -> 
176
^
trailer_expr -> 
176
in
trailer_expr -> 
176
]
trailer_expr -> 
176
<<
trailer_expr -> 
176
and
trailer_expr -> 
176
or
trailer_expr -> 
176
if
trailer_expr -> 
176
//
trailer_expr -> 
176
%
trailer_expr -> 
176
,
trailer_expr -> 
176
<=
trailer_expr -> 
176
<
trailer_expr -> 
176
==
trailer_expr -> 
176
for
trailer_expr -> 
176
-
trailer_expr -> 
176
*
trailer_expr -> 
177
!=
atom -> [ ]
177
>>
atom -> [ ]
177
|
atom -> [ ]
177
+=
atom -> [ ]
177
NEWLINE
atom -> [ ]
177
<<
atom -> [ ]
177
.
atom -> [ ]
177
%=
atom -> [ ]
177
/=
atom -> [ ]
177
&
atom -> [ ]
177
%
atom -> [ ]
177
*=
atom -> [ ]
177
-=
atom -> [ ]
177
**=
atom -> [ ]
177
|=
atom -> [ ]
177
>>=
atom -> [ ]
177
^
atom -> [ ]
177
=
atom -> [ ]
177
-
atom -> [ ]
177
,
atom -> [ ]
177
in
atom -> [ ]
177
:
atom -> [ ]
177
or
atom -> [ ]
177
/
atom -> [ ]
177
**
atom -> [ ]
177
//
atom -> [ ]
177
//=
atom -> [ ]
177
not
atom -> [ ]
177
(
atom -> [ ]
177
+
atom -> [ ]
177
and
atom -> [ ]
177
^=
atom -> [ ]
177
==
atom -> [ ]
177
@=
atom -> [ ]
177
[
atom -> [ ]
177
if
atom -> [ ]
177
<
atom -> [ ]
177
<=
atom -> [ ]
177
<<=
atom -> [ ]
177
&=
atom -> [ ]
177
>=
atom -> [ ]
177
is
atom -> [ ]
177
*
atom -> [ ]
177
@
atom -> [ ]
177
>
atom -> [ ]
178
or
not_test -> comparison
178
,
not_test -> comparison
178
for
not_test -> comparison
178
]
not_test -> comparison
178
and
not_test -> comparison
178
if
not_test -> comparison
179
[
128
179
factor
129
179
True
130
179
atom_expr
131
179
~
132
179
and_expr
133
179
-
134
179
{
135
179
test_list_comp
542
179
shift_expr
137
179
atom
138
179
)
543
179
comparison
140
179
arith_expr
141
179
power
142
179
STRING
143
179
NAME
144
179
(
145
179
and_test
146
179
term
147
179
+
148
179
xor_expr
149
179
or_test
150
179
NUMBER
151
179
not
152
179
False
153
179
expr
154
179
not_test
155
179
None
156
179
lambdef
157
179
lambda
158
179
test
159
179
test_list
160
180
>>
544
180
<<
545
180
if
shift_expr -> arith_expr
180
&
shift_expr -> arith_expr
180
|
shift_expr -> arith_expr
180
is
shift_expr -> arith_expr
180
<
shift_expr -> arith_expr
180
==
shift_expr -> arith_expr
180
or
shift_expr -> arith_expr
180
>
shift_expr -> arith_expr
180
!=
shift_expr -> arith_expr
180
for
shift_expr -> arith_expr
180
>=
shift_expr -> arith_expr
180
]
shift_expr -> arith_expr
180
in
shift_expr -> arith_expr
180
,
shift_expr -> arith_expr
180
<=
shift_expr -> arith_expr
180
and
shift_expr -> arith_expr
180
^
shift_expr -> arith_expr
180
not
shift_expr -> arith_expr
181
+
factor -> power
181
%
factor -> power
181
,
factor -> power
181
<
factor -> power
181
<<
factor -> power
181
!=
factor -> power
181
<=
factor -> power
181
and
factor -> power
181
/
factor -> power
181
^
factor -> power
181
for
factor -> power
181
@
factor -> power
181
>=
factor -> power
181
not
factor -> power
181
//
factor -> power
181
or
factor -> power
181
==
factor -> power
181
is
factor -> power
181
]
factor -> power
181
|
factor -> power
181
*
factor -> power
181
-
factor -> power
181
if
factor -> power
181
>
factor -> power
181
in
factor -> power
181
>>
factor -> power
181
&
factor -> power
182
%
atom -> STRING
182
>
atom -> STRING
182
@
atom -> STRING
182
<<
atom -> STRING
182
in
atom -> STRING
182
[
atom -> STRING
182
-
atom -> STRING
182
==
atom -> STRING
182
>=
atom -> STRING
182
not
atom -> STRING
182
/
atom -> STRING
182
+
atom -> STRING
182
*
atom -> STRING
182
(
atom -> STRING
182
//
atom -> STRING
182
if
atom -> STRING
182
.
atom -> STRING
182
<
atom -> STRING
182
,
atom -> STRING
182
&
atom -> STRING
182
<=
atom -> STRING
182
for
atom -> STRING
182
!=
atom -> STRING
182
**
atom -> STRING
182
^
atom -> STRING
182
and
atom -> STRING
182
]
atom -> STRING
182
is
atom -> STRING
182
|
atom -> STRING
182
or
atom -> STRING
182
>>
atom -> STRING
183
<
atom -> NAME
183
,
atom -> NAME
183
^
atom -> NAME
183
+
atom -> NAME
183
-
atom -> NAME
183
>=
atom -> NAME
183
@
atom -> NAME
183
!=
atom -> NAME
183
for
atom -> NAME
183
*
atom -> NAME
183
<=
atom -> NAME
183
**
atom -> NAME
183
or
atom -> NAME
183
not
atom -> NAME
183
==
atom -> NAME
183
&
atom -> NAME
183
]
atom -> NAME
183
>
atom -> NAME
183
%
atom -> NAME
183
>>
atom -> NAME
183
.
atom -> NAME
183
|
atom -> NAME
183
is
atom -> NAME
183
and
atom -> NAME
183
//
atom -> NAME
183
[
atom -> NAME
183
/
atom -> NAME
183
(
atom -> NAME
183
<<
atom -> NAME
183
if
atom -> NAME
183
in
atom -> NAME
184
comp_for
546
184
for
547
184
,
548
184
]
test_list -> test
185
]
or_test -> and_test
185
for
or_test -> and_test
185
or
549
185
,
or_test -> and_test
185
if
or_test -> and_test
186
-
550
186
+
551
186
]
arith_expr -> term
186
|
arith_expr -> term
186
>=
arith_expr -> term
186
<=
arith_expr -> term
186
not
arith_expr -> term
186
,
arith_expr -> term
186
==
arith_expr -> term
186
for
arith_expr -> term
186
in
arith_expr -> term
186
>>
arith_expr -> term
186
is
arith_expr -> term
186
if
arith_expr -> term
186
or
arith_expr -> term
186
!=
arith_expr -> term
186
>
arith_expr -> term
186
and
arith_expr -> term
186
<<
arith_expr -> term
186
<
arith_expr -> term
186
^
arith_expr -> term
186
&
arith_expr -> term
187
[
166
187
True
168
187
atom_expr
169
187
-
173
187
~
170
187
{
174
187
atom
176
187
(
179
187
power
181
187
STRING
182
187
NAME
183
187
factor
552
187
+
187
187
NUMBER
190
187
False
191
187
None
194
188
|
553
188
]
expr -> xor_expr
188
>
expr -> xor_expr
188
if
expr -> xor_expr
188
for
expr -> xor_expr
188
is
expr -> xor_expr
188
and
expr -> xor_expr
188
not
expr -> xor_expr
188
or
expr -> xor_expr
188
>=
expr -> xor_expr
188
==
expr -> xor_expr
188
,
expr -> xor_expr
188
<
expr -> xor_expr
188
!=
expr -> xor_expr
188
<=
expr -> xor_expr
188
in
expr -> xor_expr
189
]
554
190
+
atom -> NUMBER
190
*
atom -> NUMBER
190
>
atom -> NUMBER
190
<<
atom -> NUMBER
190
for
atom -> NUMBER
190
-
atom -> NUMBER
190
**
atom -> NUMBER
190
if
atom -> NUMBER
190
or
atom -> NUMBER
190
is
atom -> NUMBER
190
[
atom -> NUMBER
190
(
atom -> NUMBER
190
not
atom -> NUMBER
190
&
atom -> NUMBER
190
^
atom -> NUMBER
190
in
atom -> NUMBER
190
==
atom -> NUMBER
190
//
atom -> NUMBER
190
!=
atom -> NUMBER
190
and
atom -> NUMBER
190
]
atom -> NUMBER
190
%
atom -> NUMBER
190
<=
atom -> NUMBER
190
.
atom -> NUMBER
190
<
atom -> NUMBER
190
>>
atom -> NUMBER
190
,
atom -> NUMBER
190
/
atom -> NUMBER
190
@
atom -> NUMBER
190
>=
atom -> NUMBER
190
|
atom -> NUMBER
191
for
atom -> False
191
(
atom -> False
191
*
atom -> False
191
==
atom -> False
191
|
atom -> False
191
,
atom -> False
191
]
atom -> False
191
[
atom -> False
191
in
atom -> False
191
&
atom -> False
191
is
atom -> False
191
not
atom -> False
191
if
atom -> False
191
^
atom -> False
191
+
atom -> False
191
>
atom -> False
191
<=
atom -> False
191
<<
atom -> False
191
<
atom -> False
191
>=
atom -> False
191
%
atom -> False
191
@
atom -> False
191
and
atom -> False
191
!=
atom -> False
191
-
atom -> False
191
.
atom -> False
191
//
atom -> False
191
/
atom -> False
191
**
atom -> False
191
>>
atom -> False
191
or
atom -> False
192
>
317
192
is
318
192
in
319
192
<=
320
192
<
321
192
>=
322
192
!=
324
192
not
325
192
==
326
192
comp_op
555
192
for
comparison -> expr
192
or
comparison -> expr
192
if
comparison -> expr
192
]
comparison -> expr
192
and
comparison -> expr
192
,
comparison -> expr
193
]
and_test -> not_test
193
and
556
193
,
and_test -> not_test
193
if
and_test -> not_test
193
for
and_test -> not_test
193
or
and_test -> not_test
194
@
atom -> None
194
<=
atom -> None
194
in
atom -> None
194
and
atom -> None
194
for
atom -> None
194
&
atom -> None
194
|
atom -> None
194
>
atom -> None
194
>=
atom -> None
194
/
atom -> None
194
<<
atom -> None
194
-
atom -> None
194
!=
atom -> None
194
**
atom -> None
194
(
atom -> None
194
]
atom -> None
194
*
atom -> None
194
.
atom -> None
194
>>
atom -> None
194
==
atom -> None
194
is
atom -> None
194
<
atom -> None
194
if
atom -> None
194
^
atom -> None
194
[
atom -> None
194
%
atom -> None
194
+
atom -> None
194
not
atom -> None
194
,
atom -> None
194
or
atom -> None
194
//
atom -> None
195
for
test -> lambdef
195
]
test -> lambdef
195
,
test -> lambdef
196
vfpdef
234
196
:
557
196
varargslist
558
196
NAME
233
197
if
559
197
for
test -> or_test
197
]
test -> or_test
197
,
test -> or_test
198
]
test_list_comp -> test_list
199
(
560
199
:
561
200
del
simple_stmt -> small_stmt NEWLINE
200
break
simple_stmt -> small_stmt NEWLINE
200
raise
simple_stmt -> small_stmt NEWLINE
200
servmod
simple_stmt -> small_stmt NEWLINE
200
class
simple_stmt -> small_stmt NEWLINE
200
not
simple_stmt -> small_stmt NEWLINE
200
-
simple_stmt -> small_stmt NEWLINE
200
False
simple_stmt -> small_stmt NEWLINE
200
(
simple_stmt -> small_stmt NEWLINE
200
endsim
simple_stmt -> small_stmt NEWLINE
200
+
simple_stmt -> small_stmt NEWLINE
200
None
simple_stmt -> small_stmt NEWLINE
200
resetstats
simple_stmt -> small_stmt NEWLINE
200
conf
simple_stmt -> small_stmt NEWLINE
200
server
simple_stmt -> small_stmt NEWLINE
200
STRING
simple_stmt -> small_stmt NEWLINE
200
$
simple_stmt -> small_stmt NEWLINE
200
if
simple_stmt -> small_stmt NEWLINE
200
NUMBER
simple_stmt -> small_stmt NEWLINE
200
global
simple_stmt -> small_stmt NEWLINE
200
@
simple_stmt -> small_stmt NEWLINE
200
True
simple_stmt -> small_stmt NEWLINE
200
lambda
simple_stmt -> small_stmt NEWLINE
200
pass
simple_stmt -> small_stmt NEWLINE
200
return
simple_stmt -> small_stmt NEWLINE
200
def
simple_stmt -> small_stmt NEWLINE
200
with
simple_stmt -> small_stmt NEWLINE
200
nonlocal
simple_stmt -> small_stmt NEWLINE
200
assert
simple_stmt -> small_stmt NEWLINE
200
NAME
simple_stmt -> small_stmt NEWLINE
200
try
simple_stmt -> small_stmt NEWLINE
200
begsim
simple_stmt -> small_stmt NEWLINE
200
while
simple_stmt -> small_stmt NEWLINE
200
for
simple_stmt -> small_stmt NEWLINE
200
[
simple_stmt -> small_stmt NEWLINE
200
modopt
simple_stmt -> small_stmt NEWLINE
200
yield
simple_stmt -> small_stmt NEWLINE
200
NEWLINE
simple_stmt -> small_stmt NEWLINE
200
continue
simple_stmt -> small_stmt NEWLINE
200
{
simple_stmt -> small_stmt NEWLINE
200
~
simple_stmt -> small_stmt NEWLINE
201
in
atom -> { }
201
<=
atom -> { }
201
*
atom -> { }
201
|=
atom -> { }
201
NEWLINE
atom -> { }
201
-=
atom -> { }
201
%=
atom -> { }
201
>
atom -> { }
201
&=
atom -> { }
201
+
atom -> { }
201
**=
atom -> { }
201
@
atom -> { }
201
@=
atom -> { }
201
,
atom -> { }
201
<<=
atom -> { }
201
>=
atom -> { }
201
/=
atom -> { }
201
/
atom -> { }
201
:
atom -> { }
201
|
atom -> { }
201
is
atom -> { }
201
and
atom -> { }
201
=
atom -> { }
201
if
atom -> { }
201
(
atom -> { }
201
>>
atom -> { }
201
not
atom -> { }
201
-
atom -> { }
201
**
atom -> { }
201
or
atom -> { }
201
//=
atom -> { }
201
+=
atom -> { }
201
<
atom -> { }
201
*=
atom -> { }
201
==
atom -> { }
201
^=
atom -> { }
201
//
atom -> { }
201
>>=
atom -> { }
201
!=
atom -> { }
201
%
atom -> { }
201
.
atom -> { }
201
&
atom -> { }
201
[
atom -> { }
201
<<
atom -> { }
201
^
atom -> { }
202
[
18
202
arith_expr
562
202
factor
17
202
True
38
202
atom_expr
31
202
term
22
202
~
37
202
-
26
202
None
55
202
atom
57
202
{
21
202
power
9
202
STRING
10
202
NAME
52
202
(
16
202
NUMBER
58
202
+
27
202
False
39
203
[
18
203
factor
17
203
True
38
203
atom_expr
31
203
term
22
203
~
37
203
-
26
203
None
55
203
arith_expr
563
203
atom
57
203
{
21
203
power
9
203
STRING
10
203
NAME
52
203
(
16
203
NUMBER
58
203
+
27
203
False
39
204
(
564
205
:
565
206
@
factor -> - factor
206
=
factor -> - factor
206
<=
factor -> - factor
206
in
factor -> - factor
206
>>
factor -> - factor
206
+=
factor -> - factor
206
>>=
factor -> - factor
206
|
factor -> - factor
206
is
factor -> - factor
206
+
factor -> - factor
206
%
factor -> - factor
206
<
factor -> - factor
206
&=
factor -> - factor
206
*
factor -> - factor
206
<<
factor -> - factor
206
if
factor -> - factor
206
-
factor -> - factor
206
>=
factor -> - factor
206
not
factor -> - factor
206
and
factor -> - factor
206
/
factor -> - factor
206
:
factor -> - factor
206
or
factor -> - factor
206
NEWLINE
factor -> - factor
206
^
factor -> - factor
206
@=
factor -> - factor
206
%=
factor -> - factor
206
/=
factor -> - factor
206
<<=
factor -> - factor
206
-=
factor -> - factor
206
>
factor -> - factor
206
*=
factor -> - factor
206
**=
factor -> - factor
206
!=
factor -> - factor
206
//=
factor -> - factor
206
&
factor -> - factor
206
==
factor -> - factor
206
//
factor -> - factor
206
^=
factor -> - factor
206
,
factor -> - factor
206
|=
factor -> - factor
207
!=
factor -> + factor
207
@
factor -> + factor
207
:
factor -> + factor
207
/=
factor -> + factor
207
<<
factor -> + factor
207
is
factor -> + factor
207
and
factor -> + factor
207
<=
factor -> + factor
207
**=
factor -> + factor
207
or
factor -> + factor
207
<
factor -> + factor
207
^
factor -> + factor
207
not
factor -> + factor
207
//
factor -> + factor
207
%=
factor -> + factor
207
//=
factor -> + factor
207
|=
factor -> + factor
207
,
factor -> + factor
207
*
factor -> + factor
207
in
factor -> + factor
207
>>=
factor -> + factor
207
+=
factor -> + factor
207
*=
factor -> + factor
207
&
factor -> + factor
207
+
factor -> + factor
207
-=
factor -> + factor
207
if
factor -> + factor
207
>>
factor -> + factor
207
&=
factor -> + factor
207
|
factor -> + factor
207
=
factor -> + factor
207
>
factor -> + factor
207
%
factor -> + factor
207
@=
factor -> + factor
207
<<=
factor -> + factor
207
NEWLINE
factor -> + factor
207
>=
factor -> + factor
207
-
factor -> + factor
207
^=
factor -> + factor
207
/
factor -> + factor
207
==
factor -> + factor
208
[
166
208
factor
167
208
True
168
208
atom_expr
169
208
~
170
208
not
171
208
and_expr
172
208
-
173
208
{
174
208
shift_expr
175
208
atom
176
208
comparison
178
208
(
179
208
arith_expr
180
208
power
181
208
STRING
182
208
NAME
183
208
test
184
208
and_test
185
208
]
566
208
term
186
208
+
187
208
xor_expr
188
208
NUMBER
190
208
test_list_comp
567
208
False
191
208
expr
192
208
not_test
193
208
None
194
208
lambdef
195
208
lambda
196
208
or_test
197
208
test_list
198
209
}
568
210
//
569
210
&
term -> factor
210
*
570
210
/
571
210
%
572
210
@
573
210
<<
term -> factor
210
|
term -> factor
210
^
term -> factor
210
+
term -> factor
210
in
term -> factor
210
,
term -> factor
210
>>
term -> factor
210
-
term -> factor
211
in
574
212
-
atom -> True
212
<<
atom -> True
212
+
atom -> True
212
%
atom -> True
212
*
atom -> True
212
&
atom -> True
212
in
atom -> True
212
^
atom -> True
212
**
atom -> True
212
>>
atom -> True
212
/
atom -> True
212
[
atom -> True
212
,
atom -> True
212
.
atom -> True
212
(
atom -> True
212
//
atom -> True
212
|
atom -> True
212
@
atom -> True
213
[
208
213
{
209
213
True
212
213
~
213
213
atom
217
213
STRING
218
213
power
219
213
NAME
220
213
(
221
213
+
222
213
None
224
213
False
225
213
atom_expr
226
213
-
227
213
NUMBER
229
213
factor
575
214
,
xor_expr -> and_expr
214
^
576
214
in
xor_expr -> and_expr
214
|
xor_expr -> and_expr
215
<<
577
215
>>
578
215
&
shift_expr -> arith_expr
215
|
shift_expr -> arith_expr
215
in
shift_expr -> arith_expr
215
^
shift_expr -> arith_expr
215
,
shift_expr -> arith_expr
216
&
579
216
^
and_expr -> shift_expr
216
in
and_expr -> shift_expr
216
|
and_expr -> shift_expr
216
,
and_expr -> shift_expr
217
>>
trailer_expr -> 
217
(
580
217
[
581
217
in
trailer_expr -> 
217
trailer
582
217
.
583
217
trailer_expr
584
217
+
trailer_expr -> 
217
<<
trailer_expr -> 
217
|
trailer_expr -> 
217
//
trailer_expr -> 
217
%
trailer_expr -> 
217
,
trailer_expr -> 
217
&
trailer_expr -> 
217
/
trailer_expr -> 
217
@
trailer_expr -> 
217
**
trailer_expr -> 
217
-
trailer_expr -> 
217
^
trailer_expr -> 
217
*
trailer_expr -> 
218
|
atom -> STRING
218
(
atom -> STRING
218
%
atom -> STRING
218
//
atom -> STRING
218
[
atom -> STRING
218
/
atom -> STRING
218
-
atom -> STRING
218
**
atom -> STRING
218
^
atom -> STRING
218
@
atom -> STRING
218
,
atom -> STRING
218
&
atom -> STRING
218
<<
atom -> STRING
218
.
atom -> STRING
218
+
atom -> STRING
218
>>
atom -> STRING
218
in
atom -> STRING
218
*
atom -> STRING
219
+
factor -> power
219
%
factor -> power
219
*
factor -> power
219
-
factor -> power
219
//
factor -> power
219
/
factor -> power
219
^
factor -> power
219
,
factor -> power
219
>>
factor -> power
219
in
factor -> power
219
&
factor -> power
219
<<
factor -> power
219
@
factor -> power
219
|
factor -> power
220
&
atom -> NAME
220
*
atom -> NAME
220
//
atom -> NAME
220
,
atom -> NAME
220
[
atom -> NAME
220
/
atom -> NAME
220
%
atom -> NAME
220
>>
atom -> NAME
220
.
atom -> NAME
220
^
atom -> NAME
220
(
atom -> NAME
220
**
atom -> NAME
220
+
atom -> NAME
220
@
atom -> NAME
220
-
atom -> NAME
220
<<
atom -> NAME
220
in
atom -> NAME
220
|
atom -> NAME
221
[
128
221
factor
129
221
True
130
221
atom_expr
131
221
~
132
221
and_expr
133
221
-
134
221
{
135
221
test_list_comp
585
221
shift_expr
137
221
atom
138
221
)
586
221
comparison
140
221
arith_expr
141
221
power
142
221
STRING
143
221
NAME
144
221
(
145
221
and_test
146
221
term
147
221
+
148
221
xor_expr
149
221
or_test
150
221
NUMBER
151
221
not
152
221
False
153
221
expr
154
221
not_test
155
221
None
156
221
lambdef
157
221
lambda
158
221
test
159
221
test_list
160
222
[
208
222
{
209
222
True
212
222
~
213
222
atom
217
222
STRING
218
222
power
219
222
NAME
220
222
(
221
222
+
222
222
None
224
222
factor
587
222
False
225
222
atom_expr
226
222
-
227
222
NUMBER
229
223
-
588
223
+
589
223
|
arith_expr -> term
223
,
arith_expr -> term
223
in
arith_expr -> term
223
>>
arith_expr -> term
223
<<
arith_expr -> term
223
^
arith_expr -> term
223
&
arith_expr -> term
224
[
atom -> None
224
%
atom -> None
224
+
atom -> None
224
*
atom -> None
224
.
atom -> None
224
//
atom -> None
224
@
atom -> None
224
&
atom -> None
224
>>
atom -> None
224
/
atom -> None
224
,
atom -> None
224
-
atom -> None
224
<<
atom -> None
224
in
atom -> None
224
**
atom -> None
224
(
atom -> None
224
|
atom -> None
224
^
atom -> None
225
|
atom -> False
225
,
atom -> False
225
[
atom -> False
225
(
atom -> False
225
<<
atom -> False
225
@
atom -> False
225
*
atom -> False
225
-
atom -> False
225
in
atom -> False
225
&
atom -> False
225
.
atom -> False
225
//
atom -> False
225
+
atom -> False
225
^
atom -> False
225
/
atom -> False
225
**
atom -> False
225
>>
atom -> False
225
%
atom -> False
226
**
590
226
,
power -> atom_expr
226
-
power -> atom_expr
226
<<
power -> atom_expr
226
/
power -> atom_expr
226
in
power -> atom_expr
226
%
power -> atom_expr
226
@
power -> atom_expr
226
|
power -> atom_expr
226
>>
power -> atom_expr
226
^
power -> atom_expr
226
*
power -> atom_expr
226
&
power -> atom_expr
226
+
power -> atom_expr
226
//
power -> atom_expr
227
[
208
227
{
209
227
True
212
227
~
213
227
atom
217
227
factor
591
227
STRING
218
227
power
219
227
NAME
220
227
(
221
227
+
222
227
None
224
227
False
225
227
atom_expr
226
227
-
227
227
NUMBER
229
228
in
expr_list -> expr
228
,
592
229
.
atom -> NUMBER
229
+
atom -> NUMBER
229
//
atom -> NUMBER
229
*
atom -> NUMBER
229
>>
atom -> NUMBER
229
,
atom -> NUMBER
229
[
atom -> NUMBER
229
<<
atom -> NUMBER
229
/
atom -> NUMBER
229
-
atom -> NUMBER
229
**
atom -> NUMBER
229
(
atom -> NUMBER
229
@
atom -> NUMBER
229
%
atom -> NUMBER
229
|
atom -> NUMBER
229
&
atom -> NUMBER
229
^
atom -> NUMBER
229
in
atom -> NUMBER
230
|
593
230
,
expr -> xor_expr
230
in
expr -> xor_expr
231
arith_expr
1
231
factor
17
231
True
38
231
atom_expr
31
231
term
22
231
-
26
231
None
55
231
atom
57
231
comparison
49
231
and_expr
8
231
power
9
231
STRING
10
231
NAME
52
231
shift_expr
48
231
lambdef
15
231
test
594
231
NUMBER
58
231
(
16
231
expr
47
231
[
18
231
not_test
32
231
{
21
231
and_test
46
231
+
27
231
lambda
29
231
xor_expr
41
231
not
62
231
~
37
231
or_test
53
231
False
39
232
:
595
233
:
vfpdef -> NAME
233
,
vfpdef -> NAME
234
,
596
234
:
varargslist -> vfpdef
235
NAME
decorated -> decorators funcdef
235
continue
decorated -> decorators funcdef
235
with
decorated -> decorators funcdef
235
break
decorated -> decorators funcdef
235
return
decorated -> decorators funcdef
235
raise
decorated -> decorators funcdef
235
{
decorated -> decorators funcdef
235
None
decorated -> decorators funcdef
235
modopt
decorated -> decorators funcdef
235
endsim
decorated -> decorators funcdef
235
begsim
decorated -> decorators funcdef
235
del
decorated -> decorators funcdef
235
lambda
decorated -> decorators funcdef
235
pass
decorated -> decorators funcdef
235
servmod
decorated -> decorators funcdef
235
class
decorated -> decorators funcdef
235
[
decorated -> decorators funcdef
235
~
decorated -> decorators funcdef
235
yield
decorated -> decorators funcdef
235
def
decorated -> decorators funcdef
235
if
decorated -> decorators funcdef
235
True
decorated -> decorators funcdef
235
assert
decorated -> decorators funcdef
235
+
decorated -> decorators funcdef
235
global
decorated -> decorators funcdef
235
(
decorated -> decorators funcdef
235
STRING
decorated -> decorators funcdef
235
conf
decorated -> decorators funcdef
235
-
decorated -> decorators funcdef
235
@
decorated -> decorators funcdef
235
nonlocal
decorated -> decorators funcdef
235
not
decorated -> decorators funcdef
235
server
decorated -> decorators funcdef
235
for
decorated -> decorators funcdef
235
try
decorated -> decorators funcdef
235
NEWLINE
decorated -> decorators funcdef
235
NUMBER
decorated -> decorators funcdef
235
resetstats
decorated -> decorators funcdef
235
$
decorated -> decorators funcdef
235
False
decorated -> decorators funcdef
235
while
decorated -> decorators funcdef
236
STRING
decorated -> decorators classdef
236
servmod
decorated -> decorators classdef
236
continue
decorated -> decorators classdef
236
None
decorated -> decorators classdef
236
global
decorated -> decorators classdef
236
NEWLINE
decorated -> decorators classdef
236
True
decorated -> decorators classdef
236
class
decorated -> decorators classdef
236
[
decorated -> decorators classdef
236
begsim
decorated -> decorators classdef
236
nonlocal
decorated -> decorators classdef
236
conf
decorated -> decorators classdef
236
NUMBER
decorated -> decorators classdef
236
+
decorated -> decorators classdef
236
yield
decorated -> decorators classdef
236
resetstats
decorated -> decorators classdef
236
assert
decorated -> decorators classdef
236
raise
decorated -> decorators classdef
236
break
decorated -> decorators classdef
236
@
decorated -> decorators classdef
236
server
decorated -> decorators classdef
236
with
decorated -> decorators classdef
236
pass
decorated -> decorators classdef
236
endsim
decorated -> decorators classdef
236
not
decorated -> decorators classdef
236
for
decorated -> decorators classdef
236
(
decorated -> decorators classdef
236
lambda
decorated -> decorators classdef
236
{
decorated -> decorators classdef
236
$
decorated -> decorators classdef
236
False
decorated -> decorators classdef
236
while
decorated -> decorators classdef
236
try
decorated -> decorators classdef
236
return
decorated -> decorators classdef
236
def
decorated -> decorators classdef
236
if
decorated -> decorators classdef
236
NAME
decorated -> decorators classdef
236
del
decorated -> decorators classdef
236
-
decorated -> decorators classdef
236
modopt
decorated -> decorators classdef
236
~
decorated -> decorators classdef
237
[
18
237
True
38
237
atom_expr
31
237
-
26
237
~
37
237
None
55
237
atom
57
237
{
21
237
factor
597
237
power
9
237
STRING
10
237
NAME
52
237
(
16
237
NUMBER
58
237
+
27
237
False
39
238
arith_expr
1
238
factor
17
238
True
38
238
atom_expr
31
238
term
22
238
-
26
238
None
55
238
atom
57
238
comparison
49
238
and_expr
8
238
power
9
238
STRING
10
238
NAME
52
238
shift_expr
48
238
NUMBER
58
238
and_test
598
238
(
16
238
expr
47
238
[
18
238
not_test
32
238
{
21
238
+
27
238
xor_expr
41
238
not
62
238
~
37
238
False
39
239
[
166
239
factor
167
239
True
168
239
atom_expr
169
239
~
170
239
not
171
239
and_expr
172
239
-
173
239
{
174
239
shift_expr
175
239
atom
176
239
comparison
178
239
(
179
239
arith_expr
180
239
power
181
239
STRING
182
239
NAME
183
239
test
184
239
and_test
185
239
]
599
239
term
186
239
+
187
239
xor_expr
188
239
NUMBER
190
239
test_list_comp
600
239
False
191
239
expr
192
239
not_test
193
239
None
194
239
lambdef
195
239
lambda
196
239
or_test
197
239
test_list
198
240
}
601
241
&
term -> factor
241
*
602
241
/
603
241
%
604
241
@
605
241
//
606
241
<<
term -> factor
241
|
term -> factor
241
^
term -> factor
241
+
term -> factor
241
NEWLINE
term -> factor
241
,
term -> factor
241
>>
term -> factor
241
-
term -> factor
242
-
atom -> True
242
<<
atom -> True
242
+
atom -> True
242
%
atom -> True
242
*
atom -> True
242
&
atom -> True
242
^
atom -> True
242
,
atom -> True
242
**
atom -> True
242
>>
atom -> True
242
/
atom -> True
242
[
atom -> True
242
.
atom -> True
242
NEWLINE
atom -> True
242
(
atom -> True
242
//
atom -> True
242
|
atom -> True
242
@
atom -> True
243
[
239
243
{
240
243
True
242
243
~
243
243
None
245
243
atom
248
243
STRING
249
243
power
250
243
NAME
251
243
(
252
243
NUMBER
253
243
+
254
243
False
256
243
atom_expr
257
243
-
258
243
factor
607
244
NEWLINE
xor_expr -> and_expr
244
,
xor_expr -> and_expr
244
^
608
244
|
xor_expr -> and_expr
245
[
atom -> None
245
%
atom -> None
245
+
atom -> None
245
*
atom -> None
245
.
atom -> None
245
//
atom -> None
245
@
atom -> None
245
&
atom -> None
245
>>
atom -> None
245
/
atom -> None
245
,
atom -> None
245
NEWLINE
atom -> None
245
-
atom -> None
245
<<
atom -> None
245
**
atom -> None
245
(
atom -> None
245
|
atom -> None
245
^
atom -> None
246
>>
609
246
<<
610
246
&
shift_expr -> arith_expr
246
|
shift_expr -> arith_expr
246
^
shift_expr -> arith_expr
246
NEWLINE
shift_expr -> arith_expr
246
,
shift_expr -> arith_expr
247
&
611
247
^
and_expr -> shift_expr
247
|
and_expr -> shift_expr
247
NEWLINE
and_expr -> shift_expr
247
,
and_expr -> shift_expr
248
>>
trailer_expr -> 
248
(
612
248
[
613
248
trailer
614
248
.
615
248
trailer_expr
616
248
+
trailer_expr -> 
248
<<
trailer_expr -> 
248
|
trailer_expr -> 
248
NEWLINE
trailer_expr -> 
248
//
trailer_expr -> 
248
%
trailer_expr -> 
248
,
trailer_expr -> 
248
&
trailer_expr -> 
248
/
trailer_expr -> 
248
@
trailer_expr -> 
248
**
trailer_expr -> 
248
-
trailer_expr -> 
248
^
trailer_expr -> 
248
*
trailer_expr -> 
249
|
atom -> STRING
249
(
atom -> STRING
249
%
atom -> STRING
249
//
atom -> STRING
249
[
atom -> STRING
249
/
atom -> STRING
249
-
atom -> STRING
249
**
atom -> STRING
249
^
atom -> STRING
249
@
atom -> STRING
249
,
atom -> STRING
249
&
atom -> STRING
249
<<
atom -> STRING
249
.
atom -> STRING
249
+
atom -> STRING
249
>>
atom -> STRING
249
NEWLINE
atom -> STRING
249
*
atom -> STRING
250
+
factor -> power
250
%
factor -> power
250
*
factor -> power
250
-
factor -> power
250
//
factor -> power
250
/
factor -> power
250
|
factor -> power
250
^
factor -> power
250
,
factor -> power
250
>>
factor -> power
250
&
factor -> power
250
<<
factor -> power
250
@
factor -> power
250
NEWLINE
factor -> power
251
&
atom -> NAME
251
*
atom -> NAME
251
//
atom -> NAME
251
,
atom -> NAME
251
[
atom -> NAME
251
/
atom -> NAME
251
%
atom -> NAME
251
>>
atom -> NAME
251
.
atom -> NAME
251
NEWLINE
atom -> NAME
251
^
atom -> NAME
251
(
atom -> NAME
251
+
atom -> NAME
251
@
atom -> NAME
251
-
atom -> NAME
251
**
atom -> NAME
251
|
atom -> NAME
251
<<
atom -> NAME
252
[
128
252
factor
129
252
True
130
252
atom_expr
131
252
~
132
252
and_expr
133
252
-
134
252
{
135
252
test_list_comp
617
252
shift_expr
137
252
atom
138
252
)
618
252
comparison
140
252
arith_expr
141
252
power
142
252
STRING
143
252
NAME
144
252
(
145
252
and_test
146
252
term
147
252
+
148
252
xor_expr
149
252
or_test
150
252
NUMBER
151
252
not
152
252
False
153
252
expr
154
252
not_test
155
252
None
156
252
lambdef
157
252
lambda
158
252
test
159
252
test_list
160
253
.
atom -> NUMBER
253
+
atom -> NUMBER
253
//
atom -> NUMBER
253
*
atom -> NUMBER
253
>>
atom -> NUMBER
253
,
atom -> NUMBER
253
[
atom -> NUMBER
253
<<
atom -> NUMBER
253
/
atom -> NUMBER
253
-
atom -> NUMBER
253
**
atom -> NUMBER
253
NEWLINE
atom -> NUMBER
253
(
atom -> NUMBER
253
%
atom -> NUMBER
253
|
atom -> NUMBER
253
@
atom -> NUMBER
253
&
atom -> NUMBER
253
^
atom -> NUMBER
254
[
239
254
{
240
254
True
242
254
~
243
254
None
245
254
atom
248
254
STRING
249
254
power
250
254
NAME
251
254
(
252
254
NUMBER
253
254
+
254
254
factor
619
254
False
256
254
atom_expr
257
254
-
258
255
-
620
255
+
621
255
|
arith_expr -> term
255
,
arith_expr -> term
255
>>
arith_expr -> term
255
<<
arith_expr -> term
255
NEWLINE
arith_expr -> term
255
^
arith_expr -> term
255
&
arith_expr -> term
256
|
atom -> False
256
,
atom -> False
256
[
atom -> False
256
(
atom -> False
256
<<
atom -> False
256
@
atom -> False
256
*
atom -> False
256
-
atom -> False
256
&
atom -> False
256
.
atom -> False
256
NEWLINE
atom -> False
256
//
atom -> False
256
+
atom -> False
256
^
atom -> False
256
/
atom -> False
256
**
atom -> False
256
>>
atom -> False
256
%
atom -> False
257
**
622
257
,
power -> atom_expr
257
-
power -> atom_expr
257
<<
power -> atom_expr
257
/
power -> atom_expr
257
%
power -> atom_expr
257
@
power -> atom_expr
257
|
power -> atom_expr
257
NEWLINE
power -> atom_expr
257
>>
power -> atom_expr
257
^
power -> atom_expr
257
*
power -> atom_expr
257
&
power -> atom_expr
257
+
power -> atom_expr
257
//
power -> atom_expr
258
[
239
258
{
240
258
True
242
258
~
243
258
None
245
258
atom
248
258
factor
623
258
STRING
249
258
power
250
258
NAME
251
258
(
252
258
NUMBER
253
258
+
254
258
False
256
258
atom_expr
257
258
-
258
259
NEWLINE
yield_stmt -> yield expr_list
260
|
624
260
,
expr -> xor_expr
260
NEWLINE
expr -> xor_expr
261
,
625
261
NEWLINE
expr_list -> expr
262
(
626
262
:
627
263
STRING
augassign -> //=
263
True
augassign -> //=
263
+
augassign -> //=
263
(
augassign -> //=
263
NUMBER
augassign -> //=
263
[
augassign -> //=
263
~
augassign -> //=
263
NAME
augassign -> //=
263
not
augassign -> //=
263
None
augassign -> //=
263
{
augassign -> //=
263
yield
augassign -> //=
263
False
augassign -> //=
263
-
augassign -> //=
263
lambda
augassign -> //=
264
[
334
264
factor
335
264
True
336
264
atom_expr
337
264
~
338
264
and_expr
339
264
-
340
264
None
341
264
shift_expr
342
264
atom
343
264
{
344
264
comparison
345
264
arith_expr
346
264
power
347
264
STRING
348
264
NAME
349
264
(
350
264
NUMBER
351
264
and_test
352
264
term
353
264
+
354
264
yield
628
264
xor_expr
355
264
not
356
264
False
357
264
lambda
358
264
not_test
359
264
yield_expr
629
264
lambdef
361
264
expr
362
264
or_test
363
264
test
364
264
yield_or_testlist
630
264
test_list
631
265
not
augassign -> **=
265
~
augassign -> **=
265
True
augassign -> **=
265
NAME
augassign -> **=
265
{
augassign -> **=
265
STRING
augassign -> **=
265
lambda
augassign -> **=
265
NUMBER
augassign -> **=
265
+
augassign -> **=
265
None
augassign -> **=
265
yield
augassign -> **=
265
(
augassign -> **=
265
-
augassign -> **=
265
False
augassign -> **=
265
[
augassign -> **=
266
yield
augassign -> -=
266
lambda
augassign -> -=
266
not
augassign -> -=
266
(
augassign -> -=
266
[
augassign -> -=
266
-
augassign -> -=
266
{
augassign -> -=
266
NUMBER
augassign -> -=
266
STRING
augassign -> -=
266
True
augassign -> -=
266
+
augassign -> -=
266
NAME
augassign -> -=
266
~
augassign -> -=
266
None
augassign -> -=
266
False
augassign -> -=
267
(
augassign -> <<=
267
STRING
augassign -> <<=
267
~
augassign -> <<=
267
not
augassign -> <<=
267
NUMBER
augassign -> <<=
267
None
augassign -> <<=
267
+
augassign -> <<=
267
NAME
augassign -> <<=
267
yield
augassign -> <<=
267
-
augassign -> <<=
267
lambda
augassign -> <<=
267
True
augassign -> <<=
267
[
augassign -> <<=
267
{
augassign -> <<=
267
False
augassign -> <<=
268
~
augassign -> >>=
268
yield
augassign -> >>=
268
None
augassign -> >>=
268
NAME
augassign -> >>=
268
lambda
augassign -> >>=
268
not
augassign -> >>=
268
[
augassign -> >>=
268
(
augassign -> >>=
268
STRING
augassign -> >>=
268
-
augassign -> >>=
268
True
augassign -> >>=
268
False
augassign -> >>=
268
{
augassign -> >>=
268
NUMBER
augassign -> >>=
268
+
augassign -> >>=
269
True
augassign -> %=
269
~
augassign -> %=
269
-
augassign -> %=
269
NAME
augassign -> %=
269
STRING
augassign -> %=
269
None
augassign -> %=
269
NUMBER
augassign -> %=
269
(
augassign -> %=
269
yield
augassign -> %=
269
lambda
augassign -> %=
269
False
augassign -> %=
269
[
augassign -> %=
269
+
augassign -> %=
269
{
augassign -> %=
269
not
augassign -> %=
270
None
augassign -> *=
270
NAME
augassign -> *=
270
yield
augassign -> *=
270
STRING
augassign -> *=
270
-
augassign -> *=
270
lambda
augassign -> *=
270
[
augassign -> *=
270
False
augassign -> *=
270
NUMBER
augassign -> *=
270
(
augassign -> *=
270
not
augassign -> *=
270
{
augassign -> *=
270
~
augassign -> *=
270
True
augassign -> *=
270
+
augassign -> *=
271
(
augassign -> +=
271
NUMBER
augassign -> +=
271
lambda
augassign -> +=
271
True
augassign -> +=
271
[
augassign -> +=
271
+
augassign -> +=
271
yield
augassign -> +=
271
{
augassign -> +=
271
None
augassign -> +=
271
NAME
augassign -> +=
271
~
augassign -> +=
271
not
augassign -> +=
271
STRING
augassign -> +=
271
False
augassign -> +=
271
-
augassign -> +=
272
~
augassign -> |=
272
-
augassign -> |=
272
NAME
augassign -> |=
272
not
augassign -> |=
272
STRING
augassign -> |=
272
lambda
augassign -> |=
272
[
augassign -> |=
272
{
augassign -> |=
272
None
augassign -> |=
272
yield
augassign -> |=
272
+
augassign -> |=
272
NUMBER
augassign -> |=
272
False
augassign -> |=
272
True
augassign -> |=
272
(
augassign -> |=
273
-
augassign -> ^=
273
NAME
augassign -> ^=
273
lambda
augassign -> ^=
273
False
augassign -> ^=
273
STRING
augassign -> ^=
273
None
augassign -> ^=
273
~
augassign -> ^=
273
[
augassign -> ^=
273
not
augassign -> ^=
273
yield
augassign -> ^=
273
NUMBER
augassign -> ^=
273
{
augassign -> ^=
273
True
augassign -> ^=
273
+
augassign -> ^=
273
(
augassign -> ^=
274
NEWLINE
expr_stmt -> test_list assign
275
yield
augassign -> @=
275
{
augassign -> @=
275
True
augassign -> @=
275
not
augassign -> @=
275
lambda
augassign -> @=
275
(
augassign -> @=
275
False
augassign -> @=
275
NUMBER
augassign -> @=
275
NAME
augassign -> @=
275
+
augassign -> @=
275
STRING
augassign -> @=
275
None
augassign -> @=
275
[
augassign -> @=
275
~
augassign -> @=
275
-
augassign -> @=
276
[
632
276
factor
633
276
True
634
276
atom_expr
635
276
~
636
276
and_expr
637
276
-
638
276
None
639
276
shift_expr
640
276
atom
641
276
{
642
276
comparison
643
276
and_test
644
276
arith_expr
645
276
power
646
276
STRING
647
276
NAME
648
276
(
649
276
NUMBER
650
276
term
651
276
+
652
276
yield
653
276
xor_expr
654
276
test
655
276
not
656
276
False
657
276
lambda
658
276
not_test
659
276
yield_expr
660
276
or_test
661
276
lambdef
662
276
expr
663
276
test_list
664
277
NUMBER
augassign -> /=
277
+
augassign -> /=
277
None
augassign -> /=
277
yield
augassign -> /=
277
~
augassign -> /=
277
not
augassign -> /=
277
NAME
augassign -> /=
277
(
augassign -> /=
277
[
augassign -> /=
277
lambda
augassign -> /=
277
False
augassign -> /=
277
STRING
augassign -> /=
277
True
augassign -> /=
277
{
augassign -> /=
277
-
augassign -> /=
278
~
augassign -> &=
278
False
augassign -> &=
278
(
augassign -> &=
278
lambda
augassign -> &=
278
NAME
augassign -> &=
278
True
augassign -> &=
278
{
augassign -> &=
278
NUMBER
augassign -> &=
278
STRING
augassign -> &=
278
yield
augassign -> &=
278
not
augassign -> &=
278
-
augassign -> &=
278
[
augassign -> &=
278
+
augassign -> &=
278
None
augassign -> &=
279
[
665
279
factor
666
279
True
667
279
atom_expr
668
279
~
669
279
and_expr
670
279
-
671
279
atom
672
279
{
673
279
and_test
674
279
arith_expr
675
279
power
676
279
STRING
677
279
NAME
678
279
(
679
279
term
680
279
+
681
279
xor_expr
682
279
shift_expr
683
279
NUMBER
684
279
not
685
279
test
686
279
False
687
279
comparison
688
279
not_test
689
279
None
690
279
or_test
691
279
expr
692
279
lambda
693
279
lambdef
694
280
NEWLINE
expr_stmt -> test_list annassign
281
/=
factor -> ~ factor
281
@
factor -> ~ factor
281
NEWLINE
factor -> ~ factor
281
>>
factor -> ~ factor
281
@=
factor -> ~ factor
281
<=
factor -> ~ factor
281
and
factor -> ~ factor
281
+
factor -> ~ factor
281
:
factor -> ~ factor
281
-=
factor -> ~ factor
281
*
factor -> ~ factor
281
!=
factor -> ~ factor
281
%
factor -> ~ factor
281
//=
factor -> ~ factor
281
<<
factor -> ~ factor
281
>=
factor -> ~ factor
281
*=
factor -> ~ factor
281
=
factor -> ~ factor
281
,
factor -> ~ factor
281
&
factor -> ~ factor
281
^=
factor -> ~ factor
281
<<=
factor -> ~ factor
281
is
factor -> ~ factor
281
==
factor -> ~ factor
281
//
factor -> ~ factor
281
<
factor -> ~ factor
281
&=
factor -> ~ factor
281
/
factor -> ~ factor
281
not
factor -> ~ factor
281
-
factor -> ~ factor
281
|=
factor -> ~ factor
281
or
factor -> ~ factor
281
>>=
factor -> ~ factor
281
|
factor -> ~ factor
281
>
factor -> ~ factor
281
%=
factor -> ~ factor
281
**=
factor -> ~ factor
281
+=
factor -> ~ factor
281
^
factor -> ~ factor
281
if
factor -> ~ factor
281
in
factor -> ~ factor
282
arith_expr
1
282
factor
17
282
True
38
282
atom_expr
31
282
term
22
282
expr
695
282
-
26
282
None
55
282
atom
57
282
and_expr
8
282
power
9
282
STRING
10
282
NAME
52
282
shift_expr
48
282
NUMBER
58
282
(
16
282
[
18
282
{
21
282
+
27
282
xor_expr
41
282
~
37
282
False
39
283
[
166
283
factor
167
283
True
168
283
atom_expr
169
283
~
170
283
not
171
283
and_expr
172
283
-
173
283
{
174
283
shift_expr
175
283
atom
176
283
]
696
283
comparison
178
283
(
179
283
arith_expr
180
283
power
181
283
STRING
182
283
NAME
183
283
test
184
283
and_test
185
283
term
186
283
+
187
283
xor_expr
188
283
NUMBER
190
283
test_list_comp
697
283
False
191
283
expr
192
283
not_test
193
283
None
194
283
lambdef
195
283
lambda
196
283
or_test
197
283
test_list
198
284
not
term -> factor
284
@
698
284
%
699
284
/
700
284
*
701
284
as
term -> factor
284
//
702
284
<=
term -> factor
284
>
term -> factor
284
==
term -> factor
284
is
term -> factor
284
or
term -> factor
284
<
term -> factor
284
and
term -> factor
284
<<
term -> factor
284
^
term -> factor
284
:
term -> factor
284
!=
term -> factor
284
-
term -> factor
284
&
term -> factor
284
|
term -> factor
284
,
term -> factor
284
>=
term -> factor
284
if
term -> factor
284
+
term -> factor
284
in
term -> factor
284
>>
term -> factor
285
<<
atom -> True
285
as
atom -> True
285
&
atom -> True
285
or
atom -> True
285
[
atom -> True
285
if
atom -> True
285
:
atom -> True
285
-
atom -> True
285
*
atom -> True
285
^
atom -> True
285
,
atom -> True
285
>=
atom -> True
285
!=
atom -> True
285
(
atom -> True
285
not
atom -> True
285
|
atom -> True
285
+
atom -> True
285
**
atom -> True
285
.
atom -> True
285
is
atom -> True
285
//
atom -> True
285
>
atom -> True
285
%
atom -> True
285
in
atom -> True
285
<=
atom -> True
285
>>
atom -> True
285
/
atom -> True
285
==
atom -> True
285
and
atom -> True
285
<
atom -> True
285
@
atom -> True
286
**
703
286
,
power -> atom_expr
286
!=
power -> atom_expr
286
-
power -> atom_expr
286
<<
power -> atom_expr
286
:
power -> atom_expr
286
/
power -> atom_expr
286
<=
power -> atom_expr
286
in
power -> atom_expr
286
not
power -> atom_expr
286
%
power -> atom_expr
286
>
power -> atom_expr
286
@
power -> atom_expr
286
|
power -> atom_expr
286
<
power -> atom_expr
286
>>
power -> atom_expr
286
or
power -> atom_expr
286
and
power -> atom_expr
286
>=
power -> atom_expr
286
==
power -> atom_expr
286
^
power -> atom_expr
286
*
power -> atom_expr
286
as
power -> atom_expr
286
&
power -> atom_expr
286
is
power -> atom_expr
286
+
power -> atom_expr
286
if
power -> atom_expr
286
//
power -> atom_expr
287
[
283
287
True
285
287
atom_expr
286
287
-
289
287
~
287
287
atom
291
287
{
292
287
power
296
287
STRING
297
287
NAME
298
287
(
299
287
+
303
287
NUMBER
305
287
False
307
287
factor
704
287
None
310
288
>
xor_expr -> and_expr
288
<=
xor_expr -> and_expr
288
not
xor_expr -> and_expr
288
|
xor_expr -> and_expr
288
^
705
288
==
xor_expr -> and_expr
288
,
xor_expr -> and_expr
288
in
xor_expr -> and_expr
288
!=
xor_expr -> and_expr
288
:
xor_expr -> and_expr
288
if
xor_expr -> and_expr
288
is
xor_expr -> and_expr
288
<
xor_expr -> and_expr
288
or
xor_expr -> and_expr
288
as
xor_expr -> and_expr
288
and
xor_expr -> and_expr
288
>=
xor_expr -> and_expr
289
[
283
289
True
285
289
atom_expr
286
289
~
287
289
-
289
289
atom
291
289
{
292
289
power
296
289
STRING
297
289
NAME
298
289
(
299
289
factor
706
289
+
303
289
NUMBER
305
289
False
307
289
None
310
290
^
and_expr -> shift_expr
290
in
and_expr -> shift_expr
290
|
and_expr -> shift_expr
290
&
707
290
<
and_expr -> shift_expr
290
not
and_expr -> shift_expr
290
>=
and_expr -> shift_expr
290
<=
and_expr -> shift_expr
290
or
and_expr -> shift_expr
290
and
and_expr -> shift_expr
290
,
and_expr -> shift_expr
290
:
and_expr -> shift_expr
290
!=
and_expr -> shift_expr
290
as
and_expr -> shift_expr
290
if
and_expr -> shift_expr
290
is
and_expr -> shift_expr
290
==
and_expr -> shift_expr
290
>
and_expr -> shift_expr
291
>>
trailer_expr -> 
291
(
708
291
trailer
709
291
trailer_expr
710
291
.
711
291
+
trailer_expr -> 
291
[
712
291
is
trailer_expr -> 
291
>
trailer_expr -> 
291
not
trailer_expr -> 
291
|
trailer_expr -> 
291
&
trailer_expr -> 
291
/
trailer_expr -> 
291
@
trailer_expr -> 
291
!=
trailer_expr -> 
291
**
trailer_expr -> 
291
>=
trailer_expr -> 
291
^
trailer_expr -> 
291
in
trailer_expr -> 
291
<<
trailer_expr -> 
291
and
trailer_expr -> 
291
or
trailer_expr -> 
291
as
trailer_expr -> 
291
if
trailer_expr -> 
291
:
trailer_expr -> 
291
//
trailer_expr -> 
291
%
trailer_expr -> 
291
,
trailer_expr -> 
291
<=
trailer_expr -> 
291
<
trailer_expr -> 
291
==
trailer_expr -> 
291
-
trailer_expr -> 
291
*
trailer_expr -> 
292
}
713
293
or
not_test -> comparison
293
,
not_test -> comparison
293
:
not_test -> comparison
293
and
not_test -> comparison
293
if
not_test -> comparison
293
as
not_test -> comparison
294
as
test -> or_test
294
:
test -> or_test
294
,
test -> or_test
294
if
714
295
>>
715
295
if
shift_expr -> arith_expr
295
&
shift_expr -> arith_expr
295
<<
716
295
|
shift_expr -> arith_expr
295
is
shift_expr -> arith_expr
295
<
shift_expr -> arith_expr
295
==
shift_expr -> arith_expr
295
as
shift_expr -> arith_expr
295
or
shift_expr -> arith_expr
295
>
shift_expr -> arith_expr
295
!=
shift_expr -> arith_expr
295
>=
shift_expr -> arith_expr
295
in
shift_expr -> arith_expr
295
,
shift_expr -> arith_expr
295
<=
shift_expr -> arith_expr
295
:
shift_expr -> arith_expr
295
and
shift_expr -> arith_expr
295
^
shift_expr -> arith_expr
295
not
shift_expr -> arith_expr
296
+
factor -> power
296
%
factor -> power
296
:
factor -> power
296
,
factor -> power
296
<
factor -> power
296
<<
factor -> power
296
!=
factor -> power
296
<=
factor -> power
296
and
factor -> power
296
/
factor -> power
296
^
factor -> power
296
@
factor -> power
296
>=
factor -> power
296
not
factor -> power
296
//
factor -> power
296
or
factor -> power
296
==
factor -> power
296
is
factor -> power
296
as
factor -> power
296
|
factor -> power
296
*
factor -> power
296
-
factor -> power
296
if
factor -> power
296
>
factor -> power
296
in
factor -> power
296
>>
factor -> power
296
&
factor -> power
297
%
atom -> STRING
297
>
atom -> STRING
297
@
atom -> STRING
297
<<
atom -> STRING
297
as
atom -> STRING
297
in
atom -> STRING
297
[
atom -> STRING
297
-
atom -> STRING
297
==
atom -> STRING
297
>=
atom -> STRING
297
not
atom -> STRING
297
/
atom -> STRING
297
+
atom -> STRING
297
*
atom -> STRING
297
(
atom -> STRING
297
//
atom -> STRING
297
if
atom -> STRING
297
.
atom -> STRING
297
<
atom -> STRING
297
,
atom -> STRING
297
&
atom -> STRING
297
<=
atom -> STRING
297
!=
atom -> STRING
297
**
atom -> STRING
297
^
atom -> STRING
297
:
atom -> STRING
297
and
atom -> STRING
297
is
atom -> STRING
297
|
atom -> STRING
297
or
atom -> STRING
297
>>
atom -> STRING
298
<
atom -> NAME
298
,
atom -> NAME
298
^
atom -> NAME
298
+
atom -> NAME
298
-
atom -> NAME
298
>=
atom -> NAME
298
@
atom -> NAME
298
!=
atom -> NAME
298
*
atom -> NAME
298
<=
atom -> NAME
298
**
atom -> NAME
298
or
atom -> NAME
298
not
atom -> NAME
298
==
atom -> NAME
298
&
atom -> NAME
298
>
atom -> NAME
298
>>
atom -> NAME
298
%
atom -> NAME
298
.
atom -> NAME
298
|
atom -> NAME
298
is
atom -> NAME
298
and
atom -> NAME
298
//
atom -> NAME
298
[
atom -> NAME
298
/
atom -> NAME
298
as
atom -> NAME
298
(
atom -> NAME
298
<<
atom -> NAME
298
if
atom -> NAME
298
in
atom -> NAME
298
:
atom -> NAME
299
[
128
299
factor
129
299
True
130
299
atom_expr
131
299
~
132
299
and_expr
133
299
-
134
299
{
135
299
test_list_comp
717
299
shift_expr
137
299
atom
138
299
)
718
299
comparison
140
299
arith_expr
141
299
power
142
299
STRING
143
299
NAME
144
299
(
145
299
and_test
146
299
term
147
299
+
148
299
xor_expr
149
299
or_test
150
299
NUMBER
151
299
not
152
299
False
153
299
expr
154
299
not_test
155
299
None
156
299
lambdef
157
299
lambda
158
299
test
159
299
test_list
160
300
:
719
301
as
or_test -> and_test
301
or
720
301
,
or_test -> and_test
301
if
or_test -> and_test
301
:
or_test -> and_test
302
-
721
302
+
722
302
>=
arith_expr -> term
302
|
arith_expr -> term
302
<=
arith_expr -> term
302
not
arith_expr -> term
302
,
arith_expr -> term
302
==
arith_expr -> term
302
in
arith_expr -> term
302
>>
arith_expr -> term
302
is
arith_expr -> term
302
if
arith_expr -> term
302
or
arith_expr -> term
302
!=
arith_expr -> term
302
as
arith_expr -> term
302
>
arith_expr -> term
302
:
arith_expr -> term
302
and
arith_expr -> term
302
<<
arith_expr -> term
302
<
arith_expr -> term
302
^
arith_expr -> term
302
&
arith_expr -> term
303
[
283
303
True
285
303
atom_expr
286
303
-
289
303
~
287
303
atom
291
303
{
292
303
power
296
303
STRING
297
303
NAME
298
303
(
299
303
factor
723
303
+
303
303
NUMBER
305
303
False
307
303
None
310
304
|
724
304
>
expr -> xor_expr
304
if
expr -> xor_expr
304
is
expr -> xor_expr
304
and
expr -> xor_expr
304
not
expr -> xor_expr
304
or
expr -> xor_expr
304
>=
expr -> xor_expr
304
==
expr -> xor_expr
304
,
expr -> xor_expr
304
:
expr -> xor_expr
304
as
expr -> xor_expr
304
<
expr -> xor_expr
304
!=
expr -> xor_expr
304
<=
expr -> xor_expr
304
in
expr -> xor_expr
305
+
atom -> NUMBER
305
*
atom -> NUMBER
305
>
atom -> NUMBER
305
<<
atom -> NUMBER
305
-
atom -> NUMBER
305
**
atom -> NUMBER
305
if
atom -> NUMBER
305
or
atom -> NUMBER
305
is
atom -> NUMBER
305
as
atom -> NUMBER
305
[
atom -> NUMBER
305
(
atom -> NUMBER
305
not
atom -> NUMBER
305
&
atom -> NUMBER
305
^
atom -> NUMBER
305
in
atom -> NUMBER
305
==
atom -> NUMBER
305
//
atom -> NUMBER
305
!=
atom -> NUMBER
305
and
atom -> NUMBER
305
%
atom -> NUMBER
305
<=
atom -> NUMBER
305
.
atom -> NUMBER
305
<
atom -> NUMBER
305
>>
atom -> NUMBER
305
,
atom -> NUMBER
305
/
atom -> NUMBER
305
@
atom -> NUMBER
305
>=
atom -> NUMBER
305
|
atom -> NUMBER
305
:
atom -> NUMBER
306
[
283
306
factor
284
306
True
285
306
atom_expr
286
306
~
287
306
and_expr
288
306
-
289
306
shift_expr
290
306
atom
291
306
{
292
306
comparison
293
306
arith_expr
295
306
power
296
306
STRING
297
306
NAME
298
306
(
299
306
term
302
306
+
303
306
xor_expr
304
306
NUMBER
305
306
not
306
306
False
307
306
not_test
725
306
expr
308
306
None
310
307
(
atom -> False
307
*
atom -> False
307
==
atom -> False
307
as
atom -> False
307
|
atom -> False
307
,
atom -> False
307
[
atom -> False
307
in
atom -> False
307
&
atom -> False
307
is
atom -> False
307
not
atom -> False
307
if
atom -> False
307
^
atom -> False
307
+
atom -> False
307
>
atom -> False
307
<=
atom -> False
307
<<
atom -> False
307
<
atom -> False
307
>=
atom -> False
307
:
atom -> False
307
%
atom -> False
307
@
atom -> False
307
and
atom -> False
307
!=
atom -> False
307
-
atom -> False
307
.
atom -> False
307
//
atom -> False
307
/
atom -> False
307
**
atom -> False
307
>>
atom -> False
307
or
atom -> False
308
>
317
308
is
318
308
in
319
308
<=
320
308
<
321
308
>=
322
308
:
comparison -> expr
308
!=
324
308
not
325
308
==
326
308
comp_op
726
308
or
comparison -> expr
308
if
comparison -> expr
308
as
comparison -> expr
308
and
comparison -> expr
308
,
comparison -> expr
309
and
727
309
:
and_test -> not_test
309
,
and_test -> not_test
309
if
and_test -> not_test
309
as
and_test -> not_test
309
or
and_test -> not_test
310
@
atom -> None
310
<=
atom -> None
310
in
atom -> None
310
and
atom -> None
310
&
atom -> None
310
|
atom -> None
310
>
atom -> None
310
>=
atom -> None
310
/
atom -> None
310
<<
atom -> None
310
-
atom -> None
310
!=
atom -> None
310
**
atom -> None
310
(
atom -> None
310
*
atom -> None
310
.
atom -> None
310
as
atom -> None
310
>>
atom -> None
310
==
atom -> None
310
is
atom -> None
310
<
atom -> None
310
if
atom -> None
310
^
atom -> None
310
[
atom -> None
310
%
atom -> None
310
+
atom -> None
310
not
atom -> None
310
,
atom -> None
310
:
atom -> None
310
or
atom -> None
310
//
atom -> None
311
:
test -> lambdef
311
as
test -> lambdef
311
,
test -> lambdef
312
,
with_item -> test
312
as
728
312
:
with_item -> test
313
:
with_items -> with_item
313
,
729
314
vfpdef
234
314
:
730
314
varargslist
731
314
NAME
233
315
:
732
316
arith_expr
1
316
factor
17
316
True
38
316
atom_expr
31
316
term
22
316
-
26
316
None
55
316
atom
57
316
comparison
49
316
and_expr
8
316
power
9
316
STRING
10
316
NAME
52
316
shift_expr
48
316
NUMBER
58
316
(
16
316
expr
47
316
[
18
316
not_test
32
316
{
21
316
and_test
46
316
+
27
316
xor_expr
41
316
not
62
316
~
37
316
False
39
316
or_test
733
317
False
comp_op -> >
317
(
comp_op -> >
317
STRING
comp_op -> >
317
None
comp_op -> >
317
NAME
comp_op -> >
317
True
comp_op -> >
317
{
comp_op -> >
317
NUMBER
comp_op -> >
317
+
comp_op -> >
317
~
comp_op -> >
317
[
comp_op -> >
317
-
comp_op -> >
318
not
734
318
{
comp_op -> is
318
False
comp_op -> is
318
(
comp_op -> is
318
[
comp_op -> is
318
-
comp_op -> is
318
+
comp_op -> is
318
NAME
comp_op -> is
318
True
comp_op -> is
318
STRING
comp_op -> is
318
None
comp_op -> is
318
NUMBER
comp_op -> is
318
~
comp_op -> is
319
{
comp_op -> in
319
(
comp_op -> in
319
False
comp_op -> in
319
NUMBER
comp_op -> in
319
STRING
comp_op -> in
319
~
comp_op -> in
319
+
comp_op -> in
319
True
comp_op -> in
319
None
comp_op -> in
319
NAME
comp_op -> in
319
-
comp_op -> in
319
[
comp_op -> in
320
+
comp_op -> <=
320
~
comp_op -> <=
320
(
comp_op -> <=
320
False
comp_op -> <=
320
[
comp_op -> <=
320
None
comp_op -> <=
320
{
comp_op -> <=
320
True
comp_op -> <=
320
NUMBER
comp_op -> <=
320
STRING
comp_op -> <=
320
NAME
comp_op -> <=
320
-
comp_op -> <=
321
NUMBER
comp_op -> <
321
{
comp_op -> <
321
STRING
comp_op -> <
321
-
comp_op -> <
321
~
comp_op -> <
321
NAME
comp_op -> <
321
True
comp_op -> <
321
+
comp_op -> <
321
[
comp_op -> <
321
None
comp_op -> <
321
False
comp_op -> <
321
(
comp_op -> <
322
{
comp_op -> >=
322
False
comp_op -> >=
322
NUMBER
comp_op -> >=
322
NAME
comp_op -> >=
322
-
comp_op -> >=
322
STRING
comp_op -> >=
322
(
comp_op -> >=
322
+
comp_op -> >=
322
~
comp_op -> >=
322
[
comp_op -> >=
322
None
comp_op -> >=
322
True
comp_op -> >=
323
arith_expr
1
323
factor
17
323
True
38
323
atom_expr
31
323
term
22
323
-
26
323
None
55
323
atom
57
323
and_expr
8
323
power
9
323
STRING
10
323
NAME
52
323
shift_expr
48
323
NUMBER
58
323
(
16
323
expr
47
323
[
18
323
{
21
323
+
27
323
xor_expr
41
323
~
37
323
False
39
323
comparison
735
324
+
comp_op -> !=
324
[
comp_op -> !=
324
NAME
comp_op -> !=
324
NUMBER
comp_op -> !=
324
True
comp_op -> !=
324
None
comp_op -> !=
324
STRING
comp_op -> !=
324
-
comp_op -> !=
324
{
comp_op -> !=
324
(
comp_op -> !=
324
~
comp_op -> !=
324
False
comp_op -> !=
325
in
736
326
~
comp_op -> ==
326
None
comp_op -> ==
326
(
comp_op -> ==
326
-
comp_op -> ==
326
{
comp_op -> ==
326
[
comp_op -> ==
326
STRING
comp_op -> ==
326
False
comp_op -> ==
326
NUMBER
comp_op -> ==
326
NAME
comp_op -> ==
326
True
comp_op -> ==
326
+
comp_op -> ==
327
arith_expr
1
327
factor
17
327
True
38
327
atom_expr
31
327
term
22
327
-
26
327
None
55
327
atom
57
327
power
9
327
STRING
10
327
NAME
52
327
shift_expr
48
327
NUMBER
58
327
(
16
327
[
18
327
{
21
327
and_expr
737
327
+
27
327
~
37
327
False
39
328
[
738
328
or_test
739
328
factor
740
328
True
741
328
~
742
328
and_expr
743
328
-
744
328
atom
745
328
{
746
328
arith_expr
747
328
power
748
328
atom_expr
749
328
STRING
750
328
NAME
751
328
(
752
328
term
753
328
+
754
328
xor_expr
755
328
shift_expr
756
328
NUMBER
757
328
not
758
328
False
759
328
comparison
760
328
not_test
761
328
None
762
328
expr
763
328
and_test
764
329
NAME
765
330
[
766
330
factor
767
330
True
768
330
atom_expr
769
330
~
770
330
and_expr
771
330
-
772
330
{
773
330
shift_expr
774
330
atom
775
330
comparison
776
330
and_test
777
330
arith_expr
778
330
power
779
330
STRING
780
330
NAME
781
330
(
782
330
arglist
783
330
term
784
330
+
785
330
xor_expr
786
330
)
787
330
or_test
788
330
NUMBER
789
330
not
790
330
False
791
330
expr
792
330
*
793
330
not_test
794
330
None
795
330
lambdef
796
330
lambda
797
330
test
798
330
argument
799
330
**
800
331
.
329
331
>>
trailer_expr -> 
331
(
330
331
trailer
331
331
trailer_expr
801
331
+
trailer_expr -> 
331
[
333
331
//=
trailer_expr -> 
331
>
trailer_expr -> 
331
not
trailer_expr -> 
331
%=
trailer_expr -> 
331
|
trailer_expr -> 
331
=
trailer_expr -> 
331
NEWLINE
trailer_expr -> 
331
/=
trailer_expr -> 
331
/
trailer_expr -> 
331
@=
trailer_expr -> 
331
^
trailer_expr -> 
331
^=
trailer_expr -> 
331
<<
trailer_expr -> 
331
or
trailer_expr -> 
331
:
trailer_expr -> 
331
|=
trailer_expr -> 
331
<=
trailer_expr -> 
331
<
trailer_expr -> 
331
==
trailer_expr -> 
331
*=
trailer_expr -> 
331
*
trailer_expr -> 
331
&=
trailer_expr -> 
331
is
trailer_expr -> 
331
<<=
trailer_expr -> 
331
&
trailer_expr -> 
331
@
trailer_expr -> 
331
!=
trailer_expr -> 
331
**
trailer_expr -> 
331
>=
trailer_expr -> 
331
in
trailer_expr -> 
331
-=
trailer_expr -> 
331
and
trailer_expr -> 
331
>>=
trailer_expr -> 
331
if
trailer_expr -> 
331
**=
trailer_expr -> 
331
//
trailer_expr -> 
331
+=
trailer_expr -> 
331
%
trailer_expr -> 
331
,
trailer_expr -> 
331
-
trailer_expr -> 
332
|=
atom_expr -> atom trailer_expr
332
^
atom_expr -> atom trailer_expr
332
or
atom_expr -> atom trailer_expr
332
=
atom_expr -> atom trailer_expr
332
&
atom_expr -> atom trailer_expr
332
@
atom_expr -> atom trailer_expr
332
**=
atom_expr -> atom trailer_expr
332
|
atom_expr -> atom trailer_expr
332
-
atom_expr -> atom trailer_expr
332
*
atom_expr -> atom trailer_expr
332
%
atom_expr -> atom trailer_expr
332
@=
atom_expr -> atom trailer_expr
332
==
atom_expr -> atom trailer_expr
332
%=
atom_expr -> atom trailer_expr
332
>>=
atom_expr -> atom trailer_expr
332
**
atom_expr -> atom trailer_expr
332
and
atom_expr -> atom trailer_expr
332
NEWLINE
atom_expr -> atom trailer_expr
332
-=
atom_expr -> atom trailer_expr
332
//=
atom_expr -> atom trailer_expr
332
is
atom_expr -> atom trailer_expr
332
in
atom_expr -> atom trailer_expr
332
<<
atom_expr -> atom trailer_expr
332
!=
atom_expr -> atom trailer_expr
332
^=
atom_expr -> atom trailer_expr
332
<=
atom_expr -> atom trailer_expr
332
*=
atom_expr -> atom trailer_expr
332
+=
atom_expr -> atom trailer_expr
332
/
atom_expr -> atom trailer_expr
332
//
atom_expr -> atom trailer_expr
332
<
atom_expr -> atom trailer_expr
332
>=
atom_expr -> atom trailer_expr
332
<<=
atom_expr -> atom trailer_expr
332
>>
atom_expr -> atom trailer_expr
332
if
atom_expr -> atom trailer_expr
332
not
atom_expr -> atom trailer_expr
332
/=
atom_expr -> atom trailer_expr
332
&=
atom_expr -> atom trailer_expr
332
:
atom_expr -> atom trailer_expr
332
+
atom_expr -> atom trailer_expr
332
>
atom_expr -> atom trailer_expr
332
,
atom_expr -> atom trailer_expr
333
[
802
333
factor
803
333
True
804
333
subscriptlist
805
333
~
806
333
not
807
333
and_expr
808
333
-
809
333
atom_expr
810
333
shift_expr
811
333
atom
812
333
{
813
333
comparison
814
333
or_test
815
333
(
816
333
arith_expr
817
333
power
818
333
STRING
819
333
NAME
820
333
and_test
821
333
term
822
333
+
823
333
xor_expr
824
333
test
825
333
NUMBER
826
333
False
827
333
subscript
828
333
expr
829
333
not_test
830
333
None
831
333
lambdef
832
333
lambda
833
333
maybe_test
834
333
:
maybe_test -> 
334
[
166
334
factor
167
334
True
168
334
atom_expr
169
334
~
170
334
not
171
334
and_expr
172
334
-
173
334
{
174
334
shift_expr
175
334
atom
176
334
]
835
334
comparison
178
334
(
179
334
arith_expr
180
334
power
181
334
STRING
182
334
NAME
183
334
test
184
334
and_test
185
334
term
186
334
+
187
334
xor_expr
188
334
NUMBER
190
334
test_list_comp
836
334
False
191
334
expr
192
334
not_test
193
334
None
194
334
lambdef
195
334
lambda
196
334
or_test
197
334
test_list
198
335
not
term -> factor
335
@
837
335
%
838
335
/
839
335
*
840
335
//
841
335
<=
term -> factor
335
NEWLINE
term -> factor
335
>
term -> factor
335
==
term -> factor
335
is
term -> factor
335
or
term -> factor
335
<
term -> factor
335
and
term -> factor
335
<<
term -> factor
335
^
term -> factor
335
!=
term -> factor
335
-
term -> factor
335
&
term -> factor
335
|
term -> factor
335
,
term -> factor
335
>=
term -> factor
335
if
term -> factor
335
+
term -> factor
335
in
term -> factor
335
>>
term -> factor
336
<<
atom -> True
336
&
atom -> True
336
or
atom -> True
336
[
atom -> True
336
if
atom -> True
336
NEWLINE
atom -> True
336
-
atom -> True
336
*
atom -> True
336
^
atom -> True
336
,
atom -> True
336
>=
atom -> True
336
!=
atom -> True
336
(
atom -> True
336
not
atom -> True
336
|
atom -> True
336
+
atom -> True
336
**
atom -> True
336
.
atom -> True
336
is
atom -> True
336
//
atom -> True
336
>
atom -> True
336
%
atom -> True
336
in
atom -> True
336
<=
atom -> True
336
>>
atom -> True
336
/
atom -> True
336
==
atom -> True
336
and
atom -> True
336
<
atom -> True
336
@
atom -> True
337
**
842
337
,
power -> atom_expr
337
!=
power -> atom_expr
337
-
power -> atom_expr
337
<<
power -> atom_expr
337
not
power -> atom_expr
337
/
power -> atom_expr
337
<=
power -> atom_expr
337
in
power -> atom_expr
337
%
power -> atom_expr
337
>
power -> atom_expr
337
@
power -> atom_expr
337
|
power -> atom_expr
337
NEWLINE
power -> atom_expr
337
<
power -> atom_expr
337
>>
power -> atom_expr
337
or
power -> atom_expr
337
and
power -> atom_expr
337
>=
power -> atom_expr
337
==
power -> atom_expr
337
^
power -> atom_expr
337
*
power -> atom_expr
337
&
power -> atom_expr
337
is
power -> atom_expr
337
+
power -> atom_expr
337
if
power -> atom_expr
337
//
power -> atom_expr
338
[
334
338
True
336
338
atom_expr
337
338
-
340
338
~
338
338
None
341
338
atom
343
338
{
344
338
power
347
338
STRING
348
338
NAME
349
338
(
350
338
NUMBER
351
338
+
354
338
False
357
338
factor
843
339
NEWLINE
xor_expr -> and_expr
339
>
xor_expr -> and_expr
339
<=
xor_expr -> and_expr
339
not
xor_expr -> and_expr
339
|
xor_expr -> and_expr
339
^
844
339
==
xor_expr -> and_expr
339
,
xor_expr -> and_expr
339
in
xor_expr -> and_expr
339
!=
xor_expr -> and_expr
339
if
xor_expr -> and_expr
339
is
xor_expr -> and_expr
339
<
xor_expr -> and_expr
339
or
xor_expr -> and_expr
339
and
xor_expr -> and_expr
339
>=
xor_expr -> and_expr
340
[
334
340
True
336
340
atom_expr
337
340
~
338
340
-
340
340
None
341
340
atom
343
340
{
344
340
power
347
340
STRING
348
340
NAME
349
340
(
350
340
NUMBER
351
340
factor
845
340
+
354
340
False
357
341
@
atom -> None
341
NEWLINE
atom -> None
341
<=
atom -> None
341
in
atom -> None
341
and
atom -> None
341
&
atom -> None
341
|
atom -> None
341
>
atom -> None
341
>=
atom -> None
341
/
atom -> None
341
<<
atom -> None
341
-
atom -> None
341
!=
atom -> None
341
**
atom -> None
341
(
atom -> None
341
*
atom -> None
341
.
atom -> None
341
>>
atom -> None
341
==
atom -> None
341
is
atom -> None
341
<
atom -> None
341
if
atom -> None
341
^
atom -> None
341
[
atom -> None
341
%
atom -> None
341
+
atom -> None
341
not
atom -> None
341
,
atom -> None
341
or
atom -> None
341
//
atom -> None
342
^
and_expr -> shift_expr
342
in
and_expr -> shift_expr
342
|
and_expr -> shift_expr
342
&
846
342
<
and_expr -> shift_expr
342
not
and_expr -> shift_expr
342
>=
and_expr -> shift_expr
342
<=
and_expr -> shift_expr
342
or
and_expr -> shift_expr
342
and
and_expr -> shift_expr
342
,
and_expr -> shift_expr
342
!=
and_expr -> shift_expr
342
if
and_expr -> shift_expr
342
is
and_expr -> shift_expr
342
==
and_expr -> shift_expr
342
NEWLINE
and_expr -> shift_expr
342
>
and_expr -> shift_expr
343
>>
trailer_expr -> 
343
(
847
343
trailer
848
343
trailer_expr
849
343
.
850
343
+
trailer_expr -> 
343
[
851
343
is
trailer_expr -> 
343
>
trailer_expr -> 
343
not
trailer_expr -> 
343
|
trailer_expr -> 
343
NEWLINE
trailer_expr -> 
343
&
trailer_expr -> 
343
/
trailer_expr -> 
343
@
trailer_expr -> 
343
!=
trailer_expr -> 
343
**
trailer_expr -> 
343
>=
trailer_expr -> 
343
^
trailer_expr -> 
343
in
trailer_expr -> 
343
<<
trailer_expr -> 
343
and
trailer_expr -> 
343
or
trailer_expr -> 
343
if
trailer_expr -> 
343
//
trailer_expr -> 
343
%
trailer_expr -> 
343
,
trailer_expr -> 
343
<=
trailer_expr -> 
343
<
trailer_expr -> 
343
==
trailer_expr -> 
343
-
trailer_expr -> 
343
*
trailer_expr -> 
344
}
852
345
or
not_test -> comparison
345
NEWLINE
not_test -> comparison
345
,
not_test -> comparison
345
and
not_test -> comparison
345
if
not_test -> comparison
346
>>
853
346
if
shift_expr -> arith_expr
346
&
shift_expr -> arith_expr
346
<<
854
346
|
shift_expr -> arith_expr
346
is
shift_expr -> arith_expr
346
<
shift_expr -> arith_expr
346
==
shift_expr -> arith_expr
346
NEWLINE
shift_expr -> arith_expr
346
or
shift_expr -> arith_expr
346
>
shift_expr -> arith_expr
346
!=
shift_expr -> arith_expr
346
>=
shift_expr -> arith_expr
346
in
shift_expr -> arith_expr
346
,
shift_expr -> arith_expr
346
<=
shift_expr -> arith_expr
346
and
shift_expr -> arith_expr
346
^
shift_expr -> arith_expr
346
not
shift_expr -> arith_expr
347
+
factor -> power
347
%
factor -> power
347
,
factor -> power
347
<
factor -> power
347
<<
factor -> power
347
!=
factor -> power
347
<=
factor -> power
347
and
factor -> power
347
/
factor -> power
347
^
factor -> power
347
@
factor -> power
347
>=
factor -> power
347
not
factor -> power
347
//
factor -> power
347
or
factor -> power
347
==
factor -> power
347
is
factor -> power
347
|
factor -> power
347
NEWLINE
factor -> power
347
*
factor -> power
347
-
factor -> power
347
if
factor -> power
347
>
factor -> power
347
in
factor -> power
347
>>
factor -> power
347
&
factor -> power
348
%
atom -> STRING
348
>
atom -> STRING
348
@
atom -> STRING
348
<<
atom -> STRING
348
in
atom -> STRING
348
[
atom -> STRING
348
-
atom -> STRING
348
==
atom -> STRING
348
>=
atom -> STRING
348
not
atom -> STRING
348
/
atom -> STRING
348
+
atom -> STRING
348
NEWLINE
atom -> STRING
348
*
atom -> STRING
348
(
atom -> STRING
348
//
atom -> STRING
348
if
atom -> STRING
348
.
atom -> STRING
348
<
atom -> STRING
348
,
atom -> STRING
348
&
atom -> STRING
348
<=
atom -> STRING
348
!=
atom -> STRING
348
**
atom -> STRING
348
^
atom -> STRING
348
and
atom -> STRING
348
is
atom -> STRING
348
|
atom -> STRING
348
or
atom -> STRING
348
>>
atom -> STRING
349
<
atom -> NAME
349
,
atom -> NAME
349
^
atom -> NAME
349
+
atom -> NAME
349
-
atom -> NAME
349
>=
atom -> NAME
349
@
atom -> NAME
349
!=
atom -> NAME
349
*
atom -> NAME
349
<=
atom -> NAME
349
**
atom -> NAME
349
or
atom -> NAME
349
NEWLINE
atom -> NAME
349
not
atom -> NAME
349
==
atom -> NAME
349
&
atom -> NAME
349
>
atom -> NAME
349
>>
atom -> NAME
349
%
atom -> NAME
349
.
atom -> NAME
349
|
atom -> NAME
349
is
atom -> NAME
349
and
atom -> NAME
349
//
atom -> NAME
349
[
atom -> NAME
349
/
atom -> NAME
349
(
atom -> NAME
349
<<
atom -> NAME
349
if
atom -> NAME
349
in
atom -> NAME
350
[
128
350
factor
129
350
True
130
350
atom_expr
131
350
~
132
350
and_expr
133
350
-
134
350
{
135
350
test_list_comp
855
350
shift_expr
137
350
atom
138
350
)
856
350
comparison
140
350
arith_expr
141
350
power
142
350
STRING
143
350
NAME
144
350
(
145
350
and_test
146
350
term
147
350
+
148
350
xor_expr
149
350
or_test
150
350
NUMBER
151
350
not
152
350
False
153
350
expr
154
350
not_test
155
350
None
156
350
lambdef
157
350
lambda
158
350
test
159
350
test_list
160
351
+
atom -> NUMBER
351
*
atom -> NUMBER
351
>
atom -> NUMBER
351
<<
atom -> NUMBER
351
-
atom -> NUMBER
351
**
atom -> NUMBER
351
if
atom -> NUMBER
351
or
atom -> NUMBER
351
is
atom -> NUMBER
351
[
atom -> NUMBER
351
(
atom -> NUMBER
351
not
atom -> NUMBER
351
&
atom -> NUMBER
351
^
atom -> NUMBER
351
in
atom -> NUMBER
351
==
atom -> NUMBER
351
//
atom -> NUMBER
351
!=
atom -> NUMBER
351
and
atom -> NUMBER
351
NEWLINE
atom -> NUMBER
351
%
atom -> NUMBER
351
<=
atom -> NUMBER
351
.
atom -> NUMBER
351
<
atom -> NUMBER
351
>>
atom -> NUMBER
351
,
atom -> NUMBER
351
/
atom -> NUMBER
351
@
atom -> NUMBER
351
>=
atom -> NUMBER
351
|
atom -> NUMBER
352
or
857
352
,
or_test -> and_test
352
if
or_test -> and_test
352
NEWLINE
or_test -> and_test
353
-
858
353
+
859
353
>=
arith_expr -> term
353
|
arith_expr -> term
353
<=
arith_expr -> term
353
not
arith_expr -> term
353
,
arith_expr -> term
353
==
arith_expr -> term
353
in
arith_expr -> term
353
>>
arith_expr -> term
353
is
arith_expr -> term
353
if
arith_expr -> term
353
or
arith_expr -> term
353
!=
arith_expr -> term
353
>
arith_expr -> term
353
and
arith_expr -> term
353
<<
arith_expr -> term
353
<
arith_expr -> term
353
^
arith_expr -> term
353
NEWLINE
arith_expr -> term
353
&
arith_expr -> term
354
[
334
354
True
336
354
atom_expr
337
354
-
340
354
~
338
354
None
341
354
atom
343
354
{
344
354
power
347
354
STRING
348
354
NAME
349
354
(
350
354
NUMBER
351
354
factor
860
354
+
354
354
False
357
355
|
861
355
>
expr -> xor_expr
355
if
expr -> xor_expr
355
NEWLINE
expr -> xor_expr
355
is
expr -> xor_expr
355
and
expr -> xor_expr
355
not
expr -> xor_expr
355
or
expr -> xor_expr
355
>=
expr -> xor_expr
355
==
expr -> xor_expr
355
,
expr -> xor_expr
355
<
expr -> xor_expr
355
!=
expr -> xor_expr
355
<=
expr -> xor_expr
355
in
expr -> xor_expr
356
[
334
356
factor
335
356
True
336
356
atom_expr
337
356
~
338
356
and_expr
339
356
-
340
356
None
341
356
shift_expr
342
356
atom
343
356
{
344
356
comparison
345
356
arith_expr
346
356
power
347
356
STRING
348
356
NAME
349
356
(
350
356
NUMBER
351
356
term
353
356
+
354
356
xor_expr
355
356
not
356
356
False
357
356
not_test
862
356
expr
362
357
(
atom -> False
357
*
atom -> False
357
==
atom -> False
357
|
atom -> False
357
,
atom -> False
357
[
atom -> False
357
in
atom -> False
357
&
atom -> False
357
is
atom -> False
357
NEWLINE
atom -> False
357
not
atom -> False
357
if
atom -> False
357
^
atom -> False
357
+
atom -> False
357
>
atom -> False
357
<=
atom -> False
357
<<
atom -> False
357
<
atom -> False
357
>=
atom -> False
357
%
atom -> False
357
@
atom -> False
357
and
atom -> False
357
!=
atom -> False
357
-
atom -> False
357
.
atom -> False
357
//
atom -> False
357
/
atom -> False
357
**
atom -> False
357
>>
atom -> False
357
or
atom -> False
358
vfpdef
234
358
varargslist
863
358
:
864
358
NAME
233
359
and
865
359
,
and_test -> not_test
359
NEWLINE
and_test -> not_test
359
if
and_test -> not_test
359
or
and_test -> not_test
360
NEWLINE
return_stmt -> return test_list
361
NEWLINE
test -> lambdef
361
,
test -> lambdef
362
>
317
362
is
318
362
in
319
362
<=
320
362
<
321
362
>=
322
362
NEWLINE
comparison -> expr
362
!=
324
362
not
325
362
==
326
362
comp_op
866
362
or
comparison -> expr
362
if
comparison -> expr
362
and
comparison -> expr
362
,
comparison -> expr
363
NEWLINE
test -> or_test
363
,
test -> or_test
363
if
867
364
NEWLINE
test_list -> test
364
,
868
365
,
not_test -> not not_test
365
NEWLINE
not_test -> not not_test
365
|=
not_test -> not not_test
365
or
not_test -> not not_test
365
/=
not_test -> not not_test
365
:
not_test -> not not_test
365
//=
not_test -> not not_test
365
>>=
not_test -> not not_test
365
<<=
not_test -> not not_test
365
-=
not_test -> not not_test
365
^=
not_test -> not not_test
365
@=
not_test -> not not_test
365
%=
not_test -> not not_test
365
**=
not_test -> not not_test
365
=
not_test -> not not_test
365
and
not_test -> not not_test
365
&=
not_test -> not not_test
365
+=
not_test -> not not_test
365
if
not_test -> not not_test
365
*=
not_test -> not not_test
366
[
166
366
factor
167
366
True
168
366
atom_expr
169
366
~
170
366
not
171
366
and_expr
172
366
-
173
366
{
174
366
shift_expr
175
366
atom
176
366
]
869
366
comparison
178
366
(
179
366
arith_expr
180
366
power
181
366
STRING
182
366
NAME
183
366
test
184
366
and_test
185
366
term
186
366
+
187
366
xor_expr
188
366
NUMBER
190
366
test_list_comp
870
366
False
191
366
expr
192
366
not_test
193
366
None
194
366
lambdef
195
366
lambda
196
366
or_test
197
366
test_list
198
367
**
871
367
!=
power -> atom_expr
367
-
power -> atom_expr
367
<<
power -> atom_expr
367
not
power -> atom_expr
367
/
power -> atom_expr
367
<=
power -> atom_expr
367
in
power -> atom_expr
367
%
power -> atom_expr
367
>
power -> atom_expr
367
@
power -> atom_expr
367
|
power -> atom_expr
367
NEWLINE
power -> atom_expr
367
<
power -> atom_expr
367
from
power -> atom_expr
367
>>
power -> atom_expr
367
or
power -> atom_expr
367
and
power -> atom_expr
367
>=
power -> atom_expr
367
==
power -> atom_expr
367
^
power -> atom_expr
367
*
power -> atom_expr
367
&
power -> atom_expr
367
is
power -> atom_expr
367
+
power -> atom_expr
367
if
power -> atom_expr
367
//
power -> atom_expr
368
not
term -> factor
368
@
872
368
%
873
368
/
874
368
*
875
368
//
876
368
<=
term -> factor
368
NEWLINE
term -> factor
368
>
term -> factor
368
==
term -> factor
368
is
term -> factor
368
or
term -> factor
368
<
term -> factor
368
and
term -> factor
368
<<
term -> factor
368
^
term -> factor
368
!=
term -> factor
368
-
term -> factor
368
&
term -> factor
368
|
term -> factor
368
from
term -> factor
368
>=
term -> factor
368
if
term -> factor
368
+
term -> factor
368
in
term -> factor
368
>>
term -> factor
369
<<
atom -> True
369
&
atom -> True
369
or
atom -> True
369
[
atom -> True
369
if
atom -> True
369
NEWLINE
atom -> True
369
-
atom -> True
369
*
atom -> True
369
^
atom -> True
369
>=
atom -> True
369
!=
atom -> True
369
(
atom -> True
369
not
atom -> True
369
|
atom -> True
369
from
atom -> True
369
+
atom -> True
369
**
atom -> True
369
.
atom -> True
369
is
atom -> True
369
//
atom -> True
369
>
atom -> True
369
%
atom -> True
369
in
atom -> True
369
<=
atom -> True
369
>>
atom -> True
369
/
atom -> True
369
==
atom -> True
369
and
atom -> True
369
<
atom -> True
369
@
atom -> True
370
[
366
370
atom_expr
367
370
True
369
370
-
372
370
~
370
370
None
373
370
atom
374
370
{
375
370
power
378
370
STRING
379
370
NAME
380
370
(
381
370
NUMBER
382
370
+
386
370
False
392
370
factor
877
371
NEWLINE
xor_expr -> and_expr
371
>
xor_expr -> and_expr
371
<=
xor_expr -> and_expr
371
^
878
371
not
xor_expr -> and_expr
371
|
xor_expr -> and_expr
371
==
xor_expr -> and_expr
371
in
xor_expr -> and_expr
371
!=
xor_expr -> and_expr
371
if
xor_expr -> and_expr
371
is
xor_expr -> and_expr
371
<
xor_expr -> and_expr
371
or
xor_expr -> and_expr
371
and
xor_expr -> and_expr
371
>=
xor_expr -> and_expr
371
from
xor_expr -> and_expr
372
[
366
372
atom_expr
367
372
True
369
372
~
370
372
-
372
372
None
373
372
atom
374
372
{
375
372
power
378
372
STRING
379
372
NAME
380
372
(
381
372
NUMBER
382
372
factor
879
372
+
386
372
False
392
373
@
atom -> None
373
NEWLINE
atom -> None
373
<=
atom -> None
373
in
atom -> None
373
and
atom -> None
373
&
atom -> None
373
|
atom -> None
373
>
atom -> None
373
>=
atom -> None
373
/
atom -> None
373
<<
atom -> None
373
-
atom -> None
373
!=
atom -> None
373
**
atom -> None
373
(
atom -> None
373
*
atom -> None
373
.
atom -> None
373
>>
atom -> None
373
==
atom -> None
373
is
atom -> None
373
<
atom -> None
373
if
atom -> None
373
^
atom -> None
373
[
atom -> None
373
%
atom -> None
373
+
atom -> None
373
from
atom -> None
373
not
atom -> None
373
or
atom -> None
373
//
atom -> None
374
>>
trailer_expr -> 
374
(
880
374
trailer
881
374
trailer_expr
882
374
.
883
374
+
trailer_expr -> 
374
from
trailer_expr -> 
374
is
trailer_expr -> 
374
>
trailer_expr -> 
374
not
trailer_expr -> 
374
|
trailer_expr -> 
374
[
884
374
NEWLINE
trailer_expr -> 
374
&
trailer_expr -> 
374
/
trailer_expr -> 
374
@
trailer_expr -> 
374
!=
trailer_expr -> 
374
**
trailer_expr -> 
374
>=
trailer_expr -> 
374
^
trailer_expr -> 
374
in
trailer_expr -> 
374
<<
trailer_expr -> 
374
and
trailer_expr -> 
374
or
trailer_expr -> 
374
if
trailer_expr -> 
374
//
trailer_expr -> 
374
%
trailer_expr -> 
374
<=
trailer_expr -> 
374
<
trailer_expr -> 
374
==
trailer_expr -> 
374
-
trailer_expr -> 
374
*
trailer_expr -> 
375
}
885
376
>
317
376
is
318
376
in
319
376
<=
320
376
<
321
376
>=
322
376
NEWLINE
comparison -> expr
376
!=
324
376
not
325
376
==
326
376
from
comparison -> expr
376
comp_op
886
376
or
comparison -> expr
376
if
comparison -> expr
376
and
comparison -> expr
377
>>
887
377
if
shift_expr -> arith_expr
377
&
shift_expr -> arith_expr
377
<<
888
377
|
shift_expr -> arith_expr
377
is
shift_expr -> arith_expr
377
<
shift_expr -> arith_expr
377
==
shift_expr -> arith_expr
377
NEWLINE
shift_expr -> arith_expr
377
or
shift_expr -> arith_expr
377
>
shift_expr -> arith_expr
377
!=
shift_expr -> arith_expr
377
>=
shift_expr -> arith_expr
377
from
shift_expr -> arith_expr
377
in
shift_expr -> arith_expr
377
<=
shift_expr -> arith_expr
377
and
shift_expr -> arith_expr
377
^
shift_expr -> arith_expr
377
not
shift_expr -> arith_expr
378
+
factor -> power
378
%
factor -> power
378
<
factor -> power
378
<<
factor -> power
378
from
factor -> power
378
!=
factor -> power
378
<=
factor -> power
378
and
factor -> power
378
/
factor -> power
378
^
factor -> power
378
@
factor -> power
378
>=
factor -> power
378
not
factor -> power
378
//
factor -> power
378
or
factor -> power
378
==
factor -> power
378
is
factor -> power
378
|
factor -> power
378
NEWLINE
factor -> power
378
*
factor -> power
378
-
factor -> power
378
if
factor -> power
378
>
factor -> power
378
in
factor -> power
378
>>
factor -> power
378
&
factor -> power
379
from
atom -> STRING
379
%
atom -> STRING
379
>
atom -> STRING
379
@
atom -> STRING
379
<<
atom -> STRING
379
in
atom -> STRING
379
[
atom -> STRING
379
-
atom -> STRING
379
==
atom -> STRING
379
>=
atom -> STRING
379
not
atom -> STRING
379
/
atom -> STRING
379
+
atom -> STRING
379
NEWLINE
atom -> STRING
379
*
atom -> STRING
379
(
atom -> STRING
379
//
atom -> STRING
379
if
atom -> STRING
379
.
atom -> STRING
379
<
atom -> STRING
379
&
atom -> STRING
379
<=
atom -> STRING
379
!=
atom -> STRING
379
**
atom -> STRING
379
^
atom -> STRING
379
and
atom -> STRING
379
is
atom -> STRING
379
|
atom -> STRING
379
or
atom -> STRING
379
>>
atom -> STRING
380
<
atom -> NAME
380
^
atom -> NAME
380
from
atom -> NAME
380
+
atom -> NAME
380
-
atom -> NAME
380
>=
atom -> NAME
380
@
atom -> NAME
380
!=
atom -> NAME
380
*
atom -> NAME
380
<=
atom -> NAME
380
**
atom -> NAME
380
or
atom -> NAME
380
NEWLINE
atom -> NAME
380
not
atom -> NAME
380
==
atom -> NAME
380
&
atom -> NAME
380
>
atom -> NAME
380
>>
atom -> NAME
380
%
atom -> NAME
380
.
atom -> NAME
380
|
atom -> NAME
380
is
atom -> NAME
380
and
atom -> NAME
380
//
atom -> NAME
380
[
atom -> NAME
380
/
atom -> NAME
380
(
atom -> NAME
380
<<
atom -> NAME
380
if
atom -> NAME
380
in
atom -> NAME
381
[
128
381
factor
129
381
True
130
381
atom_expr
131
381
~
132
381
and_expr
133
381
-
134
381
{
135
381
test_list_comp
889
381
shift_expr
137
381
atom
138
381
)
890
381
comparison
140
381
arith_expr
141
381
power
142
381
STRING
143
381
NAME
144
381
(
145
381
and_test
146
381
term
147
381
+
148
381
xor_expr
149
381
or_test
150
381
NUMBER
151
381
not
152
381
False
153
381
expr
154
381
not_test
155
381
None
156
381
lambdef
157
381
lambda
158
381
test
159
381
test_list
160
382
+
atom -> NUMBER
382
*
atom -> NUMBER
382
>
atom -> NUMBER
382
<<
atom -> NUMBER
382
-
atom -> NUMBER
382
**
atom -> NUMBER
382
if
atom -> NUMBER
382
or
atom -> NUMBER
382
is
atom -> NUMBER
382
from
atom -> NUMBER
382
[
atom -> NUMBER
382
(
atom -> NUMBER
382
not
atom -> NUMBER
382
&
atom -> NUMBER
382
^
atom -> NUMBER
382
in
atom -> NUMBER
382
==
atom -> NUMBER
382
//
atom -> NUMBER
382
!=
atom -> NUMBER
382
and
atom -> NUMBER
382
NEWLINE
atom -> NUMBER
382
%
atom -> NUMBER
382
<=
atom -> NUMBER
382
.
atom -> NUMBER
382
<
atom -> NUMBER
382
>>
atom -> NUMBER
382
/
atom -> NUMBER
382
@
atom -> NUMBER
382
>=
atom -> NUMBER
382
|
atom -> NUMBER
383
or
891
383
from
or_test -> and_test
383
if
or_test -> and_test
383
NEWLINE
or_test -> and_test
384
or
not_test -> comparison
384
NEWLINE
not_test -> comparison
384
and
not_test -> comparison
384
from
not_test -> comparison
384
if
not_test -> comparison
385
-
892
385
+
893
385
>=
arith_expr -> term
385
|
arith_expr -> term
385
<=
arith_expr -> term
385
not
arith_expr -> term
385
==
arith_expr -> term
385
from
arith_expr -> term
385
in
arith_expr -> term
385
>>
arith_expr -> term
385
is
arith_expr -> term
385
if
arith_expr -> term
385
or
arith_expr -> term
385
!=
arith_expr -> term
385
>
arith_expr -> term
385
and
arith_expr -> term
385
<<
arith_expr -> term
385
<
arith_expr -> term
385
^
arith_expr -> term
385
NEWLINE
arith_expr -> term
385
&
arith_expr -> term
386
[
366
386
atom_expr
367
386
True
369
386
-
372
386
~
370
386
None
373
386
atom
374
386
{
375
386
power
378
386
STRING
379
386
NAME
380
386
(
381
386
NUMBER
382
386
factor
894
386
+
386
386
False
392
387
|
895
387
>
expr -> xor_expr
387
if
expr -> xor_expr
387
from
expr -> xor_expr
387
NEWLINE
expr -> xor_expr
387
is
expr -> xor_expr
387
and
expr -> xor_expr
387
not
expr -> xor_expr
387
or
expr -> xor_expr
387
>=
expr -> xor_expr
387
==
expr -> xor_expr
387
<
expr -> xor_expr
387
!=
expr -> xor_expr
387
<=
expr -> xor_expr
387
in
expr -> xor_expr
388
^
and_expr -> shift_expr
388
in
and_expr -> shift_expr
388
|
and_expr -> shift_expr
388
&
896
388
<
and_expr -> shift_expr
388
not
and_expr -> shift_expr
388
>=
and_expr -> shift_expr
388
<=
and_expr -> shift_expr
388
from
and_expr -> shift_expr
388
or
and_expr -> shift_expr
388
and
and_expr -> shift_expr
388
!=
and_expr -> shift_expr
388
if
and_expr -> shift_expr
388
is
and_expr -> shift_expr
388
==
and_expr -> shift_expr
388
NEWLINE
and_expr -> shift_expr
388
>
and_expr -> shift_expr
389
vfpdef
234
389
varargslist
897
389
:
898
389
NAME
233
390
from
899
390
NEWLINE
raise_stmt -> raise test
391
[
366
391
atom_expr
367
391
factor
368
391
True
369
391
~
370
391
and_expr
371
391
-
372
391
None
373
391
atom
374
391
{
375
391
expr
376
391
arith_expr
377
391
power
378
391
STRING
379
391
NAME
380
391
(
381
391
NUMBER
382
391
comparison
384
391
term
385
391
+
386
391
xor_expr
387
391
shift_expr
388
391
not
391
391
False
392
391
not_test
900
392
(
atom -> False
392
*
atom -> False
392
==
atom -> False
392
|
atom -> False
392
[
atom -> False
392
in
atom -> False
392
&
atom -> False
392
is
atom -> False
392
NEWLINE
atom -> False
392
not
atom -> False
392
if
atom -> False
392
^
atom -> False
392
+
atom -> False
392
>
atom -> False
392
<=
atom -> False
392
<<
atom -> False
392
<
atom -> False
392
>=
atom -> False
392
%
atom -> False
392
@
atom -> False
392
and
atom -> False
392
!=
atom -> False
392
-
atom -> False
392
.
atom -> False
392
//
atom -> False
392
from
atom -> False
392
/
atom -> False
392
**
atom -> False
392
>>
atom -> False
392
or
atom -> False
393
and
901
393
from
and_test -> not_test
393
NEWLINE
and_test -> not_test
393
if
and_test -> not_test
393
or
and_test -> not_test
394
from
test -> lambdef
394
NEWLINE
test -> lambdef
395
NEWLINE
test -> or_test
395
from
test -> or_test
395
if
902
396
def
decorators -> decorator decorators
396
class
decorators -> decorator decorators
397
[
166
397
factor
167
397
True
168
397
atom_expr
169
397
~
170
397
not
171
397
and_expr
172
397
-
173
397
{
174
397
shift_expr
175
397
atom
176
397
]
903
397
comparison
178
397
(
179
397
arith_expr
180
397
power
181
397
STRING
182
397
NAME
183
397
test
184
397
and_test
185
397
term
186
397
+
187
397
xor_expr
188
397
NUMBER
190
397
test_list_comp
904
397
False
191
397
expr
192
397
not_test
193
397
None
194
397
lambdef
195
397
lambda
196
397
or_test
197
397
test_list
198
398
not
term -> factor
398
@
905
398
%
906
398
/
907
398
*
908
398
//
909
398
<=
term -> factor
398
NEWLINE
term -> factor
398
>
term -> factor
398
==
term -> factor
398
is
term -> factor
398
or
term -> factor
398
<
term -> factor
398
and
term -> factor
398
<<
term -> factor
398
^
term -> factor
398
!=
term -> factor
398
-
term -> factor
398
&
term -> factor
398
|
term -> factor
398
>=
term -> factor
398
if
term -> factor
398
+
term -> factor
398
in
term -> factor
398
>>
term -> factor
399
<<
atom -> True
399
&
atom -> True
399
or
atom -> True
399
[
atom -> True
399
if
atom -> True
399
NEWLINE
atom -> True
399
-
atom -> True
399
*
atom -> True
399
^
atom -> True
399
>=
atom -> True
399
!=
atom -> True
399
(
atom -> True
399
not
atom -> True
399
|
atom -> True
399
+
atom -> True
399
**
atom -> True
399
.
atom -> True
399
is
atom -> True
399
//
atom -> True
399
>
atom -> True
399
%
atom -> True
399
in
atom -> True
399
<=
atom -> True
399
>>
atom -> True
399
/
atom -> True
399
==
atom -> True
399
and
atom -> True
399
<
atom -> True
399
@
atom -> True
400
**
910
400
!=
power -> atom_expr
400
-
power -> atom_expr
400
<<
power -> atom_expr
400
not
power -> atom_expr
400
/
power -> atom_expr
400
<=
power -> atom_expr
400
in
power -> atom_expr
400
%
power -> atom_expr
400
>
power -> atom_expr
400
@
power -> atom_expr
400
|
power -> atom_expr
400
NEWLINE
power -> atom_expr
400
<
power -> atom_expr
400
>>
power -> atom_expr
400
or
power -> atom_expr
400
and
power -> atom_expr
400
>=
power -> atom_expr
400
==
power -> atom_expr
400
^
power -> atom_expr
400
*
power -> atom_expr
400
&
power -> atom_expr
400
is
power -> atom_expr
400
+
power -> atom_expr
400
if
power -> atom_expr
400
//
power -> atom_expr
401
[
397
401
True
399
401
atom_expr
400
401
-
403
401
~
401
401
None
404
401
atom
405
401
{
406
401
power
408
401
STRING
409
401
NAME
410
401
(
411
401
NUMBER
412
401
+
415
401
False
419
401
factor
911
402
NEWLINE
xor_expr -> and_expr
402
>
xor_expr -> and_expr
402
<=
xor_expr -> and_expr
402
not
xor_expr -> and_expr
402
|
xor_expr -> and_expr
402
^
912
402
==
xor_expr -> and_expr
402
in
xor_expr -> and_expr
402
!=
xor_expr -> and_expr
402
if
xor_expr -> and_expr
402
is
xor_expr -> and_expr
402
<
xor_expr -> and_expr
402
or
xor_expr -> and_expr
402
and
xor_expr -> and_expr
402
>=
xor_expr -> and_expr
403
[
397
403
True
399
403
atom_expr
400
403
~
401
403
-
403
403
None
404
403
atom
405
403
{
406
403
power
408
403
STRING
409
403
NAME
410
403
(
411
403
NUMBER
412
403
factor
913
403
+
415
403
False
419
404
@
atom -> None
404
NEWLINE
atom -> None
404
<=
atom -> None
404
in
atom -> None
404
and
atom -> None
404
&
atom -> None
404
|
atom -> None
404
>
atom -> None
404
>=
atom -> None
404
/
atom -> None
404
<<
atom -> None
404
-
atom -> None
404
!=
atom -> None
404
**
atom -> None
404
(
atom -> None
404
*
atom -> None
404
.
atom -> None
404
>>
atom -> None
404
==
atom -> None
404
is
atom -> None
404
<
atom -> None
404
if
atom -> None
404
^
atom -> None
404
[
atom -> None
404
%
atom -> None
404
+
atom -> None
404
not
atom -> None
404
or
atom -> None
404
//
atom -> None
405
>>
trailer_expr -> 
405
(
914
405
trailer
915
405
trailer_expr
916
405
.
917
405
+
trailer_expr -> 
405
is
trailer_expr -> 
405
>
trailer_expr -> 
405
not
trailer_expr -> 
405
|
trailer_expr -> 
405
[
918
405
NEWLINE
trailer_expr -> 
405
&
trailer_expr -> 
405
/
trailer_expr -> 
405
@
trailer_expr -> 
405
!=
trailer_expr -> 
405
**
trailer_expr -> 
405
>=
trailer_expr -> 
405
^
trailer_expr -> 
405
in
trailer_expr -> 
405
<<
trailer_expr -> 
405
and
trailer_expr -> 
405
or
trailer_expr -> 
405
if
trailer_expr -> 
405
//
trailer_expr -> 
405
%
trailer_expr -> 
405
<=
trailer_expr -> 
405
<
trailer_expr -> 
405
==
trailer_expr -> 
405
-
trailer_expr -> 
405
*
trailer_expr -> 
406
}
919
407
>>
920
407
if
shift_expr -> arith_expr
407
&
shift_expr -> arith_expr
407
<<
921
407
|
shift_expr -> arith_expr
407
is
shift_expr -> arith_expr
407
<
shift_expr -> arith_expr
407
==
shift_expr -> arith_expr
407
NEWLINE
shift_expr -> arith_expr
407
or
shift_expr -> arith_expr
407
>
shift_expr -> arith_expr
407
!=
shift_expr -> arith_expr
407
>=
shift_expr -> arith_expr
407
in
shift_expr -> arith_expr
407
<=
shift_expr -> arith_expr
407
and
shift_expr -> arith_expr
407
^
shift_expr -> arith_expr
407
not
shift_expr -> arith_expr
408
+
factor -> power
408
%
factor -> power
408
<
factor -> power
408
<<
factor -> power
408
!=
factor -> power
408
<=
factor -> power
408
and
factor -> power
408
/
factor -> power
408
^
factor -> power
408
@
factor -> power
408
>=
factor -> power
408
not
factor -> power
408
//
factor -> power
408
or
factor -> power
408
==
factor -> power
408
is
factor -> power
408
|
factor -> power
408
NEWLINE
factor -> power
408
*
factor -> power
408
-
factor -> power
408
if
factor -> power
408
>
factor -> power
408
in
factor -> power
408
>>
factor -> power
408
&
factor -> power
409
%
atom -> STRING
409
>
atom -> STRING
409
@
atom -> STRING
409
<<
atom -> STRING
409
in
atom -> STRING
409
[
atom -> STRING
409
-
atom -> STRING
409
==
atom -> STRING
409
>=
atom -> STRING
409
not
atom -> STRING
409
/
atom -> STRING
409
+
atom -> STRING
409
NEWLINE
atom -> STRING
409
*
atom -> STRING
409
(
atom -> STRING
409
//
atom -> STRING
409
if
atom -> STRING
409
.
atom -> STRING
409
<
atom -> STRING
409
&
atom -> STRING
409
<=
atom -> STRING
409
!=
atom -> STRING
409
**
atom -> STRING
409
^
atom -> STRING
409
and
atom -> STRING
409
is
atom -> STRING
409
|
atom -> STRING
409
or
atom -> STRING
409
>>
atom -> STRING
410
<
atom -> NAME
410
^
atom -> NAME
410
+
atom -> NAME
410
-
atom -> NAME
410
>=
atom -> NAME
410
@
atom -> NAME
410
!=
atom -> NAME
410
*
atom -> NAME
410
<=
atom -> NAME
410
**
atom -> NAME
410
or
atom -> NAME
410
NEWLINE
atom -> NAME
410
not
atom -> NAME
410
==
atom -> NAME
410
&
atom -> NAME
410
>
atom -> NAME
410
>>
atom -> NAME
410
%
atom -> NAME
410
.
atom -> NAME
410
|
atom -> NAME
410
is
atom -> NAME
410
and
atom -> NAME
410
//
atom -> NAME
410
[
atom -> NAME
410
/
atom -> NAME
410
(
atom -> NAME
410
<<
atom -> NAME
410
if
atom -> NAME
410
in
atom -> NAME
411
[
128
411
factor
129
411
True
130
411
atom_expr
131
411
~
132
411
and_expr
133
411
-
134
411
{
135
411
test_list_comp
922
411
shift_expr
137
411
atom
138
411
)
923
411
comparison
140
411
arith_expr
141
411
power
142
411
STRING
143
411
NAME
144
411
(
145
411
and_test
146
411
term
147
411
+
148
411
xor_expr
149
411
or_test
150
411
NUMBER
151
411
not
152
411
False
153
411
expr
154
411
not_test
155
411
None
156
411
lambdef
157
411
lambda
158
411
test
159
411
test_list
160
412
+
atom -> NUMBER
412
*
atom -> NUMBER
412
>
atom -> NUMBER
412
<<
atom -> NUMBER
412
-
atom -> NUMBER
412
**
atom -> NUMBER
412
if
atom -> NUMBER
412
or
atom -> NUMBER
412
is
atom -> NUMBER
412
[
atom -> NUMBER
412
(
atom -> NUMBER
412
not
atom -> NUMBER
412
&
atom -> NUMBER
412
^
atom -> NUMBER
412
in
atom -> NUMBER
412
==
atom -> NUMBER
412
//
atom -> NUMBER
412
!=
atom -> NUMBER
412
and
atom -> NUMBER
412
NEWLINE
atom -> NUMBER
412
%
atom -> NUMBER
412
<=
atom -> NUMBER
412
.
atom -> NUMBER
412
<
atom -> NUMBER
412
>>
atom -> NUMBER
412
/
atom -> NUMBER
412
@
atom -> NUMBER
412
>=
atom -> NUMBER
412
|
atom -> NUMBER
413
or
924
413
if
or_test -> and_test
413
NEWLINE
or_test -> and_test
414
-
925
414
+
926
414
>=
arith_expr -> term
414
|
arith_expr -> term
414
<=
arith_expr -> term
414
not
arith_expr -> term
414
==
arith_expr -> term
414
in
arith_expr -> term
414
>>
arith_expr -> term
414
is
arith_expr -> term
414
if
arith_expr -> term
414
or
arith_expr -> term
414
!=
arith_expr -> term
414
>
arith_expr -> term
414
and
arith_expr -> term
414
<<
arith_expr -> term
414
<
arith_expr -> term
414
^
arith_expr -> term
414
NEWLINE
arith_expr -> term
414
&
arith_expr -> term
415
[
397
415
True
399
415
atom_expr
400
415
-
403
415
~
401
415
None
404
415
atom
405
415
{
406
415
power
408
415
STRING
409
415
NAME
410
415
(
411
415
NUMBER
412
415
factor
927
415
+
415
415
False
419
416
|
928
416
>
expr -> xor_expr
416
if
expr -> xor_expr
416
NEWLINE
expr -> xor_expr
416
is
expr -> xor_expr
416
and
expr -> xor_expr
416
not
expr -> xor_expr
416
or
expr -> xor_expr
416
>=
expr -> xor_expr
416
==
expr -> xor_expr
416
<
expr -> xor_expr
416
!=
expr -> xor_expr
416
<=
expr -> xor_expr
416
in
expr -> xor_expr
417
^
and_expr -> shift_expr
417
in
and_expr -> shift_expr
417
|
and_expr -> shift_expr
417
&
929
417
<
and_expr -> shift_expr
417
not
and_expr -> shift_expr
417
>=
and_expr -> shift_expr
417
<=
and_expr -> shift_expr
417
or
and_expr -> shift_expr
417
and
and_expr -> shift_expr
417
!=
and_expr -> shift_expr
417
if
and_expr -> shift_expr
417
is
and_expr -> shift_expr
417
==
and_expr -> shift_expr
417
NEWLINE
and_expr -> shift_expr
417
>
and_expr -> shift_expr
418
[
397
418
factor
398
418
True
399
418
atom_expr
400
418
~
401
418
and_expr
402
418
-
403
418
None
404
418
atom
405
418
{
406
418
arith_expr
407
418
power
408
418
STRING
409
418
NAME
410
418
(
411
418
NUMBER
412
418
term
414
418
+
415
418
xor_expr
416
418
shift_expr
417
418
not
418
418
False
419
418
comparison
421
418
not_test
930
418
expr
424
419
(
atom -> False
419
*
atom -> False
419
==
atom -> False
419
|
atom -> False
419
[
atom -> False
419
in
atom -> False
419
&
atom -> False
419
is
atom -> False
419
NEWLINE
atom -> False
419
not
atom -> False
419
if
atom -> False
419
^
atom -> False
419
+
atom -> False
419
>
atom -> False
419
<=
atom -> False
419
<<
atom -> False
419
<
atom -> False
419
>=
atom -> False
419
%
atom -> False
419
@
atom -> False
419
and
atom -> False
419
!=
atom -> False
419
-
atom -> False
419
.
atom -> False
419
//
atom -> False
419
/
atom -> False
419
**
atom -> False
419
>>
atom -> False
419
or
atom -> False
420
vfpdef
234
420
:
931
420
varargslist
932
420
NAME
233
421
or
not_test -> comparison
421
NEWLINE
not_test -> comparison
421
if
not_test -> comparison
421
and
not_test -> comparison
422
and
933
422
NEWLINE
and_test -> not_test
422
if
and_test -> not_test
422
or
and_test -> not_test
423
NEWLINE
test -> lambdef
424
>
317
424
is
318
424
in
319
424
<=
320
424
<
321
424
>=
322
424
NEWLINE
comparison -> expr
424
!=
324
424
not
325
424
==
326
424
comp_op
934
424
or
comparison -> expr
424
if
comparison -> expr
424
and
comparison -> expr
425
NEWLINE
test -> or_test
425
if
935
426
NEWLINE
sim_stmt -> begsim test
427
,
936
427
NEWLINE
namelist -> NAME
428
NEWLINE
global_stmt -> global namelist
429
NEWLINE
assert_stmt -> assert test_list
430
NEWLINE
nonlocal_stmt -> nonlocal namelist
431
$
program -> stmt program
432
NEWLINE
del_stmt -> del expr_list
433
$
program -> NEWLINE program
434
==
shift_expr -> arith_expr >> shift_expr
434
%=
shift_expr -> arith_expr >> shift_expr
434
,
shift_expr -> arith_expr >> shift_expr
434
|
shift_expr -> arith_expr >> shift_expr
434
NEWLINE
shift_expr -> arith_expr >> shift_expr
434
:
shift_expr -> arith_expr >> shift_expr
434
>
shift_expr -> arith_expr >> shift_expr
434
/=
shift_expr -> arith_expr >> shift_expr
434
^=
shift_expr -> arith_expr >> shift_expr
434
&=
shift_expr -> arith_expr >> shift_expr
434
>>=
shift_expr -> arith_expr >> shift_expr
434
<=
shift_expr -> arith_expr >> shift_expr
434
!=
shift_expr -> arith_expr >> shift_expr
434
**=
shift_expr -> arith_expr >> shift_expr
434
*=
shift_expr -> arith_expr >> shift_expr
434
not
shift_expr -> arith_expr >> shift_expr
434
^
shift_expr -> arith_expr >> shift_expr
434
and
shift_expr -> arith_expr >> shift_expr
434
or
shift_expr -> arith_expr >> shift_expr
434
if
shift_expr -> arith_expr >> shift_expr
434
|=
shift_expr -> arith_expr >> shift_expr
434
//=
shift_expr -> arith_expr >> shift_expr
434
@=
shift_expr -> arith_expr >> shift_expr
434
is
shift_expr -> arith_expr >> shift_expr
434
in
shift_expr -> arith_expr >> shift_expr
434
>=
shift_expr -> arith_expr >> shift_expr
434
<<=
shift_expr -> arith_expr >> shift_expr
434
=
shift_expr -> arith_expr >> shift_expr
434
-=
shift_expr -> arith_expr >> shift_expr
434
&
shift_expr -> arith_expr >> shift_expr
434
<
shift_expr -> arith_expr >> shift_expr
434
+=
shift_expr -> arith_expr >> shift_expr
435
&
shift_expr -> arith_expr << shift_expr
435
^=
shift_expr -> arith_expr << shift_expr
435
**=
shift_expr -> arith_expr << shift_expr
435
|=
shift_expr -> arith_expr << shift_expr
435
/=
shift_expr -> arith_expr << shift_expr
435
<=
shift_expr -> arith_expr << shift_expr
435
is
shift_expr -> arith_expr << shift_expr
435
=
shift_expr -> arith_expr << shift_expr
435
>=
shift_expr -> arith_expr << shift_expr
435
%=
shift_expr -> arith_expr << shift_expr
435
//=
shift_expr -> arith_expr << shift_expr
435
==
shift_expr -> arith_expr << shift_expr
435
or
shift_expr -> arith_expr << shift_expr
435
>
shift_expr -> arith_expr << shift_expr
435
NEWLINE
shift_expr -> arith_expr << shift_expr
435
not
shift_expr -> arith_expr << shift_expr
435
<
shift_expr -> arith_expr << shift_expr
435
!=
shift_expr -> arith_expr << shift_expr
435
+=
shift_expr -> arith_expr << shift_expr
435
:
shift_expr -> arith_expr << shift_expr
435
^
shift_expr -> arith_expr << shift_expr
435
and
shift_expr -> arith_expr << shift_expr
435
&=
shift_expr -> arith_expr << shift_expr
435
>>=
shift_expr -> arith_expr << shift_expr
435
in
shift_expr -> arith_expr << shift_expr
435
<<=
shift_expr -> arith_expr << shift_expr
435
*=
shift_expr -> arith_expr << shift_expr
435
if
shift_expr -> arith_expr << shift_expr
435
,
shift_expr -> arith_expr << shift_expr
435
|
shift_expr -> arith_expr << shift_expr
435
-=
shift_expr -> arith_expr << shift_expr
435
@=
shift_expr -> arith_expr << shift_expr
436
except_clause
937
436
except
938
437
INDENT
939
438
except
suite -> simple_stmt
439
NEWLINE
940
440
NEWLINE
941
441
//=
test_list -> test , test_list
441
|=
test_list -> test , test_list
441
-=
test_list -> test , test_list
441
/=
test_list -> test , test_list
441
%=
test_list -> test , test_list
441
^=
test_list -> test , test_list
441
@=
test_list -> test , test_list
441
:
test_list -> test , test_list
441
**=
test_list -> test , test_list
441
*=
test_list -> test , test_list
441
NEWLINE
test_list -> test , test_list
441
=
test_list -> test , test_list
441
&=
test_list -> test , test_list
441
+=
test_list -> test , test_list
441
<<=
test_list -> test , test_list
441
>>=
test_list -> test , test_list
442
NEWLINE
942
443
!=
atom -> [ ]
443
>>
atom -> [ ]
443
|
atom -> [ ]
443
<<
atom -> [ ]
443
>
atom -> [ ]
443
.
atom -> [ ]
443
%
atom -> [ ]
443
^
atom -> [ ]
443
-
atom -> [ ]
443
in
atom -> [ ]
443
:
atom -> [ ]
443
or
atom -> [ ]
443
/
atom -> [ ]
443
**
atom -> [ ]
443
//
atom -> [ ]
443
not
atom -> [ ]
443
(
atom -> [ ]
443
+
atom -> [ ]
443
and
atom -> [ ]
443
==
atom -> [ ]
443
[
atom -> [ ]
443
if
atom -> [ ]
443
<
atom -> [ ]
443
<=
atom -> [ ]
443
>=
atom -> [ ]
443
is
atom -> [ ]
443
*
atom -> [ ]
443
@
atom -> [ ]
443
&
atom -> [ ]
444
]
943
445
term
944
445
[
95
445
factor
96
445
True
97
445
atom_expr
98
445
~
99
445
-
101
445
atom
102
445
{
103
445
power
106
445
STRING
107
445
NAME
108
445
(
109
445
+
112
445
NUMBER
116
445
False
118
445
None
122
446
[
95
446
factor
96
446
True
97
446
term
945
446
~
99
446
-
101
446
atom_expr
98
446
atom
102
446
{
103
446
power
106
446
STRING
107
446
NAME
108
446
(
109
446
+
112
446
NUMBER
116
446
False
118
446
None
122
447
[
95
447
factor
96
447
True
97
447
atom_expr
98
447
~
99
447
-
101
447
atom
102
447
{
103
447
power
106
447
STRING
107
447
NAME
108
447
(
109
447
term
946
447
+
112
447
NUMBER
116
447
False
118
447
None
122
448
[
95
448
factor
96
448
True
97
448
atom_expr
98
448
~
99
448
-
101
448
atom
102
448
{
103
448
power
106
448
STRING
107
448
NAME
108
448
(
109
448
term
947
448
+
112
448
NUMBER
116
448
False
118
448
None
122
449
[
95
449
factor
96
449
True
97
449
atom_expr
98
449
~
99
449
-
101
449
atom
102
449
{
103
449
power
106
449
STRING
107
449
NAME
108
449
term
948
449
(
109
449
+
112
449
NUMBER
116
449
False
118
449
None
122
450
[
95
450
True
97
450
atom_expr
98
450
-
101
450
~
99
450
atom
102
450
{
103
450
power
106
450
STRING
107
450
NAME
108
450
(
109
450
+
112
450
NUMBER
116
450
False
118
450
factor
949
450
None
122
451
@
factor -> ~ factor
451
>>
factor -> ~ factor
451
<=
factor -> ~ factor
451
and
factor -> ~ factor
451
+
factor -> ~ factor
451
:
factor -> ~ factor
451
*
factor -> ~ factor
451
!=
factor -> ~ factor
451
%
factor -> ~ factor
451
<<
factor -> ~ factor
451
>=
factor -> ~ factor
451
&
factor -> ~ factor
451
is
factor -> ~ factor
451
==
factor -> ~ factor
451
//
factor -> ~ factor
451
<
factor -> ~ factor
451
/
factor -> ~ factor
451
not
factor -> ~ factor
451
-
factor -> ~ factor
451
or
factor -> ~ factor
451
|
factor -> ~ factor
451
>
factor -> ~ factor
451
^
factor -> ~ factor
451
if
factor -> ~ factor
451
in
factor -> ~ factor
452
[
95
452
factor
96
452
True
97
452
atom_expr
98
452
~
99
452
and_expr
100
452
-
101
452
atom
102
452
{
103
452
xor_expr
950
452
arith_expr
105
452
power
106
452
STRING
107
452
NAME
108
452
(
109
452
term
111
452
+
112
452
shift_expr
115
452
NUMBER
116
452
False
118
452
None
122
453
@
factor -> - factor
453
<=
factor -> - factor
453
in
factor -> - factor
453
>>
factor -> - factor
453
|
factor -> - factor
453
is
factor -> - factor
453
+
factor -> - factor
453
%
factor -> - factor
453
<
factor -> - factor
453
*
factor -> - factor
453
<<
factor -> - factor
453
if
factor -> - factor
453
-
factor -> - factor
453
>=
factor -> - factor
453
not
factor -> - factor
453
and
factor -> - factor
453
/
factor -> - factor
453
:
factor -> - factor
453
or
factor -> - factor
453
^
factor -> - factor
453
>
factor -> - factor
453
!=
factor -> - factor
453
&
factor -> - factor
453
==
factor -> - factor
453
//
factor -> - factor
454
[
766
454
factor
767
454
True
768
454
atom_expr
769
454
~
770
454
and_expr
771
454
-
772
454
{
773
454
shift_expr
774
454
atom
775
454
comparison
776
454
and_test
777
454
arith_expr
778
454
power
779
454
STRING
780
454
NAME
781
454
(
782
454
term
784
454
+
785
454
xor_expr
786
454
)
951
454
or_test
788
454
arglist
952
454
NUMBER
789
454
not
790
454
False
791
454
expr
792
454
*
793
454
not_test
794
454
None
795
454
lambdef
796
454
lambda
797
454
test
798
454
argument
799
454
**
800
455
trailer_expr
953
455
>>
trailer_expr -> 
455
(
454
455
trailer
455
455
.
457
455
+
trailer_expr -> 
455
is
trailer_expr -> 
455
>
trailer_expr -> 
455
not
trailer_expr -> 
455
|
trailer_expr -> 
455
[
458
455
&
trailer_expr -> 
455
/
trailer_expr -> 
455
@
trailer_expr -> 
455
!=
trailer_expr -> 
455
**
trailer_expr -> 
455
>=
trailer_expr -> 
455
^
trailer_expr -> 
455
in
trailer_expr -> 
455
<<
trailer_expr -> 
455
and
trailer_expr -> 
455
or
trailer_expr -> 
455
if
trailer_expr -> 
455
:
trailer_expr -> 
455
//
trailer_expr -> 
455
%
trailer_expr -> 
455
<=
trailer_expr -> 
455
<
trailer_expr -> 
455
==
trailer_expr -> 
455
-
trailer_expr -> 
455
*
trailer_expr -> 
456
^
atom_expr -> atom trailer_expr
456
or
atom_expr -> atom trailer_expr
456
&
atom_expr -> atom trailer_expr
456
@
atom_expr -> atom trailer_expr
456
|
atom_expr -> atom trailer_expr
456
-
atom_expr -> atom trailer_expr
456
*
atom_expr -> atom trailer_expr
456
%
atom_expr -> atom trailer_expr
456
==
atom_expr -> atom trailer_expr
456
**
atom_expr -> atom trailer_expr
456
and
atom_expr -> atom trailer_expr
456
is
atom_expr -> atom trailer_expr
456
in
atom_expr -> atom trailer_expr
456
<<
atom_expr -> atom trailer_expr
456
!=
atom_expr -> atom trailer_expr
456
<=
atom_expr -> atom trailer_expr
456
/
atom_expr -> atom trailer_expr
456
//
atom_expr -> atom trailer_expr
456
<
atom_expr -> atom trailer_expr
456
>=
atom_expr -> atom trailer_expr
456
>>
atom_expr -> atom trailer_expr
456
if
atom_expr -> atom trailer_expr
456
not
atom_expr -> atom trailer_expr
456
:
atom_expr -> atom trailer_expr
456
+
atom_expr -> atom trailer_expr
456
>
atom_expr -> atom trailer_expr
457
NAME
954
458
[
802
458
factor
803
458
True
804
458
atom_expr
810
458
~
806
458
not
807
458
and_expr
808
458
-
809
458
shift_expr
811
458
atom
812
458
{
813
458
comparison
814
458
or_test
815
458
(
816
458
arith_expr
817
458
power
818
458
STRING
819
458
NAME
820
458
and_test
821
458
term
822
458
+
823
458
xor_expr
824
458
subscriptlist
955
458
test
825
458
NUMBER
826
458
False
827
458
subscript
828
458
expr
829
458
not_test
830
458
None
831
458
lambdef
832
458
lambda
833
458
maybe_test
834
458
:
maybe_test -> 
459
in
atom -> { }
459
<=
atom -> { }
459
*
atom -> { }
459
>
atom -> { }
459
+
atom -> { }
459
@
atom -> { }
459
>=
atom -> { }
459
/
atom -> { }
459
:
atom -> { }
459
|
atom -> { }
459
is
atom -> { }
459
and
atom -> { }
459
if
atom -> { }
459
(
atom -> { }
459
>>
atom -> { }
459
not
atom -> { }
459
-
atom -> { }
459
<<
atom -> { }
459
**
atom -> { }
459
or
atom -> { }
459
<
atom -> { }
459
!=
atom -> { }
459
==
atom -> { }
459
%
atom -> { }
459
//
atom -> { }
459
&
atom -> { }
459
[
atom -> { }
459
.
atom -> { }
459
^
atom -> { }
460
[
738
460
factor
740
460
True
741
460
~
742
460
and_expr
743
460
-
744
460
atom
745
460
{
746
460
arith_expr
747
460
power
748
460
atom_expr
749
460
STRING
750
460
NAME
751
460
(
752
460
term
753
460
+
754
460
xor_expr
755
460
shift_expr
756
460
NUMBER
757
460
not
758
460
False
759
460
or_test
956
460
comparison
760
460
not_test
761
460
None
762
460
expr
763
460
and_test
764
461
[
95
461
factor
96
461
True
97
461
atom_expr
98
461
~
99
461
-
101
461
atom
102
461
{
103
461
arith_expr
105
461
power
106
461
STRING
107
461
NAME
108
461
shift_expr
957
461
(
109
461
term
111
461
+
112
461
NUMBER
116
461
False
118
461
None
122
462
[
95
462
factor
96
462
True
97
462
atom_expr
98
462
~
99
462
-
101
462
atom
102
462
{
103
462
arith_expr
105
462
power
106
462
STRING
107
462
NAME
108
462
(
109
462
term
111
462
+
112
462
NUMBER
116
462
False
118
462
shift_expr
958
462
None
122
463
)
959
464
or
atom -> ( )
464
>>
atom -> ( )
464
(
atom -> ( )
464
<=
atom -> ( )
464
.
atom -> ( )
464
is
atom -> ( )
464
@
atom -> ( )
464
%
atom -> ( )
464
<<
atom -> ( )
464
**
atom -> ( )
464
^
atom -> ( )
464
/
atom -> ( )
464
if
atom -> ( )
464
not
atom -> ( )
464
*
atom -> ( )
464
!=
atom -> ( )
464
<
atom -> ( )
464
&
atom -> ( )
464
-
atom -> ( )
464
>
atom -> ( )
464
//
atom -> ( )
464
:
atom -> ( )
464
==
atom -> ( )
464
in
atom -> ( )
464
+
atom -> ( )
464
[
atom -> ( )
464
>=
atom -> ( )
464
and
atom -> ( )
464
|
atom -> ( )
465
[
95
465
factor
96
465
True
97
465
atom_expr
98
465
~
99
465
and_expr
100
465
-
101
465
atom
102
465
{
103
465
arith_expr
105
465
power
106
465
STRING
107
465
NAME
108
465
(
109
465
and_test
110
465
term
111
465
+
112
465
xor_expr
113
465
shift_expr
115
465
NUMBER
116
465
not
117
465
False
118
465
or_test
960
465
expr
119
465
not_test
120
465
comparison
121
465
None
122
466
[
95
466
factor
96
466
True
97
466
atom_expr
98
466
~
99
466
-
101
466
arith_expr
961
466
atom
102
466
{
103
466
power
106
466
STRING
107
466
NAME
108
466
(
109
466
term
111
466
+
112
466
NUMBER
116
466
False
118
466
None
122
467
[
95
467
factor
96
467
True
97
467
atom_expr
98
467
~
99
467
-
101
467
atom
102
467
{
103
467
arith_expr
962
467
power
106
467
STRING
107
467
NAME
108
467
(
109
467
term
111
467
+
112
467
NUMBER
116
467
False
118
467
None
122
468
-
factor -> + factor
468
@
factor -> + factor
468
:
factor -> + factor
468
<<
factor -> + factor
468
is
factor -> + factor
468
and
factor -> + factor
468
<=
factor -> + factor
468
or
factor -> + factor
468
<
factor -> + factor
468
^
factor -> + factor
468
not
factor -> + factor
468
//
factor -> + factor
468
*
factor -> + factor
468
in
factor -> + factor
468
&
factor -> + factor
468
+
factor -> + factor
468
>>
factor -> + factor
468
if
factor -> + factor
468
|
factor -> + factor
468
%
factor -> + factor
468
>
factor -> + factor
468
>=
factor -> + factor
468
!=
factor -> + factor
468
/
factor -> + factor
468
==
factor -> + factor
469
[
95
469
factor
96
469
True
97
469
atom_expr
98
469
~
99
469
and_expr
100
469
-
101
469
atom
102
469
{
103
469
expr
963
469
arith_expr
105
469
power
106
469
STRING
107
469
NAME
108
469
(
109
469
term
111
469
+
112
469
xor_expr
113
469
shift_expr
115
469
NUMBER
116
469
False
118
469
None
122
470
suite
964
470
arith_expr
1
470
small_stmt
965
470
factor
17
470
True
38
470
atom_expr
31
470
term
22
470
-
26
470
None
55
470
atom
57
470
test
5
470
comparison
49
470
and_expr
8
470
power
9
470
STRING
10
470
NAME
52
470
shift_expr
48
470
lambdef
15
470
NUMBER
58
470
simple_stmt
966
470
(
16
470
expr
47
470
[
18
470
NEWLINE
967
470
not_test
32
470
{
21
470
and_test
46
470
+
27
470
lambda
29
470
xor_expr
41
470
yield
34
470
not
62
470
test_list
36
470
~
37
470
or_test
53
470
False
39
470
sim_stmt
45
470
nonlocal
72
470
nonlocal_stmt
73
470
return
59
470
break_stmt
60
470
return_stmt
61
470
raise_stmt
74
470
break
63
470
yield_stmt
75
470
raise
64
470
continue
77
470
expr_stmt
65
470
endsim
78
470
del
80
470
pass_stmt
81
470
flow_stmt
82
470
stat_stmt
66
470
assert_stmt
68
470
resetstats
84
470
del_stmt
85
470
continue_stmt
86
470
begsim
69
470
global_stmt
87
470
pass
88
470
global
70
470
assert
71
471
[
95
471
factor
96
471
True
97
471
atom_expr
98
471
~
99
471
-
101
471
atom
102
471
{
103
471
arith_expr
105
471
power
106
471
STRING
107
471
NAME
108
471
(
109
471
term
111
471
+
112
471
and_expr
968
471
shift_expr
115
471
NUMBER
116
471
False
118
471
None
122
472
and
not_test -> not not_test
472
or
not_test -> not not_test
472
:
not_test -> not not_test
472
if
not_test -> not not_test
473
[
95
473
factor
96
473
True
97
473
atom_expr
98
473
~
99
473
and_expr
100
473
-
101
473
atom
102
473
{
103
473
arith_expr
105
473
power
106
473
STRING
107
473
NAME
108
473
(
109
473
term
111
473
+
112
473
xor_expr
113
473
shift_expr
115
473
NUMBER
116
473
False
118
473
expr
119
473
None
122
473
comparison
969
474
[
95
474
factor
96
474
True
97
474
atom_expr
98
474
~
99
474
and_expr
100
474
-
101
474
atom
102
474
{
103
474
arith_expr
105
474
power
106
474
STRING
107
474
NAME
108
474
(
109
474
term
111
474
+
112
474
xor_expr
113
474
shift_expr
115
474
NUMBER
116
474
not
117
474
False
118
474
and_test
970
474
expr
119
474
not_test
120
474
comparison
121
474
None
122
475
:
971
476
[
95
476
factor
96
476
True
97
476
atom_expr
98
476
~
99
476
and_expr
100
476
-
101
476
atom
102
476
{
103
476
or_test
104
476
arith_expr
105
476
power
106
476
STRING
107
476
NAME
108
476
test
972
476
(
109
476
and_test
110
476
term
111
476
+
112
476
xor_expr
113
476
shift_expr
115
476
NUMBER
116
476
not
117
476
False
118
476
expr
119
476
not_test
120
476
comparison
121
476
None
122
476
lambdef
123
476
lambda
124
477
is
xor_expr -> and_expr ^ xor_expr
477
!=
xor_expr -> and_expr ^ xor_expr
477
-=
xor_expr -> and_expr ^ xor_expr
477
|
xor_expr -> and_expr ^ xor_expr
477
,
xor_expr -> and_expr ^ xor_expr
477
or
xor_expr -> and_expr ^ xor_expr
477
<
xor_expr -> and_expr ^ xor_expr
477
>
xor_expr -> and_expr ^ xor_expr
477
^=
xor_expr -> and_expr ^ xor_expr
477
>>=
xor_expr -> and_expr ^ xor_expr
477
>=
xor_expr -> and_expr ^ xor_expr
477
+=
xor_expr -> and_expr ^ xor_expr
477
|=
xor_expr -> and_expr ^ xor_expr
477
//=
xor_expr -> and_expr ^ xor_expr
477
and
xor_expr -> and_expr ^ xor_expr
477
:
xor_expr -> and_expr ^ xor_expr
477
if
xor_expr -> and_expr ^ xor_expr
477
in
xor_expr -> and_expr ^ xor_expr
477
**=
xor_expr -> and_expr ^ xor_expr
477
NEWLINE
xor_expr -> and_expr ^ xor_expr
477
<<=
xor_expr -> and_expr ^ xor_expr
477
&=
xor_expr -> and_expr ^ xor_expr
477
not
xor_expr -> and_expr ^ xor_expr
477
@=
xor_expr -> and_expr ^ xor_expr
477
<=
xor_expr -> and_expr ^ xor_expr
477
%=
xor_expr -> and_expr ^ xor_expr
477
*=
xor_expr -> and_expr ^ xor_expr
477
==
xor_expr -> and_expr ^ xor_expr
477
/=
xor_expr -> and_expr ^ xor_expr
477
=
xor_expr -> and_expr ^ xor_expr
478
NAME
126
478
dotted_name
973
479
[
766
479
factor
767
479
True
768
479
atom_expr
769
479
~
770
479
and_expr
771
479
-
772
479
{
773
479
shift_expr
774
479
atom
775
479
comparison
776
479
and_test
777
479
arith_expr
778
479
power
779
479
STRING
780
479
NAME
781
479
(
782
479
term
784
479
+
785
479
xor_expr
786
479
or_test
788
479
NUMBER
789
479
not
790
479
False
791
479
expr
792
479
*
793
479
not_test
794
479
None
795
479
arglist
974
479
lambdef
796
479
lambda
797
479
test
798
479
)
975
479
argument
799
479
**
800
480
@
decorator -> @ dotted_name NEWLINE
480
def
decorator -> @ dotted_name NEWLINE
480
class
decorator -> @ dotted_name NEWLINE
481
!=
atom -> [ ]
481
>>
atom -> [ ]
481
|
atom -> [ ]
481
<<
atom -> [ ]
481
>
atom -> [ ]
481
.
atom -> [ ]
481
%
atom -> [ ]
481
^
atom -> [ ]
481
-
atom -> [ ]
481
,
atom -> [ ]
481
in
atom -> [ ]
481
or
atom -> [ ]
481
/
atom -> [ ]
481
**
atom -> [ ]
481
//
atom -> [ ]
481
for
atom -> [ ]
481
not
atom -> [ ]
481
(
atom -> [ ]
481
)
atom -> [ ]
481
+
atom -> [ ]
481
and
atom -> [ ]
481
==
atom -> [ ]
481
[
atom -> [ ]
481
if
atom -> [ ]
481
<
atom -> [ ]
481
<=
atom -> [ ]
481
>=
atom -> [ ]
481
is
atom -> [ ]
481
*
atom -> [ ]
481
@
atom -> [ ]
481
&
atom -> [ ]
482
]
976
483
term
977
483
[
128
483
factor
129
483
True
130
483
atom_expr
131
483
~
132
483
-
134
483
{
135
483
atom
138
483
power
142
483
STRING
143
483
NAME
144
483
(
145
483
+
148
483
NUMBER
151
483
False
153
483
None
156
484
[
128
484
factor
129
484
True
130
484
term
978
484
~
132
484
-
134
484
atom_expr
131
484
{
135
484
atom
138
484
power
142
484
STRING
143
484
NAME
144
484
(
145
484
+
148
484
NUMBER
151
484
False
153
484
None
156
485
[
128
485
factor
129
485
True
130
485
atom_expr
131
485
~
132
485
-
134
485
{
135
485
atom
138
485
power
142
485
STRING
143
485
NAME
144
485
(
145
485
term
979
485
+
148
485
NUMBER
151
485
False
153
485
None
156
486
[
128
486
factor
129
486
True
130
486
atom_expr
131
486
~
132
486
-
134
486
{
135
486
atom
138
486
power
142
486
STRING
143
486
NAME
144
486
(
145
486
term
980
486
+
148
486
NUMBER
151
486
False
153
486
None
156
487
[
128
487
factor
129
487
True
130
487
atom_expr
131
487
~
132
487
-
134
487
{
135
487
atom
138
487
power
142
487
STRING
143
487
NAME
144
487
term
981
487
(
145
487
+
148
487
NUMBER
151
487
False
153
487
None
156
488
[
128
488
True
130
488
atom_expr
131
488
-
134
488
~
132
488
{
135
488
atom
138
488
power
142
488
STRING
143
488
NAME
144
488
(
145
488
+
148
488
NUMBER
151
488
False
153
488
factor
982
488
None
156
489
@
factor -> ~ factor
489
>>
factor -> ~ factor
489
)
factor -> ~ factor
489
<=
factor -> ~ factor
489
and
factor -> ~ factor
489
+
factor -> ~ factor
489
*
factor -> ~ factor
489
!=
factor -> ~ factor
489
for
factor -> ~ factor
489
%
factor -> ~ factor
489
<<
factor -> ~ factor
489
>=
factor -> ~ factor
489
,
factor -> ~ factor
489
&
factor -> ~ factor
489
is
factor -> ~ factor
489
==
factor -> ~ factor
489
//
factor -> ~ factor
489
<
factor -> ~ factor
489
/
factor -> ~ factor
489
not
factor -> ~ factor
489
-
factor -> ~ factor
489
or
factor -> ~ factor
489
|
factor -> ~ factor
489
>
factor -> ~ factor
489
^
factor -> ~ factor
489
if
factor -> ~ factor
489
in
factor -> ~ factor
490
[
128
490
factor
129
490
True
130
490
atom_expr
131
490
~
132
490
and_expr
133
490
-
134
490
{
135
490
shift_expr
137
490
atom
138
490
xor_expr
983
490
arith_expr
141
490
power
142
490
STRING
143
490
NAME
144
490
(
145
490
term
147
490
+
148
490
NUMBER
151
490
False
153
490
None
156
491
@
factor -> - factor
491
<=
factor -> - factor
491
in
factor -> - factor
491
>>
factor -> - factor
491
|
factor -> - factor
491
is
factor -> - factor
491
+
factor -> - factor
491
%
factor -> - factor
491
<
factor -> - factor
491
*
factor -> - factor
491
<<
factor -> - factor
491
if
factor -> - factor
491
for
factor -> - factor
491
-
factor -> - factor
491
>=
factor -> - factor
491
not
factor -> - factor
491
and
factor -> - factor
491
/
factor -> - factor
491
or
factor -> - factor
491
^
factor -> - factor
491
)
factor -> - factor
491
>
factor -> - factor
491
!=
factor -> - factor
491
&
factor -> - factor
491
==
factor -> - factor
491
//
factor -> - factor
491
,
factor -> - factor
492
in
atom -> { }
492
<=
atom -> { }
492
*
atom -> { }
492
>
atom -> { }
492
+
atom -> { }
492
@
atom -> { }
492
,
atom -> { }
492
>=
atom -> { }
492
/
atom -> { }
492
|
atom -> { }
492
is
atom -> { }
492
and
atom -> { }
492
if
atom -> { }
492
(
atom -> { }
492
>>
atom -> { }
492
not
atom -> { }
492
-
atom -> { }
492
<<
atom -> { }
492
**
atom -> { }
492
or
atom -> { }
492
<
atom -> { }
492
!=
atom -> { }
492
==
atom -> { }
492
for
atom -> { }
492
//
atom -> { }
492
%
atom -> { }
492
)
atom -> { }
492
&
atom -> { }
492
[
atom -> { }
492
.
atom -> { }
492
^
atom -> { }
493
>
atom -> ( test_list_comp )
493
@
atom -> ( test_list_comp )
493
&
atom -> ( test_list_comp )
493
=
atom -> ( test_list_comp )
493
%=
atom -> ( test_list_comp )
493
[
atom -> ( test_list_comp )
493
if
atom -> ( test_list_comp )
493
==
atom -> ( test_list_comp )
493
/=
atom -> ( test_list_comp )
493
>=
atom -> ( test_list_comp )
493
**=
atom -> ( test_list_comp )
493
NEWLINE
atom -> ( test_list_comp )
493
^=
atom -> ( test_list_comp )
493
*=
atom -> ( test_list_comp )
493
**
atom -> ( test_list_comp )
493
not
atom -> ( test_list_comp )
493
<<
atom -> ( test_list_comp )
493
+=
atom -> ( test_list_comp )
493
>>
atom -> ( test_list_comp )
493
&=
atom -> ( test_list_comp )
493
>>=
atom -> ( test_list_comp )
493
in
atom -> ( test_list_comp )
493
or
atom -> ( test_list_comp )
493
.
atom -> ( test_list_comp )
493
/
atom -> ( test_list_comp )
493
^
atom -> ( test_list_comp )
493
is
atom -> ( test_list_comp )
493
@=
atom -> ( test_list_comp )
493
,
atom -> ( test_list_comp )
493
|=
atom -> ( test_list_comp )
493
and
atom -> ( test_list_comp )
493
//
atom -> ( test_list_comp )
493
//=
atom -> ( test_list_comp )
493
<<=
atom -> ( test_list_comp )
493
-=
atom -> ( test_list_comp )
493
*
atom -> ( test_list_comp )
493
<=
atom -> ( test_list_comp )
493
(
atom -> ( test_list_comp )
493
<
atom -> ( test_list_comp )
493
-
atom -> ( test_list_comp )
493
!=
atom -> ( test_list_comp )
493
|
atom -> ( test_list_comp )
493
:
atom -> ( test_list_comp )
493
+
atom -> ( test_list_comp )
493
%
atom -> ( test_list_comp )
494
[
128
494
factor
129
494
True
130
494
atom_expr
131
494
~
132
494
-
134
494
{
135
494
shift_expr
137
494
atom
138
494
arith_expr
141
494
power
142
494
STRING
143
494
NAME
144
494
(
145
494
term
147
494
+
148
494
and_expr
984
494
NUMBER
151
494
False
153
494
None
156
495
NAME
985
496
[
766
496
factor
767
496
True
768
496
atom_expr
769
496
~
770
496
and_expr
771
496
-
772
496
{
773
496
shift_expr
774
496
atom
775
496
comparison
776
496
and_test
777
496
arith_expr
778
496
power
779
496
STRING
780
496
NAME
781
496
(
782
496
term
784
496
+
785
496
xor_expr
786
496
)
986
496
or_test
788
496
arglist
987
496
NUMBER
789
496
not
790
496
False
791
496
expr
792
496
*
793
496
not_test
794
496
None
795
496
lambdef
796
496
lambda
797
496
test
798
496
argument
799
496
**
800
497
trailer_expr
988
497
>>
trailer_expr -> 
497
.
495
497
(
496
497
)
trailer_expr -> 
497
trailer
497
497
+
trailer_expr -> 
497
[
499
497
is
trailer_expr -> 
497
>
trailer_expr -> 
497
not
trailer_expr -> 
497
|
trailer_expr -> 
497
&
trailer_expr -> 
497
/
trailer_expr -> 
497
@
trailer_expr -> 
497
!=
trailer_expr -> 
497
**
trailer_expr -> 
497
>=
trailer_expr -> 
497
^
trailer_expr -> 
497
in
trailer_expr -> 
497
<<
trailer_expr -> 
497
and
trailer_expr -> 
497
or
trailer_expr -> 
497
if
trailer_expr -> 
497
//
trailer_expr -> 
497
%
trailer_expr -> 
497
,
trailer_expr -> 
497
<=
trailer_expr -> 
497
<
trailer_expr -> 
497
==
trailer_expr -> 
497
for
trailer_expr -> 
497
-
trailer_expr -> 
497
*
trailer_expr -> 
498
^
atom_expr -> atom trailer_expr
498
or
atom_expr -> atom trailer_expr
498
&
atom_expr -> atom trailer_expr
498
@
atom_expr -> atom trailer_expr
498
|
atom_expr -> atom trailer_expr
498
-
atom_expr -> atom trailer_expr
498
*
atom_expr -> atom trailer_expr
498
%
atom_expr -> atom trailer_expr
498
==
atom_expr -> atom trailer_expr
498
**
atom_expr -> atom trailer_expr
498
and
atom_expr -> atom trailer_expr
498
is
atom_expr -> atom trailer_expr
498
in
atom_expr -> atom trailer_expr
498
<<
atom_expr -> atom trailer_expr
498
!=
atom_expr -> atom trailer_expr
498
<=
atom_expr -> atom trailer_expr
498
/
atom_expr -> atom trailer_expr
498
)
atom_expr -> atom trailer_expr
498
//
atom_expr -> atom trailer_expr
498
<
atom_expr -> atom trailer_expr
498
>=
atom_expr -> atom trailer_expr
498
>>
atom_expr -> atom trailer_expr
498
if
atom_expr -> atom trailer_expr
498
not
atom_expr -> atom trailer_expr
498
for
atom_expr -> atom trailer_expr
498
+
atom_expr -> atom trailer_expr
498
>
atom_expr -> atom trailer_expr
498
,
atom_expr -> atom trailer_expr
499
[
802
499
factor
803
499
True
804
499
atom_expr
810
499
~
806
499
not
807
499
and_expr
808
499
-
809
499
shift_expr
811
499
atom
812
499
{
813
499
comparison
814
499
or_test
815
499
(
816
499
arith_expr
817
499
power
818
499
STRING
819
499
NAME
820
499
and_test
821
499
subscriptlist
989
499
term
822
499
+
823
499
xor_expr
824
499
test
825
499
NUMBER
826
499
False
827
499
subscript
828
499
expr
829
499
not_test
830
499
None
831
499
lambdef
832
499
lambda
833
499
maybe_test
834
499
:
maybe_test -> 
500
[
128
500
factor
129
500
True
130
500
atom_expr
131
500
~
132
500
-
134
500
{
135
500
atom
138
500
arith_expr
141
500
power
142
500
STRING
143
500
NAME
144
500
shift_expr
990
500
(
145
500
term
147
500
+
148
500
NUMBER
151
500
False
153
500
None
156
501
[
128
501
factor
129
501
True
130
501
atom_expr
131
501
~
132
501
-
134
501
{
135
501
atom
138
501
arith_expr
141
501
power
142
501
STRING
143
501
NAME
144
501
shift_expr
991
501
(
145
501
term
147
501
+
148
501
NUMBER
151
501
False
153
501
None
156
502
)
992
503
or
atom -> ( )
503
>>
atom -> ( )
503
(
atom -> ( )
503
<=
atom -> ( )
503
.
atom -> ( )
503
is
atom -> ( )
503
@
atom -> ( )
503
,
atom -> ( )
503
%
atom -> ( )
503
<<
atom -> ( )
503
**
atom -> ( )
503
^
atom -> ( )
503
/
atom -> ( )
503
)
atom -> ( )
503
if
atom -> ( )
503
not
atom -> ( )
503
*
atom -> ( )
503
!=
atom -> ( )
503
for
atom -> ( )
503
<
atom -> ( )
503
&
atom -> ( )
503
-
atom -> ( )
503
>
atom -> ( )
503
//
atom -> ( )
503
==
atom -> ( )
503
in
atom -> ( )
503
+
atom -> ( )
503
[
atom -> ( )
503
>=
atom -> ( )
503
and
atom -> ( )
503
|
atom -> ( )
504
[
128
504
factor
129
504
True
130
504
atom_expr
131
504
~
132
504
and_expr
133
504
-
134
504
{
135
504
shift_expr
137
504
atom
138
504
comparison
140
504
arith_expr
141
504
power
142
504
STRING
143
504
NAME
144
504
(
145
504
and_test
146
504
term
147
504
+
148
504
xor_expr
149
504
NUMBER
151
504
not
152
504
False
153
504
expr
154
504
not_test
155
504
None
156
504
or_test
993
505
[
128
505
factor
129
505
True
130
505
atom_expr
131
505
~
132
505
-
134
505
{
135
505
arith_expr
994
505
atom
138
505
power
142
505
STRING
143
505
NAME
144
505
(
145
505
term
147
505
+
148
505
NUMBER
151
505
False
153
505
None
156
506
[
128
506
factor
129
506
True
130
506
atom_expr
131
506
~
132
506
-
134
506
{
135
506
atom
138
506
arith_expr
995
506
power
142
506
STRING
143
506
NAME
144
506
(
145
506
term
147
506
+
148
506
NUMBER
151
506
False
153
506
None
156
507
-
factor -> + factor
507
@
factor -> + factor
507
<<
factor -> + factor
507
is
factor -> + factor
507
and
factor -> + factor
507
<=
factor -> + factor
507
or
factor -> + factor
507
<
factor -> + factor
507
^
factor -> + factor
507
not
factor -> + factor
507
//
factor -> + factor
507
,
factor -> + factor
507
for
factor -> + factor
507
*
factor -> + factor
507
in
factor -> + factor
507
&
factor -> + factor
507
+
factor -> + factor
507
if
factor -> + factor
507
>>
factor -> + factor
507
)
factor -> + factor
507
|
factor -> + factor
507
%
factor -> + factor
507
>
factor -> + factor
507
>=
factor -> + factor
507
!=
factor -> + factor
507
/
factor -> + factor
507
==
factor -> + factor
508
[
128
508
factor
129
508
True
130
508
atom_expr
131
508
~
132
508
and_expr
133
508
-
134
508
{
135
508
shift_expr
137
508
atom
138
508
expr
996
508
arith_expr
141
508
power
142
508
STRING
143
508
NAME
144
508
(
145
508
term
147
508
+
148
508
xor_expr
149
508
NUMBER
151
508
False
153
508
None
156
509
[
738
509
factor
740
509
True
741
509
~
742
509
and_expr
743
509
-
744
509
atom
745
509
{
746
509
arith_expr
747
509
power
748
509
atom_expr
749
509
STRING
750
509
NAME
751
509
(
752
509
term
753
509
+
754
509
xor_expr
755
509
shift_expr
756
509
NUMBER
757
509
not
758
509
False
759
509
comparison
760
509
not_test
761
509
None
762
509
or_test
997
509
expr
763
509
and_test
764
510
,
not_test -> not not_test
510
and
not_test -> not not_test
510
or
not_test -> not not_test
510
for
not_test -> not not_test
510
)
not_test -> not not_test
510
if
not_test -> not not_test
511
[
128
511
factor
129
511
True
130
511
atom_expr
131
511
~
132
511
and_expr
133
511
-
134
511
{
135
511
shift_expr
137
511
atom
138
511
arith_expr
141
511
power
142
511
STRING
143
511
NAME
144
511
(
145
511
term
147
511
+
148
511
xor_expr
149
511
NUMBER
151
511
False
153
511
expr
154
511
None
156
511
comparison
998
512
[
128
512
factor
129
512
True
130
512
atom_expr
131
512
~
132
512
and_expr
133
512
-
134
512
{
135
512
shift_expr
137
512
atom
138
512
comparison
140
512
arith_expr
141
512
power
142
512
STRING
143
512
NAME
144
512
(
145
512
term
147
512
+
148
512
xor_expr
149
512
NUMBER
151
512
not
152
512
False
153
512
expr
154
512
and_test
999
512
not_test
155
512
None
156
513
:
1000
514
[
128
514
factor
129
514
True
130
514
atom_expr
131
514
~
132
514
and_expr
133
514
-
134
514
{
135
514
shift_expr
137
514
atom
138
514
comparison
140
514
arith_expr
141
514
power
142
514
STRING
143
514
NAME
144
514
(
145
514
and_test
146
514
term
147
514
+
148
514
xor_expr
149
514
or_test
150
514
NUMBER
151
514
not
152
514
False
153
514
expr
154
514
not_test
155
514
None
156
514
lambdef
157
514
lambda
158
514
test
1001
515
[
1002
515
factor
1003
515
True
1004
515
atom_expr
1005
515
~
1006
515
and_expr
1007
515
-
1008
515
shift_expr
1009
515
atom
1010
515
{
1011
515
comparison
1012
515
arith_expr
1013
515
power
1014
515
STRING
1015
515
NAME
1016
515
(
1017
515
and_test
1018
515
term
1019
515
+
1020
515
xor_expr
1021
515
or_test
1022
515
NUMBER
1023
515
not
1024
515
False
1025
515
not_test
1026
515
None
1027
515
expr
1028
515
lambda
1029
515
test_list
1030
515
lambdef
1031
515
test
1032
516
)
test_list_comp -> test comp_for
517
[
208
517
{
209
517
factor
210
517
True
212
517
~
213
517
and_expr
214
517
arith_expr
215
517
shift_expr
216
517
atom
217
517
STRING
218
517
expr_list
1033
517
power
219
517
NAME
220
517
(
221
517
+
222
517
term
223
517
None
224
517
False
225
517
atom_expr
226
517
-
227
517
expr
228
517
NUMBER
229
517
xor_expr
230
518
&=
term -> factor @ term
518
<<=
term -> factor @ term
518
+=
term -> factor @ term
518
%=
term -> factor @ term
518
^
term -> factor @ term
518
<<
term -> factor @ term
518
<=
term -> factor @ term
518
&
term -> factor @ term
518
==
term -> factor @ term
518
if
term -> factor @ term
518
|
term -> factor @ term
518
-=
term -> factor @ term
518
|=
term -> factor @ term
518
NEWLINE
term -> factor @ term
518
!=
term -> factor @ term
518
>>=
term -> factor @ term
518
or
term -> factor @ term
518
>
term -> factor @ term
518
and
term -> factor @ term
518
@=
term -> factor @ term
518
>>
term -> factor @ term
518
is
term -> factor @ term
518
-
term -> factor @ term
518
not
term -> factor @ term
518
=
term -> factor @ term
518
+
term -> factor @ term
518
in
term -> factor @ term
518
/=
term -> factor @ term
518
>=
term -> factor @ term
518
^=
term -> factor @ term
518
//=
term -> factor @ term
518
**=
term -> factor @ term
518
<
term -> factor @ term
518
,
term -> factor @ term
518
*=
term -> factor @ term
518
:
term -> factor @ term
519
-=
term -> factor / term
519
>>
term -> factor / term
519
!=
term -> factor / term
519
<
term -> factor / term
519
<=
term -> factor / term
519
|
term -> factor / term
519
is
term -> factor / term
519
=
term -> factor / term
519
//=
term -> factor / term
519
*=
term -> factor / term
519
>=
term -> factor / term
519
^
term -> factor / term
519
&
term -> factor / term
519
**=
term -> factor / term
519
+
term -> factor / term
519
/=
term -> factor / term
519
>>=
term -> factor / term
519
%=
term -> factor / term
519
NEWLINE
term -> factor / term
519
+=
term -> factor / term
519
<<
term -> factor / term
519
and
term -> factor / term
519
in
term -> factor / term
519
-
term -> factor / term
519
>
term -> factor / term
519
or
term -> factor / term
519
&=
term -> factor / term
519
^=
term -> factor / term
519
not
term -> factor / term
519
==
term -> factor / term
519
,
term -> factor / term
519
@=
term -> factor / term
519
:
term -> factor / term
519
if
term -> factor / term
519
<<=
term -> factor / term
519
|=
term -> factor / term
520
<=
term -> factor % term
520
is
term -> factor % term
520
//=
term -> factor % term
520
>
term -> factor % term
520
and
term -> factor % term
520
in
term -> factor % term
520
,
term -> factor % term
520
|=
term -> factor % term
520
or
term -> factor % term
520
**=
term -> factor % term
520
<
term -> factor % term
520
&=
term -> factor % term
520
%=
term -> factor % term
520
-
term -> factor % term
520
:
term -> factor % term
520
NEWLINE
term -> factor % term
520
!=
term -> factor % term
520
@=
term -> factor % term
520
<<=
term -> factor % term
520
>>
term -> factor % term
520
+=
term -> factor % term
520
/=
term -> factor % term
520
^=
term -> factor % term
520
^
term -> factor % term
520
+
term -> factor % term
520
*=
term -> factor % term
520
if
term -> factor % term
520
<<
term -> factor % term
520
>=
term -> factor % term
520
==
term -> factor % term
520
not
term -> factor % term
520
|
term -> factor % term
520
=
term -> factor % term
520
>>=
term -> factor % term
520
-=
term -> factor % term
520
&
term -> factor % term
521
>>=
term -> factor * term
521
is
term -> factor * term
521
+
term -> factor * term
521
>=
term -> factor * term
521
^
term -> factor * term
521
=
term -> factor * term
521
NEWLINE
term -> factor * term
521
,
term -> factor * term
521
**=
term -> factor * term
521
@=
term -> factor * term
521
<=
term -> factor * term
521
or
term -> factor * term
521
&=
term -> factor * term
521
<
term -> factor * term
521
|
term -> factor * term
521
//=
term -> factor * term
521
>>
term -> factor * term
521
-=
term -> factor * term
521
in
term -> factor * term
521
<<=
term -> factor * term
521
*=
term -> factor * term
521
not
term -> factor * term
521
==
term -> factor * term
521
+=
term -> factor * term
521
%=
term -> factor * term
521
:
term -> factor * term
521
-
term -> factor * term
521
and
term -> factor * term
521
!=
term -> factor * term
521
^=
term -> factor * term
521
/=
term -> factor * term
521
|=
term -> factor * term
521
<<
term -> factor * term
521
>
term -> factor * term
521
if
term -> factor * term
521
&
term -> factor * term
522
!=
term -> factor // term
522
or
term -> factor // term
522
^
term -> factor // term
522
+
term -> factor // term
522
>
term -> factor // term
522
is
term -> factor // term
522
&
term -> factor // term
522
-=
term -> factor // term
522
-
term -> factor // term
522
:
term -> factor // term
522
in
term -> factor // term
522
+=
term -> factor // term
522
>>
term -> factor // term
522
^=
term -> factor // term
522
|
term -> factor // term
522
<
term -> factor // term
522
>=
term -> factor // term
522
/=
term -> factor // term
522
not
term -> factor // term
522
if
term -> factor // term
522
//=
term -> factor // term
522
=
term -> factor // term
522
%=
term -> factor // term
522
&=
term -> factor // term
522
==
term -> factor // term
522
NEWLINE
term -> factor // term
522
>>=
term -> factor // term
522
@=
term -> factor // term
522
*=
term -> factor // term
522
<<=
term -> factor // term
522
<=
term -> factor // term
522
,
term -> factor // term
522
and
term -> factor // term
522
**=
term -> factor // term
522
<<
term -> factor // term
522
|=
term -> factor // term
523
!=
atom -> [ ]
523
>>
atom -> [ ]
523
|
atom -> [ ]
523
<<
atom -> [ ]
523
>
atom -> [ ]
523
.
atom -> [ ]
523
%
atom -> [ ]
523
^
atom -> [ ]
523
-
atom -> [ ]
523
,
atom -> [ ]
523
in
atom -> [ ]
523
or
atom -> [ ]
523
/
atom -> [ ]
523
**
atom -> [ ]
523
//
atom -> [ ]
523
for
atom -> [ ]
523
not
atom -> [ ]
523
(
atom -> [ ]
523
+
atom -> [ ]
523
and
atom -> [ ]
523
]
atom -> [ ]
523
==
atom -> [ ]
523
[
atom -> [ ]
523
if
atom -> [ ]
523
<
atom -> [ ]
523
<=
atom -> [ ]
523
>=
atom -> [ ]
523
is
atom -> [ ]
523
*
atom -> [ ]
523
@
atom -> [ ]
523
&
atom -> [ ]
524
]
1034
525
term
1035
525
[
166
525
factor
167
525
True
168
525
atom_expr
169
525
~
170
525
-
173
525
{
174
525
atom
176
525
(
179
525
power
181
525
STRING
182
525
NAME
183
525
+
187
525
NUMBER
190
525
False
191
525
None
194
526
[
166
526
factor
167
526
True
168
526
atom_expr
169
526
~
170
526
-
173
526
{
174
526
atom
176
526
term
1036
526
(
179
526
power
181
526
STRING
182
526
NAME
183
526
+
187
526
NUMBER
190
526
False
191
526
None
194
527
[
166
527
factor
167
527
True
168
527
term
1037
527
~
170
527
-
173
527
atom_expr
169
527
{
174
527
atom
176
527
(
179
527
power
181
527
STRING
182
527
NAME
183
527
+
187
527
NUMBER
190
527
False
191
527
None
194
528
[
166
528
factor
167
528
True
168
528
atom_expr
169
528
~
170
528
-
173
528
{
174
528
atom
176
528
(
179
528
power
181
528
STRING
182
528
NAME
183
528
term
1038
528
+
187
528
NUMBER
190
528
False
191
528
None
194
529
[
166
529
factor
167
529
True
168
529
atom_expr
169
529
~
170
529
-
173
529
{
174
529
atom
176
529
(
179
529
power
181
529
STRING
182
529
NAME
183
529
term
1039
529
+
187
529
NUMBER
190
529
False
191
529
None
194
530
[
166
530
True
168
530
atom_expr
169
530
-
173
530
~
170
530
{
174
530
atom
176
530
(
179
530
power
181
530
STRING
182
530
NAME
183
530
+
187
530
NUMBER
190
530
False
191
530
factor
1040
530
None
194
531
@
factor -> ~ factor
531
>>
factor -> ~ factor
531
<=
factor -> ~ factor
531
and
factor -> ~ factor
531
+
factor -> ~ factor
531
*
factor -> ~ factor
531
!=
factor -> ~ factor
531
for
factor -> ~ factor
531
%
factor -> ~ factor
531
<<
factor -> ~ factor
531
>=
factor -> ~ factor
531
,
factor -> ~ factor
531
&
factor -> ~ factor
531
]
factor -> ~ factor
531
is
factor -> ~ factor
531
==
factor -> ~ factor
531
//
factor -> ~ factor
531
<
factor -> ~ factor
531
/
factor -> ~ factor
531
not
factor -> ~ factor
531
-
factor -> ~ factor
531
or
factor -> ~ factor
531
|
factor -> ~ factor
531
>
factor -> ~ factor
531
^
factor -> ~ factor
531
if
factor -> ~ factor
531
in
factor -> ~ factor
532
,
not_test -> not not_test
532
]
not_test -> not not_test
532
and
not_test -> not not_test
532
or
not_test -> not not_test
532
for
not_test -> not not_test
532
if
not_test -> not not_test
533
[
166
533
factor
167
533
True
168
533
atom_expr
169
533
~
170
533
and_expr
172
533
-
173
533
{
174
533
shift_expr
175
533
atom
176
533
xor_expr
1041
533
(
179
533
arith_expr
180
533
power
181
533
STRING
182
533
NAME
183
533
term
186
533
+
187
533
NUMBER
190
533
False
191
533
None
194
534
@
factor -> - factor
534
<=
factor -> - factor
534
in
factor -> - factor
534
>>
factor -> - factor
534
|
factor -> - factor
534
is
factor -> - factor
534
+
factor -> - factor
534
%
factor -> - factor
534
<
factor -> - factor
534
*
factor -> - factor
534
<<
factor -> - factor
534
if
factor -> - factor
534
for
factor -> - factor
534
-
factor -> - factor
534
>=
factor -> - factor
534
not
factor -> - factor
534
and
factor -> - factor
534
/
factor -> - factor
534
or
factor -> - factor
534
^
factor -> - factor
534
>
factor -> - factor
534
!=
factor -> - factor
534
&
factor -> - factor
534
==
factor -> - factor
534
//
factor -> - factor
534
]
factor -> - factor
534
,
factor -> - factor
535
in
atom -> { }
535
<=
atom -> { }
535
*
atom -> { }
535
>
atom -> { }
535
+
atom -> { }
535
@
atom -> { }
535
,
atom -> { }
535
>=
atom -> { }
535
/
atom -> { }
535
|
atom -> { }
535
is
atom -> { }
535
and
atom -> { }
535
if
atom -> { }
535
(
atom -> { }
535
>>
atom -> { }
535
]
atom -> { }
535
not
atom -> { }
535
-
atom -> { }
535
<<
atom -> { }
535
**
atom -> { }
535
or
atom -> { }
535
<
atom -> { }
535
!=
atom -> { }
535
==
atom -> { }
535
for
atom -> { }
535
//
atom -> { }
535
%
atom -> { }
535
&
atom -> { }
535
[
atom -> { }
535
.
atom -> { }
535
^
atom -> { }
536
[
166
536
factor
167
536
True
168
536
atom_expr
169
536
~
170
536
-
173
536
{
174
536
shift_expr
175
536
atom
176
536
(
179
536
arith_expr
180
536
power
181
536
STRING
182
536
NAME
183
536
and_expr
1042
536
term
186
536
+
187
536
NUMBER
190
536
False
191
536
None
194
537
[
766
537
factor
767
537
True
768
537
atom_expr
769
537
~
770
537
and_expr
771
537
-
772
537
{
773
537
shift_expr
774
537
atom
775
537
comparison
776
537
and_test
777
537
arith_expr
778
537
power
779
537
STRING
780
537
NAME
781
537
(
782
537
term
784
537
+
785
537
xor_expr
786
537
)
1043
537
or_test
788
537
arglist
1044
537
NUMBER
789
537
not
790
537
False
791
537
expr
792
537
*
793
537
not_test
794
537
None
795
537
lambdef
796
537
lambda
797
537
test
798
537
argument
799
537
**
800
538
trailer_expr
1045
538
>>
trailer_expr -> 
538
(
537
538
trailer
538
538
.
540
538
+
trailer_expr -> 
538
[
541
538
is
trailer_expr -> 
538
>
trailer_expr -> 
538
not
trailer_expr -> 
538
|
trailer_expr -> 
538
&
trailer_expr -> 
538
/
trailer_expr -> 
538
@
trailer_expr -> 
538
!=
trailer_expr -> 
538
**
trailer_expr -> 
538
>=
trailer_expr -> 
538
^
trailer_expr -> 
538
in
trailer_expr -> 
538
]
trailer_expr -> 
538
<<
trailer_expr -> 
538
and
trailer_expr -> 
538
or
trailer_expr -> 
538
if
trailer_expr -> 
538
//
trailer_expr -> 
538
%
trailer_expr -> 
538
,
trailer_expr -> 
538
<=
trailer_expr -> 
538
<
trailer_expr -> 
538
==
trailer_expr -> 
538
for
trailer_expr -> 
538
-
trailer_expr -> 
538
*
trailer_expr -> 
539
^
atom_expr -> atom trailer_expr
539
or
atom_expr -> atom trailer_expr
539
&
atom_expr -> atom trailer_expr
539
@
atom_expr -> atom trailer_expr
539
|
atom_expr -> atom trailer_expr
539
-
atom_expr -> atom trailer_expr
539
*
atom_expr -> atom trailer_expr
539
%
atom_expr -> atom trailer_expr
539
==
atom_expr -> atom trailer_expr
539
**
atom_expr -> atom trailer_expr
539
and
atom_expr -> atom trailer_expr
539
is
atom_expr -> atom trailer_expr
539
in
atom_expr -> atom trailer_expr
539
<<
atom_expr -> atom trailer_expr
539
!=
atom_expr -> atom trailer_expr
539
<=
atom_expr -> atom trailer_expr
539
/
atom_expr -> atom trailer_expr
539
//
atom_expr -> atom trailer_expr
539
<
atom_expr -> atom trailer_expr
539
>=
atom_expr -> atom trailer_expr
539
>>
atom_expr -> atom trailer_expr
539
if
atom_expr -> atom trailer_expr
539
not
atom_expr -> atom trailer_expr
539
for
atom_expr -> atom trailer_expr
539
+
atom_expr -> atom trailer_expr
539
]
atom_expr -> atom trailer_expr
539
>
atom_expr -> atom trailer_expr
539
,
atom_expr -> atom trailer_expr
540
NAME
1046
541
[
802
541
factor
803
541
True
804
541
atom_expr
810
541
~
806
541
not
807
541
and_expr
808
541
-
809
541
shift_expr
811
541
atom
812
541
{
813
541
comparison
814
541
or_test
815
541
(
816
541
arith_expr
817
541
power
818
541
STRING
819
541
NAME
820
541
and_test
821
541
subscriptlist
1047
541
term
822
541
+
823
541
xor_expr
824
541
test
825
541
NUMBER
826
541
False
827
541
subscript
828
541
expr
829
541
not_test
830
541
None
831
541
lambdef
832
541
lambda
833
541
maybe_test
834
541
:
maybe_test -> 
542
)
1048
543
or
atom -> ( )
543
>>
atom -> ( )
543
(
atom -> ( )
543
<=
atom -> ( )
543
.
atom -> ( )
543
is
atom -> ( )
543
@
atom -> ( )
543
,
atom -> ( )
543
%
atom -> ( )
543
<<
atom -> ( )
543
**
atom -> ( )
543
^
atom -> ( )
543
/
atom -> ( )
543
if
atom -> ( )
543
not
atom -> ( )
543
*
atom -> ( )
543
!=
atom -> ( )
543
for
atom -> ( )
543
<
atom -> ( )
543
&
atom -> ( )
543
-
atom -> ( )
543
>
atom -> ( )
543
//
atom -> ( )
543
==
atom -> ( )
543
]
atom -> ( )
543
in
atom -> ( )
543
+
atom -> ( )
543
[
atom -> ( )
543
>=
atom -> ( )
543
and
atom -> ( )
543
|
atom -> ( )
544
[
166
544
factor
167
544
True
168
544
atom_expr
169
544
~
170
544
-
173
544
{
174
544
atom
176
544
(
179
544
arith_expr
180
544
power
181
544
STRING
182
544
NAME
183
544
shift_expr
1049
544
term
186
544
+
187
544
NUMBER
190
544
False
191
544
None
194
545
[
166
545
factor
167
545
True
168
545
atom_expr
169
545
~
170
545
-
173
545
{
174
545
atom
176
545
(
179
545
arith_expr
180
545
power
181
545
STRING
182
545
NAME
183
545
term
186
545
+
187
545
NUMBER
190
545
False
191
545
shift_expr
1050
545
None
194
546
]
test_list_comp -> test comp_for
547
[
208
547
{
209
547
factor
210
547
True
212
547
~
213
547
and_expr
214
547
arith_expr
215
547
shift_expr
216
547
atom
217
547
STRING
218
547
power
219
547
NAME
220
547
(
221
547
+
222
547
term
223
547
None
224
547
False
225
547
atom_expr
226
547
-
227
547
expr
228
547
NUMBER
229
547
xor_expr
230
547
expr_list
1051
548
[
1052
548
factor
1053
548
True
1054
548
atom_expr
1055
548
~
1056
548
not
1057
548
and_expr
1058
548
-
1059
548
shift_expr
1060
548
atom
1061
548
{
1062
548
comparison
1063
548
(
1064
548
arith_expr
1065
548
power
1066
548
STRING
1067
548
NAME
1068
548
and_test
1069
548
test
1070
548
term
1071
548
+
1072
548
xor_expr
1073
548
NUMBER
1074
548
False
1075
548
not_test
1076
548
None
1077
548
expr
1078
548
lambda
1079
548
or_test
1080
548
lambdef
1081
548
test_list
1082
549
[
166
549
factor
167
549
True
168
549
atom_expr
169
549
~
170
549
not
171
549
and_expr
172
549
-
173
549
{
174
549
shift_expr
175
549
atom
176
549
comparison
178
549
(
179
549
arith_expr
180
549
power
181
549
STRING
182
549
NAME
183
549
or_test
1083
549
and_test
185
549
term
186
549
+
187
549
xor_expr
188
549
NUMBER
190
549
False
191
549
expr
192
549
not_test
193
549
None
194
550
[
166
550
factor
167
550
True
168
550
atom_expr
169
550
~
170
550
-
173
550
{
174
550
arith_expr
1084
550
atom
176
550
(
179
550
power
181
550
STRING
182
550
NAME
183
550
term
186
550
+
187
550
NUMBER
190
550
False
191
550
None
194
551
[
166
551
factor
167
551
True
168
551
atom_expr
169
551
~
170
551
-
173
551
{
174
551
atom
176
551
arith_expr
1085
551
(
179
551
power
181
551
STRING
182
551
NAME
183
551
term
186
551
+
187
551
NUMBER
190
551
False
191
551
None
194
552
-
factor -> + factor
552
@
factor -> + factor
552
<<
factor -> + factor
552
is
factor -> + factor
552
and
factor -> + factor
552
<=
factor -> + factor
552
or
factor -> + factor
552
<
factor -> + factor
552
^
factor -> + factor
552
not
factor -> + factor
552
//
factor -> + factor
552
,
factor -> + factor
552
for
factor -> + factor
552
*
factor -> + factor
552
in
factor -> + factor
552
&
factor -> + factor
552
+
factor -> + factor
552
if
factor -> + factor
552
>>
factor -> + factor
552
|
factor -> + factor
552
%
factor -> + factor
552
>
factor -> + factor
552
>=
factor -> + factor
552
!=
factor -> + factor
552
]
factor -> + factor
552
/
factor -> + factor
552
==
factor -> + factor
553
[
166
553
factor
167
553
True
168
553
atom_expr
169
553
~
170
553
and_expr
172
553
-
173
553
{
174
553
shift_expr
175
553
atom
176
553
expr
1086
553
(
179
553
arith_expr
180
553
power
181
553
STRING
182
553
NAME
183
553
term
186
553
+
187
553
xor_expr
188
553
NUMBER
190
553
False
191
553
None
194
554
.
atom -> [ test_list_comp ]
554
[
atom -> [ test_list_comp ]
554
@
atom -> [ test_list_comp ]
554
<=
atom -> [ test_list_comp ]
554
^=
atom -> [ test_list_comp ]
554
not
atom -> [ test_list_comp ]
554
<
atom -> [ test_list_comp ]
554
&=
atom -> [ test_list_comp ]
554
/=
atom -> [ test_list_comp ]
554
in
atom -> [ test_list_comp ]
554
%=
atom -> [ test_list_comp ]
554
and
atom -> [ test_list_comp ]
554
-
atom -> [ test_list_comp ]
554
if
atom -> [ test_list_comp ]
554
|=
atom -> [ test_list_comp ]
554
!=
atom -> [ test_list_comp ]
554
is
atom -> [ test_list_comp ]
554
>>
atom -> [ test_list_comp ]
554
=
atom -> [ test_list_comp ]
554
>>=
atom -> [ test_list_comp ]
554
or
atom -> [ test_list_comp ]
554
//
atom -> [ test_list_comp ]
554
@=
atom -> [ test_list_comp ]
554
/
atom -> [ test_list_comp ]
554
*=
atom -> [ test_list_comp ]
554
,
atom -> [ test_list_comp ]
554
|
atom -> [ test_list_comp ]
554
>
atom -> [ test_list_comp ]
554
NEWLINE
atom -> [ test_list_comp ]
554
//=
atom -> [ test_list_comp ]
554
&
atom -> [ test_list_comp ]
554
<<=
atom -> [ test_list_comp ]
554
(
atom -> [ test_list_comp ]
554
-=
atom -> [ test_list_comp ]
554
**=
atom -> [ test_list_comp ]
554
%
atom -> [ test_list_comp ]
554
>=
atom -> [ test_list_comp ]
554
+=
atom -> [ test_list_comp ]
554
**
atom -> [ test_list_comp ]
554
==
atom -> [ test_list_comp ]
554
:
atom -> [ test_list_comp ]
554
<<
atom -> [ test_list_comp ]
554
+
atom -> [ test_list_comp ]
554
*
atom -> [ test_list_comp ]
554
^
atom -> [ test_list_comp ]
555
[
166
555
factor
167
555
True
168
555
atom_expr
169
555
~
170
555
and_expr
172
555
-
173
555
{
174
555
shift_expr
175
555
atom
176
555
(
179
555
arith_expr
180
555
power
181
555
STRING
182
555
NAME
183
555
term
186
555
+
187
555
xor_expr
188
555
NUMBER
190
555
False
191
555
expr
192
555
None
194
555
comparison
1087
556
[
166
556
factor
167
556
True
168
556
atom_expr
169
556
~
170
556
not
171
556
and_expr
172
556
-
173
556
{
174
556
shift_expr
175
556
atom
176
556
comparison
178
556
(
179
556
arith_expr
180
556
power
181
556
STRING
182
556
NAME
183
556
term
186
556
+
187
556
xor_expr
188
556
NUMBER
190
556
False
191
556
expr
192
556
and_test
1088
556
not_test
193
556
None
194
557
[
166
557
factor
167
557
True
168
557
atom_expr
169
557
~
170
557
not
171
557
and_expr
172
557
-
173
557
{
174
557
shift_expr
175
557
atom
176
557
comparison
178
557
(
179
557
arith_expr
180
557
power
181
557
STRING
182
557
NAME
183
557
and_test
185
557
term
186
557
+
187
557
xor_expr
188
557
NUMBER
190
557
False
191
557
expr
192
557
not_test
193
557
None
194
557
lambdef
195
557
lambda
196
557
or_test
197
557
test
1089
558
:
1090
559
[
738
559
factor
740
559
True
741
559
~
742
559
and_expr
743
559
-
744
559
atom
745
559
{
746
559
arith_expr
747
559
power
748
559
atom_expr
749
559
STRING
750
559
NAME
751
559
(
752
559
term
753
559
+
754
559
xor_expr
755
559
shift_expr
756
559
NUMBER
757
559
not
758
559
False
759
559
or_test
1091
559
comparison
760
559
not_test
761
559
None
762
559
expr
763
559
and_test
764
560
[
766
560
factor
767
560
True
768
560
atom_expr
769
560
~
770
560
and_expr
771
560
-
772
560
)
1092
560
{
773
560
shift_expr
774
560
atom
775
560
comparison
776
560
and_test
777
560
arith_expr
778
560
power
779
560
STRING
780
560
NAME
781
560
(
782
560
term
784
560
arglist
1093
560
+
785
560
xor_expr
786
560
or_test
788
560
NUMBER
789
560
not
790
560
False
791
560
expr
792
560
*
793
560
not_test
794
560
None
795
560
lambdef
796
560
lambda
797
560
test
798
560
argument
799
560
**
800
561
arith_expr
1
561
small_stmt
20
561
factor
17
561
True
38
561
atom_expr
31
561
term
22
561
-
26
561
None
55
561
atom
57
561
test
5
561
comparison
49
561
and_expr
8
561
power
9
561
STRING
10
561
NAME
52
561
shift_expr
48
561
lambdef
15
561
NUMBER
58
561
simple_stmt
1094
561
(
16
561
expr
47
561
[
18
561
NEWLINE
1095
561
not_test
32
561
{
21
561
and_test
46
561
suite
1096
561
+
27
561
lambda
29
561
xor_expr
41
561
yield
34
561
not
62
561
test_list
36
561
~
37
561
or_test
53
561
False
39
561
sim_stmt
45
561
nonlocal
72
561
nonlocal_stmt
73
561
return
59
561
break_stmt
60
561
return_stmt
61
561
raise_stmt
74
561
break
63
561
yield_stmt
75
561
raise
64
561
continue
77
561
expr_stmt
65
561
endsim
78
561
del
80
561
pass_stmt
81
561
flow_stmt
82
561
stat_stmt
66
561
assert_stmt
68
561
resetstats
84
561
del_stmt
85
561
continue_stmt
86
561
begsim
69
561
global_stmt
87
561
pass
88
561
global
70
561
assert
71
562
>=
arith_expr -> term + arith_expr
562
-=
arith_expr -> term + arith_expr
562
>
arith_expr -> term + arith_expr
562
^
arith_expr -> term + arith_expr
562
<<=
arith_expr -> term + arith_expr
562
or
arith_expr -> term + arith_expr
562
>>=
arith_expr -> term + arith_expr
562
&=
arith_expr -> term + arith_expr
562
/=
arith_expr -> term + arith_expr
562
<=
arith_expr -> term + arith_expr
562
==
arith_expr -> term + arith_expr
562
**=
arith_expr -> term + arith_expr
562
if
arith_expr -> term + arith_expr
562
>>
arith_expr -> term + arith_expr
562
+=
arith_expr -> term + arith_expr
562
//=
arith_expr -> term + arith_expr
562
%=
arith_expr -> term + arith_expr
562
<
arith_expr -> term + arith_expr
562
not
arith_expr -> term + arith_expr
562
*=
arith_expr -> term + arith_expr
562
&
arith_expr -> term + arith_expr
562
in
arith_expr -> term + arith_expr
562
and
arith_expr -> term + arith_expr
562
,
arith_expr -> term + arith_expr
562
@=
arith_expr -> term + arith_expr
562
|
arith_expr -> term + arith_expr
562
!=
arith_expr -> term + arith_expr
562
^=
arith_expr -> term + arith_expr
562
NEWLINE
arith_expr -> term + arith_expr
562
=
arith_expr -> term + arith_expr
562
:
arith_expr -> term + arith_expr
562
<<
arith_expr -> term + arith_expr
562
|=
arith_expr -> term + arith_expr
562
is
arith_expr -> term + arith_expr
563
^
arith_expr -> term - arith_expr
563
//=
arith_expr -> term - arith_expr
563
!=
arith_expr -> term - arith_expr
563
+=
arith_expr -> term - arith_expr
563
%=
arith_expr -> term - arith_expr
563
>>=
arith_expr -> term - arith_expr
563
@=
arith_expr -> term - arith_expr
563
<
arith_expr -> term - arith_expr
563
in
arith_expr -> term - arith_expr
563
==
arith_expr -> term - arith_expr
563
|
arith_expr -> term - arith_expr
563
is
arith_expr -> term - arith_expr
563
&
arith_expr -> term - arith_expr
563
>>
arith_expr -> term - arith_expr
563
<<=
arith_expr -> term - arith_expr
563
-=
arith_expr -> term - arith_expr
563
<<
arith_expr -> term - arith_expr
563
*=
arith_expr -> term - arith_expr
563
=
arith_expr -> term - arith_expr
563
and
arith_expr -> term - arith_expr
563
/=
arith_expr -> term - arith_expr
563
^=
arith_expr -> term - arith_expr
563
,
arith_expr -> term - arith_expr
563
&=
arith_expr -> term - arith_expr
563
>
arith_expr -> term - arith_expr
563
if
arith_expr -> term - arith_expr
563
**=
arith_expr -> term - arith_expr
563
NEWLINE
arith_expr -> term - arith_expr
563
not
arith_expr -> term - arith_expr
563
|=
arith_expr -> term - arith_expr
563
>=
arith_expr -> term - arith_expr
563
<=
arith_expr -> term - arith_expr
563
or
arith_expr -> term - arith_expr
563
:
arith_expr -> term - arith_expr
564
parameters
1097
564
)
1098
564
NAME
1099
564
**
1100
564
tfpdef
1101
564
*
1102
564
param
1103
565
NEWLINE
1104
566
^
atom -> [ ]
566
(
atom -> [ ]
566
>>
atom -> [ ]
566
-
atom -> [ ]
566
+
atom -> [ ]
566
,
atom -> [ ]
566
in
atom -> [ ]
566
|
atom -> [ ]
566
[
atom -> [ ]
566
*
atom -> [ ]
566
<<
atom -> [ ]
566
@
atom -> [ ]
566
.
atom -> [ ]
566
%
atom -> [ ]
566
/
atom -> [ ]
566
**
atom -> [ ]
566
//
atom -> [ ]
566
&
atom -> [ ]
567
]
1105
568
/
atom -> { }
568
@
atom -> { }
568
|
atom -> { }
568
**
atom -> { }
568
in
atom -> { }
568
,
atom -> { }
568
*
atom -> { }
568
%
atom -> { }
568
^
atom -> { }
568
//
atom -> { }
568
>>
atom -> { }
568
(
atom -> { }
568
&
atom -> { }
568
.
atom -> { }
568
[
atom -> { }
568
-
atom -> { }
568
<<
atom -> { }
568
+
atom -> { }
569
[
208
569
{
209
569
factor
210
569
True
212
569
~
213
569
atom
217
569
STRING
218
569
power
219
569
NAME
220
569
(
221
569
term
1106
569
+
222
569
None
224
569
False
225
569
atom_expr
226
569
-
227
569
NUMBER
229
570
[
208
570
{
209
570
factor
210
570
True
212
570
~
213
570
atom
217
570
STRING
218
570
power
219
570
NAME
220
570
(
221
570
+
222
570
None
224
570
False
225
570
atom_expr
226
570
-
227
570
term
1107
570
NUMBER
229
571
[
208
571
{
209
571
factor
210
571
True
212
571
~
213
571
atom
217
571
STRING
218
571
power
219
571
NAME
220
571
(
221
571
+
222
571
term
1108
571
None
224
571
False
225
571
atom_expr
226
571
-
227
571
NUMBER
229
572
[
208
572
{
209
572
factor
210
572
True
212
572
~
213
572
atom
217
572
STRING
218
572
power
219
572
NAME
220
572
(
221
572
+
222
572
None
224
572
False
225
572
atom_expr
226
572
-
227
572
NUMBER
229
572
term
1109
573
[
208
573
{
209
573
factor
210
573
True
212
573
~
213
573
atom
217
573
STRING
218
573
power
219
573
NAME
220
573
(
221
573
+
222
573
None
224
573
False
225
573
atom_expr
226
573
-
227
573
term
1110
573
NUMBER
229
574
[
1111
574
factor
1112
574
True
1113
574
atom_expr
1114
574
~
1115
574
and_expr
1116
574
-
1117
574
shift_expr
1118
574
atom
1119
574
{
1120
574
comparison
1121
574
or_test
1122
574
arith_expr
1123
574
power
1124
574
STRING
1125
574
NAME
1126
574
test_list
1127
574
(
1128
574
and_test
1129
574
term
1130
574
+
1131
574
xor_expr
1132
574
NUMBER
1133
574
not
1134
574
False
1135
574
expr
1136
574
not_test
1137
574
test
1138
574
None
1139
574
lambdef
1140
574
lambda
1141
575
<<
factor -> ~ factor
575
-
factor -> ~ factor
575
@
factor -> ~ factor
575
,
factor -> ~ factor
575
|
factor -> ~ factor
575
*
factor -> ~ factor
575
&
factor -> ~ factor
575
>>
factor -> ~ factor
575
//
factor -> ~ factor
575
%
factor -> ~ factor
575
/
factor -> ~ factor
575
^
factor -> ~ factor
575
+
factor -> ~ factor
575
in
factor -> ~ factor
576
[
208
576
{
209
576
factor
210
576
True
212
576
~
213
576
and_expr
214
576
arith_expr
215
576
shift_expr
216
576
atom
217
576
STRING
218
576
power
219
576
NAME
220
576
(
221
576
+
222
576
term
223
576
None
224
576
False
225
576
atom_expr
226
576
-
227
576
xor_expr
1142
576
NUMBER
229
577
[
208
577
{
209
577
factor
210
577
True
212
577
~
213
577
arith_expr
215
577
atom
217
577
STRING
218
577
power
219
577
NAME
220
577
(
221
577
+
222
577
term
223
577
None
224
577
False
225
577
atom_expr
226
577
shift_expr
1143
577
-
227
577
NUMBER
229
578
[
208
578
{
209
578
factor
210
578
True
212
578
~
213
578
arith_expr
215
578
atom
217
578
STRING
218
578
power
219
578
NAME
220
578
(
221
578
+
222
578
term
223
578
None
224
578
False
225
578
atom_expr
226
578
-
227
578
NUMBER
229
578
shift_expr
1144
579
[
208
579
{
209
579
factor
210
579
True
212
579
~
213
579
arith_expr
215
579
shift_expr
216
579
atom
217
579
STRING
218
579
power
219
579
NAME
220
579
(
221
579
+
222
579
term
223
579
None
224
579
False
225
579
atom_expr
226
579
-
227
579
NUMBER
229
579
and_expr
1145
580
[
766
580
factor
767
580
True
768
580
atom_expr
769
580
~
770
580
and_expr
771
580
-
772
580
{
773
580
shift_expr
774
580
atom
775
580
comparison
776
580
and_test
777
580
arith_expr
778
580
power
779
580
STRING
780
580
NAME
781
580
(
782
580
term
784
580
+
785
580
xor_expr
786
580
)
1146
580
or_test
788
580
arglist
1147
580
NUMBER
789
580
not
790
580
False
791
580
expr
792
580
*
793
580
not_test
794
580
None
795
580
lambdef
796
580
lambda
797
580
test
798
580
argument
799
580
**
800
581
[
802
581
factor
803
581
True
804
581
atom_expr
810
581
~
806
581
not
807
581
and_expr
808
581
-
809
581
shift_expr
811
581
atom
812
581
{
813
581
comparison
814
581
or_test
815
581
(
816
581
arith_expr
817
581
power
818
581
STRING
819
581
NAME
820
581
and_test
821
581
subscriptlist
1148
581
term
822
581
+
823
581
xor_expr
824
581
test
825
581
NUMBER
826
581
False
827
581
subscript
828
581
expr
829
581
not_test
830
581
None
831
581
lambdef
832
581
lambda
833
581
maybe_test
834
581
:
maybe_test -> 
582
trailer_expr
1149
582
>>
trailer_expr -> 
582
(
580
582
[
581
582
in
trailer_expr -> 
582
trailer
582
582
.
583
582
+
trailer_expr -> 
582
<<
trailer_expr -> 
582
|
trailer_expr -> 
582
//
trailer_expr -> 
582
%
trailer_expr -> 
582
,
trailer_expr -> 
582
&
trailer_expr -> 
582
/
trailer_expr -> 
582
@
trailer_expr -> 
582
**
trailer_expr -> 
582
-
trailer_expr -> 
582
^
trailer_expr -> 
582
*
trailer_expr -> 
583
NAME
1150
584
**
atom_expr -> atom trailer_expr
584
>>
atom_expr -> atom trailer_expr
584
*
atom_expr -> atom trailer_expr
584
^
atom_expr -> atom trailer_expr
584
@
atom_expr -> atom trailer_expr
584
/
atom_expr -> atom trailer_expr
584
&
atom_expr -> atom trailer_expr
584
|
atom_expr -> atom trailer_expr
584
+
atom_expr -> atom trailer_expr
584
-
atom_expr -> atom trailer_expr
584
in
atom_expr -> atom trailer_expr
584
,
atom_expr -> atom trailer_expr
584
<<
atom_expr -> atom trailer_expr
584
%
atom_expr -> atom trailer_expr
584
//
atom_expr -> atom trailer_expr
585
)
1151
586
@
atom -> ( )
586
>>
atom -> ( )
586
^
atom -> ( )
586
**
atom -> ( )
586
/
atom -> ( )
586
&
atom -> ( )
586
(
atom -> ( )
586
+
atom -> ( )
586
in
atom -> ( )
586
[
atom -> ( )
586
-
atom -> ( )
586
.
atom -> ( )
586
%
atom -> ( )
586
,
atom -> ( )
586
//
atom -> ( )
586
*
atom -> ( )
586
<<
atom -> ( )
586
|
atom -> ( )
587
^
factor -> + factor
587
*
factor -> + factor
587
@
factor -> + factor
587
in
factor -> + factor
587
|
factor -> + factor
587
%
factor -> + factor
587
/
factor -> + factor
587
&
factor -> + factor
587
//
factor -> + factor
587
+
factor -> + factor
587
<<
factor -> + factor
587
-
factor -> + factor
587
>>
factor -> + factor
587
,
factor -> + factor
588
[
208
588
{
209
588
factor
210
588
True
212
588
~
213
588
atom
217
588
STRING
218
588
power
219
588
NAME
220
588
(
221
588
+
222
588
term
223
588
None
224
588
False
225
588
atom_expr
226
588
-
227
588
NUMBER
229
588
arith_expr
1152
589
[
208
589
{
209
589
factor
210
589
True
212
589
~
213
589
atom
217
589
STRING
218
589
power
219
589
arith_expr
1153
589
NAME
220
589
(
221
589
+
222
589
term
223
589
None
224
589
False
225
589
atom_expr
226
589
-
227
589
NUMBER
229
590
[
208
590
{
209
590
True
212
590
~
213
590
atom
217
590
STRING
218
590
power
219
590
NAME
220
590
(
221
590
+
222
590
None
224
590
False
225
590
atom_expr
226
590
-
227
590
NUMBER
229
590
factor
1154
591
%
factor -> - factor
591
/
factor -> - factor
591
*
factor -> - factor
591
@
factor -> - factor
591
in
factor -> - factor
591
^
factor -> - factor
591
>>
factor -> - factor
591
&
factor -> - factor
591
|
factor -> - factor
591
<<
factor -> - factor
591
//
factor -> - factor
591
+
factor -> - factor
591
-
factor -> - factor
591
,
factor -> - factor
592
[
208
592
{
209
592
factor
210
592
True
212
592
~
213
592
and_expr
214
592
arith_expr
215
592
shift_expr
216
592
atom
217
592
STRING
218
592
power
219
592
NAME
220
592
(
221
592
+
222
592
term
223
592
None
224
592
False
225
592
atom_expr
226
592
-
227
592
expr
228
592
NUMBER
229
592
xor_expr
230
592
expr_list
1155
593
[
208
593
{
209
593
factor
210
593
True
212
593
~
213
593
and_expr
214
593
arith_expr
215
593
shift_expr
216
593
atom
217
593
STRING
218
593
power
219
593
expr
1156
593
NAME
220
593
(
221
593
+
222
593
term
223
593
None
224
593
False
225
593
atom_expr
226
593
-
227
593
NUMBER
229
593
xor_expr
230
594
@=
lambdef -> lambda : test
594
//=
lambdef -> lambda : test
594
*=
lambdef -> lambda : test
594
+=
lambdef -> lambda : test
594
,
lambdef -> lambda : test
594
:
lambdef -> lambda : test
594
**=
lambdef -> lambda : test
594
^=
lambdef -> lambda : test
594
NEWLINE
lambdef -> lambda : test
594
>>=
lambdef -> lambda : test
594
=
lambdef -> lambda : test
594
%=
lambdef -> lambda : test
594
|=
lambdef -> lambda : test
594
-=
lambdef -> lambda : test
594
/=
lambdef -> lambda : test
594
<<=
lambdef -> lambda : test
594
&=
lambdef -> lambda : test
595
arith_expr
1
595
factor
17
595
True
38
595
atom_expr
31
595
term
22
595
-
26
595
None
55
595
atom
57
595
comparison
49
595
and_expr
8
595
power
9
595
STRING
10
595
NAME
52
595
shift_expr
48
595
lambdef
15
595
NUMBER
58
595
(
16
595
expr
47
595
[
18
595
not_test
32
595
{
21
595
and_test
46
595
+
27
595
lambda
29
595
xor_expr
41
595
not
62
595
~
37
595
or_test
53
595
False
39
595
test
1157
596
varargslist
1158
596
vfpdef
234
596
NAME
233
597
:
power -> atom_expr ** factor
597
!=
power -> atom_expr ** factor
597
@
power -> atom_expr ** factor
597
%=
power -> atom_expr ** factor
597
|
power -> atom_expr ** factor
597
^=
power -> atom_expr ** factor
597
in
power -> atom_expr ** factor
597
==
power -> atom_expr ** factor
597
&=
power -> atom_expr ** factor
597
if
power -> atom_expr ** factor
597
NEWLINE
power -> atom_expr ** factor
597
**=
power -> atom_expr ** factor
597
and
power -> atom_expr ** factor
597
<<=
power -> atom_expr ** factor
597
=
power -> atom_expr ** factor
597
@=
power -> atom_expr ** factor
597
|=
power -> atom_expr ** factor
597
>=
power -> atom_expr ** factor
597
/
power -> atom_expr ** factor
597
not
power -> atom_expr ** factor
597
-=
power -> atom_expr ** factor
597
^
power -> atom_expr ** factor
597
//
power -> atom_expr ** factor
597
>>=
power -> atom_expr ** factor
597
//=
power -> atom_expr ** factor
597
>
power -> atom_expr ** factor
597
+
power -> atom_expr ** factor
597
%
power -> atom_expr ** factor
597
-
power -> atom_expr ** factor
597
is
power -> atom_expr ** factor
597
<=
power -> atom_expr ** factor
597
<
power -> atom_expr ** factor
597
,
power -> atom_expr ** factor
597
*
power -> atom_expr ** factor
597
/=
power -> atom_expr ** factor
597
<<
power -> atom_expr ** factor
597
+=
power -> atom_expr ** factor
597
or
power -> atom_expr ** factor
597
*=
power -> atom_expr ** factor
597
>>
power -> atom_expr ** factor
597
&
power -> atom_expr ** factor
598
@=
and_test -> not_test and and_test
598
//=
and_test -> not_test and and_test
598
^=
and_test -> not_test and and_test
598
*=
and_test -> not_test and and_test
598
-=
and_test -> not_test and and_test
598
NEWLINE
and_test -> not_test and and_test
598
or
and_test -> not_test and and_test
598
<<=
and_test -> not_test and and_test
598
**=
and_test -> not_test and and_test
598
=
and_test -> not_test and and_test
598
/=
and_test -> not_test and and_test
598
&=
and_test -> not_test and and_test
598
:
and_test -> not_test and and_test
598
+=
and_test -> not_test and and_test
598
>>=
and_test -> not_test and and_test
598
|=
and_test -> not_test and and_test
598
%=
and_test -> not_test and and_test
598
if
and_test -> not_test and and_test
598
,
and_test -> not_test and and_test
599
^
atom -> [ ]
599
(
atom -> [ ]
599
>>
atom -> [ ]
599
-
atom -> [ ]
599
+
atom -> [ ]
599
,
atom -> [ ]
599
|
atom -> [ ]
599
NEWLINE
atom -> [ ]
599
[
atom -> [ ]
599
*
atom -> [ ]
599
<<
atom -> [ ]
599
@
atom -> [ ]
599
.
atom -> [ ]
599
%
atom -> [ ]
599
/
atom -> [ ]
599
**
atom -> [ ]
599
//
atom -> [ ]
599
&
atom -> [ ]
600
]
1159
601
/
atom -> { }
601
@
atom -> { }
601
|
atom -> { }
601
**
atom -> { }
601
,
atom -> { }
601
*
atom -> { }
601
%
atom -> { }
601
^
atom -> { }
601
NEWLINE
atom -> { }
601
//
atom -> { }
601
>>
atom -> { }
601
(
atom -> { }
601
&
atom -> { }
601
.
atom -> { }
601
[
atom -> { }
601
-
atom -> { }
601
<<
atom -> { }
601
+
atom -> { }
602
[
239
602
{
240
602
factor
241
602
True
242
602
~
243
602
None
245
602
atom
248
602
STRING
249
602
power
250
602
NAME
251
602
(
252
602
NUMBER
253
602
+
254
602
False
256
602
atom_expr
257
602
-
258
602
term
1160
603
[
239
603
{
240
603
factor
241
603
True
242
603
~
243
603
None
245
603
atom
248
603
STRING
249
603
power
250
603
NAME
251
603
(
252
603
NUMBER
253
603
+
254
603
term
1161
603
False
256
603
atom_expr
257
603
-
258
604
[
239
604
{
240
604
factor
241
604
True
242
604
~
243
604
None
245
604
atom
248
604
STRING
249
604
power
250
604
NAME
251
604
(
252
604
term
1162
604
NUMBER
253
604
+
254
604
False
256
604
atom_expr
257
604
-
258
605
[
239
605
{
240
605
factor
241
605
True
242
605
~
243
605
None
245
605
atom
248
605
STRING
249
605
power
250
605
NAME
251
605
(
252
605
NUMBER
253
605
+
254
605
False
256
605
atom_expr
257
605
-
258
605
term
1163
606
[
239
606
{
240
606
factor
241
606
True
242
606
~
243
606
None
245
606
atom
248
606
STRING
249
606
power
250
606
NAME
251
606
(
252
606
term
1164
606
NUMBER
253
606
+
254
606
False
256
606
atom_expr
257
606
-
258
607
<<
factor -> ~ factor
607
-
factor -> ~ factor
607
@
factor -> ~ factor
607
,
factor -> ~ factor
607
|
factor -> ~ factor
607
*
factor -> ~ factor
607
NEWLINE
factor -> ~ factor
607
&
factor -> ~ factor
607
>>
factor -> ~ factor
607
//
factor -> ~ factor
607
%
factor -> ~ factor
607
/
factor -> ~ factor
607
^
factor -> ~ factor
607
+
factor -> ~ factor
608
[
239
608
{
240
608
factor
241
608
True
242
608
~
243
608
and_expr
244
608
None
245
608
arith_expr
246
608
shift_expr
247
608
atom
248
608
STRING
249
608
power
250
608
NAME
251
608
(
252
608
NUMBER
253
608
+
254
608
term
255
608
False
256
608
atom_expr
257
608
-
258
608
xor_expr
1165
609
[
239
609
{
240
609
factor
241
609
True
242
609
~
243
609
None
245
609
arith_expr
246
609
atom
248
609
STRING
249
609
power
250
609
NAME
251
609
(
252
609
NUMBER
253
609
+
254
609
term
255
609
False
256
609
atom_expr
257
609
-
258
609
shift_expr
1166
610
[
239
610
{
240
610
factor
241
610
True
242
610
~
243
610
None
245
610
arith_expr
246
610
atom
248
610
STRING
249
610
power
250
610
NAME
251
610
(
252
610
NUMBER
253
610
+
254
610
term
255
610
False
256
610
atom_expr
257
610
shift_expr
1167
610
-
258
611
[
239
611
{
240
611
factor
241
611
True
242
611
~
243
611
None
245
611
arith_expr
246
611
shift_expr
247
611
atom
248
611
STRING
249
611
power
250
611
NAME
251
611
(
252
611
NUMBER
253
611
+
254
611
term
255
611
False
256
611
atom_expr
257
611
-
258
611
and_expr
1168
612
[
766
612
factor
767
612
True
768
612
atom_expr
769
612
~
770
612
and_expr
771
612
-
772
612
{
773
612
shift_expr
774
612
atom
775
612
comparison
776
612
and_test
777
612
arith_expr
778
612
power
779
612
STRING
780
612
NAME
781
612
(
782
612
term
784
612
+
785
612
xor_expr
786
612
)
1169
612
or_test
788
612
arglist
1170
612
NUMBER
789
612
not
790
612
False
791
612
expr
792
612
*
793
612
not_test
794
612
None
795
612
lambdef
796
612
lambda
797
612
test
798
612
argument
799
612
**
800
613
[
802
613
factor
803
613
True
804
613
atom_expr
810
613
~
806
613
not
807
613
and_expr
808
613
-
809
613
shift_expr
811
613
atom
812
613
{
813
613
comparison
814
613
or_test
815
613
(
816
613
arith_expr
817
613
power
818
613
STRING
819
613
NAME
820
613
and_test
821
613
subscriptlist
1171
613
term
822
613
+
823
613
xor_expr
824
613
test
825
613
NUMBER
826
613
False
827
613
subscript
828
613
expr
829
613
not_test
830
613
None
831
613
lambdef
832
613
lambda
833
613
maybe_test
834
613
:
maybe_test -> 
614
trailer_expr
1172
614
>>
trailer_expr -> 
614
(
612
614
[
613
614
trailer
614
614
.
615
614
+
trailer_expr -> 
614
<<
trailer_expr -> 
614
|
trailer_expr -> 
614
NEWLINE
trailer_expr -> 
614
//
trailer_expr -> 
614
%
trailer_expr -> 
614
,
trailer_expr -> 
614
&
trailer_expr -> 
614
/
trailer_expr -> 
614
@
trailer_expr -> 
614
**
trailer_expr -> 
614
-
trailer_expr -> 
614
^
trailer_expr -> 
614
*
trailer_expr -> 
615
NAME
1173
616
**
atom_expr -> atom trailer_expr
616
>>
atom_expr -> atom trailer_expr
616
*
atom_expr -> atom trailer_expr
616
^
atom_expr -> atom trailer_expr
616
NEWLINE
atom_expr -> atom trailer_expr
616
@
atom_expr -> atom trailer_expr
616
/
atom_expr -> atom trailer_expr
616
&
atom_expr -> atom trailer_expr
616
|
atom_expr -> atom trailer_expr
616
+
atom_expr -> atom trailer_expr
616
-
atom_expr -> atom trailer_expr
616
,
atom_expr -> atom trailer_expr
616
<<
atom_expr -> atom trailer_expr
616
%
atom_expr -> atom trailer_expr
616
//
atom_expr -> atom trailer_expr
617
)
1174
618
NEWLINE
atom -> ( )
618
@
atom -> ( )
618
>>
atom -> ( )
618
^
atom -> ( )
618
**
atom -> ( )
618
/
atom -> ( )
618
&
atom -> ( )
618
(
atom -> ( )
618
+
atom -> ( )
618
[
atom -> ( )
618
-
atom -> ( )
618
.
atom -> ( )
618
%
atom -> ( )
618
,
atom -> ( )
618
//
atom -> ( )
618
*
atom -> ( )
618
<<
atom -> ( )
618
|
atom -> ( )
619
^
factor -> + factor
619
*
factor -> + factor
619
@
factor -> + factor
619
|
factor -> + factor
619
%
factor -> + factor
619
/
factor -> + factor
619
&
factor -> + factor
619
//
factor -> + factor
619
+
factor -> + factor
619
<<
factor -> + factor
619
NEWLINE
factor -> + factor
619
-
factor -> + factor
619
>>
factor -> + factor
619
,
factor -> + factor
620
[
239
620
{
240
620
factor
241
620
True
242
620
~
243
620
None
245
620
atom
248
620
STRING
249
620
power
250
620
NAME
251
620
(
252
620
NUMBER
253
620
+
254
620
term
255
620
False
256
620
atom_expr
257
620
-
258
620
arith_expr
1175
621
[
239
621
{
240
621
factor
241
621
True
242
621
~
243
621
None
245
621
atom
248
621
STRING
249
621
power
250
621
arith_expr
1176
621
NAME
251
621
(
252
621
NUMBER
253
621
+
254
621
term
255
621
False
256
621
atom_expr
257
621
-
258
622
[
239
622
{
240
622
True
242
622
~
243
622
None
245
622
atom
248
622
STRING
249
622
power
250
622
NAME
251
622
(
252
622
NUMBER
253
622
+
254
622
False
256
622
atom_expr
257
622
-
258
622
factor
1177
623
%
factor -> - factor
623
/
factor -> - factor
623
*
factor -> - factor
623
@
factor -> - factor
623
NEWLINE
factor -> - factor
623
^
factor -> - factor
623
>>
factor -> - factor
623
&
factor -> - factor
623
|
factor -> - factor
623
<<
factor -> - factor
623
//
factor -> - factor
623
+
factor -> - factor
623
-
factor -> - factor
623
,
factor -> - factor
624
[
239
624
{
240
624
factor
241
624
True
242
624
~
243
624
and_expr
244
624
None
245
624
arith_expr
246
624
shift_expr
247
624
atom
248
624
STRING
249
624
power
250
624
NAME
251
624
(
252
624
NUMBER
253
624
+
254
624
term
255
624
False
256
624
atom_expr
257
624
-
258
624
expr
1178
624
xor_expr
260
625
[
239
625
{
240
625
factor
241
625
True
242
625
~
243
625
and_expr
244
625
None
245
625
arith_expr
246
625
shift_expr
247
625
atom
248
625
STRING
249
625
power
250
625
NAME
251
625
(
252
625
expr_list
1179
625
NUMBER
253
625
+
254
625
term
255
625
False
256
625
atom_expr
257
625
-
258
625
xor_expr
260
625
expr
261
626
NAME
1180
627
NEWLINE
1181
628
[
334
628
factor
335
628
True
336
628
atom_expr
337
628
~
338
628
and_expr
339
628
-
340
628
None
341
628
shift_expr
342
628
atom
343
628
{
344
628
comparison
345
628
arith_expr
346
628
power
347
628
STRING
348
628
NAME
349
628
(
350
628
NUMBER
351
628
and_test
352
628
term
353
628
+
354
628
xor_expr
355
628
not
356
628
False
357
628
lambda
358
628
test_list
1182
628
NEWLINE
yield_expr -> yield
628
not_test
359
628
lambdef
361
628
expr
362
628
yield_arg
1183
628
or_test
363
628
test
364
628
from
1184
629
NEWLINE
yield_or_testlist -> yield_expr
630
NEWLINE
expr_stmt -> test_list augassign yield_or_testlist
631
NEWLINE
yield_or_testlist -> test_list
632
[
166
632
factor
167
632
True
168
632
atom_expr
169
632
~
170
632
not
171
632
and_expr
172
632
-
173
632
{
174
632
shift_expr
175
632
atom
176
632
]
1185
632
comparison
178
632
(
179
632
arith_expr
180
632
power
181
632
STRING
182
632
NAME
183
632
test
184
632
and_test
185
632
term
186
632
+
187
632
xor_expr
188
632
NUMBER
190
632
test_list_comp
1186
632
False
191
632
expr
192
632
not_test
193
632
None
194
632
lambdef
195
632
lambda
196
632
or_test
197
632
test_list
198
633
not
term -> factor
633
@
1187
633
%
1188
633
/
1189
633
*
1190
633
//
1191
633
<=
term -> factor
633
NEWLINE
term -> factor
633
>
term -> factor
633
==
term -> factor
633
is
term -> factor
633
or
term -> factor
633
<
term -> factor
633
and
term -> factor
633
<<
term -> factor
633
^
term -> factor
633
!=
term -> factor
633
-
term -> factor
633
&
term -> factor
633
|
term -> factor
633
,
term -> factor
633
>=
term -> factor
633
if
term -> factor
633
=
term -> factor
633
+
term -> factor
633
in
term -> factor
633
>>
term -> factor
634
<<
atom -> True
634
&
atom -> True
634
or
atom -> True
634
[
atom -> True
634
if
atom -> True
634
NEWLINE
atom -> True
634
-
atom -> True
634
*
atom -> True
634
^
atom -> True
634
,
atom -> True
634
>=
atom -> True
634
!=
atom -> True
634
=
atom -> True
634
(
atom -> True
634
not
atom -> True
634
|
atom -> True
634
+
atom -> True
634
**
atom -> True
634
.
atom -> True
634
is
atom -> True
634
//
atom -> True
634
>
atom -> True
634
%
atom -> True
634
in
atom -> True
634
<=
atom -> True
634
>>
atom -> True
634
/
atom -> True
634
==
atom -> True
634
and
atom -> True
634
<
atom -> True
634
@
atom -> True
635
=
power -> atom_expr
635
**
1192
635
,
power -> atom_expr
635
!=
power -> atom_expr
635
-
power -> atom_expr
635
<<
power -> atom_expr
635
not
power -> atom_expr
635
/
power -> atom_expr
635
<=
power -> atom_expr
635
in
power -> atom_expr
635
%
power -> atom_expr
635
>
power -> atom_expr
635
@
power -> atom_expr
635
|
power -> atom_expr
635
NEWLINE
power -> atom_expr
635
<
power -> atom_expr
635
>>
power -> atom_expr
635
or
power -> atom_expr
635
and
power -> atom_expr
635
>=
power -> atom_expr
635
==
power -> atom_expr
635
^
power -> atom_expr
635
*
power -> atom_expr
635
&
power -> atom_expr
635
is
power -> atom_expr
635
+
power -> atom_expr
635
if
power -> atom_expr
635
//
power -> atom_expr
636
[
632
636
True
634
636
atom_expr
635
636
-
638
636
~
636
636
None
639
636
atom
641
636
{
642
636
power
646
636
STRING
647
636
NAME
648
636
(
649
636
NUMBER
650
636
+
652
636
False
657
636
factor
1193
637
NEWLINE
xor_expr -> and_expr
637
>
xor_expr -> and_expr
637
<=
xor_expr -> and_expr
637
not
xor_expr -> and_expr
637
|
xor_expr -> and_expr
637
^
1194
637
==
xor_expr -> and_expr
637
,
xor_expr -> and_expr
637
in
xor_expr -> and_expr
637
!=
xor_expr -> and_expr
637
if
xor_expr -> and_expr
637
is
xor_expr -> and_expr
637
<
xor_expr -> and_expr
637
or
xor_expr -> and_expr
637
=
xor_expr -> and_expr
637
and
xor_expr -> and_expr
637
>=
xor_expr -> and_expr
638
[
632
638
True
634
638
atom_expr
635
638
~
636
638
-
638
638
None
639
638
atom
641
638
{
642
638
power
646
638
STRING
647
638
NAME
648
638
(
649
638
NUMBER
650
638
factor
1195
638
+
652
638
False
657
639
@
atom -> None
639
NEWLINE
atom -> None
639
<=
atom -> None
639
in
atom -> None
639
and
atom -> None
639
&
atom -> None
639
|
atom -> None
639
>
atom -> None
639
>=
atom -> None
639
/
atom -> None
639
<<
atom -> None
639
-
atom -> None
639
!=
atom -> None
639
**
atom -> None
639
(
atom -> None
639
*
atom -> None
639
=
atom -> None
639
.
atom -> None
639
>>
atom -> None
639
==
atom -> None
639
is
atom -> None
639
<
atom -> None
639
if
atom -> None
639
^
atom -> None
639
[
atom -> None
639
%
atom -> None
639
+
atom -> None
639
not
atom -> None
639
,
atom -> None
639
or
atom -> None
639
//
atom -> None
640
^
and_expr -> shift_expr
640
in
and_expr -> shift_expr
640
|
and_expr -> shift_expr
640
&
1196
640
<
and_expr -> shift_expr
640
not
and_expr -> shift_expr
640
>=
and_expr -> shift_expr
640
<=
and_expr -> shift_expr
640
or
and_expr -> shift_expr
640
and
and_expr -> shift_expr
640
,
and_expr -> shift_expr
640
!=
and_expr -> shift_expr
640
if
and_expr -> shift_expr
640
is
and_expr -> shift_expr
640
==
and_expr -> shift_expr
640
NEWLINE
and_expr -> shift_expr
640
>
and_expr -> shift_expr
640
=
and_expr -> shift_expr
641
>>
trailer_expr -> 
641
(
1197
641
trailer
1198
641
trailer_expr
1199
641
.
1200
641
+
trailer_expr -> 
641
[
1201
641
is
trailer_expr -> 
641
>
trailer_expr -> 
641
not
trailer_expr -> 
641
|
trailer_expr -> 
641
NEWLINE
trailer_expr -> 
641
=
trailer_expr -> 
641
&
trailer_expr -> 
641
/
trailer_expr -> 
641
@
trailer_expr -> 
641
!=
trailer_expr -> 
641
**
trailer_expr -> 
641
>=
trailer_expr -> 
641
^
trailer_expr -> 
641
in
trailer_expr -> 
641
<<
trailer_expr -> 
641
and
trailer_expr -> 
641
or
trailer_expr -> 
641
if
trailer_expr -> 
641
//
trailer_expr -> 
641
%
trailer_expr -> 
641
,
trailer_expr -> 
641
<=
trailer_expr -> 
641
<
trailer_expr -> 
641
==
trailer_expr -> 
641
-
trailer_expr -> 
641
*
trailer_expr -> 
642
}
1202
643
or
not_test -> comparison
643
NEWLINE
not_test -> comparison
643
,
not_test -> comparison
643
=
not_test -> comparison
643
and
not_test -> comparison
643
if
not_test -> comparison
644
=
or_test -> and_test
644
or
1203
644
,
or_test -> and_test
644
if
or_test -> and_test
644
NEWLINE
or_test -> and_test
645
>>
1204
645
if
shift_expr -> arith_expr
645
&
shift_expr -> arith_expr
645
<<
1205
645
|
shift_expr -> arith_expr
645
is
shift_expr -> arith_expr
645
<
shift_expr -> arith_expr
645
==
shift_expr -> arith_expr
645
=
shift_expr -> arith_expr
645
NEWLINE
shift_expr -> arith_expr
645
or
shift_expr -> arith_expr
645
>
shift_expr -> arith_expr
645
!=
shift_expr -> arith_expr
645
>=
shift_expr -> arith_expr
645
in
shift_expr -> arith_expr
645
,
shift_expr -> arith_expr
645
<=
shift_expr -> arith_expr
645
and
shift_expr -> arith_expr
645
^
shift_expr -> arith_expr
645
not
shift_expr -> arith_expr
646
+
factor -> power
646
%
factor -> power
646
=
factor -> power
646
,
factor -> power
646
<
factor -> power
646
<<
factor -> power
646
!=
factor -> power
646
<=
factor -> power
646
and
factor -> power
646
/
factor -> power
646
^
factor -> power
646
@
factor -> power
646
>=
factor -> power
646
not
factor -> power
646
//
factor -> power
646
or
factor -> power
646
==
factor -> power
646
is
factor -> power
646
|
factor -> power
646
NEWLINE
factor -> power
646
*
factor -> power
646
-
factor -> power
646
if
factor -> power
646
>
factor -> power
646
in
factor -> power
646
>>
factor -> power
646
&
factor -> power
647
%
atom -> STRING
647
>
atom -> STRING
647
@
atom -> STRING
647
<<
atom -> STRING
647
in
atom -> STRING
647
[
atom -> STRING
647
-
atom -> STRING
647
==
atom -> STRING
647
>=
atom -> STRING
647
not
atom -> STRING
647
/
atom -> STRING
647
+
atom -> STRING
647
=
atom -> STRING
647
NEWLINE
atom -> STRING
647
*
atom -> STRING
647
(
atom -> STRING
647
//
atom -> STRING
647
if
atom -> STRING
647
.
atom -> STRING
647
<
atom -> STRING
647
,
atom -> STRING
647
&
atom -> STRING
647
<=
atom -> STRING
647
!=
atom -> STRING
647
**
atom -> STRING
647
^
atom -> STRING
647
and
atom -> STRING
647
is
atom -> STRING
647
|
atom -> STRING
647
or
atom -> STRING
647
>>
atom -> STRING
648
<
atom -> NAME
648
,
atom -> NAME
648
^
atom -> NAME
648
+
atom -> NAME
648
-
atom -> NAME
648
>=
atom -> NAME
648
@
atom -> NAME
648
!=
atom -> NAME
648
*
atom -> NAME
648
=
atom -> NAME
648
<=
atom -> NAME
648
**
atom -> NAME
648
or
atom -> NAME
648
NEWLINE
atom -> NAME
648
not
atom -> NAME
648
==
atom -> NAME
648
&
atom -> NAME
648
>
atom -> NAME
648
>>
atom -> NAME
648
%
atom -> NAME
648
.
atom -> NAME
648
|
atom -> NAME
648
is
atom -> NAME
648
and
atom -> NAME
648
//
atom -> NAME
648
[
atom -> NAME
648
/
atom -> NAME
648
(
atom -> NAME
648
<<
atom -> NAME
648
if
atom -> NAME
648
in
atom -> NAME
649
[
128
649
factor
129
649
True
130
649
atom_expr
131
649
~
132
649
and_expr
133
649
-
134
649
{
135
649
test_list_comp
1206
649
shift_expr
137
649
atom
138
649
)
1207
649
comparison
140
649
arith_expr
141
649
power
142
649
STRING
143
649
NAME
144
649
(
145
649
and_test
146
649
term
147
649
+
148
649
xor_expr
149
649
or_test
150
649
NUMBER
151
649
not
152
649
False
153
649
expr
154
649
not_test
155
649
None
156
649
lambdef
157
649
lambda
158
649
test
159
649
test_list
160
650
+
atom -> NUMBER
650
*
atom -> NUMBER
650
>
atom -> NUMBER
650
<<
atom -> NUMBER
650
-
atom -> NUMBER
650
**
atom -> NUMBER
650
if
atom -> NUMBER
650
or
atom -> NUMBER
650
is
atom -> NUMBER
650
=
atom -> NUMBER
650
[
atom -> NUMBER
650
(
atom -> NUMBER
650
not
atom -> NUMBER
650
&
atom -> NUMBER
650
^
atom -> NUMBER
650
in
atom -> NUMBER
650
==
atom -> NUMBER
650
//
atom -> NUMBER
650
!=
atom -> NUMBER
650
and
atom -> NUMBER
650
NEWLINE
atom -> NUMBER
650
%
atom -> NUMBER
650
<=
atom -> NUMBER
650
.
atom -> NUMBER
650
<
atom -> NUMBER
650
>>
atom -> NUMBER
650
,
atom -> NUMBER
650
/
atom -> NUMBER
650
@
atom -> NUMBER
650
>=
atom -> NUMBER
650
|
atom -> NUMBER
651
-
1208
651
+
1209
651
|
arith_expr -> term
651
>=
arith_expr -> term
651
<=
arith_expr -> term
651
not
arith_expr -> term
651
,
arith_expr -> term
651
==
arith_expr -> term
651
in
arith_expr -> term
651
>>
arith_expr -> term
651
is
arith_expr -> term
651
if
arith_expr -> term
651
or
arith_expr -> term
651
!=
arith_expr -> term
651
>
arith_expr -> term
651
=
arith_expr -> term
651
and
arith_expr -> term
651
<<
arith_expr -> term
651
<
arith_expr -> term
651
^
arith_expr -> term
651
NEWLINE
arith_expr -> term
651
&
arith_expr -> term
652
[
632
652
True
634
652
atom_expr
635
652
-
638
652
~
636
652
None
639
652
atom
641
652
{
642
652
power
646
652
STRING
647
652
NAME
648
652
(
649
652
NUMBER
650
652
factor
1210
652
+
652
652
False
657
653
[
632
653
factor
633
653
True
634
653
atom_expr
635
653
~
636
653
and_expr
637
653
-
638
653
None
639
653
shift_expr
640
653
atom
641
653
{
642
653
comparison
643
653
and_test
644
653
arith_expr
645
653
power
646
653
STRING
647
653
NAME
648
653
(
649
653
NUMBER
650
653
term
651
653
+
652
653
xor_expr
654
653
test
655
653
not
656
653
False
657
653
lambda
658
653
test_list
1211
653
NEWLINE
yield_expr -> yield
653
not_test
659
653
or_test
661
653
lambdef
662
653
expr
663
653
yield_arg
1212
653
=
yield_expr -> yield
653
from
1213
654
|
1214
654
>
expr -> xor_expr
654
if
expr -> xor_expr
654
NEWLINE
expr -> xor_expr
654
is
expr -> xor_expr
654
and
expr -> xor_expr
654
=
expr -> xor_expr
654
not
expr -> xor_expr
654
or
expr -> xor_expr
654
>=
expr -> xor_expr
654
==
expr -> xor_expr
654
,
expr -> xor_expr
654
<
expr -> xor_expr
654
!=
expr -> xor_expr
654
<=
expr -> xor_expr
654
in
expr -> xor_expr
655
NEWLINE
test_list -> test
655
,
1215
655
=
test_list -> test
656
[
632
656
factor
633
656
True
634
656
atom_expr
635
656
~
636
656
and_expr
637
656
-
638
656
None
639
656
shift_expr
640
656
atom
641
656
{
642
656
comparison
643
656
arith_expr
645
656
power
646
656
STRING
647
656
NAME
648
656
(
649
656
NUMBER
650
656
term
651
656
+
652
656
xor_expr
654
656
not
656
656
False
657
656
not_test
1216
656
expr
663
657
(
atom -> False
657
*
atom -> False
657
==
atom -> False
657
|
atom -> False
657
,
atom -> False
657
[
atom -> False
657
in
atom -> False
657
&
atom -> False
657
=
atom -> False
657
NEWLINE
atom -> False
657
not
atom -> False
657
is
atom -> False
657
if
atom -> False
657
^
atom -> False
657
+
atom -> False
657
>
atom -> False
657
<=
atom -> False
657
<<
atom -> False
657
<
atom -> False
657
>=
atom -> False
657
%
atom -> False
657
@
atom -> False
657
and
atom -> False
657
!=
atom -> False
657
-
atom -> False
657
.
atom -> False
657
//
atom -> False
657
/
atom -> False
657
**
atom -> False
657
>>
atom -> False
657
or
atom -> False
658
vfpdef
234
658
varargslist
1217
658
:
1218
658
NAME
233
659
and
1219
659
,
and_test -> not_test
659
NEWLINE
and_test -> not_test
659
if
and_test -> not_test
659
or
and_test -> not_test
659
=
and_test -> not_test
660
=
276
660
assign
1220
660
NEWLINE
assign -> 
661
NEWLINE
test -> or_test
661
=
test -> or_test
661
if
1221
661
,
test -> or_test
662
=
test -> lambdef
662
NEWLINE
test -> lambdef
662
,
test -> lambdef
663
>
317
663
is
318
663
in
319
663
<=
320
663
<
321
663
>=
322
663
NEWLINE
comparison -> expr
663
!=
324
663
not
325
663
==
326
663
comp_op
1222
663
=
comparison -> expr
663
or
comparison -> expr
663
if
comparison -> expr
663
and
comparison -> expr
663
,
comparison -> expr
664
=
276
664
NEWLINE
assign -> 
664
assign
1223
665
[
166
665
factor
167
665
True
168
665
atom_expr
169
665
~
170
665
not
171
665
and_expr
172
665
-
173
665
{
174
665
shift_expr
175
665
atom
176
665
]
1224
665
comparison
178
665
(
179
665
arith_expr
180
665
power
181
665
STRING
182
665
NAME
183
665
test
184
665
and_test
185
665
term
186
665
+
187
665
xor_expr
188
665
NUMBER
190
665
test_list_comp
1225
665
False
191
665
expr
192
665
not_test
193
665
None
194
665
lambdef
195
665
lambda
196
665
or_test
197
665
test_list
198
666
not
term -> factor
666
@
1226
666
%
1227
666
/
1228
666
*
1229
666
//
1230
666
<=
term -> factor
666
>
term -> factor
666
==
term -> factor
666
is
term -> factor
666
or
term -> factor
666
<
term -> factor
666
and
term -> factor
666
<<
term -> factor
666
^
term -> factor
666
!=
term -> factor
666
-
term -> factor
666
&
term -> factor
666
|
term -> factor
666
>=
term -> factor
666
if
term -> factor
666
=
term -> factor
666
+
term -> factor
666
in
term -> factor
666
>>
term -> factor
667
<<
atom -> True
667
&
atom -> True
667
or
atom -> True
667
[
atom -> True
667
if
atom -> True
667
-
atom -> True
667
*
atom -> True
667
^
atom -> True
667
>=
atom -> True
667
!=
atom -> True
667
=
atom -> True
667
(
atom -> True
667
not
atom -> True
667
|
atom -> True
667
+
atom -> True
667
**
atom -> True
667
.
atom -> True
667
is
atom -> True
667
//
atom -> True
667
>
atom -> True
667
%
atom -> True
667
in
atom -> True
667
<=
atom -> True
667
>>
atom -> True
667
/
atom -> True
667
==
atom -> True
667
and
atom -> True
667
<
atom -> True
667
@
atom -> True
668
=
power -> atom_expr
668
**
1231
668
!=
power -> atom_expr
668
-
power -> atom_expr
668
<<
power -> atom_expr
668
not
power -> atom_expr
668
/
power -> atom_expr
668
<=
power -> atom_expr
668
in
power -> atom_expr
668
%
power -> atom_expr
668
>
power -> atom_expr
668
@
power -> atom_expr
668
|
power -> atom_expr
668
<
power -> atom_expr
668
>>
power -> atom_expr
668
or
power -> atom_expr
668
and
power -> atom_expr
668
>=
power -> atom_expr
668
==
power -> atom_expr
668
^
power -> atom_expr
668
*
power -> atom_expr
668
&
power -> atom_expr
668
is
power -> atom_expr
668
+
power -> atom_expr
668
if
power -> atom_expr
668
//
power -> atom_expr
669
[
665
669
True
667
669
atom_expr
668
669
-
671
669
~
669
669
atom
672
669
{
673
669
power
676
669
STRING
677
669
NAME
678
669
(
679
669
+
681
669
NUMBER
684
669
False
687
669
factor
1232
669
None
690
670
>
xor_expr -> and_expr
670
<=
xor_expr -> and_expr
670
not
xor_expr -> and_expr
670
|
xor_expr -> and_expr
670
^
1233
670
==
xor_expr -> and_expr
670
in
xor_expr -> and_expr
670
!=
xor_expr -> and_expr
670
if
xor_expr -> and_expr
670
is
xor_expr -> and_expr
670
<
xor_expr -> and_expr
670
or
xor_expr -> and_expr
670
=
xor_expr -> and_expr
670
and
xor_expr -> and_expr
670
>=
xor_expr -> and_expr
671
[
665
671
True
667
671
atom_expr
668
671
~
669
671
-
671
671
atom
672
671
{
673
671
power
676
671
STRING
677
671
NAME
678
671
(
679
671
factor
1234
671
+
681
671
NUMBER
684
671
False
687
671
None
690
672
>>
trailer_expr -> 
672
(
1235
672
trailer
1236
672
trailer_expr
1237
672
.
1238
672
+
trailer_expr -> 
672
[
1239
672
is
trailer_expr -> 
672
>
trailer_expr -> 
672
not
trailer_expr -> 
672
|
trailer_expr -> 
672
=
trailer_expr -> 
672
&
trailer_expr -> 
672
/
trailer_expr -> 
672
@
trailer_expr -> 
672
!=
trailer_expr -> 
672
**
trailer_expr -> 
672
>=
trailer_expr -> 
672
^
trailer_expr -> 
672
in
trailer_expr -> 
672
<<
trailer_expr -> 
672
and
trailer_expr -> 
672
or
trailer_expr -> 
672
if
trailer_expr -> 
672
//
trailer_expr -> 
672
%
trailer_expr -> 
672
<=
trailer_expr -> 
672
<
trailer_expr -> 
672
==
trailer_expr -> 
672
-
trailer_expr -> 
672
*
trailer_expr -> 
673
}
1240
674
=
or_test -> and_test
674
or
1241
674
if
or_test -> and_test
675
>>
1242
675
if
shift_expr -> arith_expr
675
&
shift_expr -> arith_expr
675
<<
1243
675
|
shift_expr -> arith_expr
675
is
shift_expr -> arith_expr
675
<
shift_expr -> arith_expr
675
==
shift_expr -> arith_expr
675
=
shift_expr -> arith_expr
675
or
shift_expr -> arith_expr
675
>
shift_expr -> arith_expr
675
!=
shift_expr -> arith_expr
675
>=
shift_expr -> arith_expr
675
in
shift_expr -> arith_expr
675
<=
shift_expr -> arith_expr
675
and
shift_expr -> arith_expr
675
^
shift_expr -> arith_expr
675
not
shift_expr -> arith_expr
676
+
factor -> power
676
%
factor -> power
676
=
factor -> power
676
<
factor -> power
676
<<
factor -> power
676
!=
factor -> power
676
<=
factor -> power
676
and
factor -> power
676
/
factor -> power
676
^
factor -> power
676
@
factor -> power
676
>=
factor -> power
676
not
factor -> power
676
//
factor -> power
676
or
factor -> power
676
==
factor -> power
676
is
factor -> power
676
|
factor -> power
676
*
factor -> power
676
-
factor -> power
676
if
factor -> power
676
>
factor -> power
676
in
factor -> power
676
>>
factor -> power
676
&
factor -> power
677
%
atom -> STRING
677
>
atom -> STRING
677
@
atom -> STRING
677
<<
atom -> STRING
677
in
atom -> STRING
677
[
atom -> STRING
677
-
atom -> STRING
677
==
atom -> STRING
677
>=
atom -> STRING
677
not
atom -> STRING
677
/
atom -> STRING
677
+
atom -> STRING
677
=
atom -> STRING
677
*
atom -> STRING
677
(
atom -> STRING
677
//
atom -> STRING
677
if
atom -> STRING
677
.
atom -> STRING
677
<
atom -> STRING
677
&
atom -> STRING
677
<=
atom -> STRING
677
!=
atom -> STRING
677
**
atom -> STRING
677
^
atom -> STRING
677
and
atom -> STRING
677
is
atom -> STRING
677
|
atom -> STRING
677
or
atom -> STRING
677
>>
atom -> STRING
678
<
atom -> NAME
678
^
atom -> NAME
678
+
atom -> NAME
678
-
atom -> NAME
678
>=
atom -> NAME
678
@
atom -> NAME
678
!=
atom -> NAME
678
*
atom -> NAME
678
=
atom -> NAME
678
<=
atom -> NAME
678
**
atom -> NAME
678
or
atom -> NAME
678
not
atom -> NAME
678
==
atom -> NAME
678
&
atom -> NAME
678
>
atom -> NAME
678
%
atom -> NAME
678
>>
atom -> NAME
678
.
atom -> NAME
678
|
atom -> NAME
678
is
atom -> NAME
678
and
atom -> NAME
678
//
atom -> NAME
678
[
atom -> NAME
678
/
atom -> NAME
678
(
atom -> NAME
678
<<
atom -> NAME
678
if
atom -> NAME
678
in
atom -> NAME
679
[
128
679
factor
129
679
True
130
679
atom_expr
131
679
~
132
679
and_expr
133
679
-
134
679
{
135
679
test_list_comp
1244
679
shift_expr
137
679
atom
138
679
)
1245
679
comparison
140
679
arith_expr
141
679
power
142
679
STRING
143
679
NAME
144
679
(
145
679
and_test
146
679
term
147
679
+
148
679
xor_expr
149
679
or_test
150
679
NUMBER
151
679
not
152
679
False
153
679
expr
154
679
not_test
155
679
None
156
679
lambdef
157
679
lambda
158
679
test
159
679
test_list
160
680
-
1246
680
+
1247
680
|
arith_expr -> term
680
>=
arith_expr -> term
680
<=
arith_expr -> term
680
not
arith_expr -> term
680
==
arith_expr -> term
680
in
arith_expr -> term
680
>>
arith_expr -> term
680
is
arith_expr -> term
680
if
arith_expr -> term
680
or
arith_expr -> term
680
!=
arith_expr -> term
680
>
arith_expr -> term
680
=
arith_expr -> term
680
and
arith_expr -> term
680
<<
arith_expr -> term
680
<
arith_expr -> term
680
^
arith_expr -> term
680
&
arith_expr -> term
681
[
665
681
True
667
681
atom_expr
668
681
-
671
681
~
669
681
atom
672
681
{
673
681
power
676
681
STRING
677
681
NAME
678
681
(
679
681
factor
1248
681
+
681
681
NUMBER
684
681
False
687
681
None
690
682
|
1249
682
>
expr -> xor_expr
682
if
expr -> xor_expr
682
is
expr -> xor_expr
682
and
expr -> xor_expr
682
=
expr -> xor_expr
682
not
expr -> xor_expr
682
or
expr -> xor_expr
682
>=
expr -> xor_expr
682
==
expr -> xor_expr
682
<
expr -> xor_expr
682
!=
expr -> xor_expr
682
<=
expr -> xor_expr
682
in
expr -> xor_expr
683
^
and_expr -> shift_expr
683
in
and_expr -> shift_expr
683
|
and_expr -> shift_expr
683
&
1250
683
<
and_expr -> shift_expr
683
not
and_expr -> shift_expr
683
>=
and_expr -> shift_expr
683
<=
and_expr -> shift_expr
683
or
and_expr -> shift_expr
683
and
and_expr -> shift_expr
683
!=
and_expr -> shift_expr
683
if
and_expr -> shift_expr
683
is
and_expr -> shift_expr
683
==
and_expr -> shift_expr
683
>
and_expr -> shift_expr
683
=
and_expr -> shift_expr
684
+
atom -> NUMBER
684
*
atom -> NUMBER
684
>
atom -> NUMBER
684
<<
atom -> NUMBER
684
-
atom -> NUMBER
684
**
atom -> NUMBER
684
if
atom -> NUMBER
684
or
atom -> NUMBER
684
is
atom -> NUMBER
684
=
atom -> NUMBER
684
[
atom -> NUMBER
684
(
atom -> NUMBER
684
not
atom -> NUMBER
684
&
atom -> NUMBER
684
^
atom -> NUMBER
684
in
atom -> NUMBER
684
==
atom -> NUMBER
684
//
atom -> NUMBER
684
!=
atom -> NUMBER
684
and
atom -> NUMBER
684
%
atom -> NUMBER
684
<=
atom -> NUMBER
684
.
atom -> NUMBER
684
<
atom -> NUMBER
684
>>
atom -> NUMBER
684
/
atom -> NUMBER
684
@
atom -> NUMBER
684
>=
atom -> NUMBER
684
|
atom -> NUMBER
685
[
665
685
factor
666
685
True
667
685
atom_expr
668
685
~
669
685
and_expr
670
685
-
671
685
atom
672
685
{
673
685
arith_expr
675
685
power
676
685
STRING
677
685
NAME
678
685
(
679
685
term
680
685
+
681
685
xor_expr
682
685
shift_expr
683
685
NUMBER
684
685
not
685
685
False
687
685
comparison
688
685
not_test
1251
685
None
690
685
expr
692
686
=
1252
687
(
atom -> False
687
*
atom -> False
687
==
atom -> False
687
|
atom -> False
687
[
atom -> False
687
in
atom -> False
687
&
atom -> False
687
=
atom -> False
687
is
atom -> False
687
not
atom -> False
687
if
atom -> False
687
^
atom -> False
687
+
atom -> False
687
>
atom -> False
687
<=
atom -> False
687
<<
atom -> False
687
<
atom -> False
687
>=
atom -> False
687
%
atom -> False
687
@
atom -> False
687
and
atom -> False
687
!=
atom -> False
687
-
atom -> False
687
.
atom -> False
687
//
atom -> False
687
/
atom -> False
687
**
atom -> False
687
>>
atom -> False
687
or
atom -> False
688
or
not_test -> comparison
688
if
not_test -> comparison
688
=
not_test -> comparison
688
and
not_test -> comparison
689
and
1253
689
if
and_test -> not_test
689
or
and_test -> not_test
689
=
and_test -> not_test
690
@
atom -> None
690
<=
atom -> None
690
in
atom -> None
690
and
atom -> None
690
&
atom -> None
690
|
atom -> None
690
>
atom -> None
690
>=
atom -> None
690
/
atom -> None
690
<<
atom -> None
690
-
atom -> None
690
!=
atom -> None
690
**
atom -> None
690
(
atom -> None
690
*
atom -> None
690
=
atom -> None
690
.
atom -> None
690
>>
atom -> None
690
==
atom -> None
690
is
atom -> None
690
<
atom -> None
690
if
atom -> None
690
^
atom -> None
690
[
atom -> None
690
%
atom -> None
690
+
atom -> None
690
not
atom -> None
690
or
atom -> None
690
//
atom -> None
691
if
1254
691
=
test -> or_test
692
>
317
692
is
318
692
in
319
692
<=
320
692
<
321
692
>=
322
692
!=
324
692
not
325
692
==
326
692
=
comparison -> expr
692
comp_op
1255
692
or
comparison -> expr
692
if
comparison -> expr
692
and
comparison -> expr
693
vfpdef
234
693
:
1256
693
varargslist
1257
693
NAME
233
694
=
test -> lambdef
695
//=
expr -> xor_expr | expr
695
and
expr -> xor_expr | expr
695
==
expr -> xor_expr | expr
695
**=
expr -> xor_expr | expr
695
<
expr -> xor_expr | expr
695
not
expr -> xor_expr | expr
695
=
expr -> xor_expr | expr
695
^=
expr -> xor_expr | expr
695
/=
expr -> xor_expr | expr
695
|=
expr -> xor_expr | expr
695
@=
expr -> xor_expr | expr
695
-=
expr -> xor_expr | expr
695
%=
expr -> xor_expr | expr
695
>>=
expr -> xor_expr | expr
695
,
expr -> xor_expr | expr
695
*=
expr -> xor_expr | expr
695
in
expr -> xor_expr | expr
695
+=
expr -> xor_expr | expr
695
&=
expr -> xor_expr | expr
695
>
expr -> xor_expr | expr
695
<=
expr -> xor_expr | expr
695
<<=
expr -> xor_expr | expr
695
is
expr -> xor_expr | expr
695
>=
expr -> xor_expr | expr
695
or
expr -> xor_expr | expr
695
NEWLINE
expr -> xor_expr | expr
695
:
expr -> xor_expr | expr
695
if
expr -> xor_expr | expr
695
!=
expr -> xor_expr | expr
696
!=
atom -> [ ]
696
>>
atom -> [ ]
696
as
atom -> [ ]
696
|
atom -> [ ]
696
<<
atom -> [ ]
696
>
atom -> [ ]
696
.
atom -> [ ]
696
%
atom -> [ ]
696
^
atom -> [ ]
696
-
atom -> [ ]
696
,
atom -> [ ]
696
in
atom -> [ ]
696
:
atom -> [ ]
696
or
atom -> [ ]
696
/
atom -> [ ]
696
**
atom -> [ ]
696
//
atom -> [ ]
696
not
atom -> [ ]
696
(
atom -> [ ]
696
+
atom -> [ ]
696
and
atom -> [ ]
696
==
atom -> [ ]
696
[
atom -> [ ]
696
if
atom -> [ ]
696
<
atom -> [ ]
696
<=
atom -> [ ]
696
>=
atom -> [ ]
696
is
atom -> [ ]
696
*
atom -> [ ]
696
@
atom -> [ ]
696
&
atom -> [ ]
697
]
1258
698
term
1259
698
[
283
698
factor
284
698
True
285
698
atom_expr
286
698
~
287
698
-
289
698
atom
291
698
{
292
698
power
296
698
STRING
297
698
NAME
298
698
(
299
698
+
303
698
NUMBER
305
698
False
307
698
None
310
699
[
283
699
factor
284
699
True
285
699
term
1260
699
~
287
699
-
289
699
atom_expr
286
699
atom
291
699
{
292
699
power
296
699
STRING
297
699
NAME
298
699
(
299
699
+
303
699
NUMBER
305
699
False
307
699
None
310
700
[
283
700
factor
284
700
True
285
700
atom_expr
286
700
~
287
700
-
289
700
atom
291
700
{
292
700
power
296
700
STRING
297
700
NAME
298
700
(
299
700
term
1261
700
+
303
700
NUMBER
305
700
False
307
700
None
310
701
[
283
701
factor
284
701
True
285
701
atom_expr
286
701
~
287
701
-
289
701
atom
291
701
{
292
701
power
296
701
STRING
297
701
NAME
298
701
(
299
701
term
1262
701
+
303
701
NUMBER
305
701
False
307
701
None
310
702
[
283
702
factor
284
702
True
285
702
atom_expr
286
702
~
287
702
-
289
702
atom
291
702
{
292
702
power
296
702
STRING
297
702
NAME
298
702
term
1263
702
(
299
702
+
303
702
NUMBER
305
702
False
307
702
None
310
703
[
283
703
True
285
703
atom_expr
286
703
-
289
703
~
287
703
atom
291
703
{
292
703
power
296
703
STRING
297
703
NAME
298
703
(
299
703
+
303
703
NUMBER
305
703
False
307
703
factor
1264
703
None
310
704
@
factor -> ~ factor
704
as
factor -> ~ factor
704
>>
factor -> ~ factor
704
<=
factor -> ~ factor
704
and
factor -> ~ factor
704
+
factor -> ~ factor
704
:
factor -> ~ factor
704
*
factor -> ~ factor
704
!=
factor -> ~ factor
704
%
factor -> ~ factor
704
<<
factor -> ~ factor
704
>=
factor -> ~ factor
704
,
factor -> ~ factor
704
&
factor -> ~ factor
704
is
factor -> ~ factor
704
==
factor -> ~ factor
704
//
factor -> ~ factor
704
<
factor -> ~ factor
704
/
factor -> ~ factor
704
not
factor -> ~ factor
704
-
factor -> ~ factor
704
or
factor -> ~ factor
704
|
factor -> ~ factor
704
>
factor -> ~ factor
704
^
factor -> ~ factor
704
if
factor -> ~ factor
704
in
factor -> ~ factor
705
[
283
705
factor
284
705
True
285
705
atom_expr
286
705
~
287
705
and_expr
288
705
-
289
705
shift_expr
290
705
atom
291
705
{
292
705
xor_expr
1265
705
arith_expr
295
705
power
296
705
STRING
297
705
NAME
298
705
(
299
705
term
302
705
+
303
705
NUMBER
305
705
False
307
705
None
310
706
@
factor -> - factor
706
<=
factor -> - factor
706
in
factor -> - factor
706
as
factor -> - factor
706
>>
factor -> - factor
706
|
factor -> - factor
706
is
factor -> - factor
706
+
factor -> - factor
706
%
factor -> - factor
706
<
factor -> - factor
706
*
factor -> - factor
706
<<
factor -> - factor
706
if
factor -> - factor
706
-
factor -> - factor
706
>=
factor -> - factor
706
not
factor -> - factor
706
and
factor -> - factor
706
/
factor -> - factor
706
:
factor -> - factor
706
or
factor -> - factor
706
^
factor -> - factor
706
>
factor -> - factor
706
!=
factor -> - factor
706
&
factor -> - factor
706
==
factor -> - factor
706
//
factor -> - factor
706
,
factor -> - factor
707
[
283
707
factor
284
707
True
285
707
atom_expr
286
707
~
287
707
-
289
707
shift_expr
290
707
atom
291
707
{
292
707
arith_expr
295
707
power
296
707
STRING
297
707
NAME
298
707
(
299
707
term
302
707
+
303
707
and_expr
1266
707
NUMBER
305
707
False
307
707
None
310
708
[
766
708
factor
767
708
True
768
708
atom_expr
769
708
~
770
708
and_expr
771
708
-
772
708
{
773
708
shift_expr
774
708
atom
775
708
comparison
776
708
and_test
777
708
arith_expr
778
708
power
779
708
STRING
780
708
NAME
781
708
(
782
708
term
784
708
+
785
708
xor_expr
786
708
)
1267
708
or_test
788
708
arglist
1268
708
NUMBER
789
708
not
790
708
False
791
708
expr
792
708
*
793
708
not_test
794
708
None
795
708
lambdef
796
708
lambda
797
708
test
798
708
argument
799
708
**
800
709
trailer_expr
1269
709
>>
trailer_expr -> 
709
(
708
709
trailer
709
709
.
711
709
+
trailer_expr -> 
709
[
712
709
is
trailer_expr -> 
709
>
trailer_expr -> 
709
not
trailer_expr -> 
709
|
trailer_expr -> 
709
&
trailer_expr -> 
709
/
trailer_expr -> 
709
@
trailer_expr -> 
709
!=
trailer_expr -> 
709
**
trailer_expr -> 
709
>=
trailer_expr -> 
709
^
trailer_expr -> 
709
in
trailer_expr -> 
709
<<
trailer_expr -> 
709
and
trailer_expr -> 
709
or
trailer_expr -> 
709
as
trailer_expr -> 
709
if
trailer_expr -> 
709
:
trailer_expr -> 
709
//
trailer_expr -> 
709
%
trailer_expr -> 
709
,
trailer_expr -> 
709
<=
trailer_expr -> 
709
<
trailer_expr -> 
709
==
trailer_expr -> 
709
-
trailer_expr -> 
709
*
trailer_expr -> 
710
as
atom_expr -> atom trailer_expr
710
^
atom_expr -> atom trailer_expr
710
or
atom_expr -> atom trailer_expr
710
&
atom_expr -> atom trailer_expr
710
@
atom_expr -> atom trailer_expr
710
|
atom_expr -> atom trailer_expr
710
-
atom_expr -> atom trailer_expr
710
*
atom_expr -> atom trailer_expr
710
%
atom_expr -> atom trailer_expr
710
==
atom_expr -> atom trailer_expr
710
**
atom_expr -> atom trailer_expr
710
and
atom_expr -> atom trailer_expr
710
is
atom_expr -> atom trailer_expr
710
in
atom_expr -> atom trailer_expr
710
<<
atom_expr -> atom trailer_expr
710
!=
atom_expr -> atom trailer_expr
710
<=
atom_expr -> atom trailer_expr
710
/
atom_expr -> atom trailer_expr
710
//
atom_expr -> atom trailer_expr
710
<
atom_expr -> atom trailer_expr
710
>=
atom_expr -> atom trailer_expr
710
>>
atom_expr -> atom trailer_expr
710
if
atom_expr -> atom trailer_expr
710
not
atom_expr -> atom trailer_expr
710
:
atom_expr -> atom trailer_expr
710
+
atom_expr -> atom trailer_expr
710
>
atom_expr -> atom trailer_expr
710
,
atom_expr -> atom trailer_expr
711
NAME
1270
712
[
802
712
factor
803
712
True
804
712
atom_expr
810
712
~
806
712
not
807
712
and_expr
808
712
-
809
712
shift_expr
811
712
atom
812
712
{
813
712
comparison
814
712
or_test
815
712
(
816
712
arith_expr
817
712
power
818
712
STRING
819
712
NAME
820
712
and_test
821
712
subscriptlist
1271
712
term
822
712
+
823
712
xor_expr
824
712
test
825
712
NUMBER
826
712
False
827
712
subscript
828
712
expr
829
712
not_test
830
712
None
831
712
lambdef
832
712
lambda
833
712
maybe_test
834
712
:
maybe_test -> 
713
in
atom -> { }
713
<=
atom -> { }
713
*
atom -> { }
713
>
atom -> { }
713
+
atom -> { }
713
@
atom -> { }
713
,
atom -> { }
713
>=
atom -> { }
713
as
atom -> { }
713
/
atom -> { }
713
:
atom -> { }
713
|
atom -> { }
713
is
atom -> { }
713
and
atom -> { }
713
if
atom -> { }
713
(
atom -> { }
713
>>
atom -> { }
713
not
atom -> { }
713
-
atom -> { }
713
<<
atom -> { }
713
**
atom -> { }
713
or
atom -> { }
713
<
atom -> { }
713
!=
atom -> { }
713
==
atom -> { }
713
%
atom -> { }
713
//
atom -> { }
713
&
atom -> { }
713
[
atom -> { }
713
.
atom -> { }
713
^
atom -> { }
714
[
738
714
factor
740
714
True
741
714
~
742
714
and_expr
743
714
-
744
714
atom
745
714
{
746
714
arith_expr
747
714
power
748
714
atom_expr
749
714
STRING
750
714
NAME
751
714
(
752
714
term
753
714
+
754
714
xor_expr
755
714
shift_expr
756
714
NUMBER
757
714
not
758
714
False
759
714
or_test
1272
714
comparison
760
714
not_test
761
714
None
762
714
expr
763
714
and_test
764
715
[
283
715
factor
284
715
True
285
715
atom_expr
286
715
~
287
715
-
289
715
atom
291
715
{
292
715
arith_expr
295
715
power
296
715
STRING
297
715
NAME
298
715
shift_expr
1273
715
(
299
715
term
302
715
+
303
715
NUMBER
305
715
False
307
715
None
310
716
[
283
716
factor
284
716
True
285
716
atom_expr
286
716
~
287
716
-
289
716
atom
291
716
{
292
716
arith_expr
295
716
power
296
716
STRING
297
716
NAME
298
716
(
299
716
term
302
716
+
303
716
NUMBER
305
716
False
307
716
shift_expr
1274
716
None
310
717
)
1275
718
or
atom -> ( )
718
>>
atom -> ( )
718
(
atom -> ( )
718
<=
atom -> ( )
718
.
atom -> ( )
718
is
atom -> ( )
718
@
atom -> ( )
718
,
atom -> ( )
718
%
atom -> ( )
718
<<
atom -> ( )
718
**
atom -> ( )
718
^
atom -> ( )
718
/
atom -> ( )
718
if
atom -> ( )
718
not
atom -> ( )
718
*
atom -> ( )
718
!=
atom -> ( )
718
<
atom -> ( )
718
&
atom -> ( )
718
-
atom -> ( )
718
>
atom -> ( )
718
//
atom -> ( )
718
:
atom -> ( )
718
==
atom -> ( )
718
in
atom -> ( )
718
+
atom -> ( )
718
[
atom -> ( )
718
as
atom -> ( )
718
>=
atom -> ( )
718
and
atom -> ( )
718
|
atom -> ( )
719
arith_expr
1
719
small_stmt
20
719
factor
17
719
True
38
719
atom_expr
31
719
term
22
719
-
26
719
None
55
719
atom
57
719
test
5
719
comparison
49
719
and_expr
8
719
power
9
719
STRING
10
719
NAME
52
719
shift_expr
48
719
lambdef
15
719
NUMBER
58
719
simple_stmt
1094
719
suite
1276
719
(
16
719
expr
47
719
[
18
719
NEWLINE
1095
719
not_test
32
719
{
21
719
and_test
46
719
+
27
719
lambda
29
719
xor_expr
41
719
yield
34
719
not
62
719
test_list
36
719
~
37
719
or_test
53
719
False
39
719
sim_stmt
45
719
nonlocal
72
719
nonlocal_stmt
73
719
return
59
719
break_stmt
60
719
return_stmt
61
719
raise_stmt
74
719
break
63
719
yield_stmt
75
719
raise
64
719
continue
77
719
expr_stmt
65
719
endsim
78
719
del
80
719
pass_stmt
81
719
flow_stmt
82
719
stat_stmt
66
719
assert_stmt
68
719
resetstats
84
719
del_stmt
85
719
continue_stmt
86
719
begsim
69
719
global_stmt
87
719
pass
88
719
global
70
719
assert
71
720
[
283
720
factor
284
720
True
285
720
atom_expr
286
720
~
287
720
and_expr
288
720
-
289
720
shift_expr
290
720
atom
291
720
{
292
720
comparison
293
720
arith_expr
295
720
power
296
720
STRING
297
720
NAME
298
720
(
299
720
and_test
301
720
term
302
720
+
303
720
xor_expr
304
720
NUMBER
305
720
not
306
720
False
307
720
or_test
1277
720
expr
308
720
not_test
309
720
None
310
721
[
283
721
factor
284
721
True
285
721
atom_expr
286
721
~
287
721
-
289
721
arith_expr
1278
721
atom
291
721
{
292
721
power
296
721
STRING
297
721
NAME
298
721
(
299
721
term
302
721
+
303
721
NUMBER
305
721
False
307
721
None
310
722
[
283
722
factor
284
722
True
285
722
atom_expr
286
722
~
287
722
-
289
722
atom
291
722
{
292
722
arith_expr
1279
722
power
296
722
STRING
297
722
NAME
298
722
(
299
722
term
302
722
+
303
722
NUMBER
305
722
False
307
722
None
310
723
-
factor -> + factor
723
@
factor -> + factor
723
:
factor -> + factor
723
<<
factor -> + factor
723
is
factor -> + factor
723
and
factor -> + factor
723
<=
factor -> + factor
723
or
factor -> + factor
723
<
factor -> + factor
723
^
factor -> + factor
723
not
factor -> + factor
723
//
factor -> + factor
723
,
factor -> + factor
723
*
factor -> + factor
723
in
factor -> + factor
723
&
factor -> + factor
723
as
factor -> + factor
723
+
factor -> + factor
723
if
factor -> + factor
723
>>
factor -> + factor
723
|
factor -> + factor
723
%
factor -> + factor
723
>
factor -> + factor
723
>=
factor -> + factor
723
!=
factor -> + factor
723
/
factor -> + factor
723
==
factor -> + factor
724
[
283
724
factor
284
724
True
285
724
atom_expr
286
724
~
287
724
and_expr
288
724
-
289
724
shift_expr
290
724
atom
291
724
{
292
724
expr
1280
724
arith_expr
295
724
power
296
724
STRING
297
724
NAME
298
724
(
299
724
term
302
724
+
303
724
xor_expr
304
724
NUMBER
305
724
False
307
724
None
310
725
,
not_test -> not not_test
725
and
not_test -> not not_test
725
or
not_test -> not not_test
725
as
not_test -> not not_test
725
if
not_test -> not not_test
725
:
not_test -> not not_test
726
[
283
726
factor
284
726
True
285
726
atom_expr
286
726
~
287
726
and_expr
288
726
-
289
726
shift_expr
290
726
atom
291
726
{
292
726
arith_expr
295
726
power
296
726
STRING
297
726
NAME
298
726
(
299
726
term
302
726
+
303
726
xor_expr
304
726
NUMBER
305
726
False
307
726
expr
308
726
None
310
726
comparison
1281
727
[
283
727
factor
284
727
True
285
727
atom_expr
286
727
~
287
727
and_expr
288
727
-
289
727
shift_expr
290
727
atom
291
727
{
292
727
comparison
293
727
arith_expr
295
727
power
296
727
STRING
297
727
NAME
298
727
(
299
727
term
302
727
+
303
727
xor_expr
304
727
NUMBER
305
727
not
306
727
False
307
727
and_test
1282
727
expr
308
727
not_test
309
727
None
310
728
[
1283
728
{
1284
728
factor
1285
728
True
1286
728
~
1287
728
and_expr
1288
728
arith_expr
1289
728
shift_expr
1290
728
atom
1291
728
STRING
1292
728
power
1293
728
NAME
1294
728
(
1295
728
+
1296
728
term
1297
728
None
1298
728
False
1299
728
atom_expr
1300
728
-
1301
728
NUMBER
1302
728
xor_expr
1303
728
expr
1304
729
[
283
729
factor
284
729
True
285
729
atom_expr
286
729
~
287
729
and_expr
288
729
-
289
729
shift_expr
290
729
atom
291
729
{
292
729
comparison
293
729
or_test
294
729
arith_expr
295
729
power
296
729
STRING
297
729
NAME
298
729
(
299
729
and_test
301
729
term
302
729
+
303
729
xor_expr
304
729
NUMBER
305
729
not
306
729
False
307
729
expr
308
729
not_test
309
729
None
310
729
lambdef
311
729
test
312
729
with_item
313
729
lambda
314
729
with_items
1305
730
[
283
730
factor
284
730
True
285
730
atom_expr
286
730
~
287
730
and_expr
288
730
-
289
730
shift_expr
290
730
atom
291
730
{
292
730
comparison
293
730
or_test
294
730
arith_expr
295
730
power
296
730
STRING
297
730
NAME
298
730
test
1306
730
(
299
730
and_test
301
730
term
302
730
+
303
730
xor_expr
304
730
NUMBER
305
730
not
306
730
False
307
730
expr
308
730
not_test
309
730
None
310
730
lambdef
311
730
lambda
314
731
:
1307
732
arith_expr
1
732
small_stmt
1308
732
factor
17
732
True
38
732
atom_expr
31
732
term
22
732
-
26
732
None
55
732
atom
57
732
test
5
732
comparison
49
732
and_expr
8
732
power
9
732
STRING
10
732
NAME
52
732
shift_expr
48
732
lambdef
15
732
NUMBER
58
732
simple_stmt
1309
732
(
16
732
expr
47
732
suite
1310
732
[
18
732
NEWLINE
1311
732
not_test
32
732
{
21
732
and_test
46
732
+
27
732
lambda
29
732
xor_expr
41
732
yield
34
732
not
62
732
test_list
36
732
~
37
732
or_test
53
732
False
39
732
sim_stmt
45
732
nonlocal
72
732
nonlocal_stmt
73
732
return
59
732
break_stmt
60
732
return_stmt
61
732
raise_stmt
74
732
break
63
732
yield_stmt
75
732
raise
64
732
continue
77
732
expr_stmt
65
732
endsim
78
732
del
80
732
pass_stmt
81
732
flow_stmt
82
732
stat_stmt
66
732
assert_stmt
68
732
resetstats
84
732
del_stmt
85
732
continue_stmt
86
732
begsim
69
732
global_stmt
87
732
pass
88
732
global
70
732
assert
71
733
@=
or_test -> and_test or or_test
733
if
or_test -> and_test or or_test
733
>>=
or_test -> and_test or or_test
733
**=
or_test -> and_test or or_test
733
*=
or_test -> and_test or or_test
733
//=
or_test -> and_test or or_test
733
|=
or_test -> and_test or or_test
733
=
or_test -> and_test or or_test
733
&=
or_test -> and_test or or_test
733
:
or_test -> and_test or or_test
733
+=
or_test -> and_test or or_test
733
NEWLINE
or_test -> and_test or or_test
733
<<=
or_test -> and_test or or_test
733
,
or_test -> and_test or or_test
733
-=
or_test -> and_test or or_test
733
^=
or_test -> and_test or or_test
733
%=
or_test -> and_test or or_test
733
/=
or_test -> and_test or or_test
734
NUMBER
comp_op -> is not
734
{
comp_op -> is not
734
+
comp_op -> is not
734
-
comp_op -> is not
734
[
comp_op -> is not
734
(
comp_op -> is not
734
~
comp_op -> is not
734
False
comp_op -> is not
734
None
comp_op -> is not
734
True
comp_op -> is not
734
STRING
comp_op -> is not
734
NAME
comp_op -> is not
735
^=
comparison -> expr comp_op comparison
735
=
comparison -> expr comp_op comparison
735
,
comparison -> expr comp_op comparison
735
**=
comparison -> expr comp_op comparison
735
@=
comparison -> expr comp_op comparison
735
*=
comparison -> expr comp_op comparison
735
+=
comparison -> expr comp_op comparison
735
/=
comparison -> expr comp_op comparison
735
or
comparison -> expr comp_op comparison
735
|=
comparison -> expr comp_op comparison
735
:
comparison -> expr comp_op comparison
735
if
comparison -> expr comp_op comparison
735
and
comparison -> expr comp_op comparison
735
%=
comparison -> expr comp_op comparison
735
<<=
comparison -> expr comp_op comparison
735
NEWLINE
comparison -> expr comp_op comparison
735
//=
comparison -> expr comp_op comparison
735
-=
comparison -> expr comp_op comparison
735
&=
comparison -> expr comp_op comparison
735
>>=
comparison -> expr comp_op comparison
736
NAME
comp_op -> not in
736
None
comp_op -> not in
736
NUMBER
comp_op -> not in
736
False
comp_op -> not in
736
-
comp_op -> not in
736
(
comp_op -> not in
736
[
comp_op -> not in
736
True
comp_op -> not in
736
+
comp_op -> not in
736
~
comp_op -> not in
736
{
comp_op -> not in
736
STRING
comp_op -> not in
737
+=
and_expr -> shift_expr & and_expr
737
in
and_expr -> shift_expr & and_expr
737
/=
and_expr -> shift_expr & and_expr
737
,
and_expr -> shift_expr & and_expr
737
<=
and_expr -> shift_expr & and_expr
737
|=
and_expr -> shift_expr & and_expr
737
>=
and_expr -> shift_expr & and_expr
737
^=
and_expr -> shift_expr & and_expr
737
<<=
and_expr -> shift_expr & and_expr
737
or
and_expr -> shift_expr & and_expr
737
!=
and_expr -> shift_expr & and_expr
737
is
and_expr -> shift_expr & and_expr
737
%=
and_expr -> shift_expr & and_expr
737
&=
and_expr -> shift_expr & and_expr
737
==
and_expr -> shift_expr & and_expr
737
>
and_expr -> shift_expr & and_expr
737
>>=
and_expr -> shift_expr & and_expr
737
**=
and_expr -> shift_expr & and_expr
737
^
and_expr -> shift_expr & and_expr
737
and
and_expr -> shift_expr & and_expr
737
:
and_expr -> shift_expr & and_expr
737
*=
and_expr -> shift_expr & and_expr
737
@=
and_expr -> shift_expr & and_expr
737
if
and_expr -> shift_expr & and_expr
737
<
and_expr -> shift_expr & and_expr
737
=
and_expr -> shift_expr & and_expr
737
NEWLINE
and_expr -> shift_expr & and_expr
737
not
and_expr -> shift_expr & and_expr
737
-=
and_expr -> shift_expr & and_expr
737
|
and_expr -> shift_expr & and_expr
737
//=
and_expr -> shift_expr & and_expr
738
[
166
738
factor
167
738
True
168
738
atom_expr
169
738
~
170
738
not
171
738
and_expr
172
738
-
173
738
{
174
738
shift_expr
175
738
atom
176
738
]
1312
738
comparison
178
738
(
179
738
arith_expr
180
738
power
181
738
STRING
182
738
NAME
183
738
test
184
738
and_test
185
738
term
186
738
+
187
738
xor_expr
188
738
NUMBER
190
738
test_list_comp
1313
738
False
191
738
expr
192
738
not_test
193
738
None
194
738
lambdef
195
738
lambda
196
738
or_test
197
738
test_list
198
739
else
1314
740
not
term -> factor
740
@
1315
740
%
1316
740
/
1317
740
*
1318
740
//
1319
740
<=
term -> factor
740
>
term -> factor
740
==
term -> factor
740
else
term -> factor
740
is
term -> factor
740
or
term -> factor
740
<
term -> factor
740
and
term -> factor
740
<<
term -> factor
740
^
term -> factor
740
!=
term -> factor
740
-
term -> factor
740
&
term -> factor
740
|
term -> factor
740
>=
term -> factor
740
+
term -> factor
740
in
term -> factor
740
>>
term -> factor
741
<<
atom -> True
741
&
atom -> True
741
or
atom -> True
741
[
atom -> True
741
-
atom -> True
741
*
atom -> True
741
^
atom -> True
741
>=
atom -> True
741
else
atom -> True
741
!=
atom -> True
741
(
atom -> True
741
not
atom -> True
741
|
atom -> True
741
+
atom -> True
741
**
atom -> True
741
.
atom -> True
741
is
atom -> True
741
//
atom -> True
741
>
atom -> True
741
%
atom -> True
741
in
atom -> True
741
<=
atom -> True
741
>>
atom -> True
741
/
atom -> True
741
==
atom -> True
741
and
atom -> True
741
<
atom -> True
741
@
atom -> True
742
[
738
742
{
746
742
+
754
742
True
741
742
-
744
742
~
742
742
atom
745
742
STRING
750
742
power
748
742
atom_expr
749
742
NAME
751
742
(
752
742
factor
1320
742
None
762
742
False
759
742
NUMBER
757
743
>
xor_expr -> and_expr
743
<=
xor_expr -> and_expr
743
not
xor_expr -> and_expr
743
|
xor_expr -> and_expr
743
^
1321
743
==
xor_expr -> and_expr
743
in
xor_expr -> and_expr
743
!=
xor_expr -> and_expr
743
is
xor_expr -> and_expr
743
<
xor_expr -> and_expr
743
or
xor_expr -> and_expr
743
and
xor_expr -> and_expr
743
>=
xor_expr -> and_expr
743
else
xor_expr -> and_expr
744
[
738
744
{
746
744
+
754
744
True
741
744
~
742
744
-
744
744
atom
745
744
factor
1322
744
STRING
750
744
power
748
744
atom_expr
749
744
NAME
751
744
(
752
744
None
762
744
False
759
744
NUMBER
757
745
>>
trailer_expr -> 
745
(
1323
745
trailer
1324
745
trailer_expr
1325
745
.
1326
745
+
trailer_expr -> 
745
[
1327
745
is
trailer_expr -> 
745
>
trailer_expr -> 
745
not
trailer_expr -> 
745
|
trailer_expr -> 
745
&
trailer_expr -> 
745
/
trailer_expr -> 
745
@
trailer_expr -> 
745
!=
trailer_expr -> 
745
**
trailer_expr -> 
745
>=
trailer_expr -> 
745
^
trailer_expr -> 
745
in
trailer_expr -> 
745
<<
trailer_expr -> 
745
and
trailer_expr -> 
745
or
trailer_expr -> 
745
//
trailer_expr -> 
745
%
trailer_expr -> 
745
<=
trailer_expr -> 
745
<
trailer_expr -> 
745
==
trailer_expr -> 
745
-
trailer_expr -> 
745
else
trailer_expr -> 
745
*
trailer_expr -> 
746
}
1328
747
>>
1329
747
&
shift_expr -> arith_expr
747
|
shift_expr -> arith_expr
747
<<
1330
747
is
shift_expr -> arith_expr
747
<
shift_expr -> arith_expr
747
==
shift_expr -> arith_expr
747
or
shift_expr -> arith_expr
747
>
shift_expr -> arith_expr
747
!=
shift_expr -> arith_expr
747
>=
shift_expr -> arith_expr
747
in
shift_expr -> arith_expr
747
<=
shift_expr -> arith_expr
747
and
shift_expr -> arith_expr
747
^
shift_expr -> arith_expr
747
else
shift_expr -> arith_expr
747
not
shift_expr -> arith_expr
748
+
factor -> power
748
%
factor -> power
748
<
factor -> power
748
<<
factor -> power
748
!=
factor -> power
748
<=
factor -> power
748
and
factor -> power
748
/
factor -> power
748
^
factor -> power
748
@
factor -> power
748
>=
factor -> power
748
not
factor -> power
748
//
factor -> power
748
or
factor -> power
748
==
factor -> power
748
is
factor -> power
748
|
factor -> power
748
*
factor -> power
748
-
factor -> power
748
else
factor -> power
748
>
factor -> power
748
in
factor -> power
748
>>
factor -> power
748
&
factor -> power
749
**
1331
749
!=
power -> atom_expr
749
-
power -> atom_expr
749
<<
power -> atom_expr
749
not
power -> atom_expr
749
/
power -> atom_expr
749
<=
power -> atom_expr
749
in
power -> atom_expr
749
%
power -> atom_expr
749
>
power -> atom_expr
749
@
power -> atom_expr
749
|
power -> atom_expr
749
<
power -> atom_expr
749
>>
power -> atom_expr
749
or
power -> atom_expr
749
and
power -> atom_expr
749
>=
power -> atom_expr
749
==
power -> atom_expr
749
^
power -> atom_expr
749
else
power -> atom_expr
749
*
power -> atom_expr
749
&
power -> atom_expr
749
is
power -> atom_expr
749
+
power -> atom_expr
749
//
power -> atom_expr
750
%
atom -> STRING
750
>
atom -> STRING
750
@
atom -> STRING
750
<<
atom -> STRING
750
else
atom -> STRING
750
in
atom -> STRING
750
[
atom -> STRING
750
-
atom -> STRING
750
==
atom -> STRING
750
>=
atom -> STRING
750
not
atom -> STRING
750
/
atom -> STRING
750
+
atom -> STRING
750
*
atom -> STRING
750
(
atom -> STRING
750
//
atom -> STRING
750
.
atom -> STRING
750
<
atom -> STRING
750
&
atom -> STRING
750
<=
atom -> STRING
750
!=
atom -> STRING
750
**
atom -> STRING
750
^
atom -> STRING
750
and
atom -> STRING
750
is
atom -> STRING
750
|
atom -> STRING
750
or
atom -> STRING
750
>>
atom -> STRING
751
<
atom -> NAME
751
^
atom -> NAME
751
+
atom -> NAME
751
-
atom -> NAME
751
>=
atom -> NAME
751
@
atom -> NAME
751
else
atom -> NAME
751
!=
atom -> NAME
751
*
atom -> NAME
751
<=
atom -> NAME
751
**
atom -> NAME
751
or
atom -> NAME
751
not
atom -> NAME
751
==
atom -> NAME
751
&
atom -> NAME
751
>
atom -> NAME
751
%
atom -> NAME
751
>>
atom -> NAME
751
.
atom -> NAME
751
|
atom -> NAME
751
is
atom -> NAME
751
and
atom -> NAME
751
//
atom -> NAME
751
[
atom -> NAME
751
/
atom -> NAME
751
(
atom -> NAME
751
<<
atom -> NAME
751
in
atom -> NAME
752
[
128
752
factor
129
752
True
130
752
atom_expr
131
752
~
132
752
and_expr
133
752
-
134
752
{
135
752
test_list_comp
1332
752
shift_expr
137
752
atom
138
752
)
1333
752
comparison
140
752
arith_expr
141
752
power
142
752
STRING
143
752
NAME
144
752
(
145
752
and_test
146
752
term
147
752
+
148
752
xor_expr
149
752
or_test
150
752
NUMBER
151
752
not
152
752
False
153
752
expr
154
752
not_test
155
752
None
156
752
lambdef
157
752
lambda
158
752
test
159
752
test_list
160
753
+
1334
753
-
1335
753
>=
arith_expr -> term
753
|
arith_expr -> term
753
<=
arith_expr -> term
753
not
arith_expr -> term
753
==
arith_expr -> term
753
in
arith_expr -> term
753
>>
arith_expr -> term
753
is
arith_expr -> term
753
or
arith_expr -> term
753
!=
arith_expr -> term
753
>
arith_expr -> term
753
else
arith_expr -> term
753
and
arith_expr -> term
753
<<
arith_expr -> term
753
<
arith_expr -> term
753
^
arith_expr -> term
753
&
arith_expr -> term
754
[
738
754
{
746
754
+
754
754
True
741
754
-
744
754
~
742
754
atom
745
754
STRING
750
754
power
748
754
atom_expr
749
754
NAME
751
754
(
752
754
factor
1336
754
None
762
754
False
759
754
NUMBER
757
755
|
1337
755
>
expr -> xor_expr
755
is
expr -> xor_expr
755
and
expr -> xor_expr
755
not
expr -> xor_expr
755
or
expr -> xor_expr
755
>=
expr -> xor_expr
755
==
expr -> xor_expr
755
<
expr -> xor_expr
755
!=
expr -> xor_expr
755
<=
expr -> xor_expr
755
in
expr -> xor_expr
755
else
expr -> xor_expr
756
^
and_expr -> shift_expr
756
in
and_expr -> shift_expr
756
|
and_expr -> shift_expr
756
&
1338
756
<
and_expr -> shift_expr
756
not
and_expr -> shift_expr
756
>=
and_expr -> shift_expr
756
<=
and_expr -> shift_expr
756
else
and_expr -> shift_expr
756
or
and_expr -> shift_expr
756
and
and_expr -> shift_expr
756
!=
and_expr -> shift_expr
756
is
and_expr -> shift_expr
756
==
and_expr -> shift_expr
756
>
and_expr -> shift_expr
757
+
atom -> NUMBER
757
*
atom -> NUMBER
757
>
atom -> NUMBER
757
<<
atom -> NUMBER
757
-
atom -> NUMBER
757
**
atom -> NUMBER
757
or
atom -> NUMBER
757
is
atom -> NUMBER
757
else
atom -> NUMBER
757
[
atom -> NUMBER
757
(
atom -> NUMBER
757
not
atom -> NUMBER
757
&
atom -> NUMBER
757
^
atom -> NUMBER
757
in
atom -> NUMBER
757
==
atom -> NUMBER
757
//
atom -> NUMBER
757
!=
atom -> NUMBER
757
and
atom -> NUMBER
757
%
atom -> NUMBER
757
<=
atom -> NUMBER
757
.
atom -> NUMBER
757
<
atom -> NUMBER
757
>>
atom -> NUMBER
757
/
atom -> NUMBER
757
@
atom -> NUMBER
757
>=
atom -> NUMBER
757
|
atom -> NUMBER
758
[
738
758
factor
740
758
True
741
758
~
742
758
and_expr
743
758
-
744
758
atom
745
758
{
746
758
arith_expr
747
758
power
748
758
atom_expr
749
758
STRING
750
758
NAME
751
758
(
752
758
term
753
758
+
754
758
xor_expr
755
758
shift_expr
756
758
NUMBER
757
758
not
758
758
False
759
758
comparison
760
758
not_test
1339
758
None
762
758
expr
763
759
(
atom -> False
759
*
atom -> False
759
==
atom -> False
759
|
atom -> False
759
[
atom -> False
759
in
atom -> False
759
&
atom -> False
759
is
atom -> False
759
not
atom -> False
759
+
atom -> False
759
^
atom -> False
759
>
atom -> False
759
<=
atom -> False
759
<<
atom -> False
759
<
atom -> False
759
>=
atom -> False
759
%
atom -> False
759
@
atom -> False
759
and
atom -> False
759
else
atom -> False
759
!=
atom -> False
759
-
atom -> False
759
.
atom -> False
759
//
atom -> False
759
/
atom -> False
759
**
atom -> False
759
>>
atom -> False
759
or
atom -> False
760
or
not_test -> comparison
760
else
not_test -> comparison
760
and
not_test -> comparison
761
else
and_test -> not_test
761
and
1340
761
or
and_test -> not_test
762
@
atom -> None
762
<=
atom -> None
762
in
atom -> None
762
and
atom -> None
762
&
atom -> None
762
|
atom -> None
762
>
atom -> None
762
>=
atom -> None
762
/
atom -> None
762
<<
atom -> None
762
-
atom -> None
762
!=
atom -> None
762
**
atom -> None
762
(
atom -> None
762
*
atom -> None
762
.
atom -> None
762
>>
atom -> None
762
==
atom -> None
762
is
atom -> None
762
<
atom -> None
762
^
atom -> None
762
[
atom -> None
762
%
atom -> None
762
+
atom -> None
762
else
atom -> None
762
not
atom -> None
762
or
atom -> None
762
//
atom -> None
763
>
317
763
is
318
763
in
319
763
<=
320
763
<
321
763
>=
322
763
not
325
763
==
326
763
!=
324
763
comp_op
1341
763
and
comparison -> expr
763
or
comparison -> expr
763
else
comparison -> expr
764
or
1342
764
else
or_test -> and_test
765
=
trailer -> . NAME
765
.
trailer -> . NAME
765
/=
trailer -> . NAME
765
not
trailer -> . NAME
765
%=
trailer -> . NAME
765
NEWLINE
trailer -> . NAME
765
if
trailer -> . NAME
765
**
trailer -> . NAME
765
<
trailer -> . NAME
765
<<=
trailer -> . NAME
765
|
trailer -> . NAME
765
:
trailer -> . NAME
765
-
trailer -> . NAME
765
(
trailer -> . NAME
765
//=
trailer -> . NAME
765
@=
trailer -> . NAME
765
**=
trailer -> . NAME
765
%
trailer -> . NAME
765
//
trailer -> . NAME
765
&=
trailer -> . NAME
765
==
trailer -> . NAME
765
>>
trailer -> . NAME
765
*=
trailer -> . NAME
765
is
trailer -> . NAME
765
!=
trailer -> . NAME
765
and
trailer -> . NAME
765
+=
trailer -> . NAME
765
>>=
trailer -> . NAME
765
>=
trailer -> . NAME
765
,
trailer -> . NAME
765
>
trailer -> . NAME
765
in
trailer -> . NAME
765
<<
trailer -> . NAME
765
^=
trailer -> . NAME
765
&
trailer -> . NAME
765
|=
trailer -> . NAME
765
/
trailer -> . NAME
765
^
trailer -> . NAME
765
[
trailer -> . NAME
765
<=
trailer -> . NAME
765
or
trailer -> . NAME
765
+
trailer -> . NAME
765
-=
trailer -> . NAME
765
*
trailer -> . NAME
765
@
trailer -> . NAME
766
[
166
766
factor
167
766
True
168
766
atom_expr
169
766
~
170
766
not
171
766
and_expr
172
766
-
173
766
{
174
766
shift_expr
175
766
atom
176
766
]
1343
766
comparison
178
766
(
179
766
arith_expr
180
766
power
181
766
STRING
182
766
NAME
183
766
test
184
766
and_test
185
766
term
186
766
+
187
766
xor_expr
188
766
NUMBER
190
766
test_list_comp
1344
766
False
191
766
expr
192
766
not_test
193
766
None
194
766
lambdef
195
766
lambda
196
766
or_test
197
766
test_list
198
767
not
term -> factor
767
@
1345
767
%
1346
767
/
1347
767
*
1348
767
//
1349
767
<=
term -> factor
767
for
term -> factor
767
)
term -> factor
767
>
term -> factor
767
==
term -> factor
767
is
term -> factor
767
or
term -> factor
767
<
term -> factor
767
and
term -> factor
767
<<
term -> factor
767
^
term -> factor
767
!=
term -> factor
767
-
term -> factor
767
&
term -> factor
767
|
term -> factor
767
,
term -> factor
767
>=
term -> factor
767
if
term -> factor
767
=
term -> factor
767
+
term -> factor
767
in
term -> factor
767
>>
term -> factor
768
<<
atom -> True
768
&
atom -> True
768
or
atom -> True
768
[
atom -> True
768
if
atom -> True
768
-
atom -> True
768
*
atom -> True
768
^
atom -> True
768
,
atom -> True
768
>=
atom -> True
768
!=
atom -> True
768
=
atom -> True
768
(
atom -> True
768
not
atom -> True
768
for
atom -> True
768
|
atom -> True
768
)
atom -> True
768
+
atom -> True
768
**
atom -> True
768
.
atom -> True
768
is
atom -> True
768
//
atom -> True
768
>
atom -> True
768
%
atom -> True
768
in
atom -> True
768
<=
atom -> True
768
>>
atom -> True
768
/
atom -> True
768
==
atom -> True
768
and
atom -> True
768
<
atom -> True
768
@
atom -> True
769
=
power -> atom_expr
769
**
1350
769
,
power -> atom_expr
769
)
power -> atom_expr
769
!=
power -> atom_expr
769
-
power -> atom_expr
769
<<
power -> atom_expr
769
not
power -> atom_expr
769
/
power -> atom_expr
769
<=
power -> atom_expr
769
in
power -> atom_expr
769
%
power -> atom_expr
769
>
power -> atom_expr
769
@
power -> atom_expr
769
|
power -> atom_expr
769
<
power -> atom_expr
769
>>
power -> atom_expr
769
or
power -> atom_expr
769
and
power -> atom_expr
769
>=
power -> atom_expr
769
==
power -> atom_expr
769
^
power -> atom_expr
769
*
power -> atom_expr
769
for
power -> atom_expr
769
&
power -> atom_expr
769
is
power -> atom_expr
769
+
power -> atom_expr
769
if
power -> atom_expr
769
//
power -> atom_expr
770
[
766
770
True
768
770
atom_expr
769
770
-
772
770
~
770
770
{
773
770
atom
775
770
power
779
770
STRING
780
770
NAME
781
770
(
782
770
+
785
770
NUMBER
789
770
False
791
770
factor
1351
770
None
795
771
>
xor_expr -> and_expr
771
^
1352
771
<=
xor_expr -> and_expr
771
not
xor_expr -> and_expr
771
|
xor_expr -> and_expr
771
==
xor_expr -> and_expr
771
,
xor_expr -> and_expr
771
in
xor_expr -> and_expr
771
!=
xor_expr -> and_expr
771
if
xor_expr -> and_expr
771
for
xor_expr -> and_expr
771
is
xor_expr -> and_expr
771
<
xor_expr -> and_expr
771
or
xor_expr -> and_expr
771
=
xor_expr -> and_expr
771
)
xor_expr -> and_expr
771
and
xor_expr -> and_expr
771
>=
xor_expr -> and_expr
772
[
766
772
True
768
772
atom_expr
769
772
~
770
772
-
772
772
{
773
772
atom
775
772
power
779
772
STRING
780
772
NAME
781
772
(
782
772
factor
1353
772
+
785
772
NUMBER
789
772
False
791
772
None
795
773
}
1354
774
^
and_expr -> shift_expr
774
in
and_expr -> shift_expr
774
|
and_expr -> shift_expr
774
&
1355
774
<
and_expr -> shift_expr
774
not
and_expr -> shift_expr
774
>=
and_expr -> shift_expr
774
for
and_expr -> shift_expr
774
<=
and_expr -> shift_expr
774
or
and_expr -> shift_expr
774
and
and_expr -> shift_expr
774
,
and_expr -> shift_expr
774
!=
and_expr -> shift_expr
774
if
and_expr -> shift_expr
774
is
and_expr -> shift_expr
774
==
and_expr -> shift_expr
774
>
and_expr -> shift_expr
774
)
and_expr -> shift_expr
774
=
and_expr -> shift_expr
775
>>
trailer_expr -> 
775
.
1356
775
(
1357
775
trailer
1358
775
)
trailer_expr -> 
775
trailer_expr
1359
775
+
trailer_expr -> 
775
[
1360
775
is
trailer_expr -> 
775
>
trailer_expr -> 
775
not
trailer_expr -> 
775
|
trailer_expr -> 
775
=
trailer_expr -> 
775
&
trailer_expr -> 
775
/
trailer_expr -> 
775
@
trailer_expr -> 
775
!=
trailer_expr -> 
775
**
trailer_expr -> 
775
>=
trailer_expr -> 
775
^
trailer_expr -> 
775
in
trailer_expr -> 
775
<<
trailer_expr -> 
775
and
trailer_expr -> 
775
or
trailer_expr -> 
775
if
trailer_expr -> 
775
//
trailer_expr -> 
775
%
trailer_expr -> 
775
,
trailer_expr -> 
775
<=
trailer_expr -> 
775
<
trailer_expr -> 
775
==
trailer_expr -> 
775
for
trailer_expr -> 
775
-
trailer_expr -> 
775
*
trailer_expr -> 
776
or
not_test -> comparison
776
)
not_test -> comparison
776
,
not_test -> comparison
776
for
not_test -> comparison
776
=
not_test -> comparison
776
and
not_test -> comparison
776
if
not_test -> comparison
777
=
or_test -> and_test
777
or
1361
777
for
or_test -> and_test
777
,
or_test -> and_test
777
if
or_test -> and_test
777
)
or_test -> and_test
778
>>
1362
778
if
shift_expr -> arith_expr
778
&
shift_expr -> arith_expr
778
<<
1363
778
|
shift_expr -> arith_expr
778
is
shift_expr -> arith_expr
778
<
shift_expr -> arith_expr
778
==
shift_expr -> arith_expr
778
=
shift_expr -> arith_expr
778
or
shift_expr -> arith_expr
778
>
shift_expr -> arith_expr
778
)
shift_expr -> arith_expr
778
!=
shift_expr -> arith_expr
778
for
shift_expr -> arith_expr
778
>=
shift_expr -> arith_expr
778
in
shift_expr -> arith_expr
778
,
shift_expr -> arith_expr
778
<=
shift_expr -> arith_expr
778
and
shift_expr -> arith_expr
778
^
shift_expr -> arith_expr
778
not
shift_expr -> arith_expr
779
+
factor -> power
779
%
factor -> power
779
=
factor -> power
779
,
factor -> power
779
<
factor -> power
779
<<
factor -> power
779
!=
factor -> power
779
<=
factor -> power
779
and
factor -> power
779
/
factor -> power
779
^
factor -> power
779
for
factor -> power
779
@
factor -> power
779
>=
factor -> power
779
not
factor -> power
779
//
factor -> power
779
or
factor -> power
779
==
factor -> power
779
is
factor -> power
779
|
factor -> power
779
)
factor -> power
779
*
factor -> power
779
-
factor -> power
779
if
factor -> power
779
>
factor -> power
779
in
factor -> power
779
>>
factor -> power
779
&
factor -> power
780
%
atom -> STRING
780
>
atom -> STRING
780
@
atom -> STRING
780
<<
atom -> STRING
780
in
atom -> STRING
780
[
atom -> STRING
780
-
atom -> STRING
780
==
atom -> STRING
780
>=
atom -> STRING
780
not
atom -> STRING
780
/
atom -> STRING
780
+
atom -> STRING
780
=
atom -> STRING
780
*
atom -> STRING
780
)
atom -> STRING
780
(
atom -> STRING
780
//
atom -> STRING
780
if
atom -> STRING
780
.
atom -> STRING
780
<
atom -> STRING
780
,
atom -> STRING
780
&
atom -> STRING
780
<=
atom -> STRING
780
for
atom -> STRING
780
!=
atom -> STRING
780
**
atom -> STRING
780
^
atom -> STRING
780
and
atom -> STRING
780
is
atom -> STRING
780
|
atom -> STRING
780
or
atom -> STRING
780
>>
atom -> STRING
781
)
atom -> NAME
781
<
atom -> NAME
781
,
atom -> NAME
781
^
atom -> NAME
781
+
atom -> NAME
781
-
atom -> NAME
781
>=
atom -> NAME
781
@
atom -> NAME
781
!=
atom -> NAME
781
for
atom -> NAME
781
*
atom -> NAME
781
=
atom -> NAME
781
<=
atom -> NAME
781
**
atom -> NAME
781
or
atom -> NAME
781
not
atom -> NAME
781
==
atom -> NAME
781
&
atom -> NAME
781
>
atom -> NAME
781
%
atom -> NAME
781
>>
atom -> NAME
781
.
atom -> NAME
781
|
atom -> NAME
781
is
atom -> NAME
781
and
atom -> NAME
781
//
atom -> NAME
781
[
atom -> NAME
781
/
atom -> NAME
781
(
atom -> NAME
781
<<
atom -> NAME
781
if
atom -> NAME
781
in
atom -> NAME
782
[
128
782
factor
129
782
True
130
782
atom_expr
131
782
~
132
782
and_expr
133
782
-
134
782
{
135
782
test_list_comp
1364
782
shift_expr
137
782
atom
138
782
)
1365
782
comparison
140
782
arith_expr
141
782
power
142
782
STRING
143
782
NAME
144
782
(
145
782
and_test
146
782
term
147
782
+
148
782
xor_expr
149
782
or_test
150
782
NUMBER
151
782
not
152
782
False
153
782
expr
154
782
not_test
155
782
None
156
782
lambdef
157
782
lambda
158
782
test
159
782
test_list
160
783
)
1366
784
-
1367
784
+
1368
784
|
arith_expr -> term
784
>=
arith_expr -> term
784
<=
arith_expr -> term
784
not
arith_expr -> term
784
,
arith_expr -> term
784
==
arith_expr -> term
784
)
arith_expr -> term
784
for
arith_expr -> term
784
in
arith_expr -> term
784
>>
arith_expr -> term
784
is
arith_expr -> term
784
if
arith_expr -> term
784
or
arith_expr -> term
784
!=
arith_expr -> term
784
>
arith_expr -> term
784
=
arith_expr -> term
784
and
arith_expr -> term
784
<<
arith_expr -> term
784
<
arith_expr -> term
784
^
arith_expr -> term
784
&
arith_expr -> term
785
[
766
785
True
768
785
atom_expr
769
785
-
772
785
~
770
785
{
773
785
atom
775
785
power
779
785
STRING
780
785
NAME
781
785
(
782
785
factor
1369
785
+
785
785
NUMBER
789
785
False
791
785
None
795
786
|
1370
786
>
expr -> xor_expr
786
if
expr -> xor_expr
786
for
expr -> xor_expr
786
is
expr -> xor_expr
786
and
expr -> xor_expr
786
)
expr -> xor_expr
786
=
expr -> xor_expr
786
not
expr -> xor_expr
786
or
expr -> xor_expr
786
>=
expr -> xor_expr
786
==
expr -> xor_expr
786
,
expr -> xor_expr
786
<
expr -> xor_expr
786
!=
expr -> xor_expr
786
<=
expr -> xor_expr
786
in
expr -> xor_expr
787
+
trailer -> ( )
787
!=
trailer -> ( )
787
<<
trailer -> ( )
787
>=
trailer -> ( )
787
%=
trailer -> ( )
787
**
trailer -> ( )
787
<<=
trailer -> ( )
787
not
trailer -> ( )
787
=
trailer -> ( )
787
+=
trailer -> ( )
787
if
trailer -> ( )
787
,
trailer -> ( )
787
|
trailer -> ( )
787
[
trailer -> ( )
787
==
trailer -> ( )
787
%
trailer -> ( )
787
*
trailer -> ( )
787
&=
trailer -> ( )
787
>>
trailer -> ( )
787
-=
trailer -> ( )
787
@
trailer -> ( )
787
/=
trailer -> ( )
787
>
trailer -> ( )
787
/
trailer -> ( )
787
^=
trailer -> ( )
787
in
trailer -> ( )
787
(
trailer -> ( )
787
*=
trailer -> ( )
787
is
trailer -> ( )
787
//
trailer -> ( )
787
<
trailer -> ( )
787
:
trailer -> ( )
787
NEWLINE
trailer -> ( )
787
|=
trailer -> ( )
787
or
trailer -> ( )
787
^
trailer -> ( )
787
>>=
trailer -> ( )
787
and
trailer -> ( )
787
**=
trailer -> ( )
787
<=
trailer -> ( )
787
//=
trailer -> ( )
787
.
trailer -> ( )
787
-
trailer -> ( )
787
&
trailer -> ( )
787
@=
trailer -> ( )
788
=
test -> or_test
788
if
1371
788
)
test -> or_test
788
for
test -> or_test
788
,
test -> or_test
789
+
atom -> NUMBER
789
*
atom -> NUMBER
789
>
atom -> NUMBER
789
<<
atom -> NUMBER
789
for
atom -> NUMBER
789
-
atom -> NUMBER
789
**
atom -> NUMBER
789
if
atom -> NUMBER
789
or
atom -> NUMBER
789
is
atom -> NUMBER
789
=
atom -> NUMBER
789
[
atom -> NUMBER
789
(
atom -> NUMBER
789
not
atom -> NUMBER
789
&
atom -> NUMBER
789
)
atom -> NUMBER
789
^
atom -> NUMBER
789
in
atom -> NUMBER
789
==
atom -> NUMBER
789
//
atom -> NUMBER
789
!=
atom -> NUMBER
789
and
atom -> NUMBER
789
%
atom -> NUMBER
789
<=
atom -> NUMBER
789
.
atom -> NUMBER
789
<
atom -> NUMBER
789
>>
atom -> NUMBER
789
,
atom -> NUMBER
789
/
atom -> NUMBER
789
@
atom -> NUMBER
789
>=
atom -> NUMBER
789
|
atom -> NUMBER
790
[
766
790
factor
767
790
True
768
790
atom_expr
769
790
~
770
790
and_expr
771
790
-
772
790
{
773
790
shift_expr
774
790
atom
775
790
comparison
776
790
arith_expr
778
790
power
779
790
STRING
780
790
NAME
781
790
(
782
790
term
784
790
+
785
790
xor_expr
786
790
NUMBER
789
790
not
790
790
False
791
790
expr
792
790
not_test
1372
790
None
795
791
for
atom -> False
791
(
atom -> False
791
*
atom -> False
791
==
atom -> False
791
|
atom -> False
791
,
atom -> False
791
[
atom -> False
791
in
atom -> False
791
&
atom -> False
791
=
atom -> False
791
is
atom -> False
791
not
atom -> False
791
if
atom -> False
791
^
atom -> False
791
+
atom -> False
791
)
atom -> False
791
>
atom -> False
791
<=
atom -> False
791
<<
atom -> False
791
<
atom -> False
791
>=
atom -> False
791
%
atom -> False
791
@
atom -> False
791
and
atom -> False
791
!=
atom -> False
791
-
atom -> False
791
.
atom -> False
791
//
atom -> False
791
/
atom -> False
791
**
atom -> False
791
>>
atom -> False
791
or
atom -> False
792
>
317
792
is
318
792
in
319
792
<=
320
792
<
321
792
>=
322
792
!=
324
792
not
325
792
==
326
792
comp_op
1373
792
for
comparison -> expr
792
=
comparison -> expr
792
or
comparison -> expr
792
if
comparison -> expr
792
)
comparison -> expr
792
and
comparison -> expr
792
,
comparison -> expr
793
[
1002
793
factor
1003
793
True
1004
793
atom_expr
1005
793
~
1006
793
and_expr
1007
793
-
1008
793
shift_expr
1009
793
atom
1010
793
{
1011
793
comparison
1012
793
arith_expr
1013
793
power
1014
793
STRING
1015
793
NAME
1016
793
(
1017
793
and_test
1018
793
term
1019
793
+
1020
793
xor_expr
1021
793
or_test
1022
793
NUMBER
1023
793
not
1024
793
False
1025
793
not_test
1026
793
None
1027
793
test
1374
793
expr
1028
793
lambda
1029
793
lambdef
1031
794
and
1375
794
,
and_test -> not_test
794
if
and_test -> not_test
794
)
and_test -> not_test
794
for
and_test -> not_test
794
or
and_test -> not_test
794
=
and_test -> not_test
795
@
atom -> None
795
<=
atom -> None
795
in
atom -> None
795
and
atom -> None
795
for
atom -> None
795
&
atom -> None
795
|
atom -> None
795
>
atom -> None
795
)
atom -> None
795
>=
atom -> None
795
/
atom -> None
795
<<
atom -> None
795
-
atom -> None
795
!=
atom -> None
795
**
atom -> None
795
(
atom -> None
795
*
atom -> None
795
=
atom -> None
795
.
atom -> None
795
>>
atom -> None
795
==
atom -> None
795
is
atom -> None
795
<
atom -> None
795
if
atom -> None
795
^
atom -> None
795
[
atom -> None
795
%
atom -> None
795
+
atom -> None
795
not
atom -> None
795
,
atom -> None
795
or
atom -> None
795
//
atom -> None
796
,
test -> lambdef
796
for
test -> lambdef
796
=
test -> lambdef
796
)
test -> lambdef
797
varargslist
1376
797
vfpdef
234
797
:
1377
797
NAME
233
798
,
argument -> test
798
comp_for
1378
798
)
argument -> test
798
=
1379
798
for
1380
799
,
1381
799
)
arglist -> argument
800
[
1002
800
factor
1003
800
True
1004
800
atom_expr
1005
800
~
1006
800
and_expr
1007
800
-
1008
800
shift_expr
1009
800
atom
1010
800
{
1011
800
comparison
1012
800
arith_expr
1013
800
power
1014
800
STRING
1015
800
NAME
1016
800
(
1017
800
and_test
1018
800
term
1019
800
+
1020
800
xor_expr
1021
800
or_test
1022
800
NUMBER
1023
800
not
1024
800
False
1025
800
not_test
1026
800
None
1027
800
expr
1028
800
test
1382
800
lambda
1029
800
lambdef
1031
801
<=
trailer_expr -> trailer trailer_expr
801
+
trailer_expr -> trailer trailer_expr
801
<<=
trailer_expr -> trailer trailer_expr
801
^
trailer_expr -> trailer trailer_expr
801
or
trailer_expr -> trailer trailer_expr
801
==
trailer_expr -> trailer trailer_expr
801
/=
trailer_expr -> trailer trailer_expr
801
//=
trailer_expr -> trailer trailer_expr
801
%=
trailer_expr -> trailer trailer_expr
801
@
trailer_expr -> trailer trailer_expr
801
%
trailer_expr -> trailer trailer_expr
801
=
trailer_expr -> trailer trailer_expr
801
^=
trailer_expr -> trailer trailer_expr
801
not
trailer_expr -> trailer trailer_expr
801
<<
trailer_expr -> trailer trailer_expr
801
-
trailer_expr -> trailer trailer_expr
801
//
trailer_expr -> trailer trailer_expr
801
@=
trailer_expr -> trailer trailer_expr
801
and
trailer_expr -> trailer trailer_expr
801
>>=
trailer_expr -> trailer trailer_expr
801
|
trailer_expr -> trailer trailer_expr
801
if
trailer_expr -> trailer trailer_expr
801
**=
trailer_expr -> trailer trailer_expr
801
>
trailer_expr -> trailer trailer_expr
801
!=
trailer_expr -> trailer trailer_expr
801
*=
trailer_expr -> trailer trailer_expr
801
,
trailer_expr -> trailer trailer_expr
801
<
trailer_expr -> trailer trailer_expr
801
>>
trailer_expr -> trailer trailer_expr
801
/
trailer_expr -> trailer trailer_expr
801
+=
trailer_expr -> trailer trailer_expr
801
:
trailer_expr -> trailer trailer_expr
801
is
trailer_expr -> trailer trailer_expr
801
NEWLINE
trailer_expr -> trailer trailer_expr
801
&
trailer_expr -> trailer trailer_expr
801
in
trailer_expr -> trailer trailer_expr
801
&=
trailer_expr -> trailer trailer_expr
801
-=
trailer_expr -> trailer trailer_expr
801
|=
trailer_expr -> trailer trailer_expr
801
>=
trailer_expr -> trailer trailer_expr
801
*
trailer_expr -> trailer trailer_expr
801
**
trailer_expr -> trailer trailer_expr
802
[
166
802
factor
167
802
True
168
802
atom_expr
169
802
~
170
802
not
171
802
and_expr
172
802
-
173
802
{
174
802
shift_expr
175
802
atom
176
802
]
1383
802
comparison
178
802
(
179
802
arith_expr
180
802
power
181
802
STRING
182
802
NAME
183
802
test
184
802
and_test
185
802
term
186
802
+
187
802
xor_expr
188
802
NUMBER
190
802
test_list_comp
1384
802
False
191
802
expr
192
802
not_test
193
802
None
194
802
lambdef
195
802
lambda
196
802
or_test
197
802
test_list
198
803
not
term -> factor
803
@
1385
803
//
1386
803
%
1387
803
/
1388
803
*
1389
803
<=
term -> factor
803
>
term -> factor
803
==
term -> factor
803
is
term -> factor
803
or
term -> factor
803
<
term -> factor
803
and
term -> factor
803
<<
term -> factor
803
^
term -> factor
803
:
term -> factor
803
!=
term -> factor
803
-
term -> factor
803
&
term -> factor
803
|
term -> factor
803
,
term -> factor
803
>=
term -> factor
803
if
term -> factor
803
+
term -> factor
803
in
term -> factor
803
>>
term -> factor
803
]
term -> factor
804
<<
atom -> True
804
&
atom -> True
804
or
atom -> True
804
[
atom -> True
804
if
atom -> True
804
:
atom -> True
804
-
atom -> True
804
*
atom -> True
804
^
atom -> True
804
,
atom -> True
804
>=
atom -> True
804
!=
atom -> True
804
(
atom -> True
804
not
atom -> True
804
|
atom -> True
804
]
atom -> True
804
+
atom -> True
804
**
atom -> True
804
.
atom -> True
804
is
atom -> True
804
//
atom -> True
804
>
atom -> True
804
%
atom -> True
804
in
atom -> True
804
<=
atom -> True
804
>>
atom -> True
804
/
atom -> True
804
==
atom -> True
804
and
atom -> True
804
<
atom -> True
804
@
atom -> True
805
]
1390
806
[
802
806
True
804
806
atom_expr
810
806
-
809
806
~
806
806
atom
812
806
{
813
806
(
816
806
power
818
806
STRING
819
806
NAME
820
806
+
823
806
NUMBER
826
806
False
827
806
factor
1391
806
None
831
807
[
802
807
factor
803
807
True
804
807
atom_expr
810
807
~
806
807
not
807
807
and_expr
808
807
-
809
807
shift_expr
811
807
atom
812
807
{
813
807
comparison
814
807
(
816
807
arith_expr
817
807
power
818
807
STRING
819
807
NAME
820
807
term
822
807
+
823
807
xor_expr
824
807
NUMBER
826
807
False
827
807
not_test
1392
807
expr
829
807
None
831
808
>
xor_expr -> and_expr
808
<=
xor_expr -> and_expr
808
not
xor_expr -> and_expr
808
|
xor_expr -> and_expr
808
^
1393
808
==
xor_expr -> and_expr
808
,
xor_expr -> and_expr
808
in
xor_expr -> and_expr
808
!=
xor_expr -> and_expr
808
:
xor_expr -> and_expr
808
if
xor_expr -> and_expr
808
is
xor_expr -> and_expr
808
<
xor_expr -> and_expr
808
or
xor_expr -> and_expr
808
]
xor_expr -> and_expr
808
and
xor_expr -> and_expr
808
>=
xor_expr -> and_expr
809
[
802
809
True
804
809
atom_expr
810
809
~
806
809
-
809
809
atom
812
809
{
813
809
(
816
809
power
818
809
STRING
819
809
NAME
820
809
factor
1394
809
+
823
809
NUMBER
826
809
False
827
809
None
831
810
**
1395
810
,
power -> atom_expr
810
!=
power -> atom_expr
810
-
power -> atom_expr
810
<<
power -> atom_expr
810
:
power -> atom_expr
810
/
power -> atom_expr
810
<=
power -> atom_expr
810
in
power -> atom_expr
810
not
power -> atom_expr
810
%
power -> atom_expr
810
>
power -> atom_expr
810
@
power -> atom_expr
810
|
power -> atom_expr
810
<
power -> atom_expr
810
>>
power -> atom_expr
810
]
power -> atom_expr
810
or
power -> atom_expr
810
and
power -> atom_expr
810
>=
power -> atom_expr
810
==
power -> atom_expr
810
^
power -> atom_expr
810
*
power -> atom_expr
810
&
power -> atom_expr
810
is
power -> atom_expr
810
+
power -> atom_expr
810
if
power -> atom_expr
810
//
power -> atom_expr
811
^
and_expr -> shift_expr
811
in
and_expr -> shift_expr
811
|
and_expr -> shift_expr
811
&
1396
811
<
and_expr -> shift_expr
811
not
and_expr -> shift_expr
811
>=
and_expr -> shift_expr
811
]
and_expr -> shift_expr
811
<=
and_expr -> shift_expr
811
or
and_expr -> shift_expr
811
and
and_expr -> shift_expr
811
,
and_expr -> shift_expr
811
:
and_expr -> shift_expr
811
!=
and_expr -> shift_expr
811
if
and_expr -> shift_expr
811
is
and_expr -> shift_expr
811
==
and_expr -> shift_expr
811
>
and_expr -> shift_expr
812
>>
trailer_expr -> 
812
(
1397
812
trailer
1398
812
trailer_expr
1399
812
.
1400
812
+
trailer_expr -> 
812
[
1401
812
is
trailer_expr -> 
812
>
trailer_expr -> 
812
not
trailer_expr -> 
812
|
trailer_expr -> 
812
&
trailer_expr -> 
812
/
trailer_expr -> 
812
@
trailer_expr -> 
812
!=
trailer_expr -> 
812
**
trailer_expr -> 
812
>=
trailer_expr -> 
812
^
trailer_expr -> 
812
in
trailer_expr -> 
812
]
trailer_expr -> 
812
<<
trailer_expr -> 
812
and
trailer_expr -> 
812
or
trailer_expr -> 
812
if
trailer_expr -> 
812
:
trailer_expr -> 
812
//
trailer_expr -> 
812
%
trailer_expr -> 
812
,
trailer_expr -> 
812
<=
trailer_expr -> 
812
<
trailer_expr -> 
812
==
trailer_expr -> 
812
-
trailer_expr -> 
812
*
trailer_expr -> 
813
}
1402
814
or
not_test -> comparison
814
,
not_test -> comparison
814
]
not_test -> comparison
814
:
not_test -> comparison
814
and
not_test -> comparison
814
if
not_test -> comparison
815
if
1403
815
:
test -> or_test
815
,
test -> or_test
815
]
test -> or_test
816
[
128
816
factor
129
816
True
130
816
atom_expr
131
816
~
132
816
and_expr
133
816
-
134
816
{
135
816
test_list_comp
1404
816
shift_expr
137
816
atom
138
816
)
1405
816
comparison
140
816
arith_expr
141
816
power
142
816
STRING
143
816
NAME
144
816
(
145
816
and_test
146
816
term
147
816
+
148
816
xor_expr
149
816
or_test
150
816
NUMBER
151
816
not
152
816
False
153
816
expr
154
816
not_test
155
816
None
156
816
lambdef
157
816
lambda
158
816
test
159
816
test_list
160
817
>>
1406
817
<<
1407
817
if
shift_expr -> arith_expr
817
&
shift_expr -> arith_expr
817
|
shift_expr -> arith_expr
817
is
shift_expr -> arith_expr
817
<
shift_expr -> arith_expr
817
==
shift_expr -> arith_expr
817
or
shift_expr -> arith_expr
817
>
shift_expr -> arith_expr
817
!=
shift_expr -> arith_expr
817
>=
shift_expr -> arith_expr
817
]
shift_expr -> arith_expr
817
in
shift_expr -> arith_expr
817
,
shift_expr -> arith_expr
817
<=
shift_expr -> arith_expr
817
:
shift_expr -> arith_expr
817
and
shift_expr -> arith_expr
817
^
shift_expr -> arith_expr
817
not
shift_expr -> arith_expr
818
+
factor -> power
818
%
factor -> power
818
:
factor -> power
818
,
factor -> power
818
<
factor -> power
818
<<
factor -> power
818
!=
factor -> power
818
<=
factor -> power
818
and
factor -> power
818
/
factor -> power
818
^
factor -> power
818
@
factor -> power
818
>=
factor -> power
818
not
factor -> power
818
//
factor -> power
818
or
factor -> power
818
==
factor -> power
818
is
factor -> power
818
]
factor -> power
818
|
factor -> power
818
*
factor -> power
818
-
factor -> power
818
if
factor -> power
818
>
factor -> power
818
in
factor -> power
818
>>
factor -> power
818
&
factor -> power
819
%
atom -> STRING
819
>
atom -> STRING
819
@
atom -> STRING
819
<<
atom -> STRING
819
in
atom -> STRING
819
[
atom -> STRING
819
-
atom -> STRING
819
==
atom -> STRING
819
>=
atom -> STRING
819
not
atom -> STRING
819
/
atom -> STRING
819
+
atom -> STRING
819
*
atom -> STRING
819
(
atom -> STRING
819
//
atom -> STRING
819
if
atom -> STRING
819
.
atom -> STRING
819
<
atom -> STRING
819
,
atom -> STRING
819
&
atom -> STRING
819
<=
atom -> STRING
819
!=
atom -> STRING
819
**
atom -> STRING
819
^
atom -> STRING
819
:
atom -> STRING
819
and
atom -> STRING
819
]
atom -> STRING
819
is
atom -> STRING
819
|
atom -> STRING
819
or
atom -> STRING
819
>>
atom -> STRING
820
<
atom -> NAME
820
,
atom -> NAME
820
^
atom -> NAME
820
+
atom -> NAME
820
-
atom -> NAME
820
>=
atom -> NAME
820
@
atom -> NAME
820
!=
atom -> NAME
820
*
atom -> NAME
820
<=
atom -> NAME
820
**
atom -> NAME
820
or
atom -> NAME
820
not
atom -> NAME
820
==
atom -> NAME
820
&
atom -> NAME
820
]
atom -> NAME
820
>
atom -> NAME
820
>>
atom -> NAME
820
%
atom -> NAME
820
.
atom -> NAME
820
|
atom -> NAME
820
is
atom -> NAME
820
and
atom -> NAME
820
//
atom -> NAME
820
[
atom -> NAME
820
/
atom -> NAME
820
(
atom -> NAME
820
<<
atom -> NAME
820
if
atom -> NAME
820
in
atom -> NAME
820
:
atom -> NAME
821
]
or_test -> and_test
821
or
1408
821
,
or_test -> and_test
821
if
or_test -> and_test
821
:
or_test -> and_test
822
-
1409
822
+
1410
822
]
arith_expr -> term
822
|
arith_expr -> term
822
>=
arith_expr -> term
822
<=
arith_expr -> term
822
not
arith_expr -> term
822
,
arith_expr -> term
822
==
arith_expr -> term
822
in
arith_expr -> term
822
>>
arith_expr -> term
822
is
arith_expr -> term
822
if
arith_expr -> term
822
or
arith_expr -> term
822
!=
arith_expr -> term
822
>
arith_expr -> term
822
:
arith_expr -> term
822
and
arith_expr -> term
822
<<
arith_expr -> term
822
<
arith_expr -> term
822
^
arith_expr -> term
822
&
arith_expr -> term
823
[
802
823
True
804
823
atom_expr
810
823
-
809
823
~
806
823
atom
812
823
{
813
823
(
816
823
power
818
823
STRING
819
823
NAME
820
823
factor
1411
823
+
823
823
NUMBER
826
823
False
827
823
None
831
824
|
1412
824
]
expr -> xor_expr
824
>
expr -> xor_expr
824
if
expr -> xor_expr
824
is
expr -> xor_expr
824
and
expr -> xor_expr
824
not
expr -> xor_expr
824
or
expr -> xor_expr
824
>=
expr -> xor_expr
824
==
expr -> xor_expr
824
,
expr -> xor_expr
824
:
expr -> xor_expr
824
<
expr -> xor_expr
824
!=
expr -> xor_expr
824
<=
expr -> xor_expr
824
in
expr -> xor_expr
825
:
maybe_test -> test
825
,
subscript -> test
825
]
subscript -> test
826
+
atom -> NUMBER
826
*
atom -> NUMBER
826
>
atom -> NUMBER
826
<<
atom -> NUMBER
826
-
atom -> NUMBER
826
**
atom -> NUMBER
826
if
atom -> NUMBER
826
or
atom -> NUMBER
826
is
atom -> NUMBER
826
[
atom -> NUMBER
826
(
atom -> NUMBER
826
not
atom -> NUMBER
826
&
atom -> NUMBER
826
^
atom -> NUMBER
826
in
atom -> NUMBER
826
==
atom -> NUMBER
826
//
atom -> NUMBER
826
!=
atom -> NUMBER
826
and
atom -> NUMBER
826
]
atom -> NUMBER
826
%
atom -> NUMBER
826
<=
atom -> NUMBER
826
.
atom -> NUMBER
826
<
atom -> NUMBER
826
>>
atom -> NUMBER
826
,
atom -> NUMBER
826
/
atom -> NUMBER
826
@
atom -> NUMBER
826
>=
atom -> NUMBER
826
|
atom -> NUMBER
826
:
atom -> NUMBER
827
(
atom -> False
827
*
atom -> False
827
==
atom -> False
827
|
atom -> False
827
,
atom -> False
827
]
atom -> False
827
[
atom -> False
827
in
atom -> False
827
&
atom -> False
827
is
atom -> False
827
not
atom -> False
827
if
atom -> False
827
^
atom -> False
827
+
atom -> False
827
>
atom -> False
827
<=
atom -> False
827
<<
atom -> False
827
<
atom -> False
827
>=
atom -> False
827
:
atom -> False
827
%
atom -> False
827
@
atom -> False
827
and
atom -> False
827
!=
atom -> False
827
-
atom -> False
827
.
atom -> False
827
//
atom -> False
827
/
atom -> False
827
**
atom -> False
827
>>
atom -> False
827
or
atom -> False
828
,
1413
828
]
subscriptlist -> subscript
829
>
317
829
is
318
829
in
319
829
<=
320
829
<
321
829
>=
322
829
:
comparison -> expr
829
!=
324
829
not
325
829
==
326
829
comp_op
1414
829
or
comparison -> expr
829
if
comparison -> expr
829
]
comparison -> expr
829
and
comparison -> expr
829
,
comparison -> expr
830
]
and_test -> not_test
830
and
1415
830
:
and_test -> not_test
830
,
and_test -> not_test
830
if
and_test -> not_test
830
or
and_test -> not_test
831
@
atom -> None
831
<=
atom -> None
831
in
atom -> None
831
and
atom -> None
831
&
atom -> None
831
|
atom -> None
831
>
atom -> None
831
>=
atom -> None
831
/
atom -> None
831
<<
atom -> None
831
-
atom -> None
831
!=
atom -> None
831
**
atom -> None
831
(
atom -> None
831
]
atom -> None
831
*
atom -> None
831
.
atom -> None
831
>>
atom -> None
831
==
atom -> None
831
is
atom -> None
831
<
atom -> None
831
if
atom -> None
831
^
atom -> None
831
[
atom -> None
831
%
atom -> None
831
+
atom -> None
831
not
atom -> None
831
,
atom -> None
831
:
atom -> None
831
or
atom -> None
831
//
atom -> None
832
]
test -> lambdef
832
:
test -> lambdef
832
,
test -> lambdef
833
vfpdef
234
833
varargslist
1416
833
:
1417
833
NAME
233
834
:
1418
835
!=
atom -> [ ]
835
>>
atom -> [ ]
835
|
atom -> [ ]
835
NEWLINE
atom -> [ ]
835
<<
atom -> [ ]
835
>
atom -> [ ]
835
.
atom -> [ ]
835
%
atom -> [ ]
835
^
atom -> [ ]
835
-
atom -> [ ]
835
,
atom -> [ ]
835
in
atom -> [ ]
835
or
atom -> [ ]
835
/
atom -> [ ]
835
**
atom -> [ ]
835
//
atom -> [ ]
835
not
atom -> [ ]
835
(
atom -> [ ]
835
+
atom -> [ ]
835
and
atom -> [ ]
835
==
atom -> [ ]
835
[
atom -> [ ]
835
if
atom -> [ ]
835
<
atom -> [ ]
835
<=
atom -> [ ]
835
>=
atom -> [ ]
835
is
atom -> [ ]
835
*
atom -> [ ]
835
@
atom -> [ ]
835
&
atom -> [ ]
836
]
1419
837
term
1420
837
[
334
837
factor
335
837
True
336
837
atom_expr
337
837
~
338
837
-
340
837
None
341
837
atom
343
837
{
344
837
power
347
837
STRING
348
837
NAME
349
837
(
350
837
NUMBER
351
837
+
354
837
False
357
838
[
334
838
factor
335
838
True
336
838
term
1421
838
~
338
838
-
340
838
atom_expr
337
838
None
341
838
atom
343
838
{
344
838
power
347
838
STRING
348
838
NAME
349
838
(
350
838
NUMBER
351
838
+
354
838
False
357
839
[
334
839
factor
335
839
True
336
839
atom_expr
337
839
~
338
839
-
340
839
None
341
839
atom
343
839
{
344
839
power
347
839
STRING
348
839
NAME
349
839
(
350
839
NUMBER
351
839
term
1422
839
+
354
839
False
357
840
[
334
840
factor
335
840
True
336
840
atom_expr
337
840
~
338
840
-
340
840
None
341
840
atom
343
840
{
344
840
power
347
840
STRING
348
840
NAME
349
840
(
350
840
NUMBER
351
840
term
1423
840
+
354
840
False
357
841
[
334
841
factor
335
841
True
336
841
atom_expr
337
841
~
338
841
-
340
841
None
341
841
atom
343
841
{
344
841
power
347
841
STRING
348
841
NAME
349
841
term
1424
841
(
350
841
NUMBER
351
841
+
354
841
False
357
842
[
334
842
True
336
842
atom_expr
337
842
-
340
842
~
338
842
None
341
842
atom
343
842
{
344
842
power
347
842
STRING
348
842
NAME
349
842
(
350
842
NUMBER
351
842
+
354
842
False
357
842
factor
1425
843
@
factor -> ~ factor
843
NEWLINE
factor -> ~ factor
843
>>
factor -> ~ factor
843
<=
factor -> ~ factor
843
and
factor -> ~ factor
843
+
factor -> ~ factor
843
*
factor -> ~ factor
843
!=
factor -> ~ factor
843
%
factor -> ~ factor
843
<<
factor -> ~ factor
843
>=
factor -> ~ factor
843
,
factor -> ~ factor
843
&
factor -> ~ factor
843
is
factor -> ~ factor
843
==
factor -> ~ factor
843
//
factor -> ~ factor
843
<
factor -> ~ factor
843
/
factor -> ~ factor
843
not
factor -> ~ factor
843
-
factor -> ~ factor
843
or
factor -> ~ factor
843
|
factor -> ~ factor
843
>
factor -> ~ factor
843
^
factor -> ~ factor
843
if
factor -> ~ factor
843
in
factor -> ~ factor
844
[
334
844
factor
335
844
True
336
844
atom_expr
337
844
~
338
844
and_expr
339
844
-
340
844
None
341
844
shift_expr
342
844
atom
343
844
{
344
844
xor_expr
1426
844
arith_expr
346
844
power
347
844
STRING
348
844
NAME
349
844
(
350
844
NUMBER
351
844
term
353
844
+
354
844
False
357
845
@
factor -> - factor
845
<=
factor -> - factor
845
in
factor -> - factor
845
>>
factor -> - factor
845
|
factor -> - factor
845
is
factor -> - factor
845
+
factor -> - factor
845
%
factor -> - factor
845
<
factor -> - factor
845
*
factor -> - factor
845
<<
factor -> - factor
845
if
factor -> - factor
845
-
factor -> - factor
845
>=
factor -> - factor
845
not
factor -> - factor
845
and
factor -> - factor
845
/
factor -> - factor
845
or
factor -> - factor
845
NEWLINE
factor -> - factor
845
^
factor -> - factor
845
>
factor -> - factor
845
!=
factor -> - factor
845
&
factor -> - factor
845
==
factor -> - factor
845
//
factor -> - factor
845
,
factor -> - factor
846
[
334
846
factor
335
846
True
336
846
atom_expr
337
846
~
338
846
-
340
846
None
341
846
shift_expr
342
846
atom
343
846
{
344
846
arith_expr
346
846
power
347
846
STRING
348
846
NAME
349
846
(
350
846
NUMBER
351
846
term
353
846
+
354
846
and_expr
1427
846
False
357
847
[
766
847
factor
767
847
True
768
847
atom_expr
769
847
~
770
847
and_expr
771
847
-
772
847
{
773
847
shift_expr
774
847
atom
775
847
comparison
776
847
and_test
777
847
arith_expr
778
847
power
779
847
STRING
780
847
NAME
781
847
(
782
847
term
784
847
+
785
847
xor_expr
786
847
)
1428
847
or_test
788
847
arglist
1429
847
NUMBER
789
847
not
790
847
False
791
847
expr
792
847
*
793
847
not_test
794
847
None
795
847
lambdef
796
847
lambda
797
847
test
798
847
argument
799
847
**
800
848
trailer_expr
1430
848
>>
trailer_expr -> 
848
(
847
848
trailer
848
848
.
850
848
+
trailer_expr -> 
848
[
851
848
is
trailer_expr -> 
848
>
trailer_expr -> 
848
not
trailer_expr -> 
848
|
trailer_expr -> 
848
NEWLINE
trailer_expr -> 
848
&
trailer_expr -> 
848
/
trailer_expr -> 
848
@
trailer_expr -> 
848
!=
trailer_expr -> 
848
**
trailer_expr -> 
848
>=
trailer_expr -> 
848
^
trailer_expr -> 
848
in
trailer_expr -> 
848
<<
trailer_expr -> 
848
and
trailer_expr -> 
848
or
trailer_expr -> 
848
if
trailer_expr -> 
848
//
trailer_expr -> 
848
%
trailer_expr -> 
848
,
trailer_expr -> 
848
<=
trailer_expr -> 
848
<
trailer_expr -> 
848
==
trailer_expr -> 
848
-
trailer_expr -> 
848
*
trailer_expr -> 
849
^
atom_expr -> atom trailer_expr
849
or
atom_expr -> atom trailer_expr
849
&
atom_expr -> atom trailer_expr
849
@
atom_expr -> atom trailer_expr
849
|
atom_expr -> atom trailer_expr
849
-
atom_expr -> atom trailer_expr
849
*
atom_expr -> atom trailer_expr
849
%
atom_expr -> atom trailer_expr
849
==
atom_expr -> atom trailer_expr
849
**
atom_expr -> atom trailer_expr
849
and
atom_expr -> atom trailer_expr
849
NEWLINE
atom_expr -> atom trailer_expr
849
is
atom_expr -> atom trailer_expr
849
in
atom_expr -> atom trailer_expr
849
<<
atom_expr -> atom trailer_expr
849
!=
atom_expr -> atom trailer_expr
849
<=
atom_expr -> atom trailer_expr
849
/
atom_expr -> atom trailer_expr
849
//
atom_expr -> atom trailer_expr
849
<
atom_expr -> atom trailer_expr
849
>=
atom_expr -> atom trailer_expr
849
>>
atom_expr -> atom trailer_expr
849
if
atom_expr -> atom trailer_expr
849
not
atom_expr -> atom trailer_expr
849
+
atom_expr -> atom trailer_expr
849
>
atom_expr -> atom trailer_expr
849
,
atom_expr -> atom trailer_expr
850
NAME
1431
851
[
802
851
factor
803
851
True
804
851
atom_expr
810
851
~
806
851
not
807
851
and_expr
808
851
-
809
851
shift_expr
811
851
atom
812
851
{
813
851
comparison
814
851
or_test
815
851
(
816
851
arith_expr
817
851
power
818
851
STRING
819
851
NAME
820
851
and_test
821
851
subscriptlist
1432
851
term
822
851
+
823
851
xor_expr
824
851
test
825
851
NUMBER
826
851
False
827
851
subscript
828
851
expr
829
851
not_test
830
851
None
831
851
lambdef
832
851
lambda
833
851
maybe_test
834
851
:
maybe_test -> 
852
in
atom -> { }
852
<=
atom -> { }
852
*
atom -> { }
852
NEWLINE
atom -> { }
852
>
atom -> { }
852
+
atom -> { }
852
@
atom -> { }
852
,
atom -> { }
852
>=
atom -> { }
852
/
atom -> { }
852
|
atom -> { }
852
is
atom -> { }
852
and
atom -> { }
852
if
atom -> { }
852
(
atom -> { }
852
>>
atom -> { }
852
not
atom -> { }
852
-
atom -> { }
852
<<
atom -> { }
852
**
atom -> { }
852
or
atom -> { }
852
<
atom -> { }
852
!=
atom -> { }
852
==
atom -> { }
852
%
atom -> { }
852
//
atom -> { }
852
&
atom -> { }
852
[
atom -> { }
852
.
atom -> { }
852
^
atom -> { }
853
[
334
853
factor
335
853
True
336
853
atom_expr
337
853
~
338
853
-
340
853
None
341
853
atom
343
853
{
344
853
arith_expr
346
853
power
347
853
STRING
348
853
NAME
349
853
shift_expr
1433
853
(
350
853
NUMBER
351
853
term
353
853
+
354
853
False
357
854
[
334
854
factor
335
854
True
336
854
atom_expr
337
854
~
338
854
-
340
854
None
341
854
atom
343
854
{
344
854
arith_expr
346
854
power
347
854
STRING
348
854
NAME
349
854
(
350
854
NUMBER
351
854
term
353
854
+
354
854
False
357
854
shift_expr
1434
855
)
1435
856
or
atom -> ( )
856
>>
atom -> ( )
856
(
atom -> ( )
856
<=
atom -> ( )
856
.
atom -> ( )
856
is
atom -> ( )
856
@
atom -> ( )
856
,
atom -> ( )
856
%
atom -> ( )
856
<<
atom -> ( )
856
**
atom -> ( )
856
^
atom -> ( )
856
/
atom -> ( )
856
if
atom -> ( )
856
not
atom -> ( )
856
*
atom -> ( )
856
!=
atom -> ( )
856
<
atom -> ( )
856
NEWLINE
atom -> ( )
856
&
atom -> ( )
856
-
atom -> ( )
856
>
atom -> ( )
856
//
atom -> ( )
856
==
atom -> ( )
856
in
atom -> ( )
856
+
atom -> ( )
856
[
atom -> ( )
856
>=
atom -> ( )
856
and
atom -> ( )
856
|
atom -> ( )
857
[
334
857
factor
335
857
True
336
857
atom_expr
337
857
~
338
857
and_expr
339
857
-
340
857
None
341
857
shift_expr
342
857
atom
343
857
{
344
857
comparison
345
857
arith_expr
346
857
power
347
857
STRING
348
857
NAME
349
857
(
350
857
NUMBER
351
857
and_test
352
857
term
353
857
+
354
857
xor_expr
355
857
not
356
857
False
357
857
not_test
359
857
expr
362
857
or_test
1436
858
[
334
858
factor
335
858
True
336
858
atom_expr
337
858
~
338
858
-
340
858
None
341
858
arith_expr
1437
858
atom
343
858
{
344
858
power
347
858
STRING
348
858
NAME
349
858
(
350
858
NUMBER
351
858
term
353
858
+
354
858
False
357
859
[
334
859
factor
335
859
True
336
859
atom_expr
337
859
~
338
859
-
340
859
None
341
859
atom
343
859
{
344
859
arith_expr
1438
859
power
347
859
STRING
348
859
NAME
349
859
(
350
859
NUMBER
351
859
term
353
859
+
354
859
False
357
860
-
factor -> + factor
860
@
factor -> + factor
860
<<
factor -> + factor
860
is
factor -> + factor
860
and
factor -> + factor
860
<=
factor -> + factor
860
or
factor -> + factor
860
<
factor -> + factor
860
^
factor -> + factor
860
not
factor -> + factor
860
//
factor -> + factor
860
,
factor -> + factor
860
*
factor -> + factor
860
in
factor -> + factor
860
&
factor -> + factor
860
+
factor -> + factor
860
if
factor -> + factor
860
>>
factor -> + factor
860
|
factor -> + factor
860
%
factor -> + factor
860
>
factor -> + factor
860
NEWLINE
factor -> + factor
860
>=
factor -> + factor
860
!=
factor -> + factor
860
/
factor -> + factor
860
==
factor -> + factor
861
[
334
861
factor
335
861
True
336
861
atom_expr
337
861
~
338
861
and_expr
339
861
-
340
861
None
341
861
shift_expr
342
861
atom
343
861
{
344
861
expr
1439
861
arith_expr
346
861
power
347
861
STRING
348
861
NAME
349
861
(
350
861
NUMBER
351
861
term
353
861
+
354
861
xor_expr
355
861
False
357
862
,
not_test -> not not_test
862
NEWLINE
not_test -> not not_test
862
and
not_test -> not not_test
862
or
not_test -> not not_test
862
if
not_test -> not not_test
863
:
1440
864
[
334
864
factor
335
864
True
336
864
atom_expr
337
864
~
338
864
and_expr
339
864
-
340
864
None
341
864
shift_expr
342
864
atom
343
864
{
344
864
comparison
345
864
arith_expr
346
864
power
347
864
STRING
348
864
NAME
349
864
(
350
864
NUMBER
351
864
and_test
352
864
term
353
864
+
354
864
xor_expr
355
864
not
356
864
False
357
864
lambda
358
864
not_test
359
864
lambdef
361
864
expr
362
864
or_test
363
864
test
1441
865
[
334
865
factor
335
865
True
336
865
atom_expr
337
865
~
338
865
and_expr
339
865
-
340
865
None
341
865
shift_expr
342
865
atom
343
865
{
344
865
comparison
345
865
arith_expr
346
865
power
347
865
STRING
348
865
NAME
349
865
(
350
865
NUMBER
351
865
term
353
865
+
354
865
xor_expr
355
865
not
356
865
False
357
865
and_test
1442
865
not_test
359
865
expr
362
866
[
334
866
factor
335
866
True
336
866
atom_expr
337
866
~
338
866
and_expr
339
866
-
340
866
None
341
866
shift_expr
342
866
atom
343
866
{
344
866
arith_expr
346
866
power
347
866
STRING
348
866
NAME
349
866
(
350
866
NUMBER
351
866
term
353
866
+
354
866
xor_expr
355
866
False
357
866
expr
362
866
comparison
1443
867
[
738
867
factor
740
867
True
741
867
~
742
867
and_expr
743
867
-
744
867
atom
745
867
{
746
867
arith_expr
747
867
power
748
867
atom_expr
749
867
STRING
750
867
NAME
751
867
(
752
867
term
753
867
+
754
867
xor_expr
755
867
shift_expr
756
867
NUMBER
757
867
not
758
867
False
759
867
comparison
760
867
not_test
761
867
None
762
867
expr
763
867
and_test
764
867
or_test
1444
868
[
334
868
factor
335
868
True
336
868
atom_expr
337
868
~
338
868
and_expr
339
868
-
340
868
None
341
868
shift_expr
342
868
atom
343
868
{
344
868
comparison
345
868
arith_expr
346
868
power
347
868
STRING
348
868
NAME
349
868
(
350
868
NUMBER
351
868
and_test
352
868
term
353
868
+
354
868
xor_expr
355
868
not
356
868
False
357
868
lambda
358
868
test_list
1445
868
not_test
359
868
lambdef
361
868
expr
362
868
or_test
363
868
test
364
869
!=
atom -> [ ]
869
>>
atom -> [ ]
869
|
atom -> [ ]
869
NEWLINE
atom -> [ ]
869
<<
atom -> [ ]
869
>
atom -> [ ]
869
.
atom -> [ ]
869
%
atom -> [ ]
869
^
atom -> [ ]
869
-
atom -> [ ]
869
from
atom -> [ ]
869
in
atom -> [ ]
869
or
atom -> [ ]
869
/
atom -> [ ]
869
**
atom -> [ ]
869
//
atom -> [ ]
869
not
atom -> [ ]
869
(
atom -> [ ]
869
+
atom -> [ ]
869
and
atom -> [ ]
869
==
atom -> [ ]
869
[
atom -> [ ]
869
if
atom -> [ ]
869
<
atom -> [ ]
869
<=
atom -> [ ]
869
>=
atom -> [ ]
869
is
atom -> [ ]
869
*
atom -> [ ]
869
@
atom -> [ ]
869
&
atom -> [ ]
870
]
1446
871
[
366
871
atom_expr
367
871
True
369
871
-
372
871
~
370
871
None
373
871
atom
374
871
{
375
871
power
378
871
STRING
379
871
NAME
380
871
(
381
871
NUMBER
382
871
+
386
871
False
392
871
factor
1447
872
term
1448
872
[
366
872
atom_expr
367
872
factor
368
872
True
369
872
~
370
872
-
372
872
None
373
872
atom
374
872
{
375
872
power
378
872
STRING
379
872
NAME
380
872
(
381
872
NUMBER
382
872
+
386
872
False
392
873
[
366
873
atom_expr
367
873
factor
368
873
True
369
873
term
1449
873
~
370
873
-
372
873
None
373
873
atom
374
873
{
375
873
power
378
873
STRING
379
873
NAME
380
873
(
381
873
NUMBER
382
873
+
386
873
False
392
874
[
366
874
atom_expr
367
874
factor
368
874
True
369
874
~
370
874
-
372
874
None
373
874
atom
374
874
{
375
874
power
378
874
STRING
379
874
NAME
380
874
(
381
874
NUMBER
382
874
term
1450
874
+
386
874
False
392
875
[
366
875
atom_expr
367
875
factor
368
875
True
369
875
~
370
875
-
372
875
None
373
875
atom
374
875
{
375
875
power
378
875
STRING
379
875
NAME
380
875
(
381
875
NUMBER
382
875
term
1451
875
+
386
875
False
392
876
[
366
876
atom_expr
367
876
factor
368
876
True
369
876
~
370
876
-
372
876
None
373
876
atom
374
876
{
375
876
power
378
876
STRING
379
876
NAME
380
876
term
1452
876
(
381
876
NUMBER
382
876
+
386
876
False
392
877
@
factor -> ~ factor
877
NEWLINE
factor -> ~ factor
877
>>
factor -> ~ factor
877
<=
factor -> ~ factor
877
and
factor -> ~ factor
877
+
factor -> ~ factor
877
from
factor -> ~ factor
877
*
factor -> ~ factor
877
!=
factor -> ~ factor
877
%
factor -> ~ factor
877
<<
factor -> ~ factor
877
>=
factor -> ~ factor
877
&
factor -> ~ factor
877
is
factor -> ~ factor
877
==
factor -> ~ factor
877
//
factor -> ~ factor
877
<
factor -> ~ factor
877
/
factor -> ~ factor
877
not
factor -> ~ factor
877
-
factor -> ~ factor
877
or
factor -> ~ factor
877
|
factor -> ~ factor
877
>
factor -> ~ factor
877
^
factor -> ~ factor
877
if
factor -> ~ factor
877
in
factor -> ~ factor
878
[
366
878
atom_expr
367
878
factor
368
878
True
369
878
~
370
878
and_expr
371
878
-
372
878
None
373
878
atom
374
878
{
375
878
xor_expr
1453
878
arith_expr
377
878
power
378
878
STRING
379
878
NAME
380
878
(
381
878
NUMBER
382
878
term
385
878
+
386
878
shift_expr
388
878
False
392
879
@
factor -> - factor
879
<=
factor -> - factor
879
in
factor -> - factor
879
>>
factor -> - factor
879
|
factor -> - factor
879
is
factor -> - factor
879
+
factor -> - factor
879
%
factor -> - factor
879
<
factor -> - factor
879
*
factor -> - factor
879
<<
factor -> - factor
879
if
factor -> - factor
879
-
factor -> - factor
879
>=
factor -> - factor
879
not
factor -> - factor
879
and
factor -> - factor
879
from
factor -> - factor
879
/
factor -> - factor
879
or
factor -> - factor
879
NEWLINE
factor -> - factor
879
^
factor -> - factor
879
>
factor -> - factor
879
!=
factor -> - factor
879
&
factor -> - factor
879
==
factor -> - factor
879
//
factor -> - factor
880
[
766
880
factor
767
880
True
768
880
atom_expr
769
880
~
770
880
and_expr
771
880
-
772
880
{
773
880
shift_expr
774
880
atom
775
880
comparison
776
880
and_test
777
880
arith_expr
778
880
power
779
880
STRING
780
880
NAME
781
880
(
782
880
term
784
880
+
785
880
xor_expr
786
880
)
1454
880
or_test
788
880
arglist
1455
880
NUMBER
789
880
not
790
880
False
791
880
expr
792
880
*
793
880
not_test
794
880
None
795
880
lambdef
796
880
lambda
797
880
test
798
880
argument
799
880
**
800
881
trailer_expr
1456
881
>>
trailer_expr -> 
881
(
880
881
trailer
881
881
.
883
881
+
trailer_expr -> 
881
from
trailer_expr -> 
881
is
trailer_expr -> 
881
>
trailer_expr -> 
881
not
trailer_expr -> 
881
|
trailer_expr -> 
881
[
884
881
NEWLINE
trailer_expr -> 
881
&
trailer_expr -> 
881
/
trailer_expr -> 
881
@
trailer_expr -> 
881
!=
trailer_expr -> 
881
**
trailer_expr -> 
881
>=
trailer_expr -> 
881
^
trailer_expr -> 
881
in
trailer_expr -> 
881
<<
trailer_expr -> 
881
and
trailer_expr -> 
881
or
trailer_expr -> 
881
if
trailer_expr -> 
881
//
trailer_expr -> 
881
%
trailer_expr -> 
881
<=
trailer_expr -> 
881
<
trailer_expr -> 
881
==
trailer_expr -> 
881
-
trailer_expr -> 
881
*
trailer_expr -> 
882
^
atom_expr -> atom trailer_expr
882
or
atom_expr -> atom trailer_expr
882
&
atom_expr -> atom trailer_expr
882
@
atom_expr -> atom trailer_expr
882
|
atom_expr -> atom trailer_expr
882
-
atom_expr -> atom trailer_expr
882
*
atom_expr -> atom trailer_expr
882
%
atom_expr -> atom trailer_expr
882
==
atom_expr -> atom trailer_expr
882
**
atom_expr -> atom trailer_expr
882
and
atom_expr -> atom trailer_expr
882
NEWLINE
atom_expr -> atom trailer_expr
882
is
atom_expr -> atom trailer_expr
882
in
atom_expr -> atom trailer_expr
882
<<
atom_expr -> atom trailer_expr
882
!=
atom_expr -> atom trailer_expr
882
<=
atom_expr -> atom trailer_expr
882
/
atom_expr -> atom trailer_expr
882
//
atom_expr -> atom trailer_expr
882
<
atom_expr -> atom trailer_expr
882
from
atom_expr -> atom trailer_expr
882
>=
atom_expr -> atom trailer_expr
882
>>
atom_expr -> atom trailer_expr
882
if
atom_expr -> atom trailer_expr
882
not
atom_expr -> atom trailer_expr
882
+
atom_expr -> atom trailer_expr
882
>
atom_expr -> atom trailer_expr
883
NAME
1457
884
[
802
884
factor
803
884
True
804
884
atom_expr
810
884
~
806
884
not
807
884
and_expr
808
884
-
809
884
shift_expr
811
884
atom
812
884
{
813
884
comparison
814
884
or_test
815
884
(
816
884
arith_expr
817
884
power
818
884
STRING
819
884
NAME
820
884
and_test
821
884
term
822
884
+
823
884
xor_expr
824
884
subscriptlist
1458
884
test
825
884
NUMBER
826
884
False
827
884
subscript
828
884
expr
829
884
not_test
830
884
None
831
884
lambdef
832
884
lambda
833
884
maybe_test
834
884
:
maybe_test -> 
885
in
atom -> { }
885
<=
atom -> { }
885
*
atom -> { }
885
NEWLINE
atom -> { }
885
>
atom -> { }
885
+
atom -> { }
885
@
atom -> { }
885
>=
atom -> { }
885
/
atom -> { }
885
|
atom -> { }
885
is
atom -> { }
885
and
atom -> { }
885
if
atom -> { }
885
(
atom -> { }
885
>>
atom -> { }
885
not
atom -> { }
885
-
atom -> { }
885
<<
atom -> { }
885
**
atom -> { }
885
or
atom -> { }
885
<
atom -> { }
885
!=
atom -> { }
885
==
atom -> { }
885
%
atom -> { }
885
//
atom -> { }
885
&
atom -> { }
885
[
atom -> { }
885
from
atom -> { }
885
.
atom -> { }
885
^
atom -> { }
886
[
366
886
atom_expr
367
886
factor
368
886
True
369
886
~
370
886
and_expr
371
886
-
372
886
None
373
886
atom
374
886
{
375
886
expr
376
886
arith_expr
377
886
power
378
886
STRING
379
886
NAME
380
886
(
381
886
NUMBER
382
886
term
385
886
+
386
886
xor_expr
387
886
shift_expr
388
886
False
392
886
comparison
1459
887
[
366
887
atom_expr
367
887
factor
368
887
True
369
887
~
370
887
-
372
887
None
373
887
atom
374
887
{
375
887
arith_expr
377
887
power
378
887
STRING
379
887
NAME
380
887
shift_expr
1460
887
(
381
887
NUMBER
382
887
term
385
887
+
386
887
False
392
888
[
366
888
atom_expr
367
888
factor
368
888
True
369
888
~
370
888
-
372
888
None
373
888
atom
374
888
{
375
888
arith_expr
377
888
power
378
888
STRING
379
888
NAME
380
888
(
381
888
NUMBER
382
888
term
385
888
+
386
888
False
392
888
shift_expr
1461
889
)
1462
890
or
atom -> ( )
890
>>
atom -> ( )
890
(
atom -> ( )
890
<=
atom -> ( )
890
.
atom -> ( )
890
is
atom -> ( )
890
@
atom -> ( )
890
%
atom -> ( )
890
from
atom -> ( )
890
<<
atom -> ( )
890
**
atom -> ( )
890
^
atom -> ( )
890
/
atom -> ( )
890
if
atom -> ( )
890
not
atom -> ( )
890
*
atom -> ( )
890
!=
atom -> ( )
890
<
atom -> ( )
890
NEWLINE
atom -> ( )
890
&
atom -> ( )
890
-
atom -> ( )
890
>
atom -> ( )
890
//
atom -> ( )
890
==
atom -> ( )
890
in
atom -> ( )
890
+
atom -> ( )
890
[
atom -> ( )
890
>=
atom -> ( )
890
and
atom -> ( )
890
|
atom -> ( )
891
[
366
891
atom_expr
367
891
factor
368
891
True
369
891
~
370
891
and_expr
371
891
-
372
891
None
373
891
atom
374
891
{
375
891
expr
376
891
arith_expr
377
891
power
378
891
STRING
379
891
NAME
380
891
(
381
891
NUMBER
382
891
and_test
383
891
comparison
384
891
term
385
891
+
386
891
xor_expr
387
891
shift_expr
388
891
not
391
891
False
392
891
or_test
1463
891
not_test
393
892
[
366
892
atom_expr
367
892
factor
368
892
True
369
892
~
370
892
-
372
892
None
373
892
arith_expr
1464
892
atom
374
892
{
375
892
power
378
892
STRING
379
892
NAME
380
892
(
381
892
NUMBER
382
892
term
385
892
+
386
892
False
392
893
[
366
893
atom_expr
367
893
factor
368
893
True
369
893
~
370
893
-
372
893
None
373
893
atom
374
893
{
375
893
arith_expr
1465
893
power
378
893
STRING
379
893
NAME
380
893
(
381
893
NUMBER
382
893
term
385
893
+
386
893
False
392
894
-
factor -> + factor
894
@
factor -> + factor
894
<<
factor -> + factor
894
is
factor -> + factor
894
and
factor -> + factor
894
<=
factor -> + factor
894
or
factor -> + factor
894
<
factor -> + factor
894
^
factor -> + factor
894
from
factor -> + factor
894
not
factor -> + factor
894
//
factor -> + factor
894
*
factor -> + factor
894
in
factor -> + factor
894
&
factor -> + factor
894
+
factor -> + factor
894
>>
factor -> + factor
894
if
factor -> + factor
894
|
factor -> + factor
894
%
factor -> + factor
894
>
factor -> + factor
894
NEWLINE
factor -> + factor
894
>=
factor -> + factor
894
!=
factor -> + factor
894
/
factor -> + factor
894
==
factor -> + factor
895
[
366
895
atom_expr
367
895
factor
368
895
True
369
895
~
370
895
and_expr
371
895
-
372
895
None
373
895
atom
374
895
{
375
895
expr
1466
895
arith_expr
377
895
power
378
895
STRING
379
895
NAME
380
895
(
381
895
NUMBER
382
895
term
385
895
+
386
895
xor_expr
387
895
shift_expr
388
895
False
392
896
[
366
896
atom_expr
367
896
factor
368
896
True
369
896
~
370
896
-
372
896
None
373
896
atom
374
896
{
375
896
arith_expr
377
896
power
378
896
STRING
379
896
NAME
380
896
(
381
896
NUMBER
382
896
term
385
896
+
386
896
and_expr
1467
896
shift_expr
388
896
False
392
897
:
1468
898
[
366
898
atom_expr
367
898
factor
368
898
True
369
898
~
370
898
and_expr
371
898
-
372
898
None
373
898
atom
374
898
{
375
898
expr
376
898
arith_expr
377
898
power
378
898
STRING
379
898
NAME
380
898
(
381
898
NUMBER
382
898
and_test
383
898
comparison
384
898
term
385
898
+
386
898
xor_expr
387
898
shift_expr
388
898
lambda
389
898
not
391
898
False
392
898
not_test
393
898
test
1469
898
lambdef
394
898
or_test
395
899
[
397
899
factor
398
899
True
399
899
atom_expr
400
899
~
401
899
and_expr
402
899
-
403
899
None
404
899
atom
405
899
{
406
899
arith_expr
407
899
power
408
899
STRING
409
899
NAME
410
899
(
411
899
NUMBER
412
899
and_test
413
899
term
414
899
+
415
899
xor_expr
416
899
shift_expr
417
899
not
418
899
False
419
899
lambda
420
899
test
1470
899
comparison
421
899
not_test
422
899
lambdef
423
899
expr
424
899
or_test
425
900
NEWLINE
not_test -> not not_test
900
and
not_test -> not not_test
900
or
not_test -> not not_test
900
if
not_test -> not not_test
900
from
not_test -> not not_test
901
[
366
901
atom_expr
367
901
factor
368
901
True
369
901
~
370
901
and_expr
371
901
-
372
901
None
373
901
atom
374
901
{
375
901
expr
376
901
arith_expr
377
901
power
378
901
STRING
379
901
NAME
380
901
(
381
901
NUMBER
382
901
comparison
384
901
term
385
901
+
386
901
xor_expr
387
901
shift_expr
388
901
not
391
901
False
392
901
and_test
1471
901
not_test
393
902
[
738
902
factor
740
902
True
741
902
~
742
902
and_expr
743
902
-
744
902
atom
745
902
{
746
902
arith_expr
747
902
power
748
902
atom_expr
749
902
STRING
750
902
NAME
751
902
(
752
902
term
753
902
+
754
902
xor_expr
755
902
shift_expr
756
902
NUMBER
757
902
not
758
902
False
759
902
comparison
760
902
not_test
761
902
None
762
902
expr
763
902
and_test
764
902
or_test
1472
903
!=
atom -> [ ]
903
>>
atom -> [ ]
903
|
atom -> [ ]
903
NEWLINE
atom -> [ ]
903
<<
atom -> [ ]
903
>
atom -> [ ]
903
.
atom -> [ ]
903
%
atom -> [ ]
903
^
atom -> [ ]
903
-
atom -> [ ]
903
in
atom -> [ ]
903
or
atom -> [ ]
903
/
atom -> [ ]
903
**
atom -> [ ]
903
//
atom -> [ ]
903
not
atom -> [ ]
903
(
atom -> [ ]
903
+
atom -> [ ]
903
and
atom -> [ ]
903
==
atom -> [ ]
903
[
atom -> [ ]
903
if
atom -> [ ]
903
<
atom -> [ ]
903
<=
atom -> [ ]
903
>=
atom -> [ ]
903
is
atom -> [ ]
903
*
atom -> [ ]
903
@
atom -> [ ]
903
&
atom -> [ ]
904
]
1473
905
term
1474
905
[
397
905
factor
398
905
True
399
905
atom_expr
400
905
~
401
905
-
403
905
None
404
905
atom
405
905
{
406
905
power
408
905
STRING
409
905
NAME
410
905
(
411
905
NUMBER
412
905
+
415
905
False
419
906
[
397
906
factor
398
906
True
399
906
term
1475
906
~
401
906
-
403
906
atom_expr
400
906
None
404
906
atom
405
906
{
406
906
power
408
906
STRING
409
906
NAME
410
906
(
411
906
NUMBER
412
906
+
415
906
False
419
907
[
397
907
factor
398
907
True
399
907
atom_expr
400
907
~
401
907
-
403
907
None
404
907
atom
405
907
{
406
907
power
408
907
STRING
409
907
NAME
410
907
(
411
907
NUMBER
412
907
term
1476
907
+
415
907
False
419
908
[
397
908
factor
398
908
True
399
908
atom_expr
400
908
~
401
908
-
403
908
None
404
908
atom
405
908
{
406
908
power
408
908
STRING
409
908
NAME
410
908
(
411
908
NUMBER
412
908
term
1477
908
+
415
908
False
419
909
[
397
909
factor
398
909
True
399
909
atom_expr
400
909
~
401
909
-
403
909
None
404
909
atom
405
909
{
406
909
power
408
909
STRING
409
909
NAME
410
909
term
1478
909
(
411
909
NUMBER
412
909
+
415
909
False
419
910
[
397
910
True
399
910
atom_expr
400
910
-
403
910
~
401
910
None
404
910
atom
405
910
{
406
910
power
408
910
STRING
409
910
NAME
410
910
(
411
910
NUMBER
412
910
+
415
910
False
419
910
factor
1479
911
@
factor -> ~ factor
911
NEWLINE
factor -> ~ factor
911
>>
factor -> ~ factor
911
<=
factor -> ~ factor
911
and
factor -> ~ factor
911
+
factor -> ~ factor
911
*
factor -> ~ factor
911
!=
factor -> ~ factor
911
%
factor -> ~ factor
911
<<
factor -> ~ factor
911
>=
factor -> ~ factor
911
&
factor -> ~ factor
911
is
factor -> ~ factor
911
==
factor -> ~ factor
911
//
factor -> ~ factor
911
<
factor -> ~ factor
911
/
factor -> ~ factor
911
not
factor -> ~ factor
911
-
factor -> ~ factor
911
or
factor -> ~ factor
911
|
factor -> ~ factor
911
>
factor -> ~ factor
911
^
factor -> ~ factor
911
if
factor -> ~ factor
911
in
factor -> ~ factor
912
[
397
912
factor
398
912
True
399
912
atom_expr
400
912
~
401
912
and_expr
402
912
-
403
912
None
404
912
atom
405
912
{
406
912
xor_expr
1480
912
arith_expr
407
912
power
408
912
STRING
409
912
NAME
410
912
(
411
912
NUMBER
412
912
term
414
912
+
415
912
shift_expr
417
912
False
419
913
@
factor -> - factor
913
<=
factor -> - factor
913
in
factor -> - factor
913
>>
factor -> - factor
913
|
factor -> - factor
913
is
factor -> - factor
913
+
factor -> - factor
913
%
factor -> - factor
913
<
factor -> - factor
913
*
factor -> - factor
913
<<
factor -> - factor
913
if
factor -> - factor
913
-
factor -> - factor
913
>=
factor -> - factor
913
not
factor -> - factor
913
and
factor -> - factor
913
/
factor -> - factor
913
or
factor -> - factor
913
NEWLINE
factor -> - factor
913
^
factor -> - factor
913
>
factor -> - factor
913
!=
factor -> - factor
913
&
factor -> - factor
913
==
factor -> - factor
913
//
factor -> - factor
914
[
766
914
factor
767
914
True
768
914
atom_expr
769
914
~
770
914
and_expr
771
914
-
772
914
{
773
914
shift_expr
774
914
atom
775
914
comparison
776
914
and_test
777
914
arith_expr
778
914
power
779
914
STRING
780
914
NAME
781
914
(
782
914
term
784
914
+
785
914
xor_expr
786
914
)
1481
914
or_test
788
914
arglist
1482
914
NUMBER
789
914
not
790
914
False
791
914
expr
792
914
*
793
914
not_test
794
914
None
795
914
lambdef
796
914
lambda
797
914
test
798
914
argument
799
914
**
800
915
trailer_expr
1483
915
>>
trailer_expr -> 
915
(
914
915
trailer
915
915
.
917
915
+
trailer_expr -> 
915
is
trailer_expr -> 
915
>
trailer_expr -> 
915
not
trailer_expr -> 
915
|
trailer_expr -> 
915
[
918
915
NEWLINE
trailer_expr -> 
915
&
trailer_expr -> 
915
/
trailer_expr -> 
915
@
trailer_expr -> 
915
!=
trailer_expr -> 
915
**
trailer_expr -> 
915
>=
trailer_expr -> 
915
^
trailer_expr -> 
915
in
trailer_expr -> 
915
<<
trailer_expr -> 
915
and
trailer_expr -> 
915
or
trailer_expr -> 
915
if
trailer_expr -> 
915
//
trailer_expr -> 
915
%
trailer_expr -> 
915
<=
trailer_expr -> 
915
<
trailer_expr -> 
915
==
trailer_expr -> 
915
-
trailer_expr -> 
915
*
trailer_expr -> 
916
^
atom_expr -> atom trailer_expr
916
or
atom_expr -> atom trailer_expr
916
&
atom_expr -> atom trailer_expr
916
@
atom_expr -> atom trailer_expr
916
|
atom_expr -> atom trailer_expr
916
-
atom_expr -> atom trailer_expr
916
*
atom_expr -> atom trailer_expr
916
%
atom_expr -> atom trailer_expr
916
==
atom_expr -> atom trailer_expr
916
**
atom_expr -> atom trailer_expr
916
and
atom_expr -> atom trailer_expr
916
NEWLINE
atom_expr -> atom trailer_expr
916
is
atom_expr -> atom trailer_expr
916
in
atom_expr -> atom trailer_expr
916
<<
atom_expr -> atom trailer_expr
916
!=
atom_expr -> atom trailer_expr
916
<=
atom_expr -> atom trailer_expr
916
/
atom_expr -> atom trailer_expr
916
//
atom_expr -> atom trailer_expr
916
<
atom_expr -> atom trailer_expr
916
>=
atom_expr -> atom trailer_expr
916
>>
atom_expr -> atom trailer_expr
916
if
atom_expr -> atom trailer_expr
916
not
atom_expr -> atom trailer_expr
916
+
atom_expr -> atom trailer_expr
916
>
atom_expr -> atom trailer_expr
917
NAME
1484
918
[
802
918
factor
803
918
True
804
918
atom_expr
810
918
~
806
918
not
807
918
and_expr
808
918
-
809
918
shift_expr
811
918
atom
812
918
{
813
918
comparison
814
918
or_test
815
918
(
816
918
arith_expr
817
918
power
818
918
STRING
819
918
NAME
820
918
and_test
821
918
term
822
918
+
823
918
xor_expr
824
918
subscriptlist
1485
918
test
825
918
NUMBER
826
918
False
827
918
subscript
828
918
expr
829
918
not_test
830
918
None
831
918
lambdef
832
918
lambda
833
918
maybe_test
834
918
:
maybe_test -> 
919
in
atom -> { }
919
<=
atom -> { }
919
*
atom -> { }
919
NEWLINE
atom -> { }
919
>
atom -> { }
919
+
atom -> { }
919
@
atom -> { }
919
>=
atom -> { }
919
/
atom -> { }
919
|
atom -> { }
919
is
atom -> { }
919
and
atom -> { }
919
if
atom -> { }
919
(
atom -> { }
919
>>
atom -> { }
919
not
atom -> { }
919
-
atom -> { }
919
<<
atom -> { }
919
**
atom -> { }
919
or
atom -> { }
919
<
atom -> { }
919
!=
atom -> { }
919
==
atom -> { }
919
%
atom -> { }
919
//
atom -> { }
919
&
atom -> { }
919
[
atom -> { }
919
.
atom -> { }
919
^
atom -> { }
920
[
397
920
factor
398
920
True
399
920
atom_expr
400
920
~
401
920
-
403
920
None
404
920
atom
405
920
{
406
920
arith_expr
407
920
power
408
920
STRING
409
920
NAME
410
920
shift_expr
1486
920
(
411
920
NUMBER
412
920
term
414
920
+
415
920
False
419
921
[
397
921
factor
398
921
True
399
921
atom_expr
400
921
~
401
921
-
403
921
None
404
921
atom
405
921
{
406
921
arith_expr
407
921
power
408
921
STRING
409
921
NAME
410
921
(
411
921
NUMBER
412
921
term
414
921
+
415
921
False
419
921
shift_expr
1487
922
)
1488
923
or
atom -> ( )
923
>>
atom -> ( )
923
(
atom -> ( )
923
<=
atom -> ( )
923
.
atom -> ( )
923
is
atom -> ( )
923
@
atom -> ( )
923
%
atom -> ( )
923
<<
atom -> ( )
923
**
atom -> ( )
923
^
atom -> ( )
923
/
atom -> ( )
923
if
atom -> ( )
923
not
atom -> ( )
923
*
atom -> ( )
923
!=
atom -> ( )
923
<
atom -> ( )
923
NEWLINE
atom -> ( )
923
&
atom -> ( )
923
-
atom -> ( )
923
>
atom -> ( )
923
//
atom -> ( )
923
==
atom -> ( )
923
in
atom -> ( )
923
+
atom -> ( )
923
[
atom -> ( )
923
>=
atom -> ( )
923
and
atom -> ( )
923
|
atom -> ( )
924
[
397
924
factor
398
924
True
399
924
atom_expr
400
924
~
401
924
and_expr
402
924
-
403
924
None
404
924
atom
405
924
{
406
924
arith_expr
407
924
power
408
924
STRING
409
924
NAME
410
924
(
411
924
NUMBER
412
924
and_test
413
924
term
414
924
+
415
924
xor_expr
416
924
shift_expr
417
924
not
418
924
False
419
924
comparison
421
924
not_test
422
924
expr
424
924
or_test
1489
925
[
397
925
factor
398
925
True
399
925
atom_expr
400
925
~
401
925
-
403
925
None
404
925
arith_expr
1490
925
atom
405
925
{
406
925
power
408
925
STRING
409
925
NAME
410
925
(
411
925
NUMBER
412
925
term
414
925
+
415
925
False
419
926
[
397
926
factor
398
926
True
399
926
atom_expr
400
926
~
401
926
-
403
926
None
404
926
atom
405
926
{
406
926
arith_expr
1491
926
power
408
926
STRING
409
926
NAME
410
926
(
411
926
NUMBER
412
926
term
414
926
+
415
926
False
419
927
-
factor -> + factor
927
@
factor -> + factor
927
<<
factor -> + factor
927
is
factor -> + factor
927
and
factor -> + factor
927
<=
factor -> + factor
927
or
factor -> + factor
927
<
factor -> + factor
927
^
factor -> + factor
927
not
factor -> + factor
927
//
factor -> + factor
927
*
factor -> + factor
927
in
factor -> + factor
927
&
factor -> + factor
927
+
factor -> + factor
927
>>
factor -> + factor
927
if
factor -> + factor
927
|
factor -> + factor
927
%
factor -> + factor
927
>
factor -> + factor
927
NEWLINE
factor -> + factor
927
>=
factor -> + factor
927
!=
factor -> + factor
927
/
factor -> + factor
927
==
factor -> + factor
928
[
397
928
factor
398
928
True
399
928
atom_expr
400
928
~
401
928
and_expr
402
928
-
403
928
None
404
928
atom
405
928
{
406
928
expr
1492
928
arith_expr
407
928
power
408
928
STRING
409
928
NAME
410
928
(
411
928
NUMBER
412
928
term
414
928
+
415
928
xor_expr
416
928
shift_expr
417
928
False
419
929
[
397
929
factor
398
929
True
399
929
atom_expr
400
929
~
401
929
-
403
929
None
404
929
atom
405
929
{
406
929
arith_expr
407
929
power
408
929
STRING
409
929
NAME
410
929
(
411
929
NUMBER
412
929
term
414
929
+
415
929
and_expr
1493
929
shift_expr
417
929
False
419
930
NEWLINE
not_test -> not not_test
930
and
not_test -> not not_test
930
or
not_test -> not not_test
930
if
not_test -> not not_test
931
[
397
931
factor
398
931
True
399
931
atom_expr
400
931
~
401
931
and_expr
402
931
-
403
931
None
404
931
atom
405
931
{
406
931
arith_expr
407
931
power
408
931
STRING
409
931
NAME
410
931
(
411
931
NUMBER
412
931
and_test
413
931
term
414
931
+
415
931
xor_expr
416
931
shift_expr
417
931
not
418
931
False
419
931
lambda
420
931
comparison
421
931
not_test
422
931
lambdef
423
931
expr
424
931
or_test
425
931
test
1494
932
:
1495
933
[
397
933
factor
398
933
True
399
933
atom_expr
400
933
~
401
933
and_expr
402
933
-
403
933
None
404
933
atom
405
933
{
406
933
arith_expr
407
933
power
408
933
STRING
409
933
NAME
410
933
(
411
933
NUMBER
412
933
term
414
933
+
415
933
xor_expr
416
933
shift_expr
417
933
not
418
933
False
419
933
and_test
1496
933
comparison
421
933
not_test
422
933
expr
424
934
[
397
934
factor
398
934
True
399
934
atom_expr
400
934
~
401
934
and_expr
402
934
-
403
934
None
404
934
atom
405
934
{
406
934
arith_expr
407
934
power
408
934
STRING
409
934
NAME
410
934
(
411
934
NUMBER
412
934
term
414
934
+
415
934
xor_expr
416
934
shift_expr
417
934
False
419
934
expr
424
934
comparison
1497
935
[
738
935
factor
740
935
True
741
935
~
742
935
and_expr
743
935
-
744
935
atom
745
935
{
746
935
arith_expr
747
935
power
748
935
atom_expr
749
935
STRING
750
935
NAME
751
935
(
752
935
term
753
935
+
754
935
xor_expr
755
935
shift_expr
756
935
NUMBER
757
935
not
758
935
False
759
935
comparison
760
935
not_test
761
935
None
762
935
expr
763
935
and_test
764
935
or_test
1498
936
NAME
427
936
namelist
1499
937
finally
1500
937
else
1501
937
while
try_stmt -> try : suite except_clause
937
conf
try_stmt -> try : suite except_clause
937
raise
try_stmt -> try : suite except_clause
937
NAME
try_stmt -> try : suite except_clause
937
NEWLINE
try_stmt -> try : suite except_clause
937
try
try_stmt -> try : suite except_clause
937
modopt
try_stmt -> try : suite except_clause
937
for
try_stmt -> try : suite except_clause
937
(
try_stmt -> try : suite except_clause
937
lambda
try_stmt -> try : suite except_clause
937
True
try_stmt -> try : suite except_clause
937
[
try_stmt -> try : suite except_clause
937
continue
try_stmt -> try : suite except_clause
937
{
try_stmt -> try : suite except_clause
937
server
try_stmt -> try : suite except_clause
937
None
try_stmt -> try : suite except_clause
937
servmod
try_stmt -> try : suite except_clause
937
break
try_stmt -> try : suite except_clause
937
endsim
try_stmt -> try : suite except_clause
937
assert
try_stmt -> try : suite except_clause
937
yield
try_stmt -> try : suite except_clause
937
$
try_stmt -> try : suite except_clause
937
not
try_stmt -> try : suite except_clause
937
global
try_stmt -> try : suite except_clause
937
begsim
try_stmt -> try : suite except_clause
937
False
try_stmt -> try : suite except_clause
937
if
try_stmt -> try : suite except_clause
937
resetstats
try_stmt -> try : suite except_clause
937
NUMBER
try_stmt -> try : suite except_clause
937
+
try_stmt -> try : suite except_clause
937
class
try_stmt -> try : suite except_clause
937
nonlocal
try_stmt -> try : suite except_clause
937
pass
try_stmt -> try : suite except_clause
937
return
try_stmt -> try : suite except_clause
937
with
try_stmt -> try : suite except_clause
937
@
try_stmt -> try : suite except_clause
937
-
try_stmt -> try : suite except_clause
937
del
try_stmt -> try : suite except_clause
937
STRING
try_stmt -> try : suite except_clause
937
~
try_stmt -> try : suite except_clause
937
def
try_stmt -> try : suite except_clause
938
[
1502
938
test
1503
938
factor
1504
938
True
1505
938
atom_expr
1506
938
~
1507
938
and_expr
1508
938
-
1509
938
atom
1510
938
{
1511
938
or_test
1512
938
arith_expr
1513
938
power
1514
938
STRING
1515
938
NAME
1516
938
shift_expr
1517
938
:
1518
938
(
1519
938
and_test
1520
938
term
1521
938
+
1522
938
xor_expr
1523
938
NUMBER
1524
938
not
1525
938
False
1526
938
expr
1527
938
not_test
1528
938
comparison
1529
938
None
1530
938
lambdef
1531
938
lambda
1532
939
arith_expr
1
939
try
1533
939
modopt
1534
939
compound_stmt
1535
939
test
5
939
servmod
1536
939
while
1537
939
and_expr
8
939
power
9
939
STRING
10
939
decorated
1538
939
cli_serv_model
1539
939
@
13
939
try_stmt
1540
939
lambdef
15
939
(
16
939
factor
17
939
[
18
939
class
1541
939
small_stmt
1542
939
{
21
939
term
22
939
def
1543
939
server
1544
939
while_stmt
1545
939
-
26
939
+
27
939
for
1546
939
if
1547
939
lambda
29
939
decorators
1548
939
atom_expr
31
939
not_test
32
939
if_stmt
1549
939
yield
34
939
conf
1550
939
test_list
36
939
~
37
939
True
38
939
False
39
939
funcdef
1551
939
xor_expr
41
939
with
1552
939
for_stmt
1553
939
sim_stmt
45
939
and_test
46
939
expr
47
939
shift_expr
48
939
comparison
49
939
with_stmt
1554
939
simple_stmt
1555
939
NAME
52
939
or_test
53
939
confdef
1556
939
None
55
939
classdef
1557
939
atom
57
939
NUMBER
58
939
return
59
939
break_stmt
60
939
return_stmt
61
939
stmt
1558
939
not
62
939
break
63
939
raise
64
939
expr_stmt
65
939
stat_stmt
66
939
decorator
67
939
assert_stmt
68
939
begsim
69
939
global
70
939
assert
71
939
nonlocal
72
939
nonlocal_stmt
73
939
raise_stmt
74
939
yield_stmt
75
939
stmt_list
1559
939
continue
77
939
endsim
78
939
del
80
939
pass_stmt
81
939
flow_stmt
82
939
resetstats
84
939
del_stmt
85
939
continue_stmt
86
939
global_stmt
87
939
pass
88
940
except
simple_stmt -> small_stmt NEWLINE
941
INDENT
1560
942
INDENT
1561
943
.
atom -> [ test_list_comp ]
943
[
atom -> [ test_list_comp ]
943
@
atom -> [ test_list_comp ]
943
<=
atom -> [ test_list_comp ]
943
<
atom -> [ test_list_comp ]
943
not
atom -> [ test_list_comp ]
943
in
atom -> [ test_list_comp ]
943
and
atom -> [ test_list_comp ]
943
-
atom -> [ test_list_comp ]
943
if
atom -> [ test_list_comp ]
943
!=
atom -> [ test_list_comp ]
943
is
atom -> [ test_list_comp ]
943
>>
atom -> [ test_list_comp ]
943
or
atom -> [ test_list_comp ]
943
//
atom -> [ test_list_comp ]
943
/
atom -> [ test_list_comp ]
943
|
atom -> [ test_list_comp ]
943
>
atom -> [ test_list_comp ]
943
&
atom -> [ test_list_comp ]
943
(
atom -> [ test_list_comp ]
943
%
atom -> [ test_list_comp ]
943
>=
atom -> [ test_list_comp ]
943
==
atom -> [ test_list_comp ]
943
**
atom -> [ test_list_comp ]
943
:
atom -> [ test_list_comp ]
943
<<
atom -> [ test_list_comp ]
943
+
atom -> [ test_list_comp ]
943
*
atom -> [ test_list_comp ]
943
^
atom -> [ test_list_comp ]
944
<<
term -> factor @ term
944
^
term -> factor @ term
944
<=
term -> factor @ term
944
&
term -> factor @ term
944
==
term -> factor @ term
944
if
term -> factor @ term
944
|
term -> factor @ term
944
!=
term -> factor @ term
944
or
term -> factor @ term
944
>
term -> factor @ term
944
and
term -> factor @ term
944
>>
term -> factor @ term
944
is
term -> factor @ term
944
-
term -> factor @ term
944
not
term -> factor @ term
944
+
term -> factor @ term
944
in
term -> factor @ term
944
>=
term -> factor @ term
944
<
term -> factor @ term
944
:
term -> factor @ term
945
<=
term -> factor % term
945
is
term -> factor % term
945
>
term -> factor % term
945
and
term -> factor % term
945
in
term -> factor % term
945
or
term -> factor % term
945
<
term -> factor % term
945
:
term -> factor % term
945
-
term -> factor % term
945
!=
term -> factor % term
945
>>
term -> factor % term
945
^
term -> factor % term
945
+
term -> factor % term
945
if
term -> factor % term
945
<<
term -> factor % term
945
>=
term -> factor % term
945
==
term -> factor % term
945
not
term -> factor % term
945
|
term -> factor % term
945
&
term -> factor % term
946
>>
term -> factor / term
946
!=
term -> factor / term
946
<
term -> factor / term
946
<=
term -> factor / term
946
|
term -> factor / term
946
is
term -> factor / term
946
>=
term -> factor / term
946
^
term -> factor / term
946
&
term -> factor / term
946
+
term -> factor / term
946
<<
term -> factor / term
946
and
term -> factor / term
946
-
term -> factor / term
946
in
term -> factor / term
946
>
term -> factor / term
946
or
term -> factor / term
946
not
term -> factor / term
946
==
term -> factor / term
946
:
term -> factor / term
946
if
term -> factor / term
947
is
term -> factor * term
947
+
term -> factor * term
947
>=
term -> factor * term
947
^
term -> factor * term
947
<=
term -> factor * term
947
or
term -> factor * term
947
<
term -> factor * term
947
|
term -> factor * term
947
>>
term -> factor * term
947
in
term -> factor * term
947
not
term -> factor * term
947
==
term -> factor * term
947
:
term -> factor * term
947
-
term -> factor * term
947
and
term -> factor * term
947
!=
term -> factor * term
947
<<
term -> factor * term
947
>
term -> factor * term
947
if
term -> factor * term
947
&
term -> factor * term
948
!=
term -> factor // term
948
or
term -> factor // term
948
^
term -> factor // term
948
>
term -> factor // term
948
is
term -> factor // term
948
&
term -> factor // term
948
-
term -> factor // term
948
:
term -> factor // term
948
in
term -> factor // term
948
>>
term -> factor // term
948
|
term -> factor // term
948
<
term -> factor // term
948
>=
term -> factor // term
948
not
term -> factor // term
948
if
term -> factor // term
948
==
term -> factor // term
948
<=
term -> factor // term
948
and
term -> factor // term
948
<<
term -> factor // term
948
+
term -> factor // term
949
:
power -> atom_expr ** factor
949
!=
power -> atom_expr ** factor
949
@
power -> atom_expr ** factor
949
|
power -> atom_expr ** factor
949
in
power -> atom_expr ** factor
949
==
power -> atom_expr ** factor
949
if
power -> atom_expr ** factor
949
and
power -> atom_expr ** factor
949
>=
power -> atom_expr ** factor
949
/
power -> atom_expr ** factor
949
not
power -> atom_expr ** factor
949
^
power -> atom_expr ** factor
949
//
power -> atom_expr ** factor
949
>
power -> atom_expr ** factor
949
+
power -> atom_expr ** factor
949
%
power -> atom_expr ** factor
949
-
power -> atom_expr ** factor
949
is
power -> atom_expr ** factor
949
<=
power -> atom_expr ** factor
949
<
power -> atom_expr ** factor
949
*
power -> atom_expr ** factor
949
<<
power -> atom_expr ** factor
949
or
power -> atom_expr ** factor
949
>>
power -> atom_expr ** factor
949
&
power -> atom_expr ** factor
950
not
xor_expr -> and_expr ^ xor_expr
950
<
xor_expr -> and_expr ^ xor_expr
950
>=
xor_expr -> and_expr ^ xor_expr
950
>
xor_expr -> and_expr ^ xor_expr
950
is
xor_expr -> and_expr ^ xor_expr
950
!=
xor_expr -> and_expr ^ xor_expr
950
and
xor_expr -> and_expr ^ xor_expr
950
:
xor_expr -> and_expr ^ xor_expr
950
if
xor_expr -> and_expr ^ xor_expr
950
<=
xor_expr -> and_expr ^ xor_expr
950
in
xor_expr -> and_expr ^ xor_expr
950
==
xor_expr -> and_expr ^ xor_expr
950
|
xor_expr -> and_expr ^ xor_expr
950
or
xor_expr -> and_expr ^ xor_expr
951
+
trailer -> ( )
951
!=
trailer -> ( )
951
<<
trailer -> ( )
951
>=
trailer -> ( )
951
**
trailer -> ( )
951
not
trailer -> ( )
951
if
trailer -> ( )
951
|
trailer -> ( )
951
[
trailer -> ( )
951
==
trailer -> ( )
951
%
trailer -> ( )
951
*
trailer -> ( )
951
>>
trailer -> ( )
951
@
trailer -> ( )
951
>
trailer -> ( )
951
/
trailer -> ( )
951
in
trailer -> ( )
951
(
trailer -> ( )
951
is
trailer -> ( )
951
//
trailer -> ( )
951
<
trailer -> ( )
951
:
trailer -> ( )
951
or
trailer -> ( )
951
^
trailer -> ( )
951
and
trailer -> ( )
951
<=
trailer -> ( )
951
.
trailer -> ( )
951
-
trailer -> ( )
951
&
trailer -> ( )
952
)
1562
953
<=
trailer_expr -> trailer trailer_expr
953
+
trailer_expr -> trailer trailer_expr
953
^
trailer_expr -> trailer trailer_expr
953
or
trailer_expr -> trailer trailer_expr
953
==
trailer_expr -> trailer trailer_expr
953
%
trailer_expr -> trailer trailer_expr
953
@
trailer_expr -> trailer trailer_expr
953
not
trailer_expr -> trailer trailer_expr
953
<<
trailer_expr -> trailer trailer_expr
953
-
trailer_expr -> trailer trailer_expr
953
//
trailer_expr -> trailer trailer_expr
953
and
trailer_expr -> trailer trailer_expr
953
|
trailer_expr -> trailer trailer_expr
953
if
trailer_expr -> trailer trailer_expr
953
>
trailer_expr -> trailer trailer_expr
953
!=
trailer_expr -> trailer trailer_expr
953
<
trailer_expr -> trailer trailer_expr
953
>>
trailer_expr -> trailer trailer_expr
953
/
trailer_expr -> trailer trailer_expr
953
:
trailer_expr -> trailer trailer_expr
953
is
trailer_expr -> trailer trailer_expr
953
&
trailer_expr -> trailer trailer_expr
953
in
trailer_expr -> trailer trailer_expr
953
>=
trailer_expr -> trailer trailer_expr
953
*
trailer_expr -> trailer trailer_expr
953
**
trailer_expr -> trailer trailer_expr
954
.
trailer -> . NAME
954
not
trailer -> . NAME
954
if
trailer -> . NAME
954
**
trailer -> . NAME
954
:
trailer -> . NAME
954
|
trailer -> . NAME
954
-
trailer -> . NAME
954
(
trailer -> . NAME
954
%
trailer -> . NAME
954
//
trailer -> . NAME
954
==
trailer -> . NAME
954
>>
trailer -> . NAME
954
is
trailer -> . NAME
954
!=
trailer -> . NAME
954
and
trailer -> . NAME
954
>=
trailer -> . NAME
954
>
trailer -> . NAME
954
in
trailer -> . NAME
954
<<
trailer -> . NAME
954
&
trailer -> . NAME
954
/
trailer -> . NAME
954
^
trailer -> . NAME
954
[
trailer -> . NAME
954
<=
trailer -> . NAME
954
or
trailer -> . NAME
954
+
trailer -> . NAME
954
<
trailer -> . NAME
954
*
trailer -> . NAME
954
@
trailer -> . NAME
955
]
1563
956
else
1564
957
==
shift_expr -> arith_expr >> shift_expr
957
^
shift_expr -> arith_expr >> shift_expr
957
or
shift_expr -> arith_expr >> shift_expr
957
if
shift_expr -> arith_expr >> shift_expr
957
not
shift_expr -> arith_expr >> shift_expr
957
|
shift_expr -> arith_expr >> shift_expr
957
<=
shift_expr -> arith_expr >> shift_expr
957
is
shift_expr -> arith_expr >> shift_expr
957
in
shift_expr -> arith_expr >> shift_expr
957
>=
shift_expr -> arith_expr >> shift_expr
957
>
shift_expr -> arith_expr >> shift_expr
957
:
shift_expr -> arith_expr >> shift_expr
957
&
shift_expr -> arith_expr >> shift_expr
957
<
shift_expr -> arith_expr >> shift_expr
957
and
shift_expr -> arith_expr >> shift_expr
957
!=
shift_expr -> arith_expr >> shift_expr
958
or
shift_expr -> arith_expr << shift_expr
958
>
shift_expr -> arith_expr << shift_expr
958
in
shift_expr -> arith_expr << shift_expr
958
&
shift_expr -> arith_expr << shift_expr
958
:
shift_expr -> arith_expr << shift_expr
958
is
shift_expr -> arith_expr << shift_expr
958
<
shift_expr -> arith_expr << shift_expr
958
<=
shift_expr -> arith_expr << shift_expr
958
not
shift_expr -> arith_expr << shift_expr
958
^
shift_expr -> arith_expr << shift_expr
958
if
shift_expr -> arith_expr << shift_expr
958
and
shift_expr -> arith_expr << shift_expr
958
|
shift_expr -> arith_expr << shift_expr
958
!=
shift_expr -> arith_expr << shift_expr
958
==
shift_expr -> arith_expr << shift_expr
958
>=
shift_expr -> arith_expr << shift_expr
959
>
atom -> ( test_list_comp )
959
@
atom -> ( test_list_comp )
959
&
atom -> ( test_list_comp )
959
[
atom -> ( test_list_comp )
959
if
atom -> ( test_list_comp )
959
==
atom -> ( test_list_comp )
959
>=
atom -> ( test_list_comp )
959
**
atom -> ( test_list_comp )
959
not
atom -> ( test_list_comp )
959
<<
atom -> ( test_list_comp )
959
>>
atom -> ( test_list_comp )
959
in
atom -> ( test_list_comp )
959
or
atom -> ( test_list_comp )
959
.
atom -> ( test_list_comp )
959
/
atom -> ( test_list_comp )
959
^
atom -> ( test_list_comp )
959
is
atom -> ( test_list_comp )
959
and
atom -> ( test_list_comp )
959
//
atom -> ( test_list_comp )
959
<
atom -> ( test_list_comp )
959
*
atom -> ( test_list_comp )
959
<=
atom -> ( test_list_comp )
959
(
atom -> ( test_list_comp )
959
-
atom -> ( test_list_comp )
959
|
atom -> ( test_list_comp )
959
!=
atom -> ( test_list_comp )
959
:
atom -> ( test_list_comp )
959
+
atom -> ( test_list_comp )
959
%
atom -> ( test_list_comp )
960
:
or_test -> and_test or or_test
960
if
or_test -> and_test or or_test
961
>
arith_expr -> term - arith_expr
961
==
arith_expr -> term - arith_expr
961
^
arith_expr -> term - arith_expr
961
is
arith_expr -> term - arith_expr
961
|
arith_expr -> term - arith_expr
961
&
arith_expr -> term - arith_expr
961
if
arith_expr -> term - arith_expr
961
<<
arith_expr -> term - arith_expr
961
>>
arith_expr -> term - arith_expr
961
!=
arith_expr -> term - arith_expr
961
not
arith_expr -> term - arith_expr
961
>=
arith_expr -> term - arith_expr
961
:
arith_expr -> term - arith_expr
961
and
arith_expr -> term - arith_expr
961
<=
arith_expr -> term - arith_expr
961
<
arith_expr -> term - arith_expr
961
or
arith_expr -> term - arith_expr
961
in
arith_expr -> term - arith_expr
962
!=
arith_expr -> term + arith_expr
962
>=
arith_expr -> term + arith_expr
962
not
arith_expr -> term + arith_expr
962
>
arith_expr -> term + arith_expr
962
<
arith_expr -> term + arith_expr
962
&
arith_expr -> term + arith_expr
962
^
arith_expr -> term + arith_expr
962
>>
arith_expr -> term + arith_expr
962
in
arith_expr -> term + arith_expr
962
:
arith_expr -> term + arith_expr
962
<<
arith_expr -> term + arith_expr
962
or
arith_expr -> term + arith_expr
962
is
arith_expr -> term + arith_expr
962
and
arith_expr -> term + arith_expr
962
==
arith_expr -> term + arith_expr
962
<=
arith_expr -> term + arith_expr
962
|
arith_expr -> term + arith_expr
962
if
arith_expr -> term + arith_expr
963
>=
expr -> xor_expr | expr
963
or
expr -> xor_expr | expr
963
in
expr -> xor_expr | expr
963
and
expr -> xor_expr | expr
963
==
expr -> xor_expr | expr
963
:
expr -> xor_expr | expr
963
>
expr -> xor_expr | expr
963
<=
expr -> xor_expr | expr
963
is
expr -> xor_expr | expr
963
<
expr -> xor_expr | expr
963
if
expr -> xor_expr | expr
963
not
expr -> xor_expr | expr
963
!=
expr -> xor_expr | expr
964
else
1565
964
while
while_stmt -> while test : suite
964
[
while_stmt -> while test : suite
964
def
while_stmt -> while test : suite
964
None
while_stmt -> while test : suite
964
resetstats
while_stmt -> while test : suite
964
True
while_stmt -> while test : suite
964
server
while_stmt -> while test : suite
964
raise
while_stmt -> while test : suite
964
if
while_stmt -> while test : suite
964
False
while_stmt -> while test : suite
964
return
while_stmt -> while test : suite
964
del
while_stmt -> while test : suite
964
global
while_stmt -> while test : suite
964
endsim
while_stmt -> while test : suite
964
pass
while_stmt -> while test : suite
964
STRING
while_stmt -> while test : suite
964
+
while_stmt -> while test : suite
964
conf
while_stmt -> while test : suite
964
try
while_stmt -> while test : suite
964
break
while_stmt -> while test : suite
964
servmod
while_stmt -> while test : suite
964
with
while_stmt -> while test : suite
964
lambda
while_stmt -> while test : suite
964
NUMBER
while_stmt -> while test : suite
964
modopt
while_stmt -> while test : suite
964
~
while_stmt -> while test : suite
964
-
while_stmt -> while test : suite
964
assert
while_stmt -> while test : suite
964
NAME
while_stmt -> while test : suite
964
(
while_stmt -> while test : suite
964
yield
while_stmt -> while test : suite
964
NEWLINE
while_stmt -> while test : suite
964
continue
while_stmt -> while test : suite
964
not
while_stmt -> while test : suite
964
begsim
while_stmt -> while test : suite
964
{
while_stmt -> while test : suite
964
class
while_stmt -> while test : suite
964
nonlocal
while_stmt -> while test : suite
964
@
while_stmt -> while test : suite
964
$
while_stmt -> while test : suite
964
for
while_stmt -> while test : suite
965
NEWLINE
1566
966
modopt
suite -> simple_stmt
966
~
suite -> simple_stmt
966
False
suite -> simple_stmt
966
@
suite -> simple_stmt
966
begsim
suite -> simple_stmt
966
NUMBER
suite -> simple_stmt
966
conf
suite -> simple_stmt
966
class
suite -> simple_stmt
966
if
suite -> simple_stmt
966
yield
suite -> simple_stmt
966
try
suite -> simple_stmt
966
else
suite -> simple_stmt
966
pass
suite -> simple_stmt
966
NEWLINE
suite -> simple_stmt
966
[
suite -> simple_stmt
966
break
suite -> simple_stmt
966
True
suite -> simple_stmt
966
None
suite -> simple_stmt
966
server
suite -> simple_stmt
966
assert
suite -> simple_stmt
966
$
suite -> simple_stmt
966
servmod
suite -> simple_stmt
966
raise
suite -> simple_stmt
966
nonlocal
suite -> simple_stmt
966
lambda
suite -> simple_stmt
966
return
suite -> simple_stmt
966
+
suite -> simple_stmt
966
-
suite -> simple_stmt
966
NAME
suite -> simple_stmt
966
while
suite -> simple_stmt
966
def
suite -> simple_stmt
966
with
suite -> simple_stmt
966
del
suite -> simple_stmt
966
STRING
suite -> simple_stmt
966
for
suite -> simple_stmt
966
resetstats
suite -> simple_stmt
966
global
suite -> simple_stmt
966
continue
suite -> simple_stmt
966
endsim
suite -> simple_stmt
966
not
suite -> simple_stmt
966
{
suite -> simple_stmt
966
(
suite -> simple_stmt
967
INDENT
1567
968
<
and_expr -> shift_expr & and_expr
968
if
and_expr -> shift_expr & and_expr
968
>=
and_expr -> shift_expr & and_expr
968
|
and_expr -> shift_expr & and_expr
968
not
and_expr -> shift_expr & and_expr
968
==
and_expr -> shift_expr & and_expr
968
>
and_expr -> shift_expr & and_expr
968
in
and_expr -> shift_expr & and_expr
968
^
and_expr -> shift_expr & and_expr
968
or
and_expr -> shift_expr & and_expr
968
and
and_expr -> shift_expr & and_expr
968
!=
and_expr -> shift_expr & and_expr
968
:
and_expr -> shift_expr & and_expr
968
is
and_expr -> shift_expr & and_expr
968
<=
and_expr -> shift_expr & and_expr
969
and
comparison -> expr comp_op comparison
969
or
comparison -> expr comp_op comparison
969
:
comparison -> expr comp_op comparison
969
if
comparison -> expr comp_op comparison
970
if
and_test -> not_test and and_test
970
or
and_test -> not_test and and_test
970
:
and_test -> not_test and and_test
971
[
95
971
factor
96
971
True
97
971
atom_expr
98
971
~
99
971
and_expr
100
971
-
101
971
atom
102
971
{
103
971
or_test
104
971
arith_expr
105
971
power
106
971
STRING
107
971
NAME
108
971
(
109
971
and_test
110
971
term
111
971
+
112
971
xor_expr
113
971
shift_expr
115
971
NUMBER
116
971
not
117
971
False
118
971
expr
119
971
not_test
120
971
comparison
121
971
None
122
971
lambdef
123
971
test
1568
971
lambda
124
972
:
lambdef -> lambda : test
973
(
dotted_name -> NAME . dotted_name
973
NEWLINE
dotted_name -> NAME . dotted_name
974
)
1569
975
NEWLINE
1570
976
.
atom -> [ test_list_comp ]
976
[
atom -> [ test_list_comp ]
976
@
atom -> [ test_list_comp ]
976
<=
atom -> [ test_list_comp ]
976
<
atom -> [ test_list_comp ]
976
not
atom -> [ test_list_comp ]
976
for
atom -> [ test_list_comp ]
976
in
atom -> [ test_list_comp ]
976
and
atom -> [ test_list_comp ]
976
-
atom -> [ test_list_comp ]
976
if
atom -> [ test_list_comp ]
976
!=
atom -> [ test_list_comp ]
976
is
atom -> [ test_list_comp ]
976
>>
atom -> [ test_list_comp ]
976
or
atom -> [ test_list_comp ]
976
//
atom -> [ test_list_comp ]
976
/
atom -> [ test_list_comp ]
976
,
atom -> [ test_list_comp ]
976
|
atom -> [ test_list_comp ]
976
>
atom -> [ test_list_comp ]
976
&
atom -> [ test_list_comp ]
976
(
atom -> [ test_list_comp ]
976
%
atom -> [ test_list_comp ]
976
>=
atom -> [ test_list_comp ]
976
)
atom -> [ test_list_comp ]
976
==
atom -> [ test_list_comp ]
976
**
atom -> [ test_list_comp ]
976
<<
atom -> [ test_list_comp ]
976
^
atom -> [ test_list_comp ]
976
+
atom -> [ test_list_comp ]
976
*
atom -> [ test_list_comp ]
977
for
term -> factor @ term
977
<<
term -> factor @ term
977
^
term -> factor @ term
977
<=
term -> factor @ term
977
==
term -> factor @ term
977
if
term -> factor @ term
977
|
term -> factor @ term
977
!=
term -> factor @ term
977
or
term -> factor @ term
977
>
term -> factor @ term
977
and
term -> factor @ term
977
>>
term -> factor @ term
977
is
term -> factor @ term
977
-
term -> factor @ term
977
not
term -> factor @ term
977
+
term -> factor @ term
977
in
term -> factor @ term
977
>=
term -> factor @ term
977
<
term -> factor @ term
977
,
term -> factor @ term
977
&
term -> factor @ term
977
)
term -> factor @ term
978
<=
term -> factor % term
978
is
term -> factor % term
978
>
term -> factor % term
978
and
term -> factor % term
978
in
term -> factor % term
978
,
term -> factor % term
978
or
term -> factor % term
978
<
term -> factor % term
978
-
term -> factor % term
978
!=
term -> factor % term
978
>>
term -> factor % term
978
^
term -> factor % term
978
+
term -> factor % term
978
if
term -> factor % term
978
<<
term -> factor % term
978
>=
term -> factor % term
978
==
term -> factor % term
978
not
term -> factor % term
978
|
term -> factor % term
978
)
term -> factor % term
978
&
term -> factor % term
978
for
term -> factor % term
979
>>
term -> factor / term
979
!=
term -> factor / term
979
<
term -> factor / term
979
<=
term -> factor / term
979
|
term -> factor / term
979
is
term -> factor / term
979
>=
term -> factor / term
979
^
term -> factor / term
979
&
term -> factor / term
979
+
term -> factor / term
979
for
term -> factor / term
979
<<
term -> factor / term
979
and
term -> factor / term
979
-
term -> factor / term
979
in
term -> factor / term
979
>
term -> factor / term
979
or
term -> factor / term
979
not
term -> factor / term
979
==
term -> factor / term
979
,
term -> factor / term
979
if
term -> factor / term
979
)
term -> factor / term
980
is
term -> factor * term
980
+
term -> factor * term
980
>=
term -> factor * term
980
^
term -> factor * term
980
,
term -> factor * term
980
<=
term -> factor * term
980
or
term -> factor * term
980
)
term -> factor * term
980
for
term -> factor * term
980
<
term -> factor * term
980
|
term -> factor * term
980
>>
term -> factor * term
980
in
term -> factor * term
980
not
term -> factor * term
980
==
term -> factor * term
980
-
term -> factor * term
980
and
term -> factor * term
980
!=
term -> factor * term
980
<<
term -> factor * term
980
>
term -> factor * term
980
if
term -> factor * term
980
&
term -> factor * term
981
for
term -> factor // term
981
!=
term -> factor // term
981
or
term -> factor // term
981
^
term -> factor // term
981
>
term -> factor // term
981
is
term -> factor // term
981
&
term -> factor // term
981
-
term -> factor // term
981
in
term -> factor // term
981
>>
term -> factor // term
981
|
term -> factor // term
981
<
term -> factor // term
981
>=
term -> factor // term
981
not
term -> factor // term
981
if
term -> factor // term
981
==
term -> factor // term
981
)
term -> factor // term
981
<=
term -> factor // term
981
,
term -> factor // term
981
and
term -> factor // term
981
<<
term -> factor // term
981
+
term -> factor // term
982
!=
power -> atom_expr ** factor
982
@
power -> atom_expr ** factor
982
for
power -> atom_expr ** factor
982
|
power -> atom_expr ** factor
982
in
power -> atom_expr ** factor
982
==
power -> atom_expr ** factor
982
if
power -> atom_expr ** factor
982
and
power -> atom_expr ** factor
982
>=
power -> atom_expr ** factor
982
/
power -> atom_expr ** factor
982
not
power -> atom_expr ** factor
982
^
power -> atom_expr ** factor
982
//
power -> atom_expr ** factor
982
>
power -> atom_expr ** factor
982
+
power -> atom_expr ** factor
982
%
power -> atom_expr ** factor
982
)
power -> atom_expr ** factor
982
-
power -> atom_expr ** factor
982
is
power -> atom_expr ** factor
982
<=
power -> atom_expr ** factor
982
<
power -> atom_expr ** factor
982
,
power -> atom_expr ** factor
982
*
power -> atom_expr ** factor
982
<<
power -> atom_expr ** factor
982
or
power -> atom_expr ** factor
982
>>
power -> atom_expr ** factor
982
&
power -> atom_expr ** factor
983
not
xor_expr -> and_expr ^ xor_expr
983
<
xor_expr -> and_expr ^ xor_expr
983
,
xor_expr -> and_expr ^ xor_expr
983
>=
xor_expr -> and_expr ^ xor_expr
983
>
xor_expr -> and_expr ^ xor_expr
983
)
xor_expr -> and_expr ^ xor_expr
983
!=
xor_expr -> and_expr ^ xor_expr
983
is
xor_expr -> and_expr ^ xor_expr
983
and
xor_expr -> and_expr ^ xor_expr
983
if
xor_expr -> and_expr ^ xor_expr
983
<=
xor_expr -> and_expr ^ xor_expr
983
in
xor_expr -> and_expr ^ xor_expr
983
==
xor_expr -> and_expr ^ xor_expr
983
for
xor_expr -> and_expr ^ xor_expr
983
|
xor_expr -> and_expr ^ xor_expr
983
or
xor_expr -> and_expr ^ xor_expr
984
<
and_expr -> shift_expr & and_expr
984
if
and_expr -> shift_expr & and_expr
984
>=
and_expr -> shift_expr & and_expr
984
not
and_expr -> shift_expr & and_expr
984
==
and_expr -> shift_expr & and_expr
984
>
and_expr -> shift_expr & and_expr
984
in
and_expr -> shift_expr & and_expr
984
^
and_expr -> shift_expr & and_expr
984
or
and_expr -> shift_expr & and_expr
984
and
and_expr -> shift_expr & and_expr
984
!=
and_expr -> shift_expr & and_expr
984
,
and_expr -> shift_expr & and_expr
984
for
and_expr -> shift_expr & and_expr
984
<=
and_expr -> shift_expr & and_expr
984
|
and_expr -> shift_expr & and_expr
984
is
and_expr -> shift_expr & and_expr
984
)
and_expr -> shift_expr & and_expr
985
.
trailer -> . NAME
985
not
trailer -> . NAME
985
if
trailer -> . NAME
985
**
trailer -> . NAME
985
|
trailer -> . NAME
985
-
trailer -> . NAME
985
(
trailer -> . NAME
985
%
trailer -> . NAME
985
//
trailer -> . NAME
985
==
trailer -> . NAME
985
>>
trailer -> . NAME
985
is
trailer -> . NAME
985
!=
trailer -> . NAME
985
)
trailer -> . NAME
985
and
trailer -> . NAME
985
>=
trailer -> . NAME
985
,
trailer -> . NAME
985
>
trailer -> . NAME
985
in
trailer -> . NAME
985
<<
trailer -> . NAME
985
&
trailer -> . NAME
985
/
trailer -> . NAME
985
^
trailer -> . NAME
985
[
trailer -> . NAME
985
<=
trailer -> . NAME
985
or
trailer -> . NAME
985
+
trailer -> . NAME
985
for
trailer -> . NAME
985
<
trailer -> . NAME
985
*
trailer -> . NAME
985
@
trailer -> . NAME
986
)
trailer -> ( )
986
+
trailer -> ( )
986
!=
trailer -> ( )
986
<<
trailer -> ( )
986
>=
trailer -> ( )
986
**
trailer -> ( )
986
not
trailer -> ( )
986
if
trailer -> ( )
986
,
trailer -> ( )
986
|
trailer -> ( )
986
[
trailer -> ( )
986
==
trailer -> ( )
986
%
trailer -> ( )
986
*
trailer -> ( )
986
>>
trailer -> ( )
986
for
trailer -> ( )
986
@
trailer -> ( )
986
>
trailer -> ( )
986
/
trailer -> ( )
986
in
trailer -> ( )
986
(
trailer -> ( )
986
is
trailer -> ( )
986
//
trailer -> ( )
986
<
trailer -> ( )
986
or
trailer -> ( )
986
^
trailer -> ( )
986
and
trailer -> ( )
986
<=
trailer -> ( )
986
.
trailer -> ( )
986
-
trailer -> ( )
986
&
trailer -> ( )
987
)
1571
988
<=
trailer_expr -> trailer trailer_expr
988
+
trailer_expr -> trailer trailer_expr
988
^
trailer_expr -> trailer trailer_expr
988
for
trailer_expr -> trailer trailer_expr
988
or
trailer_expr -> trailer trailer_expr
988
==
trailer_expr -> trailer trailer_expr
988
%
trailer_expr -> trailer trailer_expr
988
@
trailer_expr -> trailer trailer_expr
988
not
trailer_expr -> trailer trailer_expr
988
<<
trailer_expr -> trailer trailer_expr
988
-
trailer_expr -> trailer trailer_expr
988
//
trailer_expr -> trailer trailer_expr
988
and
trailer_expr -> trailer trailer_expr
988
|
trailer_expr -> trailer trailer_expr
988
if
trailer_expr -> trailer trailer_expr
988
>
trailer_expr -> trailer trailer_expr
988
!=
trailer_expr -> trailer trailer_expr
988
,
trailer_expr -> trailer trailer_expr
988
<
trailer_expr -> trailer trailer_expr
988
>>
trailer_expr -> trailer trailer_expr
988
/
trailer_expr -> trailer trailer_expr
988
is
trailer_expr -> trailer trailer_expr
988
&
trailer_expr -> trailer trailer_expr
988
in
trailer_expr -> trailer trailer_expr
988
>=
trailer_expr -> trailer trailer_expr
988
*
trailer_expr -> trailer trailer_expr
988
)
trailer_expr -> trailer trailer_expr
988
**
trailer_expr -> trailer trailer_expr
989
]
1572
990
==
shift_expr -> arith_expr >> shift_expr
990
^
shift_expr -> arith_expr >> shift_expr
990
or
shift_expr -> arith_expr >> shift_expr
990
if
shift_expr -> arith_expr >> shift_expr
990
for
shift_expr -> arith_expr >> shift_expr
990
,
shift_expr -> arith_expr >> shift_expr
990
not
shift_expr -> arith_expr >> shift_expr
990
<
shift_expr -> arith_expr >> shift_expr
990
|
shift_expr -> arith_expr >> shift_expr
990
<=
shift_expr -> arith_expr >> shift_expr
990
is
shift_expr -> arith_expr >> shift_expr
990
in
shift_expr -> arith_expr >> shift_expr
990
>=
shift_expr -> arith_expr >> shift_expr
990
)
shift_expr -> arith_expr >> shift_expr
990
&
shift_expr -> arith_expr >> shift_expr
990
>
shift_expr -> arith_expr >> shift_expr
990
and
shift_expr -> arith_expr >> shift_expr
990
!=
shift_expr -> arith_expr >> shift_expr
991
for
shift_expr -> arith_expr << shift_expr
991
or
shift_expr -> arith_expr << shift_expr
991
>
shift_expr -> arith_expr << shift_expr
991
in
shift_expr -> arith_expr << shift_expr
991
&
shift_expr -> arith_expr << shift_expr
991
is
shift_expr -> arith_expr << shift_expr
991
<
shift_expr -> arith_expr << shift_expr
991
)
shift_expr -> arith_expr << shift_expr
991
<=
shift_expr -> arith_expr << shift_expr
991
not
shift_expr -> arith_expr << shift_expr
991
if
shift_expr -> arith_expr << shift_expr
991
,
shift_expr -> arith_expr << shift_expr
991
and
shift_expr -> arith_expr << shift_expr
991
^
shift_expr -> arith_expr << shift_expr
991
|
shift_expr -> arith_expr << shift_expr
991
!=
shift_expr -> arith_expr << shift_expr
991
==
shift_expr -> arith_expr << shift_expr
991
>=
shift_expr -> arith_expr << shift_expr
992
>
atom -> ( test_list_comp )
992
@
atom -> ( test_list_comp )
992
&
atom -> ( test_list_comp )
992
[
atom -> ( test_list_comp )
992
)
atom -> ( test_list_comp )
992
if
atom -> ( test_list_comp )
992
==
atom -> ( test_list_comp )
992
>=
atom -> ( test_list_comp )
992
**
atom -> ( test_list_comp )
992
not
atom -> ( test_list_comp )
992
<<
atom -> ( test_list_comp )
992
>>
atom -> ( test_list_comp )
992
in
atom -> ( test_list_comp )
992
or
atom -> ( test_list_comp )
992
.
atom -> ( test_list_comp )
992
/
atom -> ( test_list_comp )
992
^
atom -> ( test_list_comp )
992
is
atom -> ( test_list_comp )
992
,
atom -> ( test_list_comp )
992
and
atom -> ( test_list_comp )
992
//
atom -> ( test_list_comp )
992
<
atom -> ( test_list_comp )
992
*
atom -> ( test_list_comp )
992
<=
atom -> ( test_list_comp )
992
(
atom -> ( test_list_comp )
992
for
atom -> ( test_list_comp )
992
-
atom -> ( test_list_comp )
992
!=
atom -> ( test_list_comp )
992
|
atom -> ( test_list_comp )
992
+
atom -> ( test_list_comp )
992
%
atom -> ( test_list_comp )
993
for
or_test -> and_test or or_test
993
if
or_test -> and_test or or_test
993
)
or_test -> and_test or or_test
993
,
or_test -> and_test or or_test
994
^
arith_expr -> term - arith_expr
994
!=
arith_expr -> term - arith_expr
994
<
arith_expr -> term - arith_expr
994
in
arith_expr -> term - arith_expr
994
==
arith_expr -> term - arith_expr
994
|
arith_expr -> term - arith_expr
994
is
arith_expr -> term - arith_expr
994
&
arith_expr -> term - arith_expr
994
>>
arith_expr -> term - arith_expr
994
<<
arith_expr -> term - arith_expr
994
and
arith_expr -> term - arith_expr
994
,
arith_expr -> term - arith_expr
994
>
arith_expr -> term - arith_expr
994
if
arith_expr -> term - arith_expr
994
for
arith_expr -> term - arith_expr
994
not
arith_expr -> term - arith_expr
994
)
arith_expr -> term - arith_expr
994
>=
arith_expr -> term - arith_expr
994
<=
arith_expr -> term - arith_expr
994
or
arith_expr -> term - arith_expr
995
>=
arith_expr -> term + arith_expr
995
>
arith_expr -> term + arith_expr
995
^
arith_expr -> term + arith_expr
995
or
arith_expr -> term + arith_expr
995
==
arith_expr -> term + arith_expr
995
<=
arith_expr -> term + arith_expr
995
if
arith_expr -> term + arith_expr
995
>>
arith_expr -> term + arith_expr
995
<
arith_expr -> term + arith_expr
995
not
arith_expr -> term + arith_expr
995
&
arith_expr -> term + arith_expr
995
in
arith_expr -> term + arith_expr
995
and
arith_expr -> term + arith_expr
995
,
arith_expr -> term + arith_expr
995
|
arith_expr -> term + arith_expr
995
!=
arith_expr -> term + arith_expr
995
)
arith_expr -> term + arith_expr
995
<<
arith_expr -> term + arith_expr
995
for
arith_expr -> term + arith_expr
995
is
arith_expr -> term + arith_expr
996
>=
expr -> xor_expr | expr
996
,
expr -> xor_expr | expr
996
or
expr -> xor_expr | expr
996
in
expr -> xor_expr | expr
996
!=
expr -> xor_expr | expr
996
and
expr -> xor_expr | expr
996
==
expr -> xor_expr | expr
996
>
expr -> xor_expr | expr
996
<=
expr -> xor_expr | expr
996
is
expr -> xor_expr | expr
996
)
expr -> xor_expr | expr
996
<
expr -> xor_expr | expr
996
if
expr -> xor_expr | expr
996
not
expr -> xor_expr | expr
996
for
expr -> xor_expr | expr
997
else
1573
998
for
comparison -> expr comp_op comparison
998
)
comparison -> expr comp_op comparison
998
or
comparison -> expr comp_op comparison
998
if
comparison -> expr comp_op comparison
998
and
comparison -> expr comp_op comparison
998
,
comparison -> expr comp_op comparison
999
for
and_test -> not_test and and_test
999
or
and_test -> not_test and and_test
999
)
and_test -> not_test and and_test
999
if
and_test -> not_test and and_test
999
,
and_test -> not_test and and_test
1000
[
128
1000
factor
129
1000
True
130
1000
atom_expr
131
1000
~
132
1000
and_expr
133
1000
-
134
1000
{
135
1000
shift_expr
137
1000
atom
138
1000
comparison
140
1000
arith_expr
141
1000
power
142
1000
STRING
143
1000
NAME
144
1000
(
145
1000
and_test
146
1000
term
147
1000
+
148
1000
xor_expr
149
1000
or_test
150
1000
NUMBER
151
1000
not
152
1000
False
153
1000
expr
154
1000
not_test
155
1000
None
156
1000
test
1574
1000
lambdef
157
1000
lambda
158
1001
,
lambdef -> lambda : test
1001
for
lambdef -> lambda : test
1001
)
lambdef -> lambda : test
1002
[
166
1002
factor
167
1002
True
168
1002
atom_expr
169
1002
~
170
1002
not
171
1002
and_expr
172
1002
-
173
1002
{
174
1002
shift_expr
175
1002
atom
176
1002
]
1575
1002
comparison
178
1002
(
179
1002
arith_expr
180
1002
power
181
1002
STRING
182
1002
NAME
183
1002
test
184
1002
and_test
185
1002
term
186
1002
+
187
1002
xor_expr
188
1002
NUMBER
190
1002
test_list_comp
1576
1002
False
191
1002
expr
192
1002
not_test
193
1002
None
194
1002
lambdef
195
1002
lambda
196
1002
or_test
197
1002
test_list
198
1003
not
term -> factor
1003
@
1577
1003
%
1578
1003
/
1579
1003
*
1580
1003
//
1581
1003
<=
term -> factor
1003
)
term -> factor
1003
>
term -> factor
1003
==
term -> factor
1003
is
term -> factor
1003
or
term -> factor
1003
<
term -> factor
1003
and
term -> factor
1003
<<
term -> factor
1003
^
term -> factor
1003
!=
term -> factor
1003
-
term -> factor
1003
&
term -> factor
1003
|
term -> factor
1003
,
term -> factor
1003
>=
term -> factor
1003
if
term -> factor
1003
+
term -> factor
1003
in
term -> factor
1003
>>
term -> factor
1004
<<
atom -> True
1004
&
atom -> True
1004
or
atom -> True
1004
[
atom -> True
1004
if
atom -> True
1004
-
atom -> True
1004
*
atom -> True
1004
^
atom -> True
1004
,
atom -> True
1004
>=
atom -> True
1004
!=
atom -> True
1004
(
atom -> True
1004
not
atom -> True
1004
|
atom -> True
1004
)
atom -> True
1004
+
atom -> True
1004
**
atom -> True
1004
.
atom -> True
1004
is
atom -> True
1004
//
atom -> True
1004
>
atom -> True
1004
%
atom -> True
1004
in
atom -> True
1004
<=
atom -> True
1004
>>
atom -> True
1004
/
atom -> True
1004
==
atom -> True
1004
and
atom -> True
1004
<
atom -> True
1004
@
atom -> True
1005
**
1582
1005
,
power -> atom_expr
1005
)
power -> atom_expr
1005
!=
power -> atom_expr
1005
-
power -> atom_expr
1005
<<
power -> atom_expr
1005
not
power -> atom_expr
1005
/
power -> atom_expr
1005
<=
power -> atom_expr
1005
in
power -> atom_expr
1005
%
power -> atom_expr
1005
>
power -> atom_expr
1005
@
power -> atom_expr
1005
|
power -> atom_expr
1005
<
power -> atom_expr
1005
>>
power -> atom_expr
1005
or
power -> atom_expr
1005
and
power -> atom_expr
1005
>=
power -> atom_expr
1005
==
power -> atom_expr
1005
^
power -> atom_expr
1005
*
power -> atom_expr
1005
&
power -> atom_expr
1005
is
power -> atom_expr
1005
+
power -> atom_expr
1005
if
power -> atom_expr
1005
//
power -> atom_expr
1006
[
1002
1006
True
1004
1006
atom_expr
1005
1006
-
1008
1006
~
1006
1006
atom
1010
1006
{
1011
1006
power
1014
1006
STRING
1015
1006
NAME
1016
1006
(
1017
1006
+
1020
1006
NUMBER
1023
1006
False
1025
1006
factor
1583
1006
None
1027
1007
>
xor_expr -> and_expr
1007
^
1584
1007
<=
xor_expr -> and_expr
1007
not
xor_expr -> and_expr
1007
|
xor_expr -> and_expr
1007
==
xor_expr -> and_expr
1007
,
xor_expr -> and_expr
1007
in
xor_expr -> and_expr
1007
!=
xor_expr -> and_expr
1007
if
xor_expr -> and_expr
1007
is
xor_expr -> and_expr
1007
<
xor_expr -> and_expr
1007
or
xor_expr -> and_expr
1007
)
xor_expr -> and_expr
1007
and
xor_expr -> and_expr
1007
>=
xor_expr -> and_expr
1008
[
1002
1008
True
1004
1008
atom_expr
1005
1008
~
1006
1008
-
1008
1008
atom
1010
1008
{
1011
1008
power
1014
1008
STRING
1015
1008
NAME
1016
1008
(
1017
1008
factor
1585
1008
+
1020
1008
NUMBER
1023
1008
False
1025
1008
None
1027
1009
^
and_expr -> shift_expr
1009
in
and_expr -> shift_expr
1009
|
and_expr -> shift_expr
1009
&
1586
1009
<
and_expr -> shift_expr
1009
not
and_expr -> shift_expr
1009
>=
and_expr -> shift_expr
1009
<=
and_expr -> shift_expr
1009
or
and_expr -> shift_expr
1009
and
and_expr -> shift_expr
1009
,
and_expr -> shift_expr
1009
!=
and_expr -> shift_expr
1009
if
and_expr -> shift_expr
1009
is
and_expr -> shift_expr
1009
==
and_expr -> shift_expr
1009
>
and_expr -> shift_expr
1009
)
and_expr -> shift_expr
1010
>>
trailer_expr -> 
1010
.
1587
1010
(
1588
1010
trailer
1589
1010
)
trailer_expr -> 
1010
trailer_expr
1590
1010
+
trailer_expr -> 
1010
[
1591
1010
is
trailer_expr -> 
1010
>
trailer_expr -> 
1010
not
trailer_expr -> 
1010
|
trailer_expr -> 
1010
&
trailer_expr -> 
1010
/
trailer_expr -> 
1010
@
trailer_expr -> 
1010
!=
trailer_expr -> 
1010
**
trailer_expr -> 
1010
>=
trailer_expr -> 
1010
^
trailer_expr -> 
1010
in
trailer_expr -> 
1010
<<
trailer_expr -> 
1010
and
trailer_expr -> 
1010
or
trailer_expr -> 
1010
if
trailer_expr -> 
1010
//
trailer_expr -> 
1010
%
trailer_expr -> 
1010
,
trailer_expr -> 
1010
<=
trailer_expr -> 
1010
<
trailer_expr -> 
1010
==
trailer_expr -> 
1010
-
trailer_expr -> 
1010
*
trailer_expr -> 
1011
}
1592
1012
or
not_test -> comparison
1012
)
not_test -> comparison
1012
,
not_test -> comparison
1012
and
not_test -> comparison
1012
if
not_test -> comparison
1013
>>
1593
1013
if
shift_expr -> arith_expr
1013
&
shift_expr -> arith_expr
1013
<<
1594
1013
|
shift_expr -> arith_expr
1013
is
shift_expr -> arith_expr
1013
<
shift_expr -> arith_expr
1013
==
shift_expr -> arith_expr
1013
or
shift_expr -> arith_expr
1013
>
shift_expr -> arith_expr
1013
)
shift_expr -> arith_expr
1013
!=
shift_expr -> arith_expr
1013
>=
shift_expr -> arith_expr
1013
in
shift_expr -> arith_expr
1013
,
shift_expr -> arith_expr
1013
<=
shift_expr -> arith_expr
1013
and
shift_expr -> arith_expr
1013
^
shift_expr -> arith_expr
1013
not
shift_expr -> arith_expr
1014
+
factor -> power
1014
%
factor -> power
1014
,
factor -> power
1014
<
factor -> power
1014
<<
factor -> power
1014
!=
factor -> power
1014
<=
factor -> power
1014
and
factor -> power
1014
/
factor -> power
1014
^
factor -> power
1014
@
factor -> power
1014
>=
factor -> power
1014
not
factor -> power
1014
//
factor -> power
1014
or
factor -> power
1014
==
factor -> power
1014
is
factor -> power
1014
|
factor -> power
1014
)
factor -> power
1014
*
factor -> power
1014
-
factor -> power
1014
if
factor -> power
1014
>
factor -> power
1014
in
factor -> power
1014
>>
factor -> power
1014
&
factor -> power
1015
%
atom -> STRING
1015
>
atom -> STRING
1015
@
atom -> STRING
1015
<<
atom -> STRING
1015
in
atom -> STRING
1015
[
atom -> STRING
1015
-
atom -> STRING
1015
==
atom -> STRING
1015
>=
atom -> STRING
1015
not
atom -> STRING
1015
/
atom -> STRING
1015
+
atom -> STRING
1015
*
atom -> STRING
1015
)
atom -> STRING
1015
(
atom -> STRING
1015
//
atom -> STRING
1015
if
atom -> STRING
1015
.
atom -> STRING
1015
<
atom -> STRING
1015
,
atom -> STRING
1015
&
atom -> STRING
1015
<=
atom -> STRING
1015
!=
atom -> STRING
1015
**
atom -> STRING
1015
^
atom -> STRING
1015
and
atom -> STRING
1015
is
atom -> STRING
1015
|
atom -> STRING
1015
or
atom -> STRING
1015
>>
atom -> STRING
1016
)
atom -> NAME
1016
<
atom -> NAME
1016
,
atom -> NAME
1016
^
atom -> NAME
1016
+
atom -> NAME
1016
-
atom -> NAME
1016
>=
atom -> NAME
1016
@
atom -> NAME
1016
!=
atom -> NAME
1016
*
atom -> NAME
1016
<=
atom -> NAME
1016
**
atom -> NAME
1016
or
atom -> NAME
1016
not
atom -> NAME
1016
==
atom -> NAME
1016
&
atom -> NAME
1016
>
atom -> NAME
1016
%
atom -> NAME
1016
>>
atom -> NAME
1016
.
atom -> NAME
1016
|
atom -> NAME
1016
is
atom -> NAME
1016
and
atom -> NAME
1016
//
atom -> NAME
1016
[
atom -> NAME
1016
/
atom -> NAME
1016
(
atom -> NAME
1016
<<
atom -> NAME
1016
if
atom -> NAME
1016
in
atom -> NAME
1017
[
128
1017
factor
129
1017
True
130
1017
atom_expr
131
1017
~
132
1017
and_expr
133
1017
-
134
1017
{
135
1017
test_list_comp
1595
1017
shift_expr
137
1017
atom
138
1017
)
1596
1017
comparison
140
1017
arith_expr
141
1017
power
142
1017
STRING
143
1017
NAME
144
1017
(
145
1017
and_test
146
1017
term
147
1017
+
148
1017
xor_expr
149
1017
or_test
150
1017
NUMBER
151
1017
not
152
1017
False
153
1017
expr
154
1017
not_test
155
1017
None
156
1017
lambdef
157
1017
lambda
158
1017
test
159
1017
test_list
160
1018
or
1597
1018
,
or_test -> and_test
1018
if
or_test -> and_test
1018
)
or_test -> and_test
1019
-
1598
1019
+
1599
1019
>=
arith_expr -> term
1019
|
arith_expr -> term
1019
<=
arith_expr -> term
1019
not
arith_expr -> term
1019
,
arith_expr -> term
1019
==
arith_expr -> term
1019
)
arith_expr -> term
1019
in
arith_expr -> term
1019
>>
arith_expr -> term
1019
is
arith_expr -> term
1019
if
arith_expr -> term
1019
or
arith_expr -> term
1019
!=
arith_expr -> term
1019
>
arith_expr -> term
1019
and
arith_expr -> term
1019
<<
arith_expr -> term
1019
<
arith_expr -> term
1019
^
arith_expr -> term
1019
&
arith_expr -> term
1020
[
1002
1020
True
1004
1020
atom_expr
1005
1020
-
1008
1020
~
1006
1020
atom
1010
1020
{
1011
1020
power
1014
1020
STRING
1015
1020
NAME
1016
1020
(
1017
1020
factor
1600
1020
+
1020
1020
NUMBER
1023
1020
False
1025
1020
None
1027
1021
|
1601
1021
>
expr -> xor_expr
1021
if
expr -> xor_expr
1021
is
expr -> xor_expr
1021
and
expr -> xor_expr
1021
)
expr -> xor_expr
1021
not
expr -> xor_expr
1021
or
expr -> xor_expr
1021
>=
expr -> xor_expr
1021
==
expr -> xor_expr
1021
,
expr -> xor_expr
1021
<
expr -> xor_expr
1021
!=
expr -> xor_expr
1021
<=
expr -> xor_expr
1021
in
expr -> xor_expr
1022
)
test -> or_test
1022
,
test -> or_test
1022
if
1602
1023
+
atom -> NUMBER
1023
*
atom -> NUMBER
1023
>
atom -> NUMBER
1023
<<
atom -> NUMBER
1023
-
atom -> NUMBER
1023
**
atom -> NUMBER
1023
if
atom -> NUMBER
1023
or
atom -> NUMBER
1023
is
atom -> NUMBER
1023
[
atom -> NUMBER
1023
(
atom -> NUMBER
1023
not
atom -> NUMBER
1023
&
atom -> NUMBER
1023
)
atom -> NUMBER
1023
^
atom -> NUMBER
1023
in
atom -> NUMBER
1023
==
atom -> NUMBER
1023
//
atom -> NUMBER
1023
!=
atom -> NUMBER
1023
and
atom -> NUMBER
1023
%
atom -> NUMBER
1023
<=
atom -> NUMBER
1023
.
atom -> NUMBER
1023
<
atom -> NUMBER
1023
>>
atom -> NUMBER
1023
,
atom -> NUMBER
1023
/
atom -> NUMBER
1023
@
atom -> NUMBER
1023
>=
atom -> NUMBER
1023
|
atom -> NUMBER
1024
[
1002
1024
factor
1003
1024
True
1004
1024
atom_expr
1005
1024
~
1006
1024
and_expr
1007
1024
-
1008
1024
shift_expr
1009
1024
atom
1010
1024
{
1011
1024
comparison
1012
1024
arith_expr
1013
1024
power
1014
1024
STRING
1015
1024
NAME
1016
1024
(
1017
1024
term
1019
1024
+
1020
1024
xor_expr
1021
1024
NUMBER
1023
1024
not
1024
1024
False
1025
1024
not_test
1603
1024
None
1027
1024
expr
1028
1025
(
atom -> False
1025
*
atom -> False
1025
==
atom -> False
1025
|
atom -> False
1025
,
atom -> False
1025
[
atom -> False
1025
in
atom -> False
1025
&
atom -> False
1025
is
atom -> False
1025
not
atom -> False
1025
if
atom -> False
1025
^
atom -> False
1025
+
atom -> False
1025
)
atom -> False
1025
>
atom -> False
1025
<=
atom -> False
1025
<<
atom -> False
1025
<
atom -> False
1025
>=
atom -> False
1025
%
atom -> False
1025
@
atom -> False
1025
and
atom -> False
1025
!=
atom -> False
1025
-
atom -> False
1025
.
atom -> False
1025
//
atom -> False
1025
/
atom -> False
1025
**
atom -> False
1025
>>
atom -> False
1025
or
atom -> False
1026
and
1604
1026
,
and_test -> not_test
1026
if
and_test -> not_test
1026
)
and_test -> not_test
1026
or
and_test -> not_test
1027
@
atom -> None
1027
<=
atom -> None
1027
in
atom -> None
1027
and
atom -> None
1027
&
atom -> None
1027
|
atom -> None
1027
>
atom -> None
1027
)
atom -> None
1027
>=
atom -> None
1027
/
atom -> None
1027
<<
atom -> None
1027
-
atom -> None
1027
!=
atom -> None
1027
**
atom -> None
1027
(
atom -> None
1027
*
atom -> None
1027
.
atom -> None
1027
>>
atom -> None
1027
==
atom -> None
1027
is
atom -> None
1027
<
atom -> None
1027
if
atom -> None
1027
^
atom -> None
1027
[
atom -> None
1027
%
atom -> None
1027
+
atom -> None
1027
not
atom -> None
1027
,
atom -> None
1027
or
atom -> None
1027
//
atom -> None
1028
>
317
1028
is
318
1028
in
319
1028
<=
320
1028
<
321
1028
>=
322
1028
!=
324
1028
not
325
1028
==
326
1028
comp_op
1605
1028
or
comparison -> expr
1028
if
comparison -> expr
1028
)
comparison -> expr
1028
and
comparison -> expr
1028
,
comparison -> expr
1029
varargslist
1606
1029
vfpdef
234
1029
:
1607
1029
NAME
233
1030
)
test_list -> test , test_list
1031
,
test -> lambdef
1031
)
test -> lambdef
1032
)
test_list -> test
1032
,
515
1033
in
1608
1034
.
atom -> [ test_list_comp ]
1034
[
atom -> [ test_list_comp ]
1034
@
atom -> [ test_list_comp ]
1034
<=
atom -> [ test_list_comp ]
1034
<
atom -> [ test_list_comp ]
1034
not
atom -> [ test_list_comp ]
1034
]
atom -> [ test_list_comp ]
1034
for
atom -> [ test_list_comp ]
1034
in
atom -> [ test_list_comp ]
1034
and
atom -> [ test_list_comp ]
1034
-
atom -> [ test_list_comp ]
1034
if
atom -> [ test_list_comp ]
1034
!=
atom -> [ test_list_comp ]
1034
is
atom -> [ test_list_comp ]
1034
>>
atom -> [ test_list_comp ]
1034
or
atom -> [ test_list_comp ]
1034
//
atom -> [ test_list_comp ]
1034
/
atom -> [ test_list_comp ]
1034
,
atom -> [ test_list_comp ]
1034
|
atom -> [ test_list_comp ]
1034
>
atom -> [ test_list_comp ]
1034
&
atom -> [ test_list_comp ]
1034
(
atom -> [ test_list_comp ]
1034
%
atom -> [ test_list_comp ]
1034
>=
atom -> [ test_list_comp ]
1034
==
atom -> [ test_list_comp ]
1034
**
atom -> [ test_list_comp ]
1034
<<
atom -> [ test_list_comp ]
1034
^
atom -> [ test_list_comp ]
1034
+
atom -> [ test_list_comp ]
1034
*
atom -> [ test_list_comp ]
1035
for
term -> factor @ term
1035
]
term -> factor @ term
1035
<<
term -> factor @ term
1035
^
term -> factor @ term
1035
<=
term -> factor @ term
1035
==
term -> factor @ term
1035
if
term -> factor @ term
1035
|
term -> factor @ term
1035
!=
term -> factor @ term
1035
or
term -> factor @ term
1035
>
term -> factor @ term
1035
and
term -> factor @ term
1035
>>
term -> factor @ term
1035
is
term -> factor @ term
1035
-
term -> factor @ term
1035
not
term -> factor @ term
1035
+
term -> factor @ term
1035
in
term -> factor @ term
1035
>=
term -> factor @ term
1035
<
term -> factor @ term
1035
,
term -> factor @ term
1035
&
term -> factor @ term
1036
for
term -> factor // term
1036
!=
term -> factor // term
1036
or
term -> factor // term
1036
^
term -> factor // term
1036
>
term -> factor // term
1036
is
term -> factor // term
1036
&
term -> factor // term
1036
-
term -> factor // term
1036
in
term -> factor // term
1036
>>
term -> factor // term
1036
|
term -> factor // term
1036
<
term -> factor // term
1036
>=
term -> factor // term
1036
not
term -> factor // term
1036
if
term -> factor // term
1036
==
term -> factor // term
1036
]
term -> factor // term
1036
<=
term -> factor // term
1036
,
term -> factor // term
1036
and
term -> factor // term
1036
<<
term -> factor // term
1036
+
term -> factor // term
1037
<=
term -> factor % term
1037
is
term -> factor % term
1037
>
term -> factor % term
1037
and
term -> factor % term
1037
in
term -> factor % term
1037
,
term -> factor % term
1037
or
term -> factor % term
1037
<
term -> factor % term
1037
-
term -> factor % term
1037
]
term -> factor % term
1037
!=
term -> factor % term
1037
>>
term -> factor % term
1037
^
term -> factor % term
1037
+
term -> factor % term
1037
if
term -> factor % term
1037
<<
term -> factor % term
1037
>=
term -> factor % term
1037
==
term -> factor % term
1037
not
term -> factor % term
1037
|
term -> factor % term
1037
&
term -> factor % term
1037
for
term -> factor % term
1038
>>
term -> factor / term
1038
!=
term -> factor / term
1038
<
term -> factor / term
1038
<=
term -> factor / term
1038
|
term -> factor / term
1038
is
term -> factor / term
1038
>=
term -> factor / term
1038
^
term -> factor / term
1038
&
term -> factor / term
1038
]
term -> factor / term
1038
+
term -> factor / term
1038
for
term -> factor / term
1038
<<
term -> factor / term
1038
and
term -> factor / term
1038
-
term -> factor / term
1038
in
term -> factor / term
1038
>
term -> factor / term
1038
or
term -> factor / term
1038
not
term -> factor / term
1038
==
term -> factor / term
1038
,
term -> factor / term
1038
if
term -> factor / term
1039
is
term -> factor * term
1039
+
term -> factor * term
1039
>=
term -> factor * term
1039
^
term -> factor * term
1039
,
term -> factor * term
1039
<=
term -> factor * term
1039
or
term -> factor * term
1039
for
term -> factor * term
1039
]
term -> factor * term
1039
<
term -> factor * term
1039
|
term -> factor * term
1039
>>
term -> factor * term
1039
in
term -> factor * term
1039
not
term -> factor * term
1039
==
term -> factor * term
1039
-
term -> factor * term
1039
and
term -> factor * term
1039
!=
term -> factor * term
1039
<<
term -> factor * term
1039
>
term -> factor * term
1039
if
term -> factor * term
1039
&
term -> factor * term
1040
!=
power -> atom_expr ** factor
1040
@
power -> atom_expr ** factor
1040
for
power -> atom_expr ** factor
1040
|
power -> atom_expr ** factor
1040
in
power -> atom_expr ** factor
1040
==
power -> atom_expr ** factor
1040
if
power -> atom_expr ** factor
1040
and
power -> atom_expr ** factor
1040
>=
power -> atom_expr ** factor
1040
/
power -> atom_expr ** factor
1040
not
power -> atom_expr ** factor
1040
^
power -> atom_expr ** factor
1040
]
power -> atom_expr ** factor
1040
//
power -> atom_expr ** factor
1040
>
power -> atom_expr ** factor
1040
+
power -> atom_expr ** factor
1040
%
power -> atom_expr ** factor
1040
-
power -> atom_expr ** factor
1040
is
power -> atom_expr ** factor
1040
<=
power -> atom_expr ** factor
1040
<
power -> atom_expr ** factor
1040
,
power -> atom_expr ** factor
1040
*
power -> atom_expr ** factor
1040
<<
power -> atom_expr ** factor
1040
or
power -> atom_expr ** factor
1040
>>
power -> atom_expr ** factor
1040
&
power -> atom_expr ** factor
1041
not
xor_expr -> and_expr ^ xor_expr
1041
<
xor_expr -> and_expr ^ xor_expr
1041
,
xor_expr -> and_expr ^ xor_expr
1041
>=
xor_expr -> and_expr ^ xor_expr
1041
>
xor_expr -> and_expr ^ xor_expr
1041
is
xor_expr -> and_expr ^ xor_expr
1041
]
xor_expr -> and_expr ^ xor_expr
1041
!=
xor_expr -> and_expr ^ xor_expr
1041
and
xor_expr -> and_expr ^ xor_expr
1041
if
xor_expr -> and_expr ^ xor_expr
1041
<=
xor_expr -> and_expr ^ xor_expr
1041
in
xor_expr -> and_expr ^ xor_expr
1041
==
xor_expr -> and_expr ^ xor_expr
1041
for
xor_expr -> and_expr ^ xor_expr
1041
|
xor_expr -> and_expr ^ xor_expr
1041
or
xor_expr -> and_expr ^ xor_expr
1042
<
and_expr -> shift_expr & and_expr
1042
if
and_expr -> shift_expr & and_expr
1042
>=
and_expr -> shift_expr & and_expr
1042
not
and_expr -> shift_expr & and_expr
1042
==
and_expr -> shift_expr & and_expr
1042
>
and_expr -> shift_expr & and_expr
1042
]
and_expr -> shift_expr & and_expr
1042
in
and_expr -> shift_expr & and_expr
1042
^
and_expr -> shift_expr & and_expr
1042
or
and_expr -> shift_expr & and_expr
1042
and
and_expr -> shift_expr & and_expr
1042
!=
and_expr -> shift_expr & and_expr
1042
,
and_expr -> shift_expr & and_expr
1042
for
and_expr -> shift_expr & and_expr
1042
|
and_expr -> shift_expr & and_expr
1042
is
and_expr -> shift_expr & and_expr
1042
<=
and_expr -> shift_expr & and_expr
1043
+
trailer -> ( )
1043
!=
trailer -> ( )
1043
<<
trailer -> ( )
1043
>=
trailer -> ( )
1043
**
trailer -> ( )
1043
not
trailer -> ( )
1043
if
trailer -> ( )
1043
,
trailer -> ( )
1043
|
trailer -> ( )
1043
[
trailer -> ( )
1043
==
trailer -> ( )
1043
%
trailer -> ( )
1043
*
trailer -> ( )
1043
>>
trailer -> ( )
1043
for
trailer -> ( )
1043
@
trailer -> ( )
1043
>
trailer -> ( )
1043
/
trailer -> ( )
1043
in
trailer -> ( )
1043
(
trailer -> ( )
1043
]
trailer -> ( )
1043
is
trailer -> ( )
1043
//
trailer -> ( )
1043
<
trailer -> ( )
1043
or
trailer -> ( )
1043
^
trailer -> ( )
1043
and
trailer -> ( )
1043
<=
trailer -> ( )
1043
.
trailer -> ( )
1043
-
trailer -> ( )
1043
&
trailer -> ( )
1044
)
1609
1045
<=
trailer_expr -> trailer trailer_expr
1045
+
trailer_expr -> trailer trailer_expr
1045
^
trailer_expr -> trailer trailer_expr
1045
for
trailer_expr -> trailer trailer_expr
1045
or
trailer_expr -> trailer trailer_expr
1045
==
trailer_expr -> trailer trailer_expr
1045
%
trailer_expr -> trailer trailer_expr
1045
@
trailer_expr -> trailer trailer_expr
1045
]
trailer_expr -> trailer trailer_expr
1045
not
trailer_expr -> trailer trailer_expr
1045
<<
trailer_expr -> trailer trailer_expr
1045
-
trailer_expr -> trailer trailer_expr
1045
//
trailer_expr -> trailer trailer_expr
1045
and
trailer_expr -> trailer trailer_expr
1045
|
trailer_expr -> trailer trailer_expr
1045
if
trailer_expr -> trailer trailer_expr
1045
>
trailer_expr -> trailer trailer_expr
1045
!=
trailer_expr -> trailer trailer_expr
1045
,
trailer_expr -> trailer trailer_expr
1045
<
trailer_expr -> trailer trailer_expr
1045
>>
trailer_expr -> trailer trailer_expr
1045
/
trailer_expr -> trailer trailer_expr
1045
is
trailer_expr -> trailer trailer_expr
1045
&
trailer_expr -> trailer trailer_expr
1045
in
trailer_expr -> trailer trailer_expr
1045
>=
trailer_expr -> trailer trailer_expr
1045
*
trailer_expr -> trailer trailer_expr
1045
**
trailer_expr -> trailer trailer_expr
1046
.
trailer -> . NAME
1046
not
trailer -> . NAME
1046
if
trailer -> . NAME
1046
**
trailer -> . NAME
1046
|
trailer -> . NAME
1046
-
trailer -> . NAME
1046
(
trailer -> . NAME
1046
%
trailer -> . NAME
1046
//
trailer -> . NAME
1046
==
trailer -> . NAME
1046
>>
trailer -> . NAME
1046
is
trailer -> . NAME
1046
!=
trailer -> . NAME
1046
and
trailer -> . NAME
1046
>=
trailer -> . NAME
1046
,
trailer -> . NAME
1046
>
trailer -> . NAME
1046
in
trailer -> . NAME
1046
<<
trailer -> . NAME
1046
&
trailer -> . NAME
1046
/
trailer -> . NAME
1046
^
trailer -> . NAME
1046
[
trailer -> . NAME
1046
<=
trailer -> . NAME
1046
]
trailer -> . NAME
1046
or
trailer -> . NAME
1046
+
trailer -> . NAME
1046
for
trailer -> . NAME
1046
<
trailer -> . NAME
1046
*
trailer -> . NAME
1046
@
trailer -> . NAME
1047
]
1610
1048
>
atom -> ( test_list_comp )
1048
@
atom -> ( test_list_comp )
1048
&
atom -> ( test_list_comp )
1048
[
atom -> ( test_list_comp )
1048
if
atom -> ( test_list_comp )
1048
==
atom -> ( test_list_comp )
1048
>=
atom -> ( test_list_comp )
1048
**
atom -> ( test_list_comp )
1048
not
atom -> ( test_list_comp )
1048
<<
atom -> ( test_list_comp )
1048
>>
atom -> ( test_list_comp )
1048
in
atom -> ( test_list_comp )
1048
or
atom -> ( test_list_comp )
1048
]
atom -> ( test_list_comp )
1048
/
atom -> ( test_list_comp )
1048
.
atom -> ( test_list_comp )
1048
^
atom -> ( test_list_comp )
1048
is
atom -> ( test_list_comp )
1048
,
atom -> ( test_list_comp )
1048
and
atom -> ( test_list_comp )
1048
//
atom -> ( test_list_comp )
1048
<
atom -> ( test_list_comp )
1048
*
atom -> ( test_list_comp )
1048
<=
atom -> ( test_list_comp )
1048
(
atom -> ( test_list_comp )
1048
for
atom -> ( test_list_comp )
1048
-
atom -> ( test_list_comp )
1048
!=
atom -> ( test_list_comp )
1048
|
atom -> ( test_list_comp )
1048
+
atom -> ( test_list_comp )
1048
%
atom -> ( test_list_comp )
1049
==
shift_expr -> arith_expr >> shift_expr
1049
^
shift_expr -> arith_expr >> shift_expr
1049
or
shift_expr -> arith_expr >> shift_expr
1049
if
shift_expr -> arith_expr >> shift_expr
1049
for
shift_expr -> arith_expr >> shift_expr
1049
,
shift_expr -> arith_expr >> shift_expr
1049
not
shift_expr -> arith_expr >> shift_expr
1049
|
shift_expr -> arith_expr >> shift_expr
1049
<=
shift_expr -> arith_expr >> shift_expr
1049
]
shift_expr -> arith_expr >> shift_expr
1049
in
shift_expr -> arith_expr >> shift_expr
1049
is
shift_expr -> arith_expr >> shift_expr
1049
>=
shift_expr -> arith_expr >> shift_expr
1049
>
shift_expr -> arith_expr >> shift_expr
1049
&
shift_expr -> arith_expr >> shift_expr
1049
<
shift_expr -> arith_expr >> shift_expr
1049
and
shift_expr -> arith_expr >> shift_expr
1049
!=
shift_expr -> arith_expr >> shift_expr
1050
for
shift_expr -> arith_expr << shift_expr
1050
or
shift_expr -> arith_expr << shift_expr
1050
]
shift_expr -> arith_expr << shift_expr
1050
in
shift_expr -> arith_expr << shift_expr
1050
>
shift_expr -> arith_expr << shift_expr
1050
&
shift_expr -> arith_expr << shift_expr
1050
is
shift_expr -> arith_expr << shift_expr
1050
<
shift_expr -> arith_expr << shift_expr
1050
<=
shift_expr -> arith_expr << shift_expr
1050
not
shift_expr -> arith_expr << shift_expr
1050
^
shift_expr -> arith_expr << shift_expr
1050
if
shift_expr -> arith_expr << shift_expr
1050
,
shift_expr -> arith_expr << shift_expr
1050
and
shift_expr -> arith_expr << shift_expr
1050
|
shift_expr -> arith_expr << shift_expr
1050
!=
shift_expr -> arith_expr << shift_expr
1050
==
shift_expr -> arith_expr << shift_expr
1050
>=
shift_expr -> arith_expr << shift_expr
1051
in
1611
1052
[
166
1052
factor
167
1052
True
168
1052
atom_expr
169
1052
~
170
1052
not
171
1052
and_expr
172
1052
-
173
1052
{
174
1052
shift_expr
175
1052
atom
176
1052
]
1612
1052
comparison
178
1052
(
179
1052
arith_expr
180
1052
power
181
1052
STRING
182
1052
NAME
183
1052
test
184
1052
and_test
185
1052
term
186
1052
+
187
1052
xor_expr
188
1052
NUMBER
190
1052
test_list_comp
1613
1052
False
191
1052
expr
192
1052
not_test
193
1052
None
194
1052
lambdef
195
1052
lambda
196
1052
or_test
197
1052
test_list
198
1053
not
term -> factor
1053
@
1614
1053
//
1615
1053
%
1616
1053
/
1617
1053
*
1618
1053
<=
term -> factor
1053
>
term -> factor
1053
==
term -> factor
1053
is
term -> factor
1053
or
term -> factor
1053
<
term -> factor
1053
and
term -> factor
1053
<<
term -> factor
1053
^
term -> factor
1053
!=
term -> factor
1053
-
term -> factor
1053
&
term -> factor
1053
|
term -> factor
1053
,
term -> factor
1053
>=
term -> factor
1053
if
term -> factor
1053
+
term -> factor
1053
in
term -> factor
1053
>>
term -> factor
1053
]
term -> factor
1054
<<
atom -> True
1054
&
atom -> True
1054
or
atom -> True
1054
[
atom -> True
1054
if
atom -> True
1054
-
atom -> True
1054
*
atom -> True
1054
^
atom -> True
1054
,
atom -> True
1054
>=
atom -> True
1054
!=
atom -> True
1054
(
atom -> True
1054
not
atom -> True
1054
|
atom -> True
1054
]
atom -> True
1054
+
atom -> True
1054
**
atom -> True
1054
.
atom -> True
1054
is
atom -> True
1054
//
atom -> True
1054
>
atom -> True
1054
%
atom -> True
1054
in
atom -> True
1054
<=
atom -> True
1054
>>
atom -> True
1054
/
atom -> True
1054
==
atom -> True
1054
and
atom -> True
1054
<
atom -> True
1054
@
atom -> True
1055
**
1619
1055
,
power -> atom_expr
1055
!=
power -> atom_expr
1055
-
power -> atom_expr
1055
<<
power -> atom_expr
1055
not
power -> atom_expr
1055
/
power -> atom_expr
1055
<=
power -> atom_expr
1055
in
power -> atom_expr
1055
%
power -> atom_expr
1055
>
power -> atom_expr
1055
@
power -> atom_expr
1055
|
power -> atom_expr
1055
<
power -> atom_expr
1055
>>
power -> atom_expr
1055
]
power -> atom_expr
1055
or
power -> atom_expr
1055
and
power -> atom_expr
1055
>=
power -> atom_expr
1055
==
power -> atom_expr
1055
^
power -> atom_expr
1055
*
power -> atom_expr
1055
&
power -> atom_expr
1055
is
power -> atom_expr
1055
+
power -> atom_expr
1055
if
power -> atom_expr
1055
//
power -> atom_expr
1056
[
1052
1056
True
1054
1056
atom_expr
1055
1056
-
1059
1056
~
1056
1056
atom
1061
1056
{
1062
1056
(
1064
1056
power
1066
1056
STRING
1067
1056
NAME
1068
1056
+
1072
1056
NUMBER
1074
1056
False
1075
1056
factor
1620
1056
None
1077
1057
[
1052
1057
factor
1053
1057
True
1054
1057
atom_expr
1055
1057
~
1056
1057
not
1057
1057
and_expr
1058
1057
-
1059
1057
shift_expr
1060
1057
atom
1061
1057
{
1062
1057
comparison
1063
1057
(
1064
1057
arith_expr
1065
1057
power
1066
1057
STRING
1067
1057
NAME
1068
1057
term
1071
1057
+
1072
1057
xor_expr
1073
1057
NUMBER
1074
1057
False
1075
1057
not_test
1621
1057
None
1077
1057
expr
1078
1058
>
xor_expr -> and_expr
1058
<=
xor_expr -> and_expr
1058
not
xor_expr -> and_expr
1058
|
xor_expr -> and_expr
1058
^
1622
1058
==
xor_expr -> and_expr
1058
,
xor_expr -> and_expr
1058
in
xor_expr -> and_expr
1058
!=
xor_expr -> and_expr
1058
if
xor_expr -> and_expr
1058
is
xor_expr -> and_expr
1058
<
xor_expr -> and_expr
1058
or
xor_expr -> and_expr
1058
]
xor_expr -> and_expr
1058
and
xor_expr -> and_expr
1058
>=
xor_expr -> and_expr
1059
[
1052
1059
True
1054
1059
atom_expr
1055
1059
~
1056
1059
-
1059
1059
atom
1061
1059
{
1062
1059
(
1064
1059
power
1066
1059
STRING
1067
1059
NAME
1068
1059
factor
1623
1059
+
1072
1059
NUMBER
1074
1059
False
1075
1059
None
1077
1060
^
and_expr -> shift_expr
1060
in
and_expr -> shift_expr
1060
|
and_expr -> shift_expr
1060
&
1624
1060
<
and_expr -> shift_expr
1060
not
and_expr -> shift_expr
1060
>=
and_expr -> shift_expr
1060
]
and_expr -> shift_expr
1060
<=
and_expr -> shift_expr
1060
or
and_expr -> shift_expr
1060
and
and_expr -> shift_expr
1060
,
and_expr -> shift_expr
1060
!=
and_expr -> shift_expr
1060
if
and_expr -> shift_expr
1060
is
and_expr -> shift_expr
1060
==
and_expr -> shift_expr
1060
>
and_expr -> shift_expr
1061
>>
trailer_expr -> 
1061
(
1625
1061
trailer
1626
1061
trailer_expr
1627
1061
.
1628
1061
+
trailer_expr -> 
1061
[
1629
1061
is
trailer_expr -> 
1061
>
trailer_expr -> 
1061
not
trailer_expr -> 
1061
|
trailer_expr -> 
1061
&
trailer_expr -> 
1061
/
trailer_expr -> 
1061
@
trailer_expr -> 
1061
!=
trailer_expr -> 
1061
**
trailer_expr -> 
1061
>=
trailer_expr -> 
1061
^
trailer_expr -> 
1061
in
trailer_expr -> 
1061
]
trailer_expr -> 
1061
<<
trailer_expr -> 
1061
and
trailer_expr -> 
1061
or
trailer_expr -> 
1061
if
trailer_expr -> 
1061
//
trailer_expr -> 
1061
%
trailer_expr -> 
1061
,
trailer_expr -> 
1061
<=
trailer_expr -> 
1061
<
trailer_expr -> 
1061
==
trailer_expr -> 
1061
-
trailer_expr -> 
1061
*
trailer_expr -> 
1062
}
1630
1063
or
not_test -> comparison
1063
,
not_test -> comparison
1063
]
not_test -> comparison
1063
and
not_test -> comparison
1063
if
not_test -> comparison
1064
[
128
1064
factor
129
1064
True
130
1064
atom_expr
131
1064
~
132
1064
and_expr
133
1064
-
134
1064
{
135
1064
test_list_comp
1631
1064
shift_expr
137
1064
atom
138
1064
)
1632
1064
comparison
140
1064
arith_expr
141
1064
power
142
1064
STRING
143
1064
NAME
144
1064
(
145
1064
and_test
146
1064
term
147
1064
+
148
1064
xor_expr
149
1064
or_test
150
1064
NUMBER
151
1064
not
152
1064
False
153
1064
expr
154
1064
not_test
155
1064
None
156
1064
lambdef
157
1064
lambda
158
1064
test
159
1064
test_list
160
1065
>>
1633
1065
<<
1634
1065
if
shift_expr -> arith_expr
1065
&
shift_expr -> arith_expr
1065
|
shift_expr -> arith_expr
1065
is
shift_expr -> arith_expr
1065
<
shift_expr -> arith_expr
1065
==
shift_expr -> arith_expr
1065
or
shift_expr -> arith_expr
1065
>
shift_expr -> arith_expr
1065
!=
shift_expr -> arith_expr
1065
>=
shift_expr -> arith_expr
1065
]
shift_expr -> arith_expr
1065
in
shift_expr -> arith_expr
1065
,
shift_expr -> arith_expr
1065
<=
shift_expr -> arith_expr
1065
and
shift_expr -> arith_expr
1065
^
shift_expr -> arith_expr
1065
not
shift_expr -> arith_expr
1066
+
factor -> power
1066
%
factor -> power
1066
,
factor -> power
1066
<
factor -> power
1066
<<
factor -> power
1066
!=
factor -> power
1066
<=
factor -> power
1066
and
factor -> power
1066
/
factor -> power
1066
^
factor -> power
1066
@
factor -> power
1066
>=
factor -> power
1066
not
factor -> power
1066
//
factor -> power
1066
or
factor -> power
1066
==
factor -> power
1066
is
factor -> power
1066
]
factor -> power
1066
|
factor -> power
1066
*
factor -> power
1066
-
factor -> power
1066
if
factor -> power
1066
>
factor -> power
1066
in
factor -> power
1066
>>
factor -> power
1066
&
factor -> power
1067
%
atom -> STRING
1067
>
atom -> STRING
1067
@
atom -> STRING
1067
<<
atom -> STRING
1067
in
atom -> STRING
1067
[
atom -> STRING
1067
-
atom -> STRING
1067
==
atom -> STRING
1067
>=
atom -> STRING
1067
not
atom -> STRING
1067
/
atom -> STRING
1067
+
atom -> STRING
1067
*
atom -> STRING
1067
(
atom -> STRING
1067
//
atom -> STRING
1067
if
atom -> STRING
1067
.
atom -> STRING
1067
<
atom -> STRING
1067
,
atom -> STRING
1067
&
atom -> STRING
1067
<=
atom -> STRING
1067
!=
atom -> STRING
1067
**
atom -> STRING
1067
^
atom -> STRING
1067
and
atom -> STRING
1067
]
atom -> STRING
1067
is
atom -> STRING
1067
|
atom -> STRING
1067
or
atom -> STRING
1067
>>
atom -> STRING
1068
<
atom -> NAME
1068
,
atom -> NAME
1068
^
atom -> NAME
1068
+
atom -> NAME
1068
-
atom -> NAME
1068
>=
atom -> NAME
1068
@
atom -> NAME
1068
!=
atom -> NAME
1068
*
atom -> NAME
1068
<=
atom -> NAME
1068
**
atom -> NAME
1068
or
atom -> NAME
1068
not
atom -> NAME
1068
==
atom -> NAME
1068
&
atom -> NAME
1068
]
atom -> NAME
1068
>
atom -> NAME
1068
%
atom -> NAME
1068
>>
atom -> NAME
1068
.
atom -> NAME
1068
|
atom -> NAME
1068
is
atom -> NAME
1068
and
atom -> NAME
1068
//
atom -> NAME
1068
[
atom -> NAME
1068
/
atom -> NAME
1068
(
atom -> NAME
1068
<<
atom -> NAME
1068
if
atom -> NAME
1068
in
atom -> NAME
1069
]
or_test -> and_test
1069
or
1635
1069
,
or_test -> and_test
1069
if
or_test -> and_test
1070
,
548
1070
]
test_list -> test
1071
-
1636
1071
+
1637
1071
]
arith_expr -> term
1071
|
arith_expr -> term
1071
>=
arith_expr -> term
1071
<=
arith_expr -> term
1071
not
arith_expr -> term
1071
,
arith_expr -> term
1071
==
arith_expr -> term
1071
in
arith_expr -> term
1071
>>
arith_expr -> term
1071
is
arith_expr -> term
1071
if
arith_expr -> term
1071
or
arith_expr -> term
1071
!=
arith_expr -> term
1071
>
arith_expr -> term
1071
and
arith_expr -> term
1071
<<
arith_expr -> term
1071
<
arith_expr -> term
1071
^
arith_expr -> term
1071
&
arith_expr -> term
1072
[
1052
1072
True
1054
1072
atom_expr
1055
1072
-
1059
1072
~
1056
1072
atom
1061
1072
{
1062
1072
(
1064
1072
power
1066
1072
STRING
1067
1072
NAME
1068
1072
factor
1638
1072
+
1072
1072
NUMBER
1074
1072
False
1075
1072
None
1077
1073
|
1639
1073
]
expr -> xor_expr
1073
>
expr -> xor_expr
1073
if
expr -> xor_expr
1073
is
expr -> xor_expr
1073
and
expr -> xor_expr
1073
not
expr -> xor_expr
1073
or
expr -> xor_expr
1073
>=
expr -> xor_expr
1073
==
expr -> xor_expr
1073
,
expr -> xor_expr
1073
<
expr -> xor_expr
1073
!=
expr -> xor_expr
1073
<=
expr -> xor_expr
1073
in
expr -> xor_expr
1074
+
atom -> NUMBER
1074
*
atom -> NUMBER
1074
>
atom -> NUMBER
1074
<<
atom -> NUMBER
1074
-
atom -> NUMBER
1074
**
atom -> NUMBER
1074
if
atom -> NUMBER
1074
or
atom -> NUMBER
1074
is
atom -> NUMBER
1074
[
atom -> NUMBER
1074
(
atom -> NUMBER
1074
not
atom -> NUMBER
1074
&
atom -> NUMBER
1074
^
atom -> NUMBER
1074
in
atom -> NUMBER
1074
==
atom -> NUMBER
1074
//
atom -> NUMBER
1074
!=
atom -> NUMBER
1074
and
atom -> NUMBER
1074
]
atom -> NUMBER
1074
%
atom -> NUMBER
1074
<=
atom -> NUMBER
1074
.
atom -> NUMBER
1074
<
atom -> NUMBER
1074
>>
atom -> NUMBER
1074
,
atom -> NUMBER
1074
/
atom -> NUMBER
1074
@
atom -> NUMBER
1074
>=
atom -> NUMBER
1074
|
atom -> NUMBER
1075
(
atom -> False
1075
*
atom -> False
1075
==
atom -> False
1075
|
atom -> False
1075
,
atom -> False
1075
]
atom -> False
1075
[
atom -> False
1075
in
atom -> False
1075
&
atom -> False
1075
is
atom -> False
1075
not
atom -> False
1075
if
atom -> False
1075
^
atom -> False
1075
+
atom -> False
1075
>
atom -> False
1075
<=
atom -> False
1075
<<
atom -> False
1075
<
atom -> False
1075
>=
atom -> False
1075
%
atom -> False
1075
@
atom -> False
1075
and
atom -> False
1075
!=
atom -> False
1075
-
atom -> False
1075
.
atom -> False
1075
//
atom -> False
1075
/
atom -> False
1075
**
atom -> False
1075
>>
atom -> False
1075
or
atom -> False
1076
]
and_test -> not_test
1076
and
1640
1076
,
and_test -> not_test
1076
if
and_test -> not_test
1076
or
and_test -> not_test
1077
@
atom -> None
1077
<=
atom -> None
1077
in
atom -> None
1077
and
atom -> None
1077
&
atom -> None
1077
|
atom -> None
1077
>
atom -> None
1077
>=
atom -> None
1077
/
atom -> None
1077
<<
atom -> None
1077
-
atom -> None
1077
!=
atom -> None
1077
**
atom -> None
1077
(
atom -> None
1077
]
atom -> None
1077
*
atom -> None
1077
.
atom -> None
1077
>>
atom -> None
1077
==
atom -> None
1077
is
atom -> None
1077
<
atom -> None
1077
if
atom -> None
1077
^
atom -> None
1077
[
atom -> None
1077
%
atom -> None
1077
+
atom -> None
1077
not
atom -> None
1077
,
atom -> None
1077
or
atom -> None
1077
//
atom -> None
1078
>
317
1078
is
318
1078
in
319
1078
<=
320
1078
<
321
1078
>=
322
1078
!=
324
1078
not
325
1078
==
326
1078
comp_op
1641
1078
or
comparison -> expr
1078
if
comparison -> expr
1078
]
comparison -> expr
1078
and
comparison -> expr
1078
,
comparison -> expr
1079
vfpdef
234
1079
NAME
233
1079
varargslist
1642
1079
:
1643
1080
if
1644
1080
,
test -> or_test
1080
]
test -> or_test
1081
]
test -> lambdef
1081
,
test -> lambdef
1082
]
test_list -> test , test_list
1083
for
or_test -> and_test or or_test
1083
if
or_test -> and_test or or_test
1083
]
or_test -> and_test or or_test
1083
,
or_test -> and_test or or_test
1084
^
arith_expr -> term - arith_expr
1084
!=
arith_expr -> term - arith_expr
1084
<
arith_expr -> term - arith_expr
1084
in
arith_expr -> term - arith_expr
1084
==
arith_expr -> term - arith_expr
1084
|
arith_expr -> term - arith_expr
1084
is
arith_expr -> term - arith_expr
1084
&
arith_expr -> term - arith_expr
1084
>>
arith_expr -> term - arith_expr
1084
]
arith_expr -> term - arith_expr
1084
<<
arith_expr -> term - arith_expr
1084
and
arith_expr -> term - arith_expr
1084
,
arith_expr -> term - arith_expr
1084
>
arith_expr -> term - arith_expr
1084
if
arith_expr -> term - arith_expr
1084
for
arith_expr -> term - arith_expr
1084
not
arith_expr -> term - arith_expr
1084
>=
arith_expr -> term - arith_expr
1084
<=
arith_expr -> term - arith_expr
1084
or
arith_expr -> term - arith_expr
1085
>=
arith_expr -> term + arith_expr
1085
>
arith_expr -> term + arith_expr
1085
^
arith_expr -> term + arith_expr
1085
or
arith_expr -> term + arith_expr
1085
==
arith_expr -> term + arith_expr
1085
<=
arith_expr -> term + arith_expr
1085
if
arith_expr -> term + arith_expr
1085
]
arith_expr -> term + arith_expr
1085
>>
arith_expr -> term + arith_expr
1085
<
arith_expr -> term + arith_expr
1085
not
arith_expr -> term + arith_expr
1085
&
arith_expr -> term + arith_expr
1085
in
arith_expr -> term + arith_expr
1085
and
arith_expr -> term + arith_expr
1085
,
arith_expr -> term + arith_expr
1085
|
arith_expr -> term + arith_expr
1085
!=
arith_expr -> term + arith_expr
1085
<<
arith_expr -> term + arith_expr
1085
for
arith_expr -> term + arith_expr
1085
is
arith_expr -> term + arith_expr
1086
>=
expr -> xor_expr | expr
1086
,
expr -> xor_expr | expr
1086
or
expr -> xor_expr | expr
1086
in
expr -> xor_expr | expr
1086
!=
expr -> xor_expr | expr
1086
]
expr -> xor_expr | expr
1086
and
expr -> xor_expr | expr
1086
==
expr -> xor_expr | expr
1086
>
expr -> xor_expr | expr
1086
<=
expr -> xor_expr | expr
1086
is
expr -> xor_expr | expr
1086
<
expr -> xor_expr | expr
1086
if
expr -> xor_expr | expr
1086
not
expr -> xor_expr | expr
1086
for
expr -> xor_expr | expr
1087
for
comparison -> expr comp_op comparison
1087
or
comparison -> expr comp_op comparison
1087
if
comparison -> expr comp_op comparison
1087
and
comparison -> expr comp_op comparison
1087
]
comparison -> expr comp_op comparison
1087
,
comparison -> expr comp_op comparison
1088
for
and_test -> not_test and and_test
1088
or
and_test -> not_test and and_test
1088
]
and_test -> not_test and and_test
1088
if
and_test -> not_test and and_test
1088
,
and_test -> not_test and and_test
1089
,
lambdef -> lambda : test
1089
for
lambdef -> lambda : test
1089
]
lambdef -> lambda : test
1090
[
166
1090
factor
167
1090
True
168
1090
atom_expr
169
1090
~
170
1090
not
171
1090
and_expr
172
1090
-
173
1090
{
174
1090
shift_expr
175
1090
atom
176
1090
comparison
178
1090
(
179
1090
arith_expr
180
1090
power
181
1090
STRING
182
1090
NAME
183
1090
and_test
185
1090
term
186
1090
+
187
1090
xor_expr
188
1090
NUMBER
190
1090
False
191
1090
expr
192
1090
not_test
193
1090
None
194
1090
lambdef
195
1090
lambda
196
1090
or_test
197
1090
test
1645
1091
else
1646
1092
:
1647
1093
)
1648
1094
modopt
suite -> simple_stmt
1094
~
suite -> simple_stmt
1094
False
suite -> simple_stmt
1094
@
suite -> simple_stmt
1094
begsim
suite -> simple_stmt
1094
NUMBER
suite -> simple_stmt
1094
conf
suite -> simple_stmt
1094
class
suite -> simple_stmt
1094
if
suite -> simple_stmt
1094
yield
suite -> simple_stmt
1094
try
suite -> simple_stmt
1094
pass
suite -> simple_stmt
1094
NEWLINE
suite -> simple_stmt
1094
[
suite -> simple_stmt
1094
break
suite -> simple_stmt
1094
True
suite -> simple_stmt
1094
None
suite -> simple_stmt
1094
server
suite -> simple_stmt
1094
assert
suite -> simple_stmt
1094
$
suite -> simple_stmt
1094
servmod
suite -> simple_stmt
1094
raise
suite -> simple_stmt
1094
nonlocal
suite -> simple_stmt
1094
lambda
suite -> simple_stmt
1094
return
suite -> simple_stmt
1094
+
suite -> simple_stmt
1094
-
suite -> simple_stmt
1094
NAME
suite -> simple_stmt
1094
while
suite -> simple_stmt
1094
def
suite -> simple_stmt
1094
with
suite -> simple_stmt
1094
del
suite -> simple_stmt
1094
STRING
suite -> simple_stmt
1094
for
suite -> simple_stmt
1094
resetstats
suite -> simple_stmt
1094
global
suite -> simple_stmt
1094
continue
suite -> simple_stmt
1094
endsim
suite -> simple_stmt
1094
not
suite -> simple_stmt
1094
{
suite -> simple_stmt
1094
(
suite -> simple_stmt
1095
INDENT
1649
1096
(
classdef -> class NAME : suite
1096
$
classdef -> class NAME : suite
1096
server
classdef -> class NAME : suite
1096
False
classdef -> class NAME : suite
1096
raise
classdef -> class NAME : suite
1096
conf
classdef -> class NAME : suite
1096
del
classdef -> class NAME : suite
1096
modopt
classdef -> class NAME : suite
1096
global
classdef -> class NAME : suite
1096
pass
classdef -> class NAME : suite
1096
return
classdef -> class NAME : suite
1096
@
classdef -> class NAME : suite
1096
not
classdef -> class NAME : suite
1096
for
classdef -> class NAME : suite
1096
assert
classdef -> class NAME : suite
1096
servmod
classdef -> class NAME : suite
1096
yield
classdef -> class NAME : suite
1096
with
classdef -> class NAME : suite
1096
NAME
classdef -> class NAME : suite
1096
def
classdef -> class NAME : suite
1096
-
classdef -> class NAME : suite
1096
STRING
classdef -> class NAME : suite
1096
NEWLINE
classdef -> class NAME : suite
1096
begsim
classdef -> class NAME : suite
1096
class
classdef -> class NAME : suite
1096
True
classdef -> class NAME : suite
1096
endsim
classdef -> class NAME : suite
1096
None
classdef -> class NAME : suite
1096
~
classdef -> class NAME : suite
1096
+
classdef -> class NAME : suite
1096
NUMBER
classdef -> class NAME : suite
1096
continue
classdef -> class NAME : suite
1096
nonlocal
classdef -> class NAME : suite
1096
resetstats
classdef -> class NAME : suite
1096
[
classdef -> class NAME : suite
1096
while
classdef -> class NAME : suite
1096
if
classdef -> class NAME : suite
1096
lambda
classdef -> class NAME : suite
1096
try
classdef -> class NAME : suite
1096
{
classdef -> class NAME : suite
1096
break
classdef -> class NAME : suite
1097
)
1650
1098
:
1651
1099
)
tfpdef -> NAME
1099
=
tfpdef -> NAME
1099
,
tfpdef -> NAME
1099
:
1652
1100
NAME
1653
1100
tfpdef
1654
1101
)
param -> tfpdef
1101
=
1655
1101
,
param -> tfpdef
1102
tfpdef
1656
1102
NAME
1653
1103
,
1657
1103
)
parameters -> param
1104
INDENT
1658
1105
.
atom -> [ test_list_comp ]
1105
/
atom -> [ test_list_comp ]
1105
*
atom -> [ test_list_comp ]
1105
,
atom -> [ test_list_comp ]
1105
[
atom -> [ test_list_comp ]
1105
@
atom -> [ test_list_comp ]
1105
|
atom -> [ test_list_comp ]
1105
in
atom -> [ test_list_comp ]
1105
**
atom -> [ test_list_comp ]
1105
&
atom -> [ test_list_comp ]
1105
<<
atom -> [ test_list_comp ]
1105
-
atom -> [ test_list_comp ]
1105
(
atom -> [ test_list_comp ]
1105
//
atom -> [ test_list_comp ]
1105
^
atom -> [ test_list_comp ]
1105
+
atom -> [ test_list_comp ]
1105
>>
atom -> [ test_list_comp ]
1105
%
atom -> [ test_list_comp ]
1106
>>
term -> factor // term
1106
|
term -> factor // term
1106
^
term -> factor // term
1106
&
term -> factor // term
1106
,
term -> factor // term
1106
-
term -> factor // term
1106
<<
term -> factor // term
1106
in
term -> factor // term
1106
+
term -> factor // term
1107
+
term -> factor * term
1107
^
term -> factor * term
1107
|
term -> factor * term
1107
<<
term -> factor * term
1107
,
term -> factor * term
1107
>>
term -> factor * term
1107
in
term -> factor * term
1107
&
term -> factor * term
1107
-
term -> factor * term
1108
&
term -> factor / term
1108
+
term -> factor / term
1108
,
term -> factor / term
1108
|
term -> factor / term
1108
>>
term -> factor / term
1108
-
term -> factor / term
1108
<<
term -> factor / term
1108
in
term -> factor / term
1108
^
term -> factor / term
1109
,
term -> factor % term
1109
>>
term -> factor % term
1109
|
term -> factor % term
1109
<<
term -> factor % term
1109
^
term -> factor % term
1109
-
term -> factor % term
1109
+
term -> factor % term
1109
&
term -> factor % term
1109
in
term -> factor % term
1110
|
term -> factor @ term
1110
-
term -> factor @ term
1110
<<
term -> factor @ term
1110
^
term -> factor @ term
1110
+
term -> factor @ term
1110
in
term -> factor @ term
1110
,
term -> factor @ term
1110
&
term -> factor @ term
1110
>>
term -> factor @ term
1111
[
166
1111
factor
167
1111
True
168
1111
atom_expr
169
1111
~
170
1111
not
171
1111
and_expr
172
1111
-
173
1111
{
174
1111
shift_expr
175
1111
atom
176
1111
]
1659
1111
comparison
178
1111
(
179
1111
arith_expr
180
1111
power
181
1111
STRING
182
1111
NAME
183
1111
test
184
1111
and_test
185
1111
term
186
1111
+
187
1111
xor_expr
188
1111
NUMBER
190
1111
test_list_comp
1660
1111
False
191
1111
expr
192
1111
not_test
193
1111
None
194
1111
lambdef
195
1111
lambda
196
1111
or_test
197
1111
test_list
198
1112
not
term -> factor
1112
@
1661
1112
%
1662
1112
/
1663
1112
*
1664
1112
//
1665
1112
<=
term -> factor
1112
>
term -> factor
1112
==
term -> factor
1112
is
term -> factor
1112
or
term -> factor
1112
<
term -> factor
1112
and
term -> factor
1112
<<
term -> factor
1112
^
term -> factor
1112
:
term -> factor
1112
!=
term -> factor
1112
-
term -> factor
1112
&
term -> factor
1112
|
term -> factor
1112
,
term -> factor
1112
>=
term -> factor
1112
if
term -> factor
1112
+
term -> factor
1112
in
term -> factor
1112
>>
term -> factor
1113
<<
atom -> True
1113
&
atom -> True
1113
or
atom -> True
1113
[
atom -> True
1113
if
atom -> True
1113
:
atom -> True
1113
-
atom -> True
1113
*
atom -> True
1113
^
atom -> True
1113
,
atom -> True
1113
>=
atom -> True
1113
!=
atom -> True
1113
(
atom -> True
1113
not
atom -> True
1113
|
atom -> True
1113
+
atom -> True
1113
**
atom -> True
1113
.
atom -> True
1113
is
atom -> True
1113
//
atom -> True
1113
>
atom -> True
1113
%
atom -> True
1113
in
atom -> True
1113
<=
atom -> True
1113
>>
atom -> True
1113
/
atom -> True
1113
==
atom -> True
1113
and
atom -> True
1113
<
atom -> True
1113
@
atom -> True
1114
**
1666
1114
,
power -> atom_expr
1114
!=
power -> atom_expr
1114
-
power -> atom_expr
1114
<<
power -> atom_expr
1114
:
power -> atom_expr
1114
/
power -> atom_expr
1114
<=
power -> atom_expr
1114
in
power -> atom_expr
1114
not
power -> atom_expr
1114
%
power -> atom_expr
1114
>
power -> atom_expr
1114
@
power -> atom_expr
1114
|
power -> atom_expr
1114
<
power -> atom_expr
1114
>>
power -> atom_expr
1114
or
power -> atom_expr
1114
and
power -> atom_expr
1114
>=
power -> atom_expr
1114
==
power -> atom_expr
1114
^
power -> atom_expr
1114
*
power -> atom_expr
1114
&
power -> atom_expr
1114
is
power -> atom_expr
1114
+
power -> atom_expr
1114
if
power -> atom_expr
1114
//
power -> atom_expr
1115
[
1111
1115
True
1113
1115
atom_expr
1114
1115
-
1117
1115
~
1115
1115
atom
1119
1115
{
1120
1115
power
1124
1115
STRING
1125
1115
NAME
1126
1115
(
1128
1115
+
1131
1115
NUMBER
1133
1115
False
1135
1115
factor
1667
1115
None
1139
1116
>
xor_expr -> and_expr
1116
<=
xor_expr -> and_expr
1116
not
xor_expr -> and_expr
1116
|
xor_expr -> and_expr
1116
^
1668
1116
==
xor_expr -> and_expr
1116
,
xor_expr -> and_expr
1116
in
xor_expr -> and_expr
1116
!=
xor_expr -> and_expr
1116
:
xor_expr -> and_expr
1116
if
xor_expr -> and_expr
1116
is
xor_expr -> and_expr
1116
<
xor_expr -> and_expr
1116
or
xor_expr -> and_expr
1116
and
xor_expr -> and_expr
1116
>=
xor_expr -> and_expr
1117
[
1111
1117
True
1113
1117
atom_expr
1114
1117
~
1115
1117
-
1117
1117
atom
1119
1117
{
1120
1117
power
1124
1117
STRING
1125
1117
NAME
1126
1117
(
1128
1117
factor
1669
1117
+
1131
1117
NUMBER
1133
1117
False
1135
1117
None
1139
1118
^
and_expr -> shift_expr
1118
in
and_expr -> shift_expr
1118
|
and_expr -> shift_expr
1118
&
1670
1118
<
and_expr -> shift_expr
1118
not
and_expr -> shift_expr
1118
>=
and_expr -> shift_expr
1118
<=
and_expr -> shift_expr
1118
or
and_expr -> shift_expr
1118
and
and_expr -> shift_expr
1118
,
and_expr -> shift_expr
1118
:
and_expr -> shift_expr
1118
!=
and_expr -> shift_expr
1118
if
and_expr -> shift_expr
1118
is
and_expr -> shift_expr
1118
==
and_expr -> shift_expr
1118
>
and_expr -> shift_expr
1119
>>
trailer_expr -> 
1119
(
1671
1119
trailer
1672
1119
trailer_expr
1673
1119
.
1674
1119
+
trailer_expr -> 
1119
[
1675
1119
is
trailer_expr -> 
1119
>
trailer_expr -> 
1119
not
trailer_expr -> 
1119
|
trailer_expr -> 
1119
&
trailer_expr -> 
1119
/
trailer_expr -> 
1119
@
trailer_expr -> 
1119
!=
trailer_expr -> 
1119
**
trailer_expr -> 
1119
>=
trailer_expr -> 
1119
^
trailer_expr -> 
1119
in
trailer_expr -> 
1119
<<
trailer_expr -> 
1119
and
trailer_expr -> 
1119
or
trailer_expr -> 
1119
if
trailer_expr -> 
1119
:
trailer_expr -> 
1119
//
trailer_expr -> 
1119
%
trailer_expr -> 
1119
,
trailer_expr -> 
1119
<=
trailer_expr -> 
1119
<
trailer_expr -> 
1119
==
trailer_expr -> 
1119
-
trailer_expr -> 
1119
*
trailer_expr -> 
1120
}
1676
1121
or
not_test -> comparison
1121
,
not_test -> comparison
1121
:
not_test -> comparison
1121
and
not_test -> comparison
1121
if
not_test -> comparison
1122
,
test -> or_test
1122
if
1677
1122
:
test -> or_test
1123
>>
1678
1123
if
shift_expr -> arith_expr
1123
&
shift_expr -> arith_expr
1123
<<
1679
1123
|
shift_expr -> arith_expr
1123
is
shift_expr -> arith_expr
1123
<
shift_expr -> arith_expr
1123
==
shift_expr -> arith_expr
1123
or
shift_expr -> arith_expr
1123
>
shift_expr -> arith_expr
1123
!=
shift_expr -> arith_expr
1123
>=
shift_expr -> arith_expr
1123
in
shift_expr -> arith_expr
1123
,
shift_expr -> arith_expr
1123
<=
shift_expr -> arith_expr
1123
:
shift_expr -> arith_expr
1123
and
shift_expr -> arith_expr
1123
^
shift_expr -> arith_expr
1123
not
shift_expr -> arith_expr
1124
+
factor -> power
1124
%
factor -> power
1124
:
factor -> power
1124
,
factor -> power
1124
<
factor -> power
1124
<<
factor -> power
1124
!=
factor -> power
1124
<=
factor -> power
1124
and
factor -> power
1124
/
factor -> power
1124
^
factor -> power
1124
@
factor -> power
1124
>=
factor -> power
1124
not
factor -> power
1124
//
factor -> power
1124
or
factor -> power
1124
==
factor -> power
1124
is
factor -> power
1124
|
factor -> power
1124
*
factor -> power
1124
-
factor -> power
1124
if
factor -> power
1124
>
factor -> power
1124
in
factor -> power
1124
>>
factor -> power
1124
&
factor -> power
1125
%
atom -> STRING
1125
>
atom -> STRING
1125
@
atom -> STRING
1125
<<
atom -> STRING
1125
in
atom -> STRING
1125
[
atom -> STRING
1125
-
atom -> STRING
1125
==
atom -> STRING
1125
>=
atom -> STRING
1125
not
atom -> STRING
1125
/
atom -> STRING
1125
+
atom -> STRING
1125
*
atom -> STRING
1125
(
atom -> STRING
1125
//
atom -> STRING
1125
if
atom -> STRING
1125
.
atom -> STRING
1125
<
atom -> STRING
1125
,
atom -> STRING
1125
&
atom -> STRING
1125
<=
atom -> STRING
1125
!=
atom -> STRING
1125
**
atom -> STRING
1125
^
atom -> STRING
1125
:
atom -> STRING
1125
and
atom -> STRING
1125
is
atom -> STRING
1125
|
atom -> STRING
1125
or
atom -> STRING
1125
>>
atom -> STRING
1126
<
atom -> NAME
1126
,
atom -> NAME
1126
^
atom -> NAME
1126
+
atom -> NAME
1126
-
atom -> NAME
1126
>=
atom -> NAME
1126
@
atom -> NAME
1126
!=
atom -> NAME
1126
*
atom -> NAME
1126
<=
atom -> NAME
1126
**
atom -> NAME
1126
or
atom -> NAME
1126
not
atom -> NAME
1126
==
atom -> NAME
1126
&
atom -> NAME
1126
>
atom -> NAME
1126
>>
atom -> NAME
1126
%
atom -> NAME
1126
.
atom -> NAME
1126
|
atom -> NAME
1126
is
atom -> NAME
1126
and
atom -> NAME
1126
//
atom -> NAME
1126
[
atom -> NAME
1126
/
atom -> NAME
1126
(
atom -> NAME
1126
<<
atom -> NAME
1126
if
atom -> NAME
1126
in
atom -> NAME
1126
:
atom -> NAME
1127
:
1680
1128
[
128
1128
factor
129
1128
True
130
1128
atom_expr
131
1128
~
132
1128
and_expr
133
1128
-
134
1128
{
135
1128
test_list_comp
1681
1128
shift_expr
137
1128
atom
138
1128
)
1682
1128
comparison
140
1128
arith_expr
141
1128
power
142
1128
STRING
143
1128
NAME
144
1128
(
145
1128
and_test
146
1128
term
147
1128
+
148
1128
xor_expr
149
1128
or_test
150
1128
NUMBER
151
1128
not
152
1128
False
153
1128
expr
154
1128
not_test
155
1128
None
156
1128
lambdef
157
1128
lambda
158
1128
test
159
1128
test_list
160
1129
or
1683
1129
,
or_test -> and_test
1129
:
or_test -> and_test
1129
if
or_test -> and_test
1130
-
1684
1130
+
1685
1130
>=
arith_expr -> term
1130
|
arith_expr -> term
1130
<=
arith_expr -> term
1130
not
arith_expr -> term
1130
,
arith_expr -> term
1130
==
arith_expr -> term
1130
in
arith_expr -> term
1130
>>
arith_expr -> term
1130
is
arith_expr -> term
1130
if
arith_expr -> term
1130
or
arith_expr -> term
1130
!=
arith_expr -> term
1130
>
arith_expr -> term
1130
:
arith_expr -> term
1130
and
arith_expr -> term
1130
<<
arith_expr -> term
1130
<
arith_expr -> term
1130
^
arith_expr -> term
1130
&
arith_expr -> term
1131
[
1111
1131
True
1113
1131
atom_expr
1114
1131
-
1117
1131
~
1115
1131
atom
1119
1131
{
1120
1131
power
1124
1131
STRING
1125
1131
NAME
1126
1131
(
1128
1131
factor
1686
1131
+
1131
1131
NUMBER
1133
1131
False
1135
1131
None
1139
1132
|
1687
1132
>
expr -> xor_expr
1132
if
expr -> xor_expr
1132
is
expr -> xor_expr
1132
and
expr -> xor_expr
1132
not
expr -> xor_expr
1132
or
expr -> xor_expr
1132
>=
expr -> xor_expr
1132
==
expr -> xor_expr
1132
,
expr -> xor_expr
1132
:
expr -> xor_expr
1132
<
expr -> xor_expr
1132
!=
expr -> xor_expr
1132
<=
expr -> xor_expr
1132
in
expr -> xor_expr
1133
+
atom -> NUMBER
1133
*
atom -> NUMBER
1133
>
atom -> NUMBER
1133
<<
atom -> NUMBER
1133
-
atom -> NUMBER
1133
**
atom -> NUMBER
1133
if
atom -> NUMBER
1133
or
atom -> NUMBER
1133
is
atom -> NUMBER
1133
[
atom -> NUMBER
1133
(
atom -> NUMBER
1133
not
atom -> NUMBER
1133
&
atom -> NUMBER
1133
^
atom -> NUMBER
1133
in
atom -> NUMBER
1133
==
atom -> NUMBER
1133
//
atom -> NUMBER
1133
!=
atom -> NUMBER
1133
and
atom -> NUMBER
1133
%
atom -> NUMBER
1133
<=
atom -> NUMBER
1133
.
atom -> NUMBER
1133
<
atom -> NUMBER
1133
>>
atom -> NUMBER
1133
,
atom -> NUMBER
1133
/
atom -> NUMBER
1133
@
atom -> NUMBER
1133
>=
atom -> NUMBER
1133
|
atom -> NUMBER
1133
:
atom -> NUMBER
1134
[
1111
1134
factor
1112
1134
True
1113
1134
atom_expr
1114
1134
~
1115
1134
and_expr
1116
1134
-
1117
1134
shift_expr
1118
1134
atom
1119
1134
{
1120
1134
comparison
1121
1134
arith_expr
1123
1134
power
1124
1134
STRING
1125
1134
NAME
1126
1134
(
1128
1134
term
1130
1134
+
1131
1134
xor_expr
1132
1134
NUMBER
1133
1134
not
1134
1134
False
1135
1134
not_test
1688
1134
expr
1136
1134
None
1139
1135
(
atom -> False
1135
*
atom -> False
1135
==
atom -> False
1135
|
atom -> False
1135
,
atom -> False
1135
[
atom -> False
1135
in
atom -> False
1135
&
atom -> False
1135
is
atom -> False
1135
not
atom -> False
1135
if
atom -> False
1135
^
atom -> False
1135
+
atom -> False
1135
>
atom -> False
1135
<=
atom -> False
1135
<<
atom -> False
1135
<
atom -> False
1135
>=
atom -> False
1135
:
atom -> False
1135
%
atom -> False
1135
@
atom -> False
1135
and
atom -> False
1135
!=
atom -> False
1135
-
atom -> False
1135
.
atom -> False
1135
//
atom -> False
1135
/
atom -> False
1135
**
atom -> False
1135
>>
atom -> False
1135
or
atom -> False
1136
>
317
1136
is
318
1136
in
319
1136
<=
320
1136
<
321
1136
>=
322
1136
:
comparison -> expr
1136
!=
324
1136
not
325
1136
==
326
1136
comp_op
1689
1136
or
comparison -> expr
1136
if
comparison -> expr
1136
and
comparison -> expr
1136
,
comparison -> expr
1137
and
1690
1137
:
and_test -> not_test
1137
,
and_test -> not_test
1137
if
and_test -> not_test
1137
or
and_test -> not_test
1138
,
1691
1138
:
test_list -> test
1139
@
atom -> None
1139
<=
atom -> None
1139
in
atom -> None
1139
and
atom -> None
1139
&
atom -> None
1139
|
atom -> None
1139
>
atom -> None
1139
>=
atom -> None
1139
/
atom -> None
1139
<<
atom -> None
1139
-
atom -> None
1139
!=
atom -> None
1139
**
atom -> None
1139
(
atom -> None
1139
*
atom -> None
1139
.
atom -> None
1139
>>
atom -> None
1139
==
atom -> None
1139
is
atom -> None
1139
<
atom -> None
1139
if
atom -> None
1139
^
atom -> None
1139
[
atom -> None
1139
%
atom -> None
1139
+
atom -> None
1139
not
atom -> None
1139
,
atom -> None
1139
:
atom -> None
1139
or
atom -> None
1139
//
atom -> None
1140
:
test -> lambdef
1140
,
test -> lambdef
1141
vfpdef
234
1141
NAME
233
1141
varargslist
1692
1141
:
1693
1142
,
xor_expr -> and_expr ^ xor_expr
1142
in
xor_expr -> and_expr ^ xor_expr
1142
|
xor_expr -> and_expr ^ xor_expr
1143
in
shift_expr -> arith_expr << shift_expr
1143
&
shift_expr -> arith_expr << shift_expr
1143
^
shift_expr -> arith_expr << shift_expr
1143
,
shift_expr -> arith_expr << shift_expr
1143
|
shift_expr -> arith_expr << shift_expr
1144
,
shift_expr -> arith_expr >> shift_expr
1144
|
shift_expr -> arith_expr >> shift_expr
1144
in
shift_expr -> arith_expr >> shift_expr
1144
&
shift_expr -> arith_expr >> shift_expr
1144
^
shift_expr -> arith_expr >> shift_expr
1145
in
and_expr -> shift_expr & and_expr
1145
^
and_expr -> shift_expr & and_expr
1145
,
and_expr -> shift_expr & and_expr
1145
|
and_expr -> shift_expr & and_expr
1146
^
trailer -> ( )
1146
@
trailer -> ( )
1146
/
trailer -> ( )
1146
[
trailer -> ( )
1146
,
trailer -> ( )
1146
in
trailer -> ( )
1146
|
trailer -> ( )
1146
.
trailer -> ( )
1146
+
trailer -> ( )
1146
-
trailer -> ( )
1146
(
trailer -> ( )
1146
<<
trailer -> ( )
1146
&
trailer -> ( )
1146
//
trailer -> ( )
1146
*
trailer -> ( )
1146
%
trailer -> ( )
1146
**
trailer -> ( )
1146
>>
trailer -> ( )
1147
)
1694
1148
]
1695
1149
,
trailer_expr -> trailer trailer_expr
1149
&
trailer_expr -> trailer trailer_expr
1149
|
trailer_expr -> trailer trailer_expr
1149
in
trailer_expr -> trailer trailer_expr
1149
%
trailer_expr -> trailer trailer_expr
1149
@
trailer_expr -> trailer trailer_expr
1149
+
trailer_expr -> trailer trailer_expr
1149
*
trailer_expr -> trailer trailer_expr
1149
>>
trailer_expr -> trailer trailer_expr
1149
^
trailer_expr -> trailer trailer_expr
1149
**
trailer_expr -> trailer trailer_expr
1149
<<
trailer_expr -> trailer trailer_expr
1149
-
trailer_expr -> trailer trailer_expr
1149
//
trailer_expr -> trailer trailer_expr
1149
/
trailer_expr -> trailer trailer_expr
1150
.
trailer -> . NAME
1150
,
trailer -> . NAME
1150
%
trailer -> . NAME
1150
//
trailer -> . NAME
1150
**
trailer -> . NAME
1150
*
trailer -> . NAME
1150
in
trailer -> . NAME
1150
|
trailer -> . NAME
1150
<<
trailer -> . NAME
1150
-
trailer -> . NAME
1150
>>
trailer -> . NAME
1150
(
trailer -> . NAME
1150
&
trailer -> . NAME
1150
+
trailer -> . NAME
1150
/
trailer -> . NAME
1150
^
trailer -> . NAME
1150
[
trailer -> . NAME
1150
@
trailer -> . NAME
1151
@
atom -> ( test_list_comp )
1151
in
atom -> ( test_list_comp )
1151
.
atom -> ( test_list_comp )
1151
&
atom -> ( test_list_comp )
1151
/
atom -> ( test_list_comp )
1151
//
atom -> ( test_list_comp )
1151
^
atom -> ( test_list_comp )
1151
(
atom -> ( test_list_comp )
1151
*
atom -> ( test_list_comp )
1151
-
atom -> ( test_list_comp )
1151
**
atom -> ( test_list_comp )
1151
|
atom -> ( test_list_comp )
1151
[
atom -> ( test_list_comp )
1151
+
atom -> ( test_list_comp )
1151
<<
atom -> ( test_list_comp )
1151
%
atom -> ( test_list_comp )
1151
,
atom -> ( test_list_comp )
1151
>>
atom -> ( test_list_comp )
1152
^
arith_expr -> term - arith_expr
1152
|
arith_expr -> term - arith_expr
1152
&
arith_expr -> term - arith_expr
1152
<<
arith_expr -> term - arith_expr
1152
>>
arith_expr -> term - arith_expr
1152
,
arith_expr -> term - arith_expr
1152
in
arith_expr -> term - arith_expr
1153
^
arith_expr -> term + arith_expr
1153
&
arith_expr -> term + arith_expr
1153
>>
arith_expr -> term + arith_expr
1153
in
arith_expr -> term + arith_expr
1153
<<
arith_expr -> term + arith_expr
1153
,
arith_expr -> term + arith_expr
1153
|
arith_expr -> term + arith_expr
1154
in
power -> atom_expr ** factor
1154
@
power -> atom_expr ** factor
1154
^
power -> atom_expr ** factor
1154
//
power -> atom_expr ** factor
1154
,
power -> atom_expr ** factor
1154
*
power -> atom_expr ** factor
1154
%
power -> atom_expr ** factor
1154
<<
power -> atom_expr ** factor
1154
|
power -> atom_expr ** factor
1154
+
power -> atom_expr ** factor
1154
-
power -> atom_expr ** factor
1154
>>
power -> atom_expr ** factor
1154
&
power -> atom_expr ** factor
1154
/
power -> atom_expr ** factor
1155
in
expr_list -> expr , expr_list
1156
in
expr -> xor_expr | expr
1156
,
expr -> xor_expr | expr
1157
+=
lambdef -> lambda varargslist : test
1157
^=
lambdef -> lambda varargslist : test
1157
&=
lambdef -> lambda varargslist : test
1157
:
lambdef -> lambda varargslist : test
1157
*=
lambdef -> lambda varargslist : test
1157
,
lambdef -> lambda varargslist : test
1157
@=
lambdef -> lambda varargslist : test
1157
/=
lambdef -> lambda varargslist : test
1157
%=
lambdef -> lambda varargslist : test
1157
**=
lambdef -> lambda varargslist : test
1157
=
lambdef -> lambda varargslist : test
1157
-=
lambdef -> lambda varargslist : test
1157
<<=
lambdef -> lambda varargslist : test
1157
|=
lambdef -> lambda varargslist : test
1157
//=
lambdef -> lambda varargslist : test
1157
>>=
lambdef -> lambda varargslist : test
1157
NEWLINE
lambdef -> lambda varargslist : test
1158
:
varargslist -> vfpdef , varargslist
1159
.
atom -> [ test_list_comp ]
1159
/
atom -> [ test_list_comp ]
1159
*
atom -> [ test_list_comp ]
1159
,
atom -> [ test_list_comp ]
1159
[
atom -> [ test_list_comp ]
1159
@
atom -> [ test_list_comp ]
1159
|
atom -> [ test_list_comp ]
1159
**
atom -> [ test_list_comp ]
1159
NEWLINE
atom -> [ test_list_comp ]
1159
&
atom -> [ test_list_comp ]
1159
<<
atom -> [ test_list_comp ]
1159
-
atom -> [ test_list_comp ]
1159
(
atom -> [ test_list_comp ]
1159
//
atom -> [ test_list_comp ]
1159
^
atom -> [ test_list_comp ]
1159
+
atom -> [ test_list_comp ]
1159
>>
atom -> [ test_list_comp ]
1159
%
atom -> [ test_list_comp ]
1160
+
term -> factor * term
1160
^
term -> factor * term
1160
|
term -> factor * term
1160
NEWLINE
term -> factor * term
1160
<<
term -> factor * term
1160
,
term -> factor * term
1160
>>
term -> factor * term
1160
&
term -> factor * term
1160
-
term -> factor * term
1161
&
term -> factor / term
1161
+
term -> factor / term
1161
,
term -> factor / term
1161
|
term -> factor / term
1161
>>
term -> factor / term
1161
NEWLINE
term -> factor / term
1161
<<
term -> factor / term
1161
-
term -> factor / term
1161
^
term -> factor / term
1162
,
term -> factor % term
1162
>>
term -> factor % term
1162
|
term -> factor % term
1162
<<
term -> factor % term
1162
^
term -> factor % term
1162
-
term -> factor % term
1162
+
term -> factor % term
1162
&
term -> factor % term
1162
NEWLINE
term -> factor % term
1163
|
term -> factor @ term
1163
-
term -> factor @ term
1163
<<
term -> factor @ term
1163
NEWLINE
term -> factor @ term
1163
^
term -> factor @ term
1163
+
term -> factor @ term
1163
,
term -> factor @ term
1163
&
term -> factor @ term
1163
>>
term -> factor @ term
1164
>>
term -> factor // term
1164
|
term -> factor // term
1164
NEWLINE
term -> factor // term
1164
^
term -> factor // term
1164
&
term -> factor // term
1164
,
term -> factor // term
1164
-
term -> factor // term
1164
<<
term -> factor // term
1164
+
term -> factor // term
1165
,
xor_expr -> and_expr ^ xor_expr
1165
NEWLINE
xor_expr -> and_expr ^ xor_expr
1165
|
xor_expr -> and_expr ^ xor_expr
1166
,
shift_expr -> arith_expr >> shift_expr
1166
|
shift_expr -> arith_expr >> shift_expr
1166
NEWLINE
shift_expr -> arith_expr >> shift_expr
1166
&
shift_expr -> arith_expr >> shift_expr
1166
^
shift_expr -> arith_expr >> shift_expr
1167
NEWLINE
shift_expr -> arith_expr << shift_expr
1167
&
shift_expr -> arith_expr << shift_expr
1167
^
shift_expr -> arith_expr << shift_expr
1167
,
shift_expr -> arith_expr << shift_expr
1167
|
shift_expr -> arith_expr << shift_expr
1168
^
and_expr -> shift_expr & and_expr
1168
,
and_expr -> shift_expr & and_expr
1168
|
and_expr -> shift_expr & and_expr
1168
NEWLINE
and_expr -> shift_expr & and_expr
1169
^
trailer -> ( )
1169
@
trailer -> ( )
1169
/
trailer -> ( )
1169
[
trailer -> ( )
1169
,
trailer -> ( )
1169
|
trailer -> ( )
1169
(
trailer -> ( )
1169
.
trailer -> ( )
1169
+
trailer -> ( )
1169
-
trailer -> ( )
1169
<<
trailer -> ( )
1169
&
trailer -> ( )
1169
//
trailer -> ( )
1169
*
trailer -> ( )
1169
%
trailer -> ( )
1169
**
trailer -> ( )
1169
NEWLINE
trailer -> ( )
1169
>>
trailer -> ( )
1170
)
1696
1171
]
1697
1172
NEWLINE
trailer_expr -> trailer trailer_expr
1172
,
trailer_expr -> trailer trailer_expr
1172
&
trailer_expr -> trailer trailer_expr
1172
|
trailer_expr -> trailer trailer_expr
1172
%
trailer_expr -> trailer trailer_expr
1172
@
trailer_expr -> trailer trailer_expr
1172
+
trailer_expr -> trailer trailer_expr
1172
*
trailer_expr -> trailer trailer_expr
1172
>>
trailer_expr -> trailer trailer_expr
1172
^
trailer_expr -> trailer trailer_expr
1172
**
trailer_expr -> trailer trailer_expr
1172
<<
trailer_expr -> trailer trailer_expr
1172
-
trailer_expr -> trailer trailer_expr
1172
//
trailer_expr -> trailer trailer_expr
1172
/
trailer_expr -> trailer trailer_expr
1173
.
trailer -> . NAME
1173
,
trailer -> . NAME
1173
%
trailer -> . NAME
1173
//
trailer -> . NAME
1173
**
trailer -> . NAME
1173
NEWLINE
trailer -> . NAME
1173
*
trailer -> . NAME
1173
|
trailer -> . NAME
1173
<<
trailer -> . NAME
1173
-
trailer -> . NAME
1173
>>
trailer -> . NAME
1173
(
trailer -> . NAME
1173
&
trailer -> . NAME
1173
+
trailer -> . NAME
1173
/
trailer -> . NAME
1173
^
trailer -> . NAME
1173
[
trailer -> . NAME
1173
@
trailer -> . NAME
1174
NEWLINE
atom -> ( test_list_comp )
1174
@
atom -> ( test_list_comp )
1174
.
atom -> ( test_list_comp )
1174
&
atom -> ( test_list_comp )
1174
/
atom -> ( test_list_comp )
1174
//
atom -> ( test_list_comp )
1174
^
atom -> ( test_list_comp )
1174
(
atom -> ( test_list_comp )
1174
*
atom -> ( test_list_comp )
1174
-
atom -> ( test_list_comp )
1174
**
atom -> ( test_list_comp )
1174
|
atom -> ( test_list_comp )
1174
[
atom -> ( test_list_comp )
1174
+
atom -> ( test_list_comp )
1174
<<
atom -> ( test_list_comp )
1174
%
atom -> ( test_list_comp )
1174
,
atom -> ( test_list_comp )
1174
>>
atom -> ( test_list_comp )
1175
^
arith_expr -> term - arith_expr
1175
|
arith_expr -> term - arith_expr
1175
&
arith_expr -> term - arith_expr
1175
NEWLINE
arith_expr -> term - arith_expr
1175
<<
arith_expr -> term - arith_expr
1175
>>
arith_expr -> term - arith_expr
1175
,
arith_expr -> term - arith_expr
1176
NEWLINE
arith_expr -> term + arith_expr
1176
&
arith_expr -> term + arith_expr
1176
^
arith_expr -> term + arith_expr
1176
>>
arith_expr -> term + arith_expr
1176
<<
arith_expr -> term + arith_expr
1176
,
arith_expr -> term + arith_expr
1176
|
arith_expr -> term + arith_expr
1177
@
power -> atom_expr ** factor
1177
^
power -> atom_expr ** factor
1177
//
power -> atom_expr ** factor
1177
,
power -> atom_expr ** factor
1177
*
power -> atom_expr ** factor
1177
%
power -> atom_expr ** factor
1177
NEWLINE
power -> atom_expr ** factor
1177
<<
power -> atom_expr ** factor
1177
|
power -> atom_expr ** factor
1177
+
power -> atom_expr ** factor
1177
-
power -> atom_expr ** factor
1177
>>
power -> atom_expr ** factor
1177
&
power -> atom_expr ** factor
1177
/
power -> atom_expr ** factor
1178
NEWLINE
expr -> xor_expr | expr
1178
,
expr -> xor_expr | expr
1179
NEWLINE
expr_list -> expr , expr_list
1180
)
1698
1181
INDENT
1699
1182
NEWLINE
yield_arg -> test_list
1183
NEWLINE
yield_expr -> yield yield_arg
1184
[
397
1184
factor
398
1184
True
399
1184
atom_expr
400
1184
~
401
1184
and_expr
402
1184
-
403
1184
None
404
1184
atom
405
1184
{
406
1184
arith_expr
407
1184
power
408
1184
STRING
409
1184
NAME
410
1184
(
411
1184
NUMBER
412
1184
and_test
413
1184
term
414
1184
+
415
1184
xor_expr
416
1184
shift_expr
417
1184
not
418
1184
False
419
1184
lambda
420
1184
comparison
421
1184
not_test
422
1184
lambdef
423
1184
expr
424
1184
or_test
425
1184
test
1700
1185
!=
atom -> [ ]
1185
>>
atom -> [ ]
1185
|
atom -> [ ]
1185
NEWLINE
atom -> [ ]
1185
<<
atom -> [ ]
1185
>
atom -> [ ]
1185
.
atom -> [ ]
1185
%
atom -> [ ]
1185
^
atom -> [ ]
1185
=
atom -> [ ]
1185
-
atom -> [ ]
1185
,
atom -> [ ]
1185
in
atom -> [ ]
1185
or
atom -> [ ]
1185
/
atom -> [ ]
1185
**
atom -> [ ]
1185
//
atom -> [ ]
1185
not
atom -> [ ]
1185
(
atom -> [ ]
1185
+
atom -> [ ]
1185
and
atom -> [ ]
1185
==
atom -> [ ]
1185
[
atom -> [ ]
1185
if
atom -> [ ]
1185
<
atom -> [ ]
1185
<=
atom -> [ ]
1185
>=
atom -> [ ]
1185
is
atom -> [ ]
1185
*
atom -> [ ]
1185
@
atom -> [ ]
1185
&
atom -> [ ]
1186
]
1701
1187
term
1702
1187
[
632
1187
factor
633
1187
True
634
1187
atom_expr
635
1187
~
636
1187
-
638
1187
None
639
1187
atom
641
1187
{
642
1187
power
646
1187
STRING
647
1187
NAME
648
1187
(
649
1187
NUMBER
650
1187
+
652
1187
False
657
1188
[
632
1188
factor
633
1188
True
634
1188
term
1703
1188
~
636
1188
-
638
1188
atom_expr
635
1188
None
639
1188
atom
641
1188
{
642
1188
power
646
1188
STRING
647
1188
NAME
648
1188
(
649
1188
NUMBER
650
1188
+
652
1188
False
657
1189
[
632
1189
factor
633
1189
True
634
1189
atom_expr
635
1189
~
636
1189
-
638
1189
None
639
1189
atom
641
1189
{
642
1189
power
646
1189
STRING
647
1189
NAME
648
1189
(
649
1189
NUMBER
650
1189
term
1704
1189
+
652
1189
False
657
1190
[
632
1190
factor
633
1190
True
634
1190
atom_expr
635
1190
~
636
1190
-
638
1190
None
639
1190
atom
641
1190
{
642
1190
power
646
1190
STRING
647
1190
NAME
648
1190
(
649
1190
NUMBER
650
1190
term
1705
1190
+
652
1190
False
657
1191
[
632
1191
factor
633
1191
True
634
1191
atom_expr
635
1191
~
636
1191
-
638
1191
None
639
1191
atom
641
1191
{
642
1191
power
646
1191
STRING
647
1191
NAME
648
1191
term
1706
1191
(
649
1191
NUMBER
650
1191
+
652
1191
False
657
1192
[
632
1192
True
634
1192
atom_expr
635
1192
-
638
1192
~
636
1192
None
639
1192
atom
641
1192
{
642
1192
power
646
1192
STRING
647
1192
NAME
648
1192
(
649
1192
NUMBER
650
1192
+
652
1192
False
657
1192
factor
1707
1193
@
factor -> ~ factor
1193
NEWLINE
factor -> ~ factor
1193
>>
factor -> ~ factor
1193
<=
factor -> ~ factor
1193
and
factor -> ~ factor
1193
+
factor -> ~ factor
1193
*
factor -> ~ factor
1193
!=
factor -> ~ factor
1193
%
factor -> ~ factor
1193
<<
factor -> ~ factor
1193
>=
factor -> ~ factor
1193
=
factor -> ~ factor
1193
,
factor -> ~ factor
1193
&
factor -> ~ factor
1193
is
factor -> ~ factor
1193
==
factor -> ~ factor
1193
//
factor -> ~ factor
1193
<
factor -> ~ factor
1193
/
factor -> ~ factor
1193
not
factor -> ~ factor
1193
-
factor -> ~ factor
1193
or
factor -> ~ factor
1193
|
factor -> ~ factor
1193
>
factor -> ~ factor
1193
^
factor -> ~ factor
1193
if
factor -> ~ factor
1193
in
factor -> ~ factor
1194
[
632
1194
factor
633
1194
True
634
1194
atom_expr
635
1194
~
636
1194
and_expr
637
1194
-
638
1194
None
639
1194
shift_expr
640
1194
atom
641
1194
{
642
1194
xor_expr
1708
1194
arith_expr
645
1194
power
646
1194
STRING
647
1194
NAME
648
1194
(
649
1194
NUMBER
650
1194
term
651
1194
+
652
1194
False
657
1195
@
factor -> - factor
1195
=
factor -> - factor
1195
<=
factor -> - factor
1195
in
factor -> - factor
1195
>>
factor -> - factor
1195
|
factor -> - factor
1195
is
factor -> - factor
1195
+
factor -> - factor
1195
%
factor -> - factor
1195
<
factor -> - factor
1195
*
factor -> - factor
1195
<<
factor -> - factor
1195
if
factor -> - factor
1195
-
factor -> - factor
1195
>=
factor -> - factor
1195
not
factor -> - factor
1195
and
factor -> - factor
1195
/
factor -> - factor
1195
or
factor -> - factor
1195
NEWLINE
factor -> - factor
1195
^
factor -> - factor
1195
>
factor -> - factor
1195
!=
factor -> - factor
1195
&
factor -> - factor
1195
==
factor -> - factor
1195
//
factor -> - factor
1195
,
factor -> - factor
1196
[
632
1196
factor
633
1196
True
634
1196
atom_expr
635
1196
~
636
1196
-
638
1196
None
639
1196
shift_expr
640
1196
atom
641
1196
{
642
1196
arith_expr
645
1196
power
646
1196
STRING
647
1196
NAME
648
1196
(
649
1196
NUMBER
650
1196
term
651
1196
+
652
1196
and_expr
1709
1196
False
657
1197
[
766
1197
factor
767
1197
True
768
1197
atom_expr
769
1197
~
770
1197
and_expr
771
1197
-
772
1197
{
773
1197
shift_expr
774
1197
atom
775
1197
comparison
776
1197
and_test
777
1197
arith_expr
778
1197
power
779
1197
STRING
780
1197
NAME
781
1197
(
782
1197
term
784
1197
+
785
1197
xor_expr
786
1197
)
1710
1197
or_test
788
1197
arglist
1711
1197
NUMBER
789
1197
not
790
1197
False
791
1197
expr
792
1197
*
793
1197
not_test
794
1197
None
795
1197
lambdef
796
1197
lambda
797
1197
test
798
1197
argument
799
1197
**
800
1198
trailer_expr
1712
1198
>>
trailer_expr -> 
1198
(
1197
1198
trailer
1198
1198
.
1200
1198
+
trailer_expr -> 
1198
[
1201
1198
is
trailer_expr -> 
1198
>
trailer_expr -> 
1198
not
trailer_expr -> 
1198
|
trailer_expr -> 
1198
=
trailer_expr -> 
1198
NEWLINE
trailer_expr -> 
1198
&
trailer_expr -> 
1198
/
trailer_expr -> 
1198
@
trailer_expr -> 
1198
!=
trailer_expr -> 
1198
**
trailer_expr -> 
1198
>=
trailer_expr -> 
1198
^
trailer_expr -> 
1198
in
trailer_expr -> 
1198
<<
trailer_expr -> 
1198
and
trailer_expr -> 
1198
or
trailer_expr -> 
1198
if
trailer_expr -> 
1198
//
trailer_expr -> 
1198
%
trailer_expr -> 
1198
,
trailer_expr -> 
1198
<=
trailer_expr -> 
1198
<
trailer_expr -> 
1198
==
trailer_expr -> 
1198
-
trailer_expr -> 
1198
*
trailer_expr -> 
1199
^
atom_expr -> atom trailer_expr
1199
or
atom_expr -> atom trailer_expr
1199
=
atom_expr -> atom trailer_expr
1199
&
atom_expr -> atom trailer_expr
1199
@
atom_expr -> atom trailer_expr
1199
|
atom_expr -> atom trailer_expr
1199
-
atom_expr -> atom trailer_expr
1199
*
atom_expr -> atom trailer_expr
1199
%
atom_expr -> atom trailer_expr
1199
==
atom_expr -> atom trailer_expr
1199
**
atom_expr -> atom trailer_expr
1199
and
atom_expr -> atom trailer_expr
1199
NEWLINE
atom_expr -> atom trailer_expr
1199
is
atom_expr -> atom trailer_expr
1199
in
atom_expr -> atom trailer_expr
1199
<<
atom_expr -> atom trailer_expr
1199
!=
atom_expr -> atom trailer_expr
1199
<=
atom_expr -> atom trailer_expr
1199
/
atom_expr -> atom trailer_expr
1199
//
atom_expr -> atom trailer_expr
1199
<
atom_expr -> atom trailer_expr
1199
>=
atom_expr -> atom trailer_expr
1199
>>
atom_expr -> atom trailer_expr
1199
if
atom_expr -> atom trailer_expr
1199
not
atom_expr -> atom trailer_expr
1199
+
atom_expr -> atom trailer_expr
1199
>
atom_expr -> atom trailer_expr
1199
,
atom_expr -> atom trailer_expr
1200
NAME
1713
1201
[
802
1201
factor
803
1201
True
804
1201
atom_expr
810
1201
~
806
1201
not
807
1201
and_expr
808
1201
-
809
1201
shift_expr
811
1201
atom
812
1201
{
813
1201
comparison
814
1201
or_test
815
1201
(
816
1201
arith_expr
817
1201
power
818
1201
STRING
819
1201
NAME
820
1201
and_test
821
1201
subscriptlist
1714
1201
term
822
1201
+
823
1201
xor_expr
824
1201
test
825
1201
NUMBER
826
1201
False
827
1201
subscript
828
1201
expr
829
1201
not_test
830
1201
None
831
1201
lambdef
832
1201
lambda
833
1201
maybe_test
834
1201
:
maybe_test -> 
1202
in
atom -> { }
1202
<=
atom -> { }
1202
*
atom -> { }
1202
NEWLINE
atom -> { }
1202
>
atom -> { }
1202
+
atom -> { }
1202
@
atom -> { }
1202
,
atom -> { }
1202
>=
atom -> { }
1202
/
atom -> { }
1202
|
atom -> { }
1202
is
atom -> { }
1202
and
atom -> { }
1202
=
atom -> { }
1202
if
atom -> { }
1202
(
atom -> { }
1202
>>
atom -> { }
1202
not
atom -> { }
1202
-
atom -> { }
1202
<<
atom -> { }
1202
**
atom -> { }
1202
or
atom -> { }
1202
<
atom -> { }
1202
!=
atom -> { }
1202
==
atom -> { }
1202
%
atom -> { }
1202
//
atom -> { }
1202
&
atom -> { }
1202
[
atom -> { }
1202
.
atom -> { }
1202
^
atom -> { }
1203
[
632
1203
factor
633
1203
True
634
1203
atom_expr
635
1203
~
636
1203
and_expr
637
1203
-
638
1203
None
639
1203
shift_expr
640
1203
atom
641
1203
{
642
1203
comparison
643
1203
and_test
644
1203
arith_expr
645
1203
power
646
1203
STRING
647
1203
NAME
648
1203
(
649
1203
NUMBER
650
1203
term
651
1203
+
652
1203
xor_expr
654
1203
not
656
1203
False
657
1203
not_test
659
1203
expr
663
1203
or_test
1715
1204
[
632
1204
factor
633
1204
True
634
1204
atom_expr
635
1204
~
636
1204
-
638
1204
None
639
1204
atom
641
1204
{
642
1204
arith_expr
645
1204
power
646
1204
STRING
647
1204
NAME
648
1204
shift_expr
1716
1204
(
649
1204
NUMBER
650
1204
term
651
1204
+
652
1204
False
657
1205
[
632
1205
factor
633
1205
True
634
1205
atom_expr
635
1205
~
636
1205
-
638
1205
None
639
1205
atom
641
1205
{
642
1205
arith_expr
645
1205
power
646
1205
STRING
647
1205
NAME
648
1205
(
649
1205
NUMBER
650
1205
term
651
1205
+
652
1205
False
657
1205
shift_expr
1717
1206
)
1718
1207
or
atom -> ( )
1207
>>
atom -> ( )
1207
(
atom -> ( )
1207
<=
atom -> ( )
1207
.
atom -> ( )
1207
is
atom -> ( )
1207
@
atom -> ( )
1207
,
atom -> ( )
1207
%
atom -> ( )
1207
<<
atom -> ( )
1207
**
atom -> ( )
1207
^
atom -> ( )
1207
/
atom -> ( )
1207
if
atom -> ( )
1207
not
atom -> ( )
1207
=
atom -> ( )
1207
*
atom -> ( )
1207
!=
atom -> ( )
1207
<
atom -> ( )
1207
NEWLINE
atom -> ( )
1207
&
atom -> ( )
1207
-
atom -> ( )
1207
>
atom -> ( )
1207
//
atom -> ( )
1207
==
atom -> ( )
1207
in
atom -> ( )
1207
+
atom -> ( )
1207
[
atom -> ( )
1207
>=
atom -> ( )
1207
and
atom -> ( )
1207
|
atom -> ( )
1208
[
632
1208
factor
633
1208
True
634
1208
atom_expr
635
1208
~
636
1208
-
638
1208
None
639
1208
arith_expr
1719
1208
atom
641
1208
{
642
1208
power
646
1208
STRING
647
1208
NAME
648
1208
(
649
1208
NUMBER
650
1208
term
651
1208
+
652
1208
False
657
1209
[
632
1209
factor
633
1209
True
634
1209
atom_expr
635
1209
~
636
1209
-
638
1209
None
639
1209
atom
641
1209
{
642
1209
arith_expr
1720
1209
power
646
1209
STRING
647
1209
NAME
648
1209
(
649
1209
NUMBER
650
1209
term
651
1209
+
652
1209
False
657
1210
-
factor -> + factor
1210
@
factor -> + factor
1210
<<
factor -> + factor
1210
is
factor -> + factor
1210
and
factor -> + factor
1210
<=
factor -> + factor
1210
or
factor -> + factor
1210
<
factor -> + factor
1210
^
factor -> + factor
1210
not
factor -> + factor
1210
//
factor -> + factor
1210
,
factor -> + factor
1210
*
factor -> + factor
1210
in
factor -> + factor
1210
&
factor -> + factor
1210
+
factor -> + factor
1210
if
factor -> + factor
1210
>>
factor -> + factor
1210
|
factor -> + factor
1210
=
factor -> + factor
1210
>
factor -> + factor
1210
%
factor -> + factor
1210
NEWLINE
factor -> + factor
1210
>=
factor -> + factor
1210
!=
factor -> + factor
1210
/
factor -> + factor
1210
==
factor -> + factor
1211
=
yield_arg -> test_list
1211
NEWLINE
yield_arg -> test_list
1212
NEWLINE
yield_expr -> yield yield_arg
1212
=
yield_expr -> yield yield_arg
1213
[
1721
1213
factor
1722
1213
True
1723
1213
atom_expr
1724
1213
~
1725
1213
and_expr
1726
1213
-
1727
1213
None
1728
1213
atom
1729
1213
{
1730
1213
and_test
1731
1213
arith_expr
1732
1213
power
1733
1213
STRING
1734
1213
NAME
1735
1213
(
1736
1213
NUMBER
1737
1213
term
1738
1213
+
1739
1213
xor_expr
1740
1213
shift_expr
1741
1213
not
1742
1213
False
1743
1213
lambda
1744
1213
comparison
1745
1213
not_test
1746
1213
or_test
1747
1213
lambdef
1748
1213
expr
1749
1213
test
1750
1214
[
632
1214
factor
633
1214
True
634
1214
atom_expr
635
1214
~
636
1214
and_expr
637
1214
-
638
1214
None
639
1214
shift_expr
640
1214
atom
641
1214
{
642
1214
expr
1751
1214
arith_expr
645
1214
power
646
1214
STRING
647
1214
NAME
648
1214
(
649
1214
NUMBER
650
1214
term
651
1214
+
652
1214
xor_expr
654
1214
False
657
1215
[
632
1215
factor
633
1215
True
634
1215
atom_expr
635
1215
~
636
1215
and_expr
637
1215
-
638
1215
None
639
1215
shift_expr
640
1215
atom
641
1215
{
642
1215
comparison
643
1215
and_test
644
1215
arith_expr
645
1215
power
646
1215
STRING
647
1215
NAME
648
1215
(
649
1215
NUMBER
650
1215
term
651
1215
+
652
1215
xor_expr
654
1215
test
655
1215
not
656
1215
False
657
1215
lambda
658
1215
test_list
1752
1215
not_test
659
1215
or_test
661
1215
lambdef
662
1215
expr
663
1216
,
not_test -> not not_test
1216
NEWLINE
not_test -> not not_test
1216
and
not_test -> not not_test
1216
=
not_test -> not not_test
1216
or
not_test -> not not_test
1216
if
not_test -> not not_test
1217
:
1753
1218
[
632
1218
factor
633
1218
True
634
1218
atom_expr
635
1218
~
636
1218
and_expr
637
1218
-
638
1218
None
639
1218
shift_expr
640
1218
atom
641
1218
{
642
1218
comparison
643
1218
and_test
644
1218
arith_expr
645
1218
power
646
1218
STRING
647
1218
NAME
648
1218
(
649
1218
NUMBER
650
1218
term
651
1218
+
652
1218
xor_expr
654
1218
not
656
1218
False
657
1218
lambda
658
1218
not_test
659
1218
or_test
661
1218
lambdef
662
1218
expr
663
1218
test
1754
1219
[
632
1219
factor
633
1219
True
634
1219
atom_expr
635
1219
~
636
1219
and_expr
637
1219
-
638
1219
None
639
1219
shift_expr
640
1219
atom
641
1219
{
642
1219
comparison
643
1219
arith_expr
645
1219
power
646
1219
STRING
647
1219
NAME
648
1219
(
649
1219
NUMBER
650
1219
term
651
1219
+
652
1219
xor_expr
654
1219
not
656
1219
False
657
1219
and_test
1755
1219
not_test
659
1219
expr
663
1220
NEWLINE
assign -> = yield_expr assign
1221
[
738
1221
factor
740
1221
True
741
1221
~
742
1221
and_expr
743
1221
-
744
1221
atom
745
1221
{
746
1221
arith_expr
747
1221
power
748
1221
atom_expr
749
1221
STRING
750
1221
NAME
751
1221
(
752
1221
or_test
1756
1221
term
753
1221
+
754
1221
xor_expr
755
1221
shift_expr
756
1221
NUMBER
757
1221
not
758
1221
False
759
1221
comparison
760
1221
not_test
761
1221
None
762
1221
expr
763
1221
and_test
764
1222
[
632
1222
factor
633
1222
True
634
1222
atom_expr
635
1222
~
636
1222
and_expr
637
1222
-
638
1222
None
639
1222
shift_expr
640
1222
atom
641
1222
{
642
1222
arith_expr
645
1222
power
646
1222
STRING
647
1222
NAME
648
1222
(
649
1222
NUMBER
650
1222
term
651
1222
+
652
1222
xor_expr
654
1222
False
657
1222
expr
663
1222
comparison
1757
1223
NEWLINE
assign -> = test_list assign
1224
!=
atom -> [ ]
1224
>>
atom -> [ ]
1224
|
atom -> [ ]
1224
<<
atom -> [ ]
1224
>
atom -> [ ]
1224
.
atom -> [ ]
1224
%
atom -> [ ]
1224
^
atom -> [ ]
1224
=
atom -> [ ]
1224
-
atom -> [ ]
1224
in
atom -> [ ]
1224
or
atom -> [ ]
1224
/
atom -> [ ]
1224
**
atom -> [ ]
1224
//
atom -> [ ]
1224
not
atom -> [ ]
1224
(
atom -> [ ]
1224
+
atom -> [ ]
1224
and
atom -> [ ]
1224
==
atom -> [ ]
1224
[
atom -> [ ]
1224
if
atom -> [ ]
1224
<
atom -> [ ]
1224
<=
atom -> [ ]
1224
>=
atom -> [ ]
1224
is
atom -> [ ]
1224
*
atom -> [ ]
1224
@
atom -> [ ]
1224
&
atom -> [ ]
1225
]
1758
1226
term
1759
1226
[
665
1226
factor
666
1226
True
667
1226
atom_expr
668
1226
~
669
1226
-
671
1226
atom
672
1226
{
673
1226
power
676
1226
STRING
677
1226
NAME
678
1226
(
679
1226
+
681
1226
NUMBER
684
1226
False
687
1226
None
690
1227
[
665
1227
factor
666
1227
True
667
1227
term
1760
1227
~
669
1227
-
671
1227
atom_expr
668
1227
atom
672
1227
{
673
1227
power
676
1227
STRING
677
1227
NAME
678
1227
(
679
1227
+
681
1227
NUMBER
684
1227
False
687
1227
None
690
1228
[
665
1228
factor
666
1228
True
667
1228
atom_expr
668
1228
~
669
1228
-
671
1228
atom
672
1228
{
673
1228
power
676
1228
STRING
677
1228
NAME
678
1228
(
679
1228
term
1761
1228
+
681
1228
NUMBER
684
1228
False
687
1228
None
690
1229
[
665
1229
factor
666
1229
True
667
1229
atom_expr
668
1229
~
669
1229
-
671
1229
atom
672
1229
{
673
1229
power
676
1229
STRING
677
1229
NAME
678
1229
(
679
1229
term
1762
1229
+
681
1229
NUMBER
684
1229
False
687
1229
None
690
1230
[
665
1230
factor
666
1230
True
667
1230
atom_expr
668
1230
~
669
1230
-
671
1230
atom
672
1230
{
673
1230
power
676
1230
STRING
677
1230
NAME
678
1230
term
1763
1230
(
679
1230
+
681
1230
NUMBER
684
1230
False
687
1230
None
690
1231
[
665
1231
True
667
1231
atom_expr
668
1231
-
671
1231
~
669
1231
atom
672
1231
{
673
1231
power
676
1231
STRING
677
1231
NAME
678
1231
(
679
1231
+
681
1231
NUMBER
684
1231
False
687
1231
factor
1764
1231
None
690
1232
@
factor -> ~ factor
1232
>>
factor -> ~ factor
1232
<=
factor -> ~ factor
1232
and
factor -> ~ factor
1232
+
factor -> ~ factor
1232
*
factor -> ~ factor
1232
!=
factor -> ~ factor
1232
%
factor -> ~ factor
1232
<<
factor -> ~ factor
1232
>=
factor -> ~ factor
1232
=
factor -> ~ factor
1232
&
factor -> ~ factor
1232
is
factor -> ~ factor
1232
==
factor -> ~ factor
1232
//
factor -> ~ factor
1232
<
factor -> ~ factor
1232
/
factor -> ~ factor
1232
not
factor -> ~ factor
1232
-
factor -> ~ factor
1232
or
factor -> ~ factor
1232
|
factor -> ~ factor
1232
>
factor -> ~ factor
1232
^
factor -> ~ factor
1232
if
factor -> ~ factor
1232
in
factor -> ~ factor
1233
[
665
1233
factor
666
1233
True
667
1233
atom_expr
668
1233
~
669
1233
and_expr
670
1233
-
671
1233
atom
672
1233
{
673
1233
xor_expr
1765
1233
arith_expr
675
1233
power
676
1233
STRING
677
1233
NAME
678
1233
(
679
1233
term
680
1233
+
681
1233
shift_expr
683
1233
NUMBER
684
1233
False
687
1233
None
690
1234
@
factor -> - factor
1234
=
factor -> - factor
1234
<=
factor -> - factor
1234
in
factor -> - factor
1234
>>
factor -> - factor
1234
|
factor -> - factor
1234
is
factor -> - factor
1234
+
factor -> - factor
1234
%
factor -> - factor
1234
<
factor -> - factor
1234
*
factor -> - factor
1234
<<
factor -> - factor
1234
if
factor -> - factor
1234
-
factor -> - factor
1234
>=
factor -> - factor
1234
not
factor -> - factor
1234
and
factor -> - factor
1234
/
factor -> - factor
1234
or
factor -> - factor
1234
^
factor -> - factor
1234
>
factor -> - factor
1234
!=
factor -> - factor
1234
&
factor -> - factor
1234
==
factor -> - factor
1234
//
factor -> - factor
1235
[
766
1235
factor
767
1235
True
768
1235
atom_expr
769
1235
~
770
1235
and_expr
771
1235
-
772
1235
{
773
1235
shift_expr
774
1235
atom
775
1235
comparison
776
1235
and_test
777
1235
arith_expr
778
1235
power
779
1235
STRING
780
1235
NAME
781
1235
(
782
1235
term
784
1235
+
785
1235
xor_expr
786
1235
)
1766
1235
or_test
788
1235
arglist
1767
1235
NUMBER
789
1235
not
790
1235
False
791
1235
expr
792
1235
*
793
1235
not_test
794
1235
None
795
1235
lambdef
796
1235
lambda
797
1235
test
798
1235
argument
799
1235
**
800
1236
trailer_expr
1768
1236
>>
trailer_expr -> 
1236
(
1235
1236
trailer
1236
1236
.
1238
1236
+
trailer_expr -> 
1236
[
1239
1236
is
trailer_expr -> 
1236
>
trailer_expr -> 
1236
not
trailer_expr -> 
1236
|
trailer_expr -> 
1236
=
trailer_expr -> 
1236
&
trailer_expr -> 
1236
/
trailer_expr -> 
1236
@
trailer_expr -> 
1236
!=
trailer_expr -> 
1236
**
trailer_expr -> 
1236
>=
trailer_expr -> 
1236
^
trailer_expr -> 
1236
in
trailer_expr -> 
1236
<<
trailer_expr -> 
1236
and
trailer_expr -> 
1236
or
trailer_expr -> 
1236
if
trailer_expr -> 
1236
//
trailer_expr -> 
1236
%
trailer_expr -> 
1236
<=
trailer_expr -> 
1236
<
trailer_expr -> 
1236
==
trailer_expr -> 
1236
-
trailer_expr -> 
1236
*
trailer_expr -> 
1237
^
atom_expr -> atom trailer_expr
1237
or
atom_expr -> atom trailer_expr
1237
=
atom_expr -> atom trailer_expr
1237
&
atom_expr -> atom trailer_expr
1237
@
atom_expr -> atom trailer_expr
1237
|
atom_expr -> atom trailer_expr
1237
-
atom_expr -> atom trailer_expr
1237
*
atom_expr -> atom trailer_expr
1237
%
atom_expr -> atom trailer_expr
1237
==
atom_expr -> atom trailer_expr
1237
**
atom_expr -> atom trailer_expr
1237
and
atom_expr -> atom trailer_expr
1237
is
atom_expr -> atom trailer_expr
1237
in
atom_expr -> atom trailer_expr
1237
<<
atom_expr -> atom trailer_expr
1237
!=
atom_expr -> atom trailer_expr
1237
<=
atom_expr -> atom trailer_expr
1237
/
atom_expr -> atom trailer_expr
1237
//
atom_expr -> atom trailer_expr
1237
<
atom_expr -> atom trailer_expr
1237
>=
atom_expr -> atom trailer_expr
1237
>>
atom_expr -> atom trailer_expr
1237
if
atom_expr -> atom trailer_expr
1237
not
atom_expr -> atom trailer_expr
1237
+
atom_expr -> atom trailer_expr
1237
>
atom_expr -> atom trailer_expr
1238
NAME
1769
1239
[
802
1239
factor
803
1239
True
804
1239
atom_expr
810
1239
~
806
1239
not
807
1239
and_expr
808
1239
-
809
1239
shift_expr
811
1239
atom
812
1239
{
813
1239
comparison
814
1239
or_test
815
1239
(
816
1239
arith_expr
817
1239
power
818
1239
STRING
819
1239
NAME
820
1239
and_test
821
1239
term
822
1239
+
823
1239
xor_expr
824
1239
subscriptlist
1770
1239
test
825
1239
NUMBER
826
1239
False
827
1239
subscript
828
1239
expr
829
1239
not_test
830
1239
None
831
1239
lambdef
832
1239
lambda
833
1239
maybe_test
834
1239
:
maybe_test -> 
1240
in
atom -> { }
1240
<=
atom -> { }
1240
*
atom -> { }
1240
>
atom -> { }
1240
+
atom -> { }
1240
@
atom -> { }
1240
>=
atom -> { }
1240
/
atom -> { }
1240
|
atom -> { }
1240
is
atom -> { }
1240
and
atom -> { }
1240
=
atom -> { }
1240
if
atom -> { }
1240
(
atom -> { }
1240
>>
atom -> { }
1240
not
atom -> { }
1240
-
atom -> { }
1240
<<
atom -> { }
1240
**
atom -> { }
1240
or
atom -> { }
1240
<
atom -> { }
1240
!=
atom -> { }
1240
==
atom -> { }
1240
%
atom -> { }
1240
//
atom -> { }
1240
&
atom -> { }
1240
[
atom -> { }
1240
.
atom -> { }
1240
^
atom -> { }
1241
[
665
1241
factor
666
1241
True
667
1241
atom_expr
668
1241
~
669
1241
and_expr
670
1241
-
671
1241
atom
672
1241
{
673
1241
and_test
674
1241
arith_expr
675
1241
power
676
1241
STRING
677
1241
NAME
678
1241
(
679
1241
term
680
1241
+
681
1241
xor_expr
682
1241
shift_expr
683
1241
NUMBER
684
1241
not
685
1241
False
687
1241
comparison
688
1241
not_test
689
1241
None
690
1241
expr
692
1241
or_test
1771
1242
[
665
1242
factor
666
1242
True
667
1242
atom_expr
668
1242
~
669
1242
-
671
1242
atom
672
1242
{
673
1242
arith_expr
675
1242
power
676
1242
STRING
677
1242
NAME
678
1242
shift_expr
1772
1242
(
679
1242
term
680
1242
+
681
1242
NUMBER
684
1242
False
687
1242
None
690
1243
[
665
1243
factor
666
1243
True
667
1243
atom_expr
668
1243
~
669
1243
-
671
1243
atom
672
1243
{
673
1243
arith_expr
675
1243
power
676
1243
STRING
677
1243
NAME
678
1243
(
679
1243
term
680
1243
+
681
1243
NUMBER
684
1243
False
687
1243
shift_expr
1773
1243
None
690
1244
)
1774
1245
or
atom -> ( )
1245
>>
atom -> ( )
1245
(
atom -> ( )
1245
<=
atom -> ( )
1245
.
atom -> ( )
1245
is
atom -> ( )
1245
@
atom -> ( )
1245
%
atom -> ( )
1245
<<
atom -> ( )
1245
**
atom -> ( )
1245
^
atom -> ( )
1245
/
atom -> ( )
1245
if
atom -> ( )
1245
not
atom -> ( )
1245
=
atom -> ( )
1245
*
atom -> ( )
1245
!=
atom -> ( )
1245
<
atom -> ( )
1245
&
atom -> ( )
1245
-
atom -> ( )
1245
>
atom -> ( )
1245
//
atom -> ( )
1245
==
atom -> ( )
1245
in
atom -> ( )
1245
+
atom -> ( )
1245
[
atom -> ( )
1245
>=
atom -> ( )
1245
and
atom -> ( )
1245
|
atom -> ( )
1246
[
665
1246
factor
666
1246
True
667
1246
atom_expr
668
1246
~
669
1246
-
671
1246
arith_expr
1775
1246
atom
672
1246
{
673
1246
power
676
1246
STRING
677
1246
NAME
678
1246
(
679
1246
term
680
1246
+
681
1246
NUMBER
684
1246
False
687
1246
None
690
1247
[
665
1247
factor
666
1247
True
667
1247
atom_expr
668
1247
~
669
1247
-
671
1247
atom
672
1247
{
673
1247
arith_expr
1776
1247
power
676
1247
STRING
677
1247
NAME
678
1247
(
679
1247
term
680
1247
+
681
1247
NUMBER
684
1247
False
687
1247
None
690
1248
-
factor -> + factor
1248
@
factor -> + factor
1248
<<
factor -> + factor
1248
is
factor -> + factor
1248
and
factor -> + factor
1248
<=
factor -> + factor
1248
or
factor -> + factor
1248
<
factor -> + factor
1248
^
factor -> + factor
1248
not
factor -> + factor
1248
//
factor -> + factor
1248
*
factor -> + factor
1248
in
factor -> + factor
1248
&
factor -> + factor
1248
+
factor -> + factor
1248
if
factor -> + factor
1248
>>
factor -> + factor
1248
|
factor -> + factor
1248
=
factor -> + factor
1248
>
factor -> + factor
1248
%
factor -> + factor
1248
>=
factor -> + factor
1248
!=
factor -> + factor
1248
/
factor -> + factor
1248
==
factor -> + factor
1249
[
665
1249
factor
666
1249
True
667
1249
atom_expr
668
1249
~
669
1249
and_expr
670
1249
-
671
1249
atom
672
1249
{
673
1249
expr
1777
1249
arith_expr
675
1249
power
676
1249
STRING
677
1249
NAME
678
1249
(
679
1249
term
680
1249
+
681
1249
xor_expr
682
1249
shift_expr
683
1249
NUMBER
684
1249
False
687
1249
None
690
1250
[
665
1250
factor
666
1250
True
667
1250
atom_expr
668
1250
~
669
1250
-
671
1250
atom
672
1250
{
673
1250
arith_expr
675
1250
power
676
1250
STRING
677
1250
NAME
678
1250
(
679
1250
term
680
1250
+
681
1250
and_expr
1778
1250
shift_expr
683
1250
NUMBER
684
1250
False
687
1250
None
690
1251
=
not_test -> not not_test
1251
and
not_test -> not not_test
1251
or
not_test -> not not_test
1251
if
not_test -> not not_test
1252
[
397
1252
factor
398
1252
True
399
1252
atom_expr
400
1252
~
401
1252
and_expr
402
1252
-
403
1252
None
404
1252
atom
405
1252
{
406
1252
arith_expr
407
1252
power
408
1252
STRING
409
1252
NAME
410
1252
(
411
1252
NUMBER
412
1252
and_test
413
1252
term
414
1252
+
415
1252
xor_expr
416
1252
shift_expr
417
1252
not
418
1252
False
419
1252
lambda
420
1252
comparison
421
1252
not_test
422
1252
lambdef
423
1252
expr
424
1252
test
1779
1252
or_test
425
1253
[
665
1253
factor
666
1253
True
667
1253
atom_expr
668
1253
~
669
1253
and_expr
670
1253
-
671
1253
atom
672
1253
{
673
1253
arith_expr
675
1253
power
676
1253
STRING
677
1253
NAME
678
1253
(
679
1253
term
680
1253
+
681
1253
xor_expr
682
1253
shift_expr
683
1253
NUMBER
684
1253
not
685
1253
False
687
1253
and_test
1780
1253
comparison
688
1253
not_test
689
1253
None
690
1253
expr
692
1254
[
738
1254
factor
740
1254
True
741
1254
~
742
1254
and_expr
743
1254
-
744
1254
atom
745
1254
{
746
1254
arith_expr
747
1254
power
748
1254
atom_expr
749
1254
STRING
750
1254
NAME
751
1254
(
752
1254
or_test
1781
1254
term
753
1254
+
754
1254
xor_expr
755
1254
shift_expr
756
1254
NUMBER
757
1254
not
758
1254
False
759
1254
comparison
760
1254
not_test
761
1254
None
762
1254
expr
763
1254
and_test
764
1255
[
665
1255
factor
666
1255
True
667
1255
atom_expr
668
1255
~
669
1255
and_expr
670
1255
-
671
1255
atom
672
1255
{
673
1255
arith_expr
675
1255
power
676
1255
STRING
677
1255
NAME
678
1255
(
679
1255
term
680
1255
+
681
1255
xor_expr
682
1255
shift_expr
683
1255
NUMBER
684
1255
False
687
1255
None
690
1255
expr
692
1255
comparison
1782
1256
[
665
1256
factor
666
1256
True
667
1256
atom_expr
668
1256
~
669
1256
and_expr
670
1256
-
671
1256
atom
672
1256
{
673
1256
and_test
674
1256
arith_expr
675
1256
power
676
1256
STRING
677
1256
NAME
678
1256
(
679
1256
term
680
1256
+
681
1256
xor_expr
682
1256
shift_expr
683
1256
NUMBER
684
1256
not
685
1256
False
687
1256
comparison
688
1256
not_test
689
1256
None
690
1256
or_test
691
1256
expr
692
1256
lambda
693
1256
test
1783
1256
lambdef
694
1257
:
1784
1258
.
atom -> [ test_list_comp ]
1258
[
atom -> [ test_list_comp ]
1258
@
atom -> [ test_list_comp ]
1258
<=
atom -> [ test_list_comp ]
1258
<
atom -> [ test_list_comp ]
1258
not
atom -> [ test_list_comp ]
1258
in
atom -> [ test_list_comp ]
1258
and
atom -> [ test_list_comp ]
1258
-
atom -> [ test_list_comp ]
1258
if
atom -> [ test_list_comp ]
1258
!=
atom -> [ test_list_comp ]
1258
is
atom -> [ test_list_comp ]
1258
>>
atom -> [ test_list_comp ]
1258
or
atom -> [ test_list_comp ]
1258
//
atom -> [ test_list_comp ]
1258
/
atom -> [ test_list_comp ]
1258
,
atom -> [ test_list_comp ]
1258
|
atom -> [ test_list_comp ]
1258
>
atom -> [ test_list_comp ]
1258
&
atom -> [ test_list_comp ]
1258
(
atom -> [ test_list_comp ]
1258
%
atom -> [ test_list_comp ]
1258
>=
atom -> [ test_list_comp ]
1258
==
atom -> [ test_list_comp ]
1258
**
atom -> [ test_list_comp ]
1258
:
atom -> [ test_list_comp ]
1258
<<
atom -> [ test_list_comp ]
1258
as
atom -> [ test_list_comp ]
1258
*
atom -> [ test_list_comp ]
1258
^
atom -> [ test_list_comp ]
1258
+
atom -> [ test_list_comp ]
1259
<<
term -> factor @ term
1259
^
term -> factor @ term
1259
<=
term -> factor @ term
1259
&
term -> factor @ term
1259
==
term -> factor @ term
1259
if
term -> factor @ term
1259
|
term -> factor @ term
1259
!=
term -> factor @ term
1259
or
term -> factor @ term
1259
>
term -> factor @ term
1259
and
term -> factor @ term
1259
>>
term -> factor @ term
1259
is
term -> factor @ term
1259
-
term -> factor @ term
1259
not
term -> factor @ term
1259
+
term -> factor @ term
1259
in
term -> factor @ term
1259
>=
term -> factor @ term
1259
as
term -> factor @ term
1259
<
term -> factor @ term
1259
,
term -> factor @ term
1259
:
term -> factor @ term
1260
<=
term -> factor % term
1260
is
term -> factor % term
1260
>
term -> factor % term
1260
and
term -> factor % term
1260
in
term -> factor % term
1260
,
term -> factor % term
1260
or
term -> factor % term
1260
<
term -> factor % term
1260
:
term -> factor % term
1260
-
term -> factor % term
1260
!=
term -> factor % term
1260
>>
term -> factor % term
1260
^
term -> factor % term
1260
+
term -> factor % term
1260
if
term -> factor % term
1260
<<
term -> factor % term
1260
as
term -> factor % term
1260
>=
term -> factor % term
1260
==
term -> factor % term
1260
not
term -> factor % term
1260
|
term -> factor % term
1260
&
term -> factor % term
1261
>>
term -> factor / term
1261
!=
term -> factor / term
1261
<
term -> factor / term
1261
<=
term -> factor / term
1261
|
term -> factor / term
1261
is
term -> factor / term
1261
>=
term -> factor / term
1261
^
term -> factor / term
1261
&
term -> factor / term
1261
+
term -> factor / term
1261
as
term -> factor / term
1261
<<
term -> factor / term
1261
and
term -> factor / term
1261
-
term -> factor / term
1261
in
term -> factor / term
1261
>
term -> factor / term
1261
or
term -> factor / term
1261
not
term -> factor / term
1261
==
term -> factor / term
1261
,
term -> factor / term
1261
:
term -> factor / term
1261
if
term -> factor / term
1262
is
term -> factor * term
1262
+
term -> factor * term
1262
>=
term -> factor * term
1262
^
term -> factor * term
1262
,
term -> factor * term
1262
<=
term -> factor * term
1262
or
term -> factor * term
1262
<
term -> factor * term
1262
|
term -> factor * term
1262
>>
term -> factor * term
1262
in
term -> factor * term
1262
not
term -> factor * term
1262
==
term -> factor * term
1262
as
term -> factor * term
1262
:
term -> factor * term
1262
-
term -> factor * term
1262
and
term -> factor * term
1262
!=
term -> factor * term
1262
<<
term -> factor * term
1262
>
term -> factor * term
1262
if
term -> factor * term
1262
&
term -> factor * term
1263
!=
term -> factor // term
1263
or
term -> factor // term
1263
^
term -> factor // term
1263
>
term -> factor // term
1263
is
term -> factor // term
1263
&
term -> factor // term
1263
-
term -> factor // term
1263
:
term -> factor // term
1263
in
term -> factor // term
1263
>>
term -> factor // term
1263
|
term -> factor // term
1263
as
term -> factor // term
1263
<
term -> factor // term
1263
>=
term -> factor // term
1263
not
term -> factor // term
1263
if
term -> factor // term
1263
==
term -> factor // term
1263
<=
term -> factor // term
1263
,
term -> factor // term
1263
and
term -> factor // term
1263
<<
term -> factor // term
1263
+
term -> factor // term
1264
:
power -> atom_expr ** factor
1264
!=
power -> atom_expr ** factor
1264
@
power -> atom_expr ** factor
1264
|
power -> atom_expr ** factor
1264
in
power -> atom_expr ** factor
1264
==
power -> atom_expr ** factor
1264
if
power -> atom_expr ** factor
1264
and
power -> atom_expr ** factor
1264
>=
power -> atom_expr ** factor
1264
/
power -> atom_expr ** factor
1264
not
power -> atom_expr ** factor
1264
^
power -> atom_expr ** factor
1264
//
power -> atom_expr ** factor
1264
as
power -> atom_expr ** factor
1264
>
power -> atom_expr ** factor
1264
+
power -> atom_expr ** factor
1264
%
power -> atom_expr ** factor
1264
-
power -> atom_expr ** factor
1264
is
power -> atom_expr ** factor
1264
<=
power -> atom_expr ** factor
1264
<
power -> atom_expr ** factor
1264
,
power -> atom_expr ** factor
1264
*
power -> atom_expr ** factor
1264
<<
power -> atom_expr ** factor
1264
or
power -> atom_expr ** factor
1264
>>
power -> atom_expr ** factor
1264
&
power -> atom_expr ** factor
1265
not
xor_expr -> and_expr ^ xor_expr
1265
<
xor_expr -> and_expr ^ xor_expr
1265
,
xor_expr -> and_expr ^ xor_expr
1265
>=
xor_expr -> and_expr ^ xor_expr
1265
>
xor_expr -> and_expr ^ xor_expr
1265
is
xor_expr -> and_expr ^ xor_expr
1265
!=
xor_expr -> and_expr ^ xor_expr
1265
and
xor_expr -> and_expr ^ xor_expr
1265
:
xor_expr -> and_expr ^ xor_expr
1265
as
xor_expr -> and_expr ^ xor_expr
1265
if
xor_expr -> and_expr ^ xor_expr
1265
<=
xor_expr -> and_expr ^ xor_expr
1265
in
xor_expr -> and_expr ^ xor_expr
1265
==
xor_expr -> and_expr ^ xor_expr
1265
|
xor_expr -> and_expr ^ xor_expr
1265
or
xor_expr -> and_expr ^ xor_expr
1266
<
and_expr -> shift_expr & and_expr
1266
if
and_expr -> shift_expr & and_expr
1266
>=
and_expr -> shift_expr & and_expr
1266
|
and_expr -> shift_expr & and_expr
1266
not
and_expr -> shift_expr & and_expr
1266
==
and_expr -> shift_expr & and_expr
1266
>
and_expr -> shift_expr & and_expr
1266
in
and_expr -> shift_expr & and_expr
1266
^
and_expr -> shift_expr & and_expr
1266
or
and_expr -> shift_expr & and_expr
1266
and
and_expr -> shift_expr & and_expr
1266
!=
and_expr -> shift_expr & and_expr
1266
as
and_expr -> shift_expr & and_expr
1266
,
and_expr -> shift_expr & and_expr
1266
:
and_expr -> shift_expr & and_expr
1266
is
and_expr -> shift_expr & and_expr
1266
<=
and_expr -> shift_expr & and_expr
1267
+
trailer -> ( )
1267
!=
trailer -> ( )
1267
<<
trailer -> ( )
1267
>=
trailer -> ( )
1267
**
trailer -> ( )
1267
not
trailer -> ( )
1267
if
trailer -> ( )
1267
,
trailer -> ( )
1267
|
trailer -> ( )
1267
[
trailer -> ( )
1267
==
trailer -> ( )
1267
%
trailer -> ( )
1267
*
trailer -> ( )
1267
>>
trailer -> ( )
1267
@
trailer -> ( )
1267
>
trailer -> ( )
1267
/
trailer -> ( )
1267
in
trailer -> ( )
1267
(
trailer -> ( )
1267
as
trailer -> ( )
1267
is
trailer -> ( )
1267
//
trailer -> ( )
1267
<
trailer -> ( )
1267
:
trailer -> ( )
1267
or
trailer -> ( )
1267
^
trailer -> ( )
1267
and
trailer -> ( )
1267
<=
trailer -> ( )
1267
.
trailer -> ( )
1267
-
trailer -> ( )
1267
&
trailer -> ( )
1268
)
1785
1269
<=
trailer_expr -> trailer trailer_expr
1269
+
trailer_expr -> trailer trailer_expr
1269
^
trailer_expr -> trailer trailer_expr
1269
or
trailer_expr -> trailer trailer_expr
1269
==
trailer_expr -> trailer trailer_expr
1269
%
trailer_expr -> trailer trailer_expr
1269
@
trailer_expr -> trailer trailer_expr
1269
not
trailer_expr -> trailer trailer_expr
1269
<<
trailer_expr -> trailer trailer_expr
1269
-
trailer_expr -> trailer trailer_expr
1269
//
trailer_expr -> trailer trailer_expr
1269
and
trailer_expr -> trailer trailer_expr
1269
|
trailer_expr -> trailer trailer_expr
1269
if
trailer_expr -> trailer trailer_expr
1269
as
trailer_expr -> trailer trailer_expr
1269
>
trailer_expr -> trailer trailer_expr
1269
!=
trailer_expr -> trailer trailer_expr
1269
,
trailer_expr -> trailer trailer_expr
1269
<
trailer_expr -> trailer trailer_expr
1269
>>
trailer_expr -> trailer trailer_expr
1269
/
trailer_expr -> trailer trailer_expr
1269
:
trailer_expr -> trailer trailer_expr
1269
is
trailer_expr -> trailer trailer_expr
1269
&
trailer_expr -> trailer trailer_expr
1269
in
trailer_expr -> trailer trailer_expr
1269
>=
trailer_expr -> trailer trailer_expr
1269
*
trailer_expr -> trailer trailer_expr
1269
**
trailer_expr -> trailer trailer_expr
1270
.
trailer -> . NAME
1270
not
trailer -> . NAME
1270
if
trailer -> . NAME
1270
**
trailer -> . NAME
1270
:
trailer -> . NAME
1270
|
trailer -> . NAME
1270
-
trailer -> . NAME
1270
(
trailer -> . NAME
1270
%
trailer -> . NAME
1270
//
trailer -> . NAME
1270
==
trailer -> . NAME
1270
>>
trailer -> . NAME
1270
is
trailer -> . NAME
1270
!=
trailer -> . NAME
1270
and
trailer -> . NAME
1270
as
trailer -> . NAME
1270
>=
trailer -> . NAME
1270
,
trailer -> . NAME
1270
>
trailer -> . NAME
1270
in
trailer -> . NAME
1270
<<
trailer -> . NAME
1270
&
trailer -> . NAME
1270
/
trailer -> . NAME
1270
^
trailer -> . NAME
1270
[
trailer -> . NAME
1270
<=
trailer -> . NAME
1270
or
trailer -> . NAME
1270
+
trailer -> . NAME
1270
<
trailer -> . NAME
1270
*
trailer -> . NAME
1270
@
trailer -> . NAME
1271
]
1786
1272
else
1787
1273
==
shift_expr -> arith_expr >> shift_expr
1273
^
shift_expr -> arith_expr >> shift_expr
1273
or
shift_expr -> arith_expr >> shift_expr
1273
if
shift_expr -> arith_expr >> shift_expr
1273
,
shift_expr -> arith_expr >> shift_expr
1273
not
shift_expr -> arith_expr >> shift_expr
1273
as
shift_expr -> arith_expr >> shift_expr
1273
|
shift_expr -> arith_expr >> shift_expr
1273
<=
shift_expr -> arith_expr >> shift_expr
1273
is
shift_expr -> arith_expr >> shift_expr
1273
in
shift_expr -> arith_expr >> shift_expr
1273
>=
shift_expr -> arith_expr >> shift_expr
1273
>
shift_expr -> arith_expr >> shift_expr
1273
:
shift_expr -> arith_expr >> shift_expr
1273
&
shift_expr -> arith_expr >> shift_expr
1273
<
shift_expr -> arith_expr >> shift_expr
1273
and
shift_expr -> arith_expr >> shift_expr
1273
!=
shift_expr -> arith_expr >> shift_expr
1274
or
shift_expr -> arith_expr << shift_expr
1274
>
shift_expr -> arith_expr << shift_expr
1274
in
shift_expr -> arith_expr << shift_expr
1274
&
shift_expr -> arith_expr << shift_expr
1274
:
shift_expr -> arith_expr << shift_expr
1274
is
shift_expr -> arith_expr << shift_expr
1274
<
shift_expr -> arith_expr << shift_expr
1274
<=
shift_expr -> arith_expr << shift_expr
1274
as
shift_expr -> arith_expr << shift_expr
1274
not
shift_expr -> arith_expr << shift_expr
1274
if
shift_expr -> arith_expr << shift_expr
1274
,
shift_expr -> arith_expr << shift_expr
1274
and
shift_expr -> arith_expr << shift_expr
1274
^
shift_expr -> arith_expr << shift_expr
1274
|
shift_expr -> arith_expr << shift_expr
1274
!=
shift_expr -> arith_expr << shift_expr
1274
==
shift_expr -> arith_expr << shift_expr
1274
>=
shift_expr -> arith_expr << shift_expr
1275
>
atom -> ( test_list_comp )
1275
@
atom -> ( test_list_comp )
1275
&
atom -> ( test_list_comp )
1275
[
atom -> ( test_list_comp )
1275
if
atom -> ( test_list_comp )
1275
==
atom -> ( test_list_comp )
1275
>=
atom -> ( test_list_comp )
1275
**
atom -> ( test_list_comp )
1275
not
atom -> ( test_list_comp )
1275
<<
atom -> ( test_list_comp )
1275
>>
atom -> ( test_list_comp )
1275
as
atom -> ( test_list_comp )
1275
in
atom -> ( test_list_comp )
1275
or
atom -> ( test_list_comp )
1275
.
atom -> ( test_list_comp )
1275
/
atom -> ( test_list_comp )
1275
^
atom -> ( test_list_comp )
1275
is
atom -> ( test_list_comp )
1275
,
atom -> ( test_list_comp )
1275
and
atom -> ( test_list_comp )
1275
//
atom -> ( test_list_comp )
1275
<
atom -> ( test_list_comp )
1275
*
atom -> ( test_list_comp )
1275
<=
atom -> ( test_list_comp )
1275
(
atom -> ( test_list_comp )
1275
-
atom -> ( test_list_comp )
1275
|
atom -> ( test_list_comp )
1275
!=
atom -> ( test_list_comp )
1275
:
atom -> ( test_list_comp )
1275
+
atom -> ( test_list_comp )
1275
%
atom -> ( test_list_comp )
1276
global
with_stmt -> with with_items : suite
1276
try
with_stmt -> with with_items : suite
1276
server
with_stmt -> with with_items : suite
1276
+
with_stmt -> with with_items : suite
1276
begsim
with_stmt -> with with_items : suite
1276
endsim
with_stmt -> with with_items : suite
1276
$
with_stmt -> with with_items : suite
1276
NUMBER
with_stmt -> with with_items : suite
1276
assert
with_stmt -> with with_items : suite
1276
return
with_stmt -> with with_items : suite
1276
raise
with_stmt -> with with_items : suite
1276
None
with_stmt -> with with_items : suite
1276
NAME
with_stmt -> with with_items : suite
1276
yield
with_stmt -> with with_items : suite
1276
nonlocal
with_stmt -> with with_items : suite
1276
modopt
with_stmt -> with with_items : suite
1276
if
with_stmt -> with with_items : suite
1276
for
with_stmt -> with with_items : suite
1276
break
with_stmt -> with with_items : suite
1276
-
with_stmt -> with with_items : suite
1276
{
with_stmt -> with with_items : suite
1276
conf
with_stmt -> with with_items : suite
1276
(
with_stmt -> with with_items : suite
1276
def
with_stmt -> with with_items : suite
1276
True
with_stmt -> with with_items : suite
1276
@
with_stmt -> with with_items : suite
1276
STRING
with_stmt -> with with_items : suite
1276
continue
with_stmt -> with with_items : suite
1276
~
with_stmt -> with with_items : suite
1276
class
with_stmt -> with with_items : suite
1276
lambda
with_stmt -> with with_items : suite
1276
False
with_stmt -> with with_items : suite
1276
while
with_stmt -> with with_items : suite
1276
with
with_stmt -> with with_items : suite
1276
resetstats
with_stmt -> with with_items : suite
1276
[
with_stmt -> with with_items : suite
1276
NEWLINE
with_stmt -> with with_items : suite
1276
servmod
with_stmt -> with with_items : suite
1276
pass
with_stmt -> with with_items : suite
1276
del
with_stmt -> with with_items : suite
1276
not
with_stmt -> with with_items : suite
1277
:
or_test -> and_test or or_test
1277
as
or_test -> and_test or or_test
1277
,
or_test -> and_test or or_test
1277
if
or_test -> and_test or or_test
1278
^
arith_expr -> term - arith_expr
1278
!=
arith_expr -> term - arith_expr
1278
<
arith_expr -> term - arith_expr
1278
in
arith_expr -> term - arith_expr
1278
==
arith_expr -> term - arith_expr
1278
|
arith_expr -> term - arith_expr
1278
is
arith_expr -> term - arith_expr
1278
as
arith_expr -> term - arith_expr
1278
&
arith_expr -> term - arith_expr
1278
>>
arith_expr -> term - arith_expr
1278
<<
arith_expr -> term - arith_expr
1278
and
arith_expr -> term - arith_expr
1278
,
arith_expr -> term - arith_expr
1278
>
arith_expr -> term - arith_expr
1278
if
arith_expr -> term - arith_expr
1278
not
arith_expr -> term - arith_expr
1278
>=
arith_expr -> term - arith_expr
1278
<=
arith_expr -> term - arith_expr
1278
or
arith_expr -> term - arith_expr
1278
:
arith_expr -> term - arith_expr
1279
>=
arith_expr -> term + arith_expr
1279
>
arith_expr -> term + arith_expr
1279
^
arith_expr -> term + arith_expr
1279
or
arith_expr -> term + arith_expr
1279
as
arith_expr -> term + arith_expr
1279
==
arith_expr -> term + arith_expr
1279
<=
arith_expr -> term + arith_expr
1279
if
arith_expr -> term + arith_expr
1279
>>
arith_expr -> term + arith_expr
1279
<
arith_expr -> term + arith_expr
1279
not
arith_expr -> term + arith_expr
1279
&
arith_expr -> term + arith_expr
1279
in
arith_expr -> term + arith_expr
1279
and
arith_expr -> term + arith_expr
1279
,
arith_expr -> term + arith_expr
1279
|
arith_expr -> term + arith_expr
1279
!=
arith_expr -> term + arith_expr
1279
:
arith_expr -> term + arith_expr
1279
<<
arith_expr -> term + arith_expr
1279
is
arith_expr -> term + arith_expr
1280
>=
expr -> xor_expr | expr
1280
,
expr -> xor_expr | expr
1280
or
expr -> xor_expr | expr
1280
in
expr -> xor_expr | expr
1280
and
expr -> xor_expr | expr
1280
as
expr -> xor_expr | expr
1280
==
expr -> xor_expr | expr
1280
:
expr -> xor_expr | expr
1280
>
expr -> xor_expr | expr
1280
<=
expr -> xor_expr | expr
1280
is
expr -> xor_expr | expr
1280
<
expr -> xor_expr | expr
1280
if
expr -> xor_expr | expr
1280
not
expr -> xor_expr | expr
1280
!=
expr -> xor_expr | expr
1281
as
comparison -> expr comp_op comparison
1281
or
comparison -> expr comp_op comparison
1281
:
comparison -> expr comp_op comparison
1281
if
comparison -> expr comp_op comparison
1281
and
comparison -> expr comp_op comparison
1281
,
comparison -> expr comp_op comparison
1282
or
and_test -> not_test and and_test
1282
if
and_test -> not_test and and_test
1282
as
and_test -> not_test and and_test
1282
,
and_test -> not_test and and_test
1282
:
and_test -> not_test and and_test
1283
[
166
1283
factor
167
1283
True
168
1283
atom_expr
169
1283
~
170
1283
not
171
1283
and_expr
172
1283
-
173
1283
{
174
1283
shift_expr
175
1283
atom
176
1283
comparison
178
1283
(
179
1283
arith_expr
180
1283
power
181
1283
STRING
182
1283
NAME
183
1283
test
184
1283
and_test
185
1283
]
1788
1283
term
186
1283
+
187
1283
xor_expr
188
1283
NUMBER
190
1283
test_list_comp
1789
1283
False
191
1283
expr
192
1283
not_test
193
1283
None
194
1283
lambdef
195
1283
lambda
196
1283
or_test
197
1283
test_list
198
1284
}
1790
1285
&
term -> factor
1285
*
1791
1285
/
1792
1285
%
1793
1285
@
1794
1285
//
1795
1285
<<
term -> factor
1285
|
term -> factor
1285
^
term -> factor
1285
+
term -> factor
1285
:
term -> factor
1285
,
term -> factor
1285
>>
term -> factor
1285
-
term -> factor
1286
-
atom -> True
1286
<<
atom -> True
1286
+
atom -> True
1286
%
atom -> True
1286
*
atom -> True
1286
&
atom -> True
1286
^
atom -> True
1286
,
atom -> True
1286
**
atom -> True
1286
>>
atom -> True
1286
/
atom -> True
1286
[
atom -> True
1286
.
atom -> True
1286
(
atom -> True
1286
//
atom -> True
1286
|
atom -> True
1286
@
atom -> True
1286
:
atom -> True
1287
[
1283
1287
{
1284
1287
True
1286
1287
~
1287
1287
atom
1291
1287
STRING
1292
1287
power
1293
1287
NAME
1294
1287
(
1295
1287
+
1296
1287
None
1298
1287
False
1299
1287
atom_expr
1300
1287
-
1301
1287
NUMBER
1302
1287
factor
1796
1288
,
xor_expr -> and_expr
1288
^
1797
1288
:
xor_expr -> and_expr
1288
|
xor_expr -> and_expr
1289
<<
1798
1289
>>
1799
1289
:
shift_expr -> arith_expr
1289
&
shift_expr -> arith_expr
1289
|
shift_expr -> arith_expr
1289
^
shift_expr -> arith_expr
1289
,
shift_expr -> arith_expr
1290
&
1800
1290
^
and_expr -> shift_expr
1290
|
and_expr -> shift_expr
1290
:
and_expr -> shift_expr
1290
,
and_expr -> shift_expr
1291
>>
trailer_expr -> 
1291
(
1801
1291
[
1802
1291
trailer
1803
1291
.
1804
1291
trailer_expr
1805
1291
+
trailer_expr -> 
1291
<<
trailer_expr -> 
1291
|
trailer_expr -> 
1291
:
trailer_expr -> 
1291
//
trailer_expr -> 
1291
%
trailer_expr -> 
1291
,
trailer_expr -> 
1291
&
trailer_expr -> 
1291
/
trailer_expr -> 
1291
@
trailer_expr -> 
1291
**
trailer_expr -> 
1291
-
trailer_expr -> 
1291
^
trailer_expr -> 
1291
*
trailer_expr -> 
1292
|
atom -> STRING
1292
(
atom -> STRING
1292
%
atom -> STRING
1292
//
atom -> STRING
1292
[
atom -> STRING
1292
/
atom -> STRING
1292
-
atom -> STRING
1292
**
atom -> STRING
1292
^
atom -> STRING
1292
@
atom -> STRING
1292
,
atom -> STRING
1292
&
atom -> STRING
1292
:
atom -> STRING
1292
<<
atom -> STRING
1292
.
atom -> STRING
1292
+
atom -> STRING
1292
>>
atom -> STRING
1292
*
atom -> STRING
1293
+
factor -> power
1293
%
factor -> power
1293
*
factor -> power
1293
-
factor -> power
1293
//
factor -> power
1293
:
factor -> power
1293
/
factor -> power
1293
^
factor -> power
1293
,
factor -> power
1293
>>
factor -> power
1293
&
factor -> power
1293
<<
factor -> power
1293
@
factor -> power
1293
|
factor -> power
1294
&
atom -> NAME
1294
*
atom -> NAME
1294
//
atom -> NAME
1294
,
atom -> NAME
1294
[
atom -> NAME
1294
/
atom -> NAME
1294
>>
atom -> NAME
1294
%
atom -> NAME
1294
.
atom -> NAME
1294
^
atom -> NAME
1294
(
atom -> NAME
1294
**
atom -> NAME
1294
+
atom -> NAME
1294
@
atom -> NAME
1294
-
atom -> NAME
1294
<<
atom -> NAME
1294
|
atom -> NAME
1294
:
atom -> NAME
1295
[
128
1295
factor
129
1295
True
130
1295
atom_expr
131
1295
~
132
1295
and_expr
133
1295
-
134
1295
{
135
1295
test_list_comp
1806
1295
shift_expr
137
1295
atom
138
1295
)
1807
1295
comparison
140
1295
arith_expr
141
1295
power
142
1295
STRING
143
1295
NAME
144
1295
(
145
1295
and_test
146
1295
term
147
1295
+
148
1295
xor_expr
149
1295
or_test
150
1295
NUMBER
151
1295
not
152
1295
False
153
1295
expr
154
1295
not_test
155
1295
None
156
1295
lambdef
157
1295
lambda
158
1295
test
159
1295
test_list
160
1296
[
1283
1296
{
1284
1296
True
1286
1296
~
1287
1296
atom
1291
1296
STRING
1292
1296
power
1293
1296
NAME
1294
1296
(
1295
1296
+
1296
1296
None
1298
1296
factor
1808
1296
False
1299
1296
atom_expr
1300
1296
-
1301
1296
NUMBER
1302
1297
-
1809
1297
+
1810
1297
|
arith_expr -> term
1297
,
arith_expr -> term
1297
>>
arith_expr -> term
1297
:
arith_expr -> term
1297
<<
arith_expr -> term
1297
^
arith_expr -> term
1297
&
arith_expr -> term
1298
(
atom -> None
1298
[
atom -> None
1298
%
atom -> None
1298
+
atom -> None
1298
*
atom -> None
1298
.
atom -> None
1298
//
atom -> None
1298
@
atom -> None
1298
&
atom -> None
1298
>>
atom -> None
1298
/
atom -> None
1298
,
atom -> None
1298
-
atom -> None
1298
<<
atom -> None
1298
**
atom -> None
1298
:
atom -> None
1298
|
atom -> None
1298
^
atom -> None
1299
|
atom -> False
1299
,
atom -> False
1299
[
atom -> False
1299
(
atom -> False
1299
<<
atom -> False
1299
@
atom -> False
1299
*
atom -> False
1299
-
atom -> False
1299
&
atom -> False
1299
.
atom -> False
1299
//
atom -> False
1299
+
atom -> False
1299
^
atom -> False
1299
/
atom -> False
1299
**
atom -> False
1299
:
atom -> False
1299
>>
atom -> False
1299
%
atom -> False
1300
**
1811
1300
,
power -> atom_expr
1300
-
power -> atom_expr
1300
<<
power -> atom_expr
1300
:
power -> atom_expr
1300
/
power -> atom_expr
1300
%
power -> atom_expr
1300
@
power -> atom_expr
1300
|
power -> atom_expr
1300
>>
power -> atom_expr
1300
^
power -> atom_expr
1300
*
power -> atom_expr
1300
&
power -> atom_expr
1300
+
power -> atom_expr
1300
//
power -> atom_expr
1301
[
1283
1301
{
1284
1301
True
1286
1301
~
1287
1301
atom
1291
1301
factor
1812
1301
STRING
1292
1301
power
1293
1301
NAME
1294
1301
(
1295
1301
+
1296
1301
None
1298
1301
False
1299
1301
atom_expr
1300
1301
-
1301
1301
NUMBER
1302
1302
.
atom -> NUMBER
1302
+
atom -> NUMBER
1302
//
atom -> NUMBER
1302
*
atom -> NUMBER
1302
>>
atom -> NUMBER
1302
,
atom -> NUMBER
1302
[
atom -> NUMBER
1302
<<
atom -> NUMBER
1302
/
atom -> NUMBER
1302
-
atom -> NUMBER
1302
**
atom -> NUMBER
1302
(
atom -> NUMBER
1302
@
atom -> NUMBER
1302
%
atom -> NUMBER
1302
|
atom -> NUMBER
1302
&
atom -> NUMBER
1302
^
atom -> NUMBER
1302
:
atom -> NUMBER
1303
|
1813
1303
,
expr -> xor_expr
1303
:
expr -> xor_expr
1304
,
with_item -> test as expr
1304
:
with_item -> test as expr
1305
:
with_items -> with_item , with_items
1306
,
lambdef -> lambda : test
1306
as
lambdef -> lambda : test
1306
:
lambdef -> lambda : test
1307
[
283
1307
factor
284
1307
True
285
1307
atom_expr
286
1307
~
287
1307
and_expr
288
1307
-
289
1307
shift_expr
290
1307
atom
291
1307
{
292
1307
comparison
293
1307
or_test
294
1307
arith_expr
295
1307
power
296
1307
STRING
297
1307
NAME
298
1307
(
299
1307
and_test
301
1307
term
302
1307
+
303
1307
xor_expr
304
1307
NUMBER
305
1307
not
306
1307
False
307
1307
expr
308
1307
not_test
309
1307
None
310
1307
lambdef
311
1307
lambda
314
1307
test
1814
1308
NEWLINE
1815
1309
modopt
suite -> simple_stmt
1309
~
suite -> simple_stmt
1309
False
suite -> simple_stmt
1309
@
suite -> simple_stmt
1309
begsim
suite -> simple_stmt
1309
NUMBER
suite -> simple_stmt
1309
elif
suite -> simple_stmt
1309
conf
suite -> simple_stmt
1309
class
suite -> simple_stmt
1309
if
suite -> simple_stmt
1309
yield
suite -> simple_stmt
1309
try
suite -> simple_stmt
1309
else
suite -> simple_stmt
1309
pass
suite -> simple_stmt
1309
NEWLINE
suite -> simple_stmt
1309
[
suite -> simple_stmt
1309
break
suite -> simple_stmt
1309
True
suite -> simple_stmt
1309
None
suite -> simple_stmt
1309
server
suite -> simple_stmt
1309
assert
suite -> simple_stmt
1309
$
suite -> simple_stmt
1309
servmod
suite -> simple_stmt
1309
raise
suite -> simple_stmt
1309
nonlocal
suite -> simple_stmt
1309
lambda
suite -> simple_stmt
1309
return
suite -> simple_stmt
1309
+
suite -> simple_stmt
1309
-
suite -> simple_stmt
1309
NAME
suite -> simple_stmt
1309
while
suite -> simple_stmt
1309
def
suite -> simple_stmt
1309
with
suite -> simple_stmt
1309
del
suite -> simple_stmt
1309
STRING
suite -> simple_stmt
1309
for
suite -> simple_stmt
1309
resetstats
suite -> simple_stmt
1309
global
suite -> simple_stmt
1309
continue
suite -> simple_stmt
1309
endsim
suite -> simple_stmt
1309
not
suite -> simple_stmt
1309
{
suite -> simple_stmt
1309
(
suite -> simple_stmt
1310
elif_clause
1816
1310
elif
1817
1310
del
elif_clause -> 
1310
NEWLINE
elif_clause -> 
1310
class
elif_clause -> 
1310
resetstats
elif_clause -> 
1310
+
elif_clause -> 
1310
break
elif_clause -> 
1310
if
elif_clause -> 
1310
[
elif_clause -> 
1310
endsim
elif_clause -> 
1310
for
elif_clause -> 
1310
begsim
elif_clause -> 
1310
try
elif_clause -> 
1310
lambda
elif_clause -> 
1310
@
elif_clause -> 
1310
with
elif_clause -> 
1310
-
elif_clause -> 
1310
(
elif_clause -> 
1310
True
elif_clause -> 
1310
STRING
elif_clause -> 
1310
NUMBER
elif_clause -> 
1310
def
elif_clause -> 
1310
global
elif_clause -> 
1310
nonlocal
elif_clause -> 
1310
{
elif_clause -> 
1310
continue
elif_clause -> 
1310
modopt
elif_clause -> 
1310
pass
elif_clause -> 
1310
None
elif_clause -> 
1310
return
elif_clause -> 
1310
$
elif_clause -> 
1310
~
elif_clause -> 
1310
servmod
elif_clause -> 
1310
else
elif_clause -> 
1310
not
elif_clause -> 
1310
conf
elif_clause -> 
1310
raise
elif_clause -> 
1310
yield
elif_clause -> 
1310
False
elif_clause -> 
1310
server
elif_clause -> 
1310
assert
elif_clause -> 
1310
while
elif_clause -> 
1310
NAME
elif_clause -> 
1311
INDENT
1818
1312
!=
atom -> [ ]
1312
>>
atom -> [ ]
1312
|
atom -> [ ]
1312
<<
atom -> [ ]
1312
>
atom -> [ ]
1312
.
atom -> [ ]
1312
%
atom -> [ ]
1312
^
atom -> [ ]
1312
-
atom -> [ ]
1312
in
atom -> [ ]
1312
or
atom -> [ ]
1312
/
atom -> [ ]
1312
**
atom -> [ ]
1312
//
atom -> [ ]
1312
not
atom -> [ ]
1312
(
atom -> [ ]
1312
else
atom -> [ ]
1312
+
atom -> [ ]
1312
and
atom -> [ ]
1312
==
atom -> [ ]
1312
[
atom -> [ ]
1312
<
atom -> [ ]
1312
<=
atom -> [ ]
1312
>=
atom -> [ ]
1312
is
atom -> [ ]
1312
*
atom -> [ ]
1312
@
atom -> [ ]
1312
&
atom -> [ ]
1313
]
1819
1314
arith_expr
1
1314
factor
17
1314
True
38
1314
atom_expr
31
1314
term
22
1314
-
26
1314
None
55
1314
atom
57
1314
test
1820
1314
comparison
49
1314
and_expr
8
1314
power
9
1314
STRING
10
1314
NAME
52
1314
shift_expr
48
1314
lambdef
15
1314
NUMBER
58
1314
(
16
1314
expr
47
1314
[
18
1314
not_test
32
1314
{
21
1314
and_test
46
1314
+
27
1314
lambda
29
1314
xor_expr
41
1314
not
62
1314
~
37
1314
or_test
53
1314
False
39
1315
term
1821
1315
[
738
1315
factor
740
1315
True
741
1315
~
742
1315
-
744
1315
atom
745
1315
{
746
1315
power
748
1315
atom_expr
749
1315
STRING
750
1315
NAME
751
1315
(
752
1315
+
754
1315
NUMBER
757
1315
False
759
1315
None
762
1316
[
738
1316
factor
740
1316
True
741
1316
term
1822
1316
~
742
1316
-
744
1316
atom
745
1316
{
746
1316
power
748
1316
atom_expr
749
1316
STRING
750
1316
NAME
751
1316
(
752
1316
+
754
1316
NUMBER
757
1316
False
759
1316
None
762
1317
[
738
1317
factor
740
1317
True
741
1317
~
742
1317
-
744
1317
atom
745
1317
{
746
1317
power
748
1317
atom_expr
749
1317
STRING
750
1317
NAME
751
1317
(
752
1317
term
1823
1317
+
754
1317
NUMBER
757
1317
False
759
1317
None
762
1318
[
738
1318
factor
740
1318
True
741
1318
~
742
1318
-
744
1318
atom
745
1318
{
746
1318
power
748
1318
atom_expr
749
1318
STRING
750
1318
NAME
751
1318
(
752
1318
term
1824
1318
+
754
1318
NUMBER
757
1318
False
759
1318
None
762
1319
[
738
1319
factor
740
1319
True
741
1319
~
742
1319
-
744
1319
atom
745
1319
{
746
1319
power
748
1319
atom_expr
749
1319
STRING
750
1319
NAME
751
1319
term
1825
1319
(
752
1319
+
754
1319
NUMBER
757
1319
False
759
1319
None
762
1320
@
factor -> ~ factor
1320
else
factor -> ~ factor
1320
>>
factor -> ~ factor
1320
<=
factor -> ~ factor
1320
and
factor -> ~ factor
1320
+
factor -> ~ factor
1320
*
factor -> ~ factor
1320
!=
factor -> ~ factor
1320
%
factor -> ~ factor
1320
<<
factor -> ~ factor
1320
>=
factor -> ~ factor
1320
&
factor -> ~ factor
1320
is
factor -> ~ factor
1320
==
factor -> ~ factor
1320
//
factor -> ~ factor
1320
<
factor -> ~ factor
1320
/
factor -> ~ factor
1320
not
factor -> ~ factor
1320
-
factor -> ~ factor
1320
or
factor -> ~ factor
1320
|
factor -> ~ factor
1320
>
factor -> ~ factor
1320
^
factor -> ~ factor
1320
in
factor -> ~ factor
1321
[
738
1321
factor
740
1321
True
741
1321
~
742
1321
and_expr
743
1321
-
744
1321
atom
745
1321
{
746
1321
arith_expr
747
1321
power
748
1321
atom_expr
749
1321
STRING
750
1321
NAME
751
1321
(
752
1321
term
753
1321
+
754
1321
xor_expr
1826
1321
shift_expr
756
1321
NUMBER
757
1321
False
759
1321
None
762
1322
@
factor -> - factor
1322
<=
factor -> - factor
1322
in
factor -> - factor
1322
>>
factor -> - factor
1322
is
factor -> - factor
1322
|
factor -> - factor
1322
+
factor -> - factor
1322
%
factor -> - factor
1322
<
factor -> - factor
1322
*
factor -> - factor
1322
<<
factor -> - factor
1322
-
factor -> - factor
1322
>=
factor -> - factor
1322
not
factor -> - factor
1322
and
factor -> - factor
1322
/
factor -> - factor
1322
or
factor -> - factor
1322
^
factor -> - factor
1322
else
factor -> - factor
1322
>
factor -> - factor
1322
!=
factor -> - factor
1322
&
factor -> - factor
1322
==
factor -> - factor
1322
//
factor -> - factor
1323
[
766
1323
factor
767
1323
True
768
1323
atom_expr
769
1323
~
770
1323
and_expr
771
1323
-
772
1323
{
773
1323
shift_expr
774
1323
atom
775
1323
comparison
776
1323
and_test
777
1323
arith_expr
778
1323
power
779
1323
STRING
780
1323
NAME
781
1323
(
782
1323
term
784
1323
+
785
1323
xor_expr
786
1323
)
1827
1323
or_test
788
1323
arglist
1828
1323
NUMBER
789
1323
not
790
1323
False
791
1323
expr
792
1323
*
793
1323
not_test
794
1323
None
795
1323
lambdef
796
1323
lambda
797
1323
test
798
1323
argument
799
1323
**
800
1324
trailer_expr
1829
1324
>>
trailer_expr -> 
1324
(
1323
1324
trailer
1324
1324
.
1326
1324
+
trailer_expr -> 
1324
[
1327
1324
is
trailer_expr -> 
1324
>
trailer_expr -> 
1324
not
trailer_expr -> 
1324
|
trailer_expr -> 
1324
&
trailer_expr -> 
1324
/
trailer_expr -> 
1324
@
trailer_expr -> 
1324
!=
trailer_expr -> 
1324
**
trailer_expr -> 
1324
>=
trailer_expr -> 
1324
^
trailer_expr -> 
1324
in
trailer_expr -> 
1324
<<
trailer_expr -> 
1324
and
trailer_expr -> 
1324
or
trailer_expr -> 
1324
//
trailer_expr -> 
1324
%
trailer_expr -> 
1324
<=
trailer_expr -> 
1324
<
trailer_expr -> 
1324
==
trailer_expr -> 
1324
-
trailer_expr -> 
1324
else
trailer_expr -> 
1324
*
trailer_expr -> 
1325
^
atom_expr -> atom trailer_expr
1325
or
atom_expr -> atom trailer_expr
1325
&
atom_expr -> atom trailer_expr
1325
@
atom_expr -> atom trailer_expr
1325
|
atom_expr -> atom trailer_expr
1325
-
atom_expr -> atom trailer_expr
1325
*
atom_expr -> atom trailer_expr
1325
%
atom_expr -> atom trailer_expr
1325
==
atom_expr -> atom trailer_expr
1325
**
atom_expr -> atom trailer_expr
1325
and
atom_expr -> atom trailer_expr
1325
is
atom_expr -> atom trailer_expr
1325
in
atom_expr -> atom trailer_expr
1325
<<
atom_expr -> atom trailer_expr
1325
!=
atom_expr -> atom trailer_expr
1325
<=
atom_expr -> atom trailer_expr
1325
/
atom_expr -> atom trailer_expr
1325
//
atom_expr -> atom trailer_expr
1325
<
atom_expr -> atom trailer_expr
1325
>=
atom_expr -> atom trailer_expr
1325
>>
atom_expr -> atom trailer_expr
1325
not
atom_expr -> atom trailer_expr
1325
+
atom_expr -> atom trailer_expr
1325
else
atom_expr -> atom trailer_expr
1325
>
atom_expr -> atom trailer_expr
1326
NAME
1830
1327
[
802
1327
factor
803
1327
True
804
1327
atom_expr
810
1327
~
806
1327
not
807
1327
and_expr
808
1327
-
809
1327
shift_expr
811
1327
atom
812
1327
{
813
1327
comparison
814
1327
or_test
815
1327
(
816
1327
arith_expr
817
1327
power
818
1327
STRING
819
1327
NAME
820
1327
and_test
821
1327
term
822
1327
+
823
1327
xor_expr
824
1327
subscriptlist
1831
1327
test
825
1327
NUMBER
826
1327
False
827
1327
subscript
828
1327
expr
829
1327
not_test
830
1327
None
831
1327
lambdef
832
1327
lambda
833
1327
maybe_test
834
1327
:
maybe_test -> 
1328
in
atom -> { }
1328
<=
atom -> { }
1328
*
atom -> { }
1328
>
atom -> { }
1328
+
atom -> { }
1328
@
atom -> { }
1328
>=
atom -> { }
1328
else
atom -> { }
1328
/
atom -> { }
1328
|
atom -> { }
1328
is
atom -> { }
1328
and
atom -> { }
1328
(
atom -> { }
1328
>>
atom -> { }
1328
not
atom -> { }
1328
-
atom -> { }
1328
<<
atom -> { }
1328
**
atom -> { }
1328
or
atom -> { }
1328
<
atom -> { }
1328
!=
atom -> { }
1328
==
atom -> { }
1328
%
atom -> { }
1328
//
atom -> { }
1328
&
atom -> { }
1328
[
atom -> { }
1328
.
atom -> { }
1328
^
atom -> { }
1329
[
738
1329
factor
740
1329
True
741
1329
~
742
1329
-
744
1329
atom
745
1329
{
746
1329
arith_expr
747
1329
power
748
1329
atom_expr
749
1329
STRING
750
1329
NAME
751
1329
shift_expr
1832
1329
(
752
1329
term
753
1329
+
754
1329
NUMBER
757
1329
False
759
1329
None
762
1330
[
738
1330
factor
740
1330
True
741
1330
~
742
1330
-
744
1330
atom
745
1330
{
746
1330
arith_expr
747
1330
power
748
1330
atom_expr
749
1330
STRING
750
1330
NAME
751
1330
(
752
1330
term
753
1330
+
754
1330
NUMBER
757
1330
False
759
1330
shift_expr
1833
1330
None
762
1331
[
738
1331
{
746
1331
+
754
1331
True
741
1331
-
744
1331
~
742
1331
atom
745
1331
STRING
750
1331
power
748
1331
atom_expr
749
1331
NAME
751
1331
(
752
1331
factor
1834
1331
None
762
1331
False
759
1331
NUMBER
757
1332
)
1835
1333
or
atom -> ( )
1333
>>
atom -> ( )
1333
(
atom -> ( )
1333
<=
atom -> ( )
1333
.
atom -> ( )
1333
is
atom -> ( )
1333
@
atom -> ( )
1333
%
atom -> ( )
1333
<<
atom -> ( )
1333
**
atom -> ( )
1333
^
atom -> ( )
1333
/
atom -> ( )
1333
not
atom -> ( )
1333
*
atom -> ( )
1333
!=
atom -> ( )
1333
<
atom -> ( )
1333
&
atom -> ( )
1333
-
atom -> ( )
1333
>
atom -> ( )
1333
//
atom -> ( )
1333
==
atom -> ( )
1333
else
atom -> ( )
1333
in
atom -> ( )
1333
+
atom -> ( )
1333
[
atom -> ( )
1333
>=
atom -> ( )
1333
and
atom -> ( )
1333
|
atom -> ( )
1334
[
738
1334
factor
740
1334
True
741
1334
~
742
1334
-
744
1334
atom
745
1334
{
746
1334
arith_expr
1836
1334
power
748
1334
atom_expr
749
1334
STRING
750
1334
NAME
751
1334
(
752
1334
term
753
1334
+
754
1334
NUMBER
757
1334
False
759
1334
None
762
1335
[
738
1335
factor
740
1335
True
741
1335
~
742
1335
-
744
1335
arith_expr
1837
1335
atom
745
1335
{
746
1335
power
748
1335
atom_expr
749
1335
STRING
750
1335
NAME
751
1335
(
752
1335
term
753
1335
+
754
1335
NUMBER
757
1335
False
759
1335
None
762
1336
-
factor -> + factor
1336
@
factor -> + factor
1336
<<
factor -> + factor
1336
is
factor -> + factor
1336
and
factor -> + factor
1336
<=
factor -> + factor
1336
or
factor -> + factor
1336
<
factor -> + factor
1336
^
factor -> + factor
1336
not
factor -> + factor
1336
//
factor -> + factor
1336
else
factor -> + factor
1336
*
factor -> + factor
1336
in
factor -> + factor
1336
&
factor -> + factor
1336
+
factor -> + factor
1336
>>
factor -> + factor
1336
|
factor -> + factor
1336
%
factor -> + factor
1336
>
factor -> + factor
1336
>=
factor -> + factor
1336
!=
factor -> + factor
1336
/
factor -> + factor
1336
==
factor -> + factor
1337
[
738
1337
factor
740
1337
True
741
1337
~
742
1337
and_expr
743
1337
-
744
1337
atom
745
1337
{
746
1337
expr
1838
1337
arith_expr
747
1337
power
748
1337
atom_expr
749
1337
STRING
750
1337
NAME
751
1337
(
752
1337
term
753
1337
+
754
1337
xor_expr
755
1337
shift_expr
756
1337
NUMBER
757
1337
False
759
1337
None
762
1338
[
738
1338
factor
740
1338
True
741
1338
~
742
1338
-
744
1338
atom
745
1338
{
746
1338
arith_expr
747
1338
power
748
1338
atom_expr
749
1338
STRING
750
1338
NAME
751
1338
(
752
1338
term
753
1338
+
754
1338
and_expr
1839
1338
shift_expr
756
1338
NUMBER
757
1338
False
759
1338
None
762
1339
and
not_test -> not not_test
1339
else
not_test -> not not_test
1339
or
not_test -> not not_test
1340
[
738
1340
factor
740
1340
True
741
1340
~
742
1340
and_expr
743
1340
-
744
1340
atom
745
1340
{
746
1340
arith_expr
747
1340
power
748
1340
atom_expr
749
1340
STRING
750
1340
NAME
751
1340
(
752
1340
term
753
1340
+
754
1340
xor_expr
755
1340
shift_expr
756
1340
NUMBER
757
1340
not
758
1340
False
759
1340
comparison
760
1340
not_test
761
1340
and_test
1840
1340
None
762
1340
expr
763
1341
[
738
1341
factor
740
1341
True
741
1341
~
742
1341
and_expr
743
1341
-
744
1341
atom
745
1341
{
746
1341
arith_expr
747
1341
power
748
1341
atom_expr
749
1341
STRING
750
1341
NAME
751
1341
(
752
1341
term
753
1341
+
754
1341
xor_expr
755
1341
shift_expr
756
1341
NUMBER
757
1341
False
759
1341
None
762
1341
expr
763
1341
comparison
1841
1342
[
738
1342
factor
740
1342
True
741
1342
~
742
1342
and_expr
743
1342
-
744
1342
atom
745
1342
{
746
1342
arith_expr
747
1342
power
748
1342
atom_expr
749
1342
STRING
750
1342
NAME
751
1342
(
752
1342
term
753
1342
+
754
1342
xor_expr
755
1342
shift_expr
756
1342
NUMBER
757
1342
not
758
1342
False
759
1342
comparison
760
1342
not_test
761
1342
None
762
1342
expr
763
1342
or_test
1842
1342
and_test
764
1343
!=
atom -> [ ]
1343
>>
atom -> [ ]
1343
|
atom -> [ ]
1343
<<
atom -> [ ]
1343
>
atom -> [ ]
1343
.
atom -> [ ]
1343
%
atom -> [ ]
1343
^
atom -> [ ]
1343
=
atom -> [ ]
1343
-
atom -> [ ]
1343
,
atom -> [ ]
1343
in
atom -> [ ]
1343
or
atom -> [ ]
1343
/
atom -> [ ]
1343
**
atom -> [ ]
1343
//
atom -> [ ]
1343
for
atom -> [ ]
1343
not
atom -> [ ]
1343
(
atom -> [ ]
1343
)
atom -> [ ]
1343
+
atom -> [ ]
1343
and
atom -> [ ]
1343
==
atom -> [ ]
1343
[
atom -> [ ]
1343
if
atom -> [ ]
1343
<
atom -> [ ]
1343
<=
atom -> [ ]
1343
>=
atom -> [ ]
1343
is
atom -> [ ]
1343
*
atom -> [ ]
1343
@
atom -> [ ]
1343
&
atom -> [ ]
1344
]
1843
1345
term
1844
1345
[
766
1345
factor
767
1345
True
768
1345
atom_expr
769
1345
~
770
1345
-
772
1345
{
773
1345
atom
775
1345
power
779
1345
STRING
780
1345
NAME
781
1345
(
782
1345
+
785
1345
NUMBER
789
1345
False
791
1345
None
795
1346
[
766
1346
factor
767
1346
True
768
1346
term
1845
1346
~
770
1346
-
772
1346
atom_expr
769
1346
{
773
1346
atom
775
1346
power
779
1346
STRING
780
1346
NAME
781
1346
(
782
1346
+
785
1346
NUMBER
789
1346
False
791
1346
None
795
1347
[
766
1347
factor
767
1347
True
768
1347
atom_expr
769
1347
~
770
1347
-
772
1347
{
773
1347
atom
775
1347
power
779
1347
STRING
780
1347
NAME
781
1347
(
782
1347
term
1846
1347
+
785
1347
NUMBER
789
1347
False
791
1347
None
795
1348
[
766
1348
factor
767
1348
True
768
1348
atom_expr
769
1348
~
770
1348
-
772
1348
{
773
1348
atom
775
1348
power
779
1348
STRING
780
1348
NAME
781
1348
(
782
1348
term
1847
1348
+
785
1348
NUMBER
789
1348
False
791
1348
None
795
1349
[
766
1349
factor
767
1349
True
768
1349
atom_expr
769
1349
~
770
1349
-
772
1349
{
773
1349
atom
775
1349
power
779
1349
STRING
780
1349
NAME
781
1349
term
1848
1349
(
782
1349
+
785
1349
NUMBER
789
1349
False
791
1349
None
795
1350
[
766
1350
True
768
1350
atom_expr
769
1350
-
772
1350
~
770
1350
{
773
1350
atom
775
1350
power
779
1350
STRING
780
1350
NAME
781
1350
(
782
1350
+
785
1350
NUMBER
789
1350
False
791
1350
factor
1849
1350
None
795
1351
@
factor -> ~ factor
1351
>>
factor -> ~ factor
1351
)
factor -> ~ factor
1351
<=
factor -> ~ factor
1351
and
factor -> ~ factor
1351
+
factor -> ~ factor
1351
*
factor -> ~ factor
1351
!=
factor -> ~ factor
1351
for
factor -> ~ factor
1351
%
factor -> ~ factor
1351
<<
factor -> ~ factor
1351
>=
factor -> ~ factor
1351
=
factor -> ~ factor
1351
,
factor -> ~ factor
1351
&
factor -> ~ factor
1351
is
factor -> ~ factor
1351
==
factor -> ~ factor
1351
//
factor -> ~ factor
1351
<
factor -> ~ factor
1351
/
factor -> ~ factor
1351
not
factor -> ~ factor
1351
-
factor -> ~ factor
1351
or
factor -> ~ factor
1351
|
factor -> ~ factor
1351
>
factor -> ~ factor
1351
^
factor -> ~ factor
1351
if
factor -> ~ factor
1351
in
factor -> ~ factor
1352
[
766
1352
factor
767
1352
True
768
1352
atom_expr
769
1352
~
770
1352
and_expr
771
1352
-
772
1352
{
773
1352
shift_expr
774
1352
atom
775
1352
xor_expr
1850
1352
arith_expr
778
1352
power
779
1352
STRING
780
1352
NAME
781
1352
(
782
1352
term
784
1352
+
785
1352
NUMBER
789
1352
False
791
1352
None
795
1353
@
factor -> - factor
1353
=
factor -> - factor
1353
<=
factor -> - factor
1353
in
factor -> - factor
1353
>>
factor -> - factor
1353
|
factor -> - factor
1353
is
factor -> - factor
1353
+
factor -> - factor
1353
%
factor -> - factor
1353
<
factor -> - factor
1353
*
factor -> - factor
1353
<<
factor -> - factor
1353
if
factor -> - factor
1353
for
factor -> - factor
1353
-
factor -> - factor
1353
>=
factor -> - factor
1353
not
factor -> - factor
1353
and
factor -> - factor
1353
/
factor -> - factor
1353
or
factor -> - factor
1353
^
factor -> - factor
1353
)
factor -> - factor
1353
>
factor -> - factor
1353
!=
factor -> - factor
1353
&
factor -> - factor
1353
==
factor -> - factor
1353
//
factor -> - factor
1353
,
factor -> - factor
1354
in
atom -> { }
1354
<=
atom -> { }
1354
*
atom -> { }
1354
>
atom -> { }
1354
+
atom -> { }
1354
@
atom -> { }
1354
,
atom -> { }
1354
>=
atom -> { }
1354
/
atom -> { }
1354
|
atom -> { }
1354
is
atom -> { }
1354
and
atom -> { }
1354
=
atom -> { }
1354
if
atom -> { }
1354
(
atom -> { }
1354
>>
atom -> { }
1354
not
atom -> { }
1354
-
atom -> { }
1354
<<
atom -> { }
1354
**
atom -> { }
1354
or
atom -> { }
1354
<
atom -> { }
1354
!=
atom -> { }
1354
==
atom -> { }
1354
for
atom -> { }
1354
//
atom -> { }
1354
%
atom -> { }
1354
)
atom -> { }
1354
&
atom -> { }
1354
[
atom -> { }
1354
.
atom -> { }
1354
^
atom -> { }
1355
[
766
1355
factor
767
1355
True
768
1355
atom_expr
769
1355
~
770
1355
-
772
1355
{
773
1355
shift_expr
774
1355
atom
775
1355
arith_expr
778
1355
power
779
1355
STRING
780
1355
NAME
781
1355
(
782
1355
term
784
1355
+
785
1355
and_expr
1851
1355
NUMBER
789
1355
False
791
1355
None
795
1356
NAME
1852
1357
[
766
1357
factor
767
1357
True
768
1357
atom_expr
769
1357
~
770
1357
and_expr
771
1357
-
772
1357
{
773
1357
shift_expr
774
1357
atom
775
1357
comparison
776
1357
and_test
777
1357
arith_expr
778
1357
power
779
1357
STRING
780
1357
NAME
781
1357
(
782
1357
term
784
1357
+
785
1357
xor_expr
786
1357
)
1853
1357
or_test
788
1357
arglist
1854
1357
NUMBER
789
1357
not
790
1357
False
791
1357
expr
792
1357
*
793
1357
not_test
794
1357
None
795
1357
lambdef
796
1357
lambda
797
1357
test
798
1357
argument
799
1357
**
800
1358
trailer_expr
1855
1358
>>
trailer_expr -> 
1358
.
1356
1358
(
1357
1358
)
trailer_expr -> 
1358
trailer
1358
1358
+
trailer_expr -> 
1358
[
1360
1358
is
trailer_expr -> 
1358
>
trailer_expr -> 
1358
not
trailer_expr -> 
1358
|
trailer_expr -> 
1358
=
trailer_expr -> 
1358
&
trailer_expr -> 
1358
/
trailer_expr -> 
1358
@
trailer_expr -> 
1358
!=
trailer_expr -> 
1358
**
trailer_expr -> 
1358
>=
trailer_expr -> 
1358
^
trailer_expr -> 
1358
in
trailer_expr -> 
1358
<<
trailer_expr -> 
1358
and
trailer_expr -> 
1358
or
trailer_expr -> 
1358
if
trailer_expr -> 
1358
//
trailer_expr -> 
1358
%
trailer_expr -> 
1358
,
trailer_expr -> 
1358
<=
trailer_expr -> 
1358
<
trailer_expr -> 
1358
==
trailer_expr -> 
1358
for
trailer_expr -> 
1358
-
trailer_expr -> 
1358
*
trailer_expr -> 
1359
^
atom_expr -> atom trailer_expr
1359
or
atom_expr -> atom trailer_expr
1359
=
atom_expr -> atom trailer_expr
1359
&
atom_expr -> atom trailer_expr
1359
@
atom_expr -> atom trailer_expr
1359
|
atom_expr -> atom trailer_expr
1359
-
atom_expr -> atom trailer_expr
1359
*
atom_expr -> atom trailer_expr
1359
%
atom_expr -> atom trailer_expr
1359
==
atom_expr -> atom trailer_expr
1359
**
atom_expr -> atom trailer_expr
1359
and
atom_expr -> atom trailer_expr
1359
is
atom_expr -> atom trailer_expr
1359
in
atom_expr -> atom trailer_expr
1359
<<
atom_expr -> atom trailer_expr
1359
!=
atom_expr -> atom trailer_expr
1359
<=
atom_expr -> atom trailer_expr
1359
/
atom_expr -> atom trailer_expr
1359
)
atom_expr -> atom trailer_expr
1359
//
atom_expr -> atom trailer_expr
1359
<
atom_expr -> atom trailer_expr
1359
>=
atom_expr -> atom trailer_expr
1359
>>
atom_expr -> atom trailer_expr
1359
if
atom_expr -> atom trailer_expr
1359
not
atom_expr -> atom trailer_expr
1359
for
atom_expr -> atom trailer_expr
1359
+
atom_expr -> atom trailer_expr
1359
>
atom_expr -> atom trailer_expr
1359
,
atom_expr -> atom trailer_expr
1360
[
802
1360
factor
803
1360
True
804
1360
atom_expr
810
1360
~
806
1360
not
807
1360
and_expr
808
1360
-
809
1360
shift_expr
811
1360
atom
812
1360
{
813
1360
comparison
814
1360
or_test
815
1360
(
816
1360
arith_expr
817
1360
power
818
1360
STRING
819
1360
NAME
820
1360
and_test
821
1360
subscriptlist
1856
1360
term
822
1360
+
823
1360
xor_expr
824
1360
test
825
1360
NUMBER
826
1360
False
827
1360
subscript
828
1360
expr
829
1360
not_test
830
1360
None
831
1360
lambdef
832
1360
lambda
833
1360
maybe_test
834
1360
:
maybe_test -> 
1361
[
766
1361
factor
767
1361
True
768
1361
atom_expr
769
1361
~
770
1361
and_expr
771
1361
-
772
1361
{
773
1361
shift_expr
774
1361
atom
775
1361
comparison
776
1361
and_test
777
1361
arith_expr
778
1361
power
779
1361
STRING
780
1361
NAME
781
1361
(
782
1361
term
784
1361
+
785
1361
xor_expr
786
1361
NUMBER
789
1361
not
790
1361
False
791
1361
expr
792
1361
not_test
794
1361
None
795
1361
or_test
1857
1362
[
766
1362
factor
767
1362
True
768
1362
atom_expr
769
1362
~
770
1362
-
772
1362
{
773
1362
atom
775
1362
arith_expr
778
1362
power
779
1362
STRING
780
1362
NAME
781
1362
shift_expr
1858
1362
(
782
1362
term
784
1362
+
785
1362
NUMBER
789
1362
False
791
1362
None
795
1363
[
766
1363
factor
767
1363
True
768
1363
atom_expr
769
1363
~
770
1363
-
772
1363
{
773
1363
atom
775
1363
arith_expr
778
1363
power
779
1363
STRING
780
1363
NAME
781
1363
shift_expr
1859
1363
(
782
1363
term
784
1363
+
785
1363
NUMBER
789
1363
False
791
1363
None
795
1364
)
1860
1365
or
atom -> ( )
1365
>>
atom -> ( )
1365
(
atom -> ( )
1365
<=
atom -> ( )
1365
.
atom -> ( )
1365
is
atom -> ( )
1365
@
atom -> ( )
1365
,
atom -> ( )
1365
%
atom -> ( )
1365
<<
atom -> ( )
1365
**
atom -> ( )
1365
^
atom -> ( )
1365
/
atom -> ( )
1365
)
atom -> ( )
1365
if
atom -> ( )
1365
not
atom -> ( )
1365
=
atom -> ( )
1365
*
atom -> ( )
1365
!=
atom -> ( )
1365
for
atom -> ( )
1365
<
atom -> ( )
1365
&
atom -> ( )
1365
-
atom -> ( )
1365
>
atom -> ( )
1365
//
atom -> ( )
1365
==
atom -> ( )
1365
in
atom -> ( )
1365
+
atom -> ( )
1365
[
atom -> ( )
1365
>=
atom -> ( )
1365
and
atom -> ( )
1365
|
atom -> ( )
1366
,
trailer -> ( arglist )
1366
.
trailer -> ( arglist )
1366
|
trailer -> ( arglist )
1366
/=
trailer -> ( arglist )
1366
&=
trailer -> ( arglist )
1366
<<=
trailer -> ( arglist )
1366
==
trailer -> ( arglist )
1366
^
trailer -> ( arglist )
1366
**
trailer -> ( arglist )
1366
//=
trailer -> ( arglist )
1366
>>
trailer -> ( arglist )
1366
not
trailer -> ( arglist )
1366
^=
trailer -> ( arglist )
1366
<<
trailer -> ( arglist )
1366
>=
trailer -> ( arglist )
1366
!=
trailer -> ( arglist )
1366
in
trailer -> ( arglist )
1366
[
trailer -> ( arglist )
1366
(
trailer -> ( arglist )
1366
NEWLINE
trailer -> ( arglist )
1366
>
trailer -> ( arglist )
1366
and
trailer -> ( arglist )
1366
**=
trailer -> ( arglist )
1366
+
trailer -> ( arglist )
1366
>>=
trailer -> ( arglist )
1366
%
trailer -> ( arglist )
1366
%=
trailer -> ( arglist )
1366
or
trailer -> ( arglist )
1366
*
trailer -> ( arglist )
1366
is
trailer -> ( arglist )
1366
|=
trailer -> ( arglist )
1366
&
trailer -> ( arglist )
1366
//
trailer -> ( arglist )
1366
=
trailer -> ( arglist )
1366
@=
trailer -> ( arglist )
1366
:
trailer -> ( arglist )
1366
-
trailer -> ( arglist )
1366
<
trailer -> ( arglist )
1366
-=
trailer -> ( arglist )
1366
+=
trailer -> ( arglist )
1366
<=
trailer -> ( arglist )
1366
if
trailer -> ( arglist )
1366
/
trailer -> ( arglist )
1366
@
trailer -> ( arglist )
1366
*=
trailer -> ( arglist )
1367
[
766
1367
factor
767
1367
True
768
1367
atom_expr
769
1367
~
770
1367
-
772
1367
{
773
1367
arith_expr
1861
1367
atom
775
1367
power
779
1367
STRING
780
1367
NAME
781
1367
(
782
1367
term
784
1367
+
785
1367
NUMBER
789
1367
False
791
1367
None
795
1368
[
766
1368
factor
767
1368
True
768
1368
atom_expr
769
1368
~
770
1368
-
772
1368
{
773
1368
atom
775
1368
arith_expr
1862
1368
power
779
1368
STRING
780
1368
NAME
781
1368
(
782
1368
term
784
1368
+
785
1368
NUMBER
789
1368
False
791
1368
None
795
1369
-
factor -> + factor
1369
@
factor -> + factor
1369
<<
factor -> + factor
1369
is
factor -> + factor
1369
and
factor -> + factor
1369
<=
factor -> + factor
1369
or
factor -> + factor
1369
<
factor -> + factor
1369
^
factor -> + factor
1369
not
factor -> + factor
1369
//
factor -> + factor
1369
,
factor -> + factor
1369
for
factor -> + factor
1369
*
factor -> + factor
1369
in
factor -> + factor
1369
&
factor -> + factor
1369
+
factor -> + factor
1369
if
factor -> + factor
1369
>>
factor -> + factor
1369
)
factor -> + factor
1369
|
factor -> + factor
1369
=
factor -> + factor
1369
>
factor -> + factor
1369
%
factor -> + factor
1369
>=
factor -> + factor
1369
!=
factor -> + factor
1369
/
factor -> + factor
1369
==
factor -> + factor
1370
[
766
1370
factor
767
1370
True
768
1370
atom_expr
769
1370
~
770
1370
and_expr
771
1370
-
772
1370
{
773
1370
shift_expr
774
1370
atom
775
1370
expr
1863
1370
arith_expr
778
1370
power
779
1370
STRING
780
1370
NAME
781
1370
(
782
1370
term
784
1370
+
785
1370
xor_expr
786
1370
NUMBER
789
1370
False
791
1370
None
795
1371
[
738
1371
factor
740
1371
True
741
1371
~
742
1371
and_expr
743
1371
-
744
1371
atom
745
1371
{
746
1371
arith_expr
747
1371
power
748
1371
atom_expr
749
1371
STRING
750
1371
NAME
751
1371
(
752
1371
or_test
1864
1371
term
753
1371
+
754
1371
xor_expr
755
1371
shift_expr
756
1371
NUMBER
757
1371
not
758
1371
False
759
1371
comparison
760
1371
not_test
761
1371
None
762
1371
expr
763
1371
and_test
764
1372
,
not_test -> not not_test
1372
=
not_test -> not not_test
1372
and
not_test -> not not_test
1372
or
not_test -> not not_test
1372
for
not_test -> not not_test
1372
)
not_test -> not not_test
1372
if
not_test -> not not_test
1373
[
766
1373
factor
767
1373
True
768
1373
atom_expr
769
1373
~
770
1373
and_expr
771
1373
-
772
1373
{
773
1373
shift_expr
774
1373
atom
775
1373
arith_expr
778
1373
power
779
1373
STRING
780
1373
NAME
781
1373
(
782
1373
term
784
1373
+
785
1373
xor_expr
786
1373
NUMBER
789
1373
False
791
1373
expr
792
1373
None
795
1373
comparison
1865
1374
,
argument -> * test
1374
)
argument -> * test
1375
[
766
1375
factor
767
1375
True
768
1375
atom_expr
769
1375
~
770
1375
and_expr
771
1375
-
772
1375
{
773
1375
shift_expr
774
1375
atom
775
1375
comparison
776
1375
arith_expr
778
1375
power
779
1375
STRING
780
1375
NAME
781
1375
(
782
1375
term
784
1375
+
785
1375
xor_expr
786
1375
NUMBER
789
1375
not
790
1375
False
791
1375
expr
792
1375
and_test
1866
1375
not_test
794
1375
None
795
1376
:
1867
1377
[
766
1377
factor
767
1377
True
768
1377
atom_expr
769
1377
~
770
1377
and_expr
771
1377
-
772
1377
{
773
1377
shift_expr
774
1377
atom
775
1377
comparison
776
1377
and_test
777
1377
arith_expr
778
1377
power
779
1377
STRING
780
1377
NAME
781
1377
(
782
1377
term
784
1377
+
785
1377
xor_expr
786
1377
or_test
788
1377
NUMBER
789
1377
not
790
1377
False
791
1377
expr
792
1377
not_test
794
1377
None
795
1377
lambdef
796
1377
lambda
797
1377
test
1868
1378
)
argument -> test comp_for
1378
,
argument -> test comp_for
1379
[
1002
1379
factor
1003
1379
True
1004
1379
atom_expr
1005
1379
~
1006
1379
and_expr
1007
1379
-
1008
1379
shift_expr
1009
1379
atom
1010
1379
{
1011
1379
comparison
1012
1379
arith_expr
1013
1379
power
1014
1379
STRING
1015
1379
NAME
1016
1379
(
1017
1379
and_test
1018
1379
term
1019
1379
+
1020
1379
xor_expr
1021
1379
or_test
1022
1379
NUMBER
1023
1379
not
1024
1379
test
1869
1379
False
1025
1379
not_test
1026
1379
None
1027
1379
expr
1028
1379
lambda
1029
1379
lambdef
1031
1380
[
208
1380
{
209
1380
factor
210
1380
True
212
1380
~
213
1380
and_expr
214
1380
arith_expr
215
1380
shift_expr
216
1380
atom
217
1380
STRING
218
1380
expr_list
1870
1380
power
219
1380
NAME
220
1380
(
221
1380
+
222
1380
term
223
1380
None
224
1380
False
225
1380
atom_expr
226
1380
-
227
1380
expr
228
1380
NUMBER
229
1380
xor_expr
230
1381
[
766
1381
factor
767
1381
True
768
1381
atom_expr
769
1381
~
770
1381
and_expr
771
1381
-
772
1381
{
773
1381
shift_expr
774
1381
atom
775
1381
comparison
776
1381
and_test
777
1381
arith_expr
778
1381
power
779
1381
STRING
780
1381
NAME
781
1381
(
782
1381
term
784
1381
+
785
1381
xor_expr
786
1381
or_test
788
1381
NUMBER
789
1381
not
790
1381
False
791
1381
expr
792
1381
*
793
1381
not_test
794
1381
None
795
1381
lambdef
796
1381
lambda
797
1381
test
798
1381
argument
799
1381
**
800
1381
arglist
1871
1382
)
argument -> ** test
1382
,
argument -> ** test
1383
!=
atom -> [ ]
1383
>>
atom -> [ ]
1383
|
atom -> [ ]
1383
<<
atom -> [ ]
1383
>
atom -> [ ]
1383
.
atom -> [ ]
1383
%
atom -> [ ]
1383
^
atom -> [ ]
1383
-
atom -> [ ]
1383
,
atom -> [ ]
1383
in
atom -> [ ]
1383
:
atom -> [ ]
1383
or
atom -> [ ]
1383
/
atom -> [ ]
1383
**
atom -> [ ]
1383
//
atom -> [ ]
1383
not
atom -> [ ]
1383
(
atom -> [ ]
1383
+
atom -> [ ]
1383
and
atom -> [ ]
1383
]
atom -> [ ]
1383
==
atom -> [ ]
1383
[
atom -> [ ]
1383
if
atom -> [ ]
1383
<
atom -> [ ]
1383
<=
atom -> [ ]
1383
>=
atom -> [ ]
1383
is
atom -> [ ]
1383
*
atom -> [ ]
1383
@
atom -> [ ]
1383
&
atom -> [ ]
1384
]
1872
1385
term
1873
1385
[
802
1385
factor
803
1385
True
804
1385
atom_expr
810
1385
~
806
1385
-
809
1385
atom
812
1385
{
813
1385
(
816
1385
power
818
1385
STRING
819
1385
NAME
820
1385
+
823
1385
NUMBER
826
1385
False
827
1385
None
831
1386
[
802
1386
factor
803
1386
True
804
1386
atom_expr
810
1386
~
806
1386
-
809
1386
atom
812
1386
{
813
1386
term
1874
1386
(
816
1386
power
818
1386
STRING
819
1386
NAME
820
1386
+
823
1386
NUMBER
826
1386
False
827
1386
None
831
1387
[
802
1387
factor
803
1387
True
804
1387
term
1875
1387
~
806
1387
-
809
1387
atom_expr
810
1387
atom
812
1387
{
813
1387
(
816
1387
power
818
1387
STRING
819
1387
NAME
820
1387
+
823
1387
NUMBER
826
1387
False
827
1387
None
831
1388
[
802
1388
factor
803
1388
True
804
1388
atom_expr
810
1388
~
806
1388
-
809
1388
atom
812
1388
{
813
1388
(
816
1388
power
818
1388
STRING
819
1388
NAME
820
1388
term
1876
1388
+
823
1388
NUMBER
826
1388
False
827
1388
None
831
1389
[
802
1389
factor
803
1389
True
804
1389
atom_expr
810
1389
~
806
1389
-
809
1389
atom
812
1389
{
813
1389
(
816
1389
power
818
1389
STRING
819
1389
NAME
820
1389
term
1877
1389
+
823
1389
NUMBER
826
1389
False
827
1389
None
831
1390
-=
trailer -> [ subscriptlist ]
1390
<=
trailer -> [ subscriptlist ]
1390
NEWLINE
trailer -> [ subscriptlist ]
1390
<<
trailer -> [ subscriptlist ]
1390
|=
trailer -> [ subscriptlist ]
1390
:
trailer -> [ subscriptlist ]
1390
*
trailer -> [ subscriptlist ]
1390
+
trailer -> [ subscriptlist ]
1390
>>
trailer -> [ subscriptlist ]
1390
in
trailer -> [ subscriptlist ]
1390
//
trailer -> [ subscriptlist ]
1390
*=
trailer -> [ subscriptlist ]
1390
@=
trailer -> [ subscriptlist ]
1390
.
trailer -> [ subscriptlist ]
1390
&=
trailer -> [ subscriptlist ]
1390
,
trailer -> [ subscriptlist ]
1390
//=
trailer -> [ subscriptlist ]
1390
^=
trailer -> [ subscriptlist ]
1390
and
trailer -> [ subscriptlist ]
1390
**
trailer -> [ subscriptlist ]
1390
=
trailer -> [ subscriptlist ]
1390
@
trailer -> [ subscriptlist ]
1390
<
trailer -> [ subscriptlist ]
1390
not
trailer -> [ subscriptlist ]
1390
-
trailer -> [ subscriptlist ]
1390
%=
trailer -> [ subscriptlist ]
1390
!=
trailer -> [ subscriptlist ]
1390
>>=
trailer -> [ subscriptlist ]
1390
%
trailer -> [ subscriptlist ]
1390
[
trailer -> [ subscriptlist ]
1390
/
trailer -> [ subscriptlist ]
1390
+=
trailer -> [ subscriptlist ]
1390
or
trailer -> [ subscriptlist ]
1390
**=
trailer -> [ subscriptlist ]
1390
&
trailer -> [ subscriptlist ]
1390
/=
trailer -> [ subscriptlist ]
1390
>=
trailer -> [ subscriptlist ]
1390
==
trailer -> [ subscriptlist ]
1390
(
trailer -> [ subscriptlist ]
1390
|
trailer -> [ subscriptlist ]
1390
is
trailer -> [ subscriptlist ]
1390
<<=
trailer -> [ subscriptlist ]
1390
if
trailer -> [ subscriptlist ]
1390
>
trailer -> [ subscriptlist ]
1390
^
trailer -> [ subscriptlist ]
1391
@
factor -> ~ factor
1391
>>
factor -> ~ factor
1391
<=
factor -> ~ factor
1391
and
factor -> ~ factor
1391
+
factor -> ~ factor
1391
:
factor -> ~ factor
1391
*
factor -> ~ factor
1391
!=
factor -> ~ factor
1391
%
factor -> ~ factor
1391
<<
factor -> ~ factor
1391
>=
factor -> ~ factor
1391
,
factor -> ~ factor
1391
&
factor -> ~ factor
1391
]
factor -> ~ factor
1391
is
factor -> ~ factor
1391
==
factor -> ~ factor
1391
//
factor -> ~ factor
1391
<
factor -> ~ factor
1391
/
factor -> ~ factor
1391
not
factor -> ~ factor
1391
-
factor -> ~ factor
1391
or
factor -> ~ factor
1391
|
factor -> ~ factor
1391
>
factor -> ~ factor
1391
^
factor -> ~ factor
1391
if
factor -> ~ factor
1391
in
factor -> ~ factor
1392
,
not_test -> not not_test
1392
]
not_test -> not not_test
1392
and
not_test -> not not_test
1392
or
not_test -> not not_test
1392
if
not_test -> not not_test
1392
:
not_test -> not not_test
1393
[
802
1393
factor
803
1393
True
804
1393
atom_expr
810
1393
~
806
1393
and_expr
808
1393
-
809
1393
shift_expr
811
1393
atom
812
1393
{
813
1393
xor_expr
1878
1393
(
816
1393
arith_expr
817
1393
power
818
1393
STRING
819
1393
NAME
820
1393
term
822
1393
+
823
1393
NUMBER
826
1393
False
827
1393
None
831
1394
@
factor -> - factor
1394
<=
factor -> - factor
1394
in
factor -> - factor
1394
>>
factor -> - factor
1394
|
factor -> - factor
1394
is
factor -> - factor
1394
+
factor -> - factor
1394
%
factor -> - factor
1394
<
factor -> - factor
1394
*
factor -> - factor
1394
<<
factor -> - factor
1394
if
factor -> - factor
1394
-
factor -> - factor
1394
>=
factor -> - factor
1394
not
factor -> - factor
1394
and
factor -> - factor
1394
/
factor -> - factor
1394
:
factor -> - factor
1394
or
factor -> - factor
1394
^
factor -> - factor
1394
>
factor -> - factor
1394
!=
factor -> - factor
1394
&
factor -> - factor
1394
==
factor -> - factor
1394
//
factor -> - factor
1394
]
factor -> - factor
1394
,
factor -> - factor
1395
[
802
1395
True
804
1395
atom_expr
810
1395
-
809
1395
~
806
1395
atom
812
1395
{
813
1395
(
816
1395
power
818
1395
STRING
819
1395
NAME
820
1395
+
823
1395
NUMBER
826
1395
False
827
1395
factor
1879
1395
None
831
1396
[
802
1396
factor
803
1396
True
804
1396
atom_expr
810
1396
~
806
1396
-
809
1396
shift_expr
811
1396
atom
812
1396
{
813
1396
(
816
1396
arith_expr
817
1396
power
818
1396
STRING
819
1396
NAME
820
1396
and_expr
1880
1396
term
822
1396
+
823
1396
NUMBER
826
1396
False
827
1396
None
831
1397
[
766
1397
factor
767
1397
True
768
1397
atom_expr
769
1397
~
770
1397
and_expr
771
1397
-
772
1397
{
773
1397
shift_expr
774
1397
atom
775
1397
comparison
776
1397
and_test
777
1397
arith_expr
778
1397
power
779
1397
STRING
780
1397
NAME
781
1397
(
782
1397
term
784
1397
+
785
1397
xor_expr
786
1397
)
1881
1397
or_test
788
1397
arglist
1882
1397
NUMBER
789
1397
not
790
1397
False
791
1397
expr
792
1397
*
793
1397
not_test
794
1397
None
795
1397
lambdef
796
1397
lambda
797
1397
test
798
1397
argument
799
1397
**
800
1398
trailer_expr
1883
1398
>>
trailer_expr -> 
1398
(
1397
1398
trailer
1398
1398
.
1400
1398
+
trailer_expr -> 
1398
[
1401
1398
is
trailer_expr -> 
1398
>
trailer_expr -> 
1398
not
trailer_expr -> 
1398
|
trailer_expr -> 
1398
&
trailer_expr -> 
1398
/
trailer_expr -> 
1398
@
trailer_expr -> 
1398
!=
trailer_expr -> 
1398
**
trailer_expr -> 
1398
>=
trailer_expr -> 
1398
^
trailer_expr -> 
1398
in
trailer_expr -> 
1398
]
trailer_expr -> 
1398
<<
trailer_expr -> 
1398
and
trailer_expr -> 
1398
or
trailer_expr -> 
1398
if
trailer_expr -> 
1398
:
trailer_expr -> 
1398
//
trailer_expr -> 
1398
%
trailer_expr -> 
1398
,
trailer_expr -> 
1398
<=
trailer_expr -> 
1398
<
trailer_expr -> 
1398
==
trailer_expr -> 
1398
-
trailer_expr -> 
1398
*
trailer_expr -> 
1399
^
atom_expr -> atom trailer_expr
1399
or
atom_expr -> atom trailer_expr
1399
&
atom_expr -> atom trailer_expr
1399
@
atom_expr -> atom trailer_expr
1399
|
atom_expr -> atom trailer_expr
1399
-
atom_expr -> atom trailer_expr
1399
*
atom_expr -> atom trailer_expr
1399
%
atom_expr -> atom trailer_expr
1399
==
atom_expr -> atom trailer_expr
1399
**
atom_expr -> atom trailer_expr
1399
and
atom_expr -> atom trailer_expr
1399
is
atom_expr -> atom trailer_expr
1399
in
atom_expr -> atom trailer_expr
1399
<<
atom_expr -> atom trailer_expr
1399
!=
atom_expr -> atom trailer_expr
1399
<=
atom_expr -> atom trailer_expr
1399
/
atom_expr -> atom trailer_expr
1399
//
atom_expr -> atom trailer_expr
1399
<
atom_expr -> atom trailer_expr
1399
>=
atom_expr -> atom trailer_expr
1399
>>
atom_expr -> atom trailer_expr
1399
if
atom_expr -> atom trailer_expr
1399
not
atom_expr -> atom trailer_expr
1399
:
atom_expr -> atom trailer_expr
1399
+
atom_expr -> atom trailer_expr
1399
]
atom_expr -> atom trailer_expr
1399
>
atom_expr -> atom trailer_expr
1399
,
atom_expr -> atom trailer_expr
1400
NAME
1884
1401
[
802
1401
factor
803
1401
True
804
1401
atom_expr
810
1401
~
806
1401
not
807
1401
and_expr
808
1401
-
809
1401
shift_expr
811
1401
atom
812
1401
{
813
1401
comparison
814
1401
or_test
815
1401
(
816
1401
arith_expr
817
1401
power
818
1401
STRING
819
1401
NAME
820
1401
and_test
821
1401
subscriptlist
1885
1401
term
822
1401
+
823
1401
xor_expr
824
1401
test
825
1401
NUMBER
826
1401
False
827
1401
subscript
828
1401
expr
829
1401
not_test
830
1401
None
831
1401
lambdef
832
1401
lambda
833
1401
maybe_test
834
1401
:
maybe_test -> 
1402
in
atom -> { }
1402
<=
atom -> { }
1402
*
atom -> { }
1402
>
atom -> { }
1402
+
atom -> { }
1402
@
atom -> { }
1402
,
atom -> { }
1402
>=
atom -> { }
1402
/
atom -> { }
1402
:
atom -> { }
1402
|
atom -> { }
1402
is
atom -> { }
1402
and
atom -> { }
1402
if
atom -> { }
1402
(
atom -> { }
1402
>>
atom -> { }
1402
]
atom -> { }
1402
not
atom -> { }
1402
-
atom -> { }
1402
<<
atom -> { }
1402
**
atom -> { }
1402
or
atom -> { }
1402
<
atom -> { }
1402
!=
atom -> { }
1402
==
atom -> { }
1402
%
atom -> { }
1402
//
atom -> { }
1402
&
atom -> { }
1402
[
atom -> { }
1402
.
atom -> { }
1402
^
atom -> { }
1403
[
738
1403
factor
740
1403
True
741
1403
~
742
1403
and_expr
743
1403
-
744
1403
atom
745
1403
{
746
1403
arith_expr
747
1403
power
748
1403
atom_expr
749
1403
STRING
750
1403
NAME
751
1403
(
752
1403
term
753
1403
+
754
1403
xor_expr
755
1403
shift_expr
756
1403
NUMBER
757
1403
not
758
1403
False
759
1403
or_test
1886
1403
comparison
760
1403
not_test
761
1403
None
762
1403
expr
763
1403
and_test
764
1404
)
1887
1405
or
atom -> ( )
1405
>>
atom -> ( )
1405
(
atom -> ( )
1405
<=
atom -> ( )
1405
.
atom -> ( )
1405
is
atom -> ( )
1405
@
atom -> ( )
1405
,
atom -> ( )
1405
%
atom -> ( )
1405
<<
atom -> ( )
1405
**
atom -> ( )
1405
^
atom -> ( )
1405
/
atom -> ( )
1405
if
atom -> ( )
1405
not
atom -> ( )
1405
*
atom -> ( )
1405
!=
atom -> ( )
1405
<
atom -> ( )
1405
&
atom -> ( )
1405
-
atom -> ( )
1405
>
atom -> ( )
1405
//
atom -> ( )
1405
:
atom -> ( )
1405
==
atom -> ( )
1405
]
atom -> ( )
1405
in
atom -> ( )
1405
+
atom -> ( )
1405
[
atom -> ( )
1405
>=
atom -> ( )
1405
and
atom -> ( )
1405
|
atom -> ( )
1406
[
802
1406
factor
803
1406
True
804
1406
atom_expr
810
1406
~
806
1406
-
809
1406
atom
812
1406
{
813
1406
(
816
1406
arith_expr
817
1406
power
818
1406
STRING
819
1406
NAME
820
1406
shift_expr
1888
1406
term
822
1406
+
823
1406
NUMBER
826
1406
False
827
1406
None
831
1407
[
802
1407
factor
803
1407
True
804
1407
atom_expr
810
1407
~
806
1407
-
809
1407
atom
812
1407
{
813
1407
(
816
1407
arith_expr
817
1407
power
818
1407
STRING
819
1407
NAME
820
1407
term
822
1407
+
823
1407
NUMBER
826
1407
False
827
1407
shift_expr
1889
1407
None
831
1408
[
802
1408
factor
803
1408
True
804
1408
atom_expr
810
1408
~
806
1408
not
807
1408
and_expr
808
1408
-
809
1408
shift_expr
811
1408
atom
812
1408
{
813
1408
comparison
814
1408
(
816
1408
arith_expr
817
1408
power
818
1408
STRING
819
1408
NAME
820
1408
or_test
1890
1408
and_test
821
1408
term
822
1408
+
823
1408
xor_expr
824
1408
NUMBER
826
1408
False
827
1408
expr
829
1408
not_test
830
1408
None
831
1409
[
802
1409
factor
803
1409
True
804
1409
atom_expr
810
1409
~
806
1409
-
809
1409
arith_expr
1891
1409
atom
812
1409
{
813
1409
(
816
1409
power
818
1409
STRING
819
1409
NAME
820
1409
term
822
1409
+
823
1409
NUMBER
826
1409
False
827
1409
None
831
1410
[
802
1410
factor
803
1410
True
804
1410
atom_expr
810
1410
~
806
1410
-
809
1410
atom
812
1410
{
813
1410
arith_expr
1892
1410
(
816
1410
power
818
1410
STRING
819
1410
NAME
820
1410
term
822
1410
+
823
1410
NUMBER
826
1410
False
827
1410
None
831
1411
-
factor -> + factor
1411
@
factor -> + factor
1411
:
factor -> + factor
1411
<<
factor -> + factor
1411
is
factor -> + factor
1411
and
factor -> + factor
1411
<=
factor -> + factor
1411
or
factor -> + factor
1411
<
factor -> + factor
1411
^
factor -> + factor
1411
not
factor -> + factor
1411
//
factor -> + factor
1411
,
factor -> + factor
1411
*
factor -> + factor
1411
in
factor -> + factor
1411
&
factor -> + factor
1411
+
factor -> + factor
1411
if
factor -> + factor
1411
>>
factor -> + factor
1411
|
factor -> + factor
1411
%
factor -> + factor
1411
>
factor -> + factor
1411
>=
factor -> + factor
1411
!=
factor -> + factor
1411
]
factor -> + factor
1411
/
factor -> + factor
1411
==
factor -> + factor
1412
[
802
1412
factor
803
1412
True
804
1412
atom_expr
810
1412
~
806
1412
and_expr
808
1412
-
809
1412
shift_expr
811
1412
atom
812
1412
{
813
1412
expr
1893
1412
(
816
1412
arith_expr
817
1412
power
818
1412
STRING
819
1412
NAME
820
1412
term
822
1412
+
823
1412
xor_expr
824
1412
NUMBER
826
1412
False
827
1412
None
831
1413
[
802
1413
factor
803
1413
True
804
1413
atom_expr
810
1413
~
806
1413
not
807
1413
and_expr
808
1413
-
809
1413
shift_expr
811
1413
atom
812
1413
{
813
1413
comparison
814
1413
or_test
815
1413
(
816
1413
arith_expr
817
1413
power
818
1413
STRING
819
1413
NAME
820
1413
and_test
821
1413
term
822
1413
+
823
1413
xor_expr
824
1413
test
825
1413
NUMBER
826
1413
False
827
1413
subscript
828
1413
expr
829
1413
not_test
830
1413
None
831
1413
lambdef
832
1413
lambda
833
1413
maybe_test
834
1413
:
maybe_test -> 
1413
subscriptlist
1894
1414
[
802
1414
factor
803
1414
True
804
1414
atom_expr
810
1414
~
806
1414
and_expr
808
1414
-
809
1414
shift_expr
811
1414
atom
812
1414
{
813
1414
(
816
1414
arith_expr
817
1414
power
818
1414
STRING
819
1414
NAME
820
1414
term
822
1414
+
823
1414
xor_expr
824
1414
NUMBER
826
1414
False
827
1414
expr
829
1414
None
831
1414
comparison
1895
1415
[
802
1415
factor
803
1415
True
804
1415
atom_expr
810
1415
~
806
1415
not
807
1415
and_expr
808
1415
-
809
1415
shift_expr
811
1415
atom
812
1415
{
813
1415
comparison
814
1415
(
816
1415
arith_expr
817
1415
power
818
1415
STRING
819
1415
NAME
820
1415
term
822
1415
+
823
1415
xor_expr
824
1415
NUMBER
826
1415
False
827
1415
and_test
1896
1415
expr
829
1415
not_test
830
1415
None
831
1416
:
1897
1417
[
802
1417
factor
803
1417
True
804
1417
atom_expr
810
1417
~
806
1417
not
807
1417
and_expr
808
1417
-
809
1417
shift_expr
811
1417
atom
812
1417
{
813
1417
comparison
814
1417
or_test
815
1417
(
816
1417
arith_expr
817
1417
power
818
1417
STRING
819
1417
NAME
820
1417
test
1898
1417
and_test
821
1417
term
822
1417
+
823
1417
xor_expr
824
1417
NUMBER
826
1417
False
827
1417
expr
829
1417
not_test
830
1417
None
831
1417
lambdef
832
1417
lambda
833
1418
[
802
1418
factor
803
1418
True
804
1418
atom_expr
810
1418
~
806
1418
not
807
1418
and_expr
808
1418
-
809
1418
shift_expr
811
1418
atom
812
1418
{
813
1418
comparison
814
1418
or_test
815
1418
(
816
1418
arith_expr
817
1418
power
818
1418
STRING
819
1418
NAME
820
1418
and_test
821
1418
term
822
1418
+
823
1418
maybe_test
1899
1418
xor_expr
824
1418
NUMBER
826
1418
False
827
1418
expr
829
1418
not_test
830
1418
test
1900
1418
]
maybe_test -> 
1418
None
831
1418
lambdef
832
1418
lambda
833
1418
,
maybe_test -> 
1418
:
maybe_test -> 
1419
.
atom -> [ test_list_comp ]
1419
[
atom -> [ test_list_comp ]
1419
@
atom -> [ test_list_comp ]
1419
<=
atom -> [ test_list_comp ]
1419
<
atom -> [ test_list_comp ]
1419
not
atom -> [ test_list_comp ]
1419
in
atom -> [ test_list_comp ]
1419
and
atom -> [ test_list_comp ]
1419
-
atom -> [ test_list_comp ]
1419
if
atom -> [ test_list_comp ]
1419
!=
atom -> [ test_list_comp ]
1419
is
atom -> [ test_list_comp ]
1419
>>
atom -> [ test_list_comp ]
1419
or
atom -> [ test_list_comp ]
1419
//
atom -> [ test_list_comp ]
1419
/
atom -> [ test_list_comp ]
1419
,
atom -> [ test_list_comp ]
1419
|
atom -> [ test_list_comp ]
1419
>
atom -> [ test_list_comp ]
1419
NEWLINE
atom -> [ test_list_comp ]
1419
&
atom -> [ test_list_comp ]
1419
(
atom -> [ test_list_comp ]
1419
%
atom -> [ test_list_comp ]
1419
>=
atom -> [ test_list_comp ]
1419
==
atom -> [ test_list_comp ]
1419
**
atom -> [ test_list_comp ]
1419
<<
atom -> [ test_list_comp ]
1419
^
atom -> [ test_list_comp ]
1419
+
atom -> [ test_list_comp ]
1419
*
atom -> [ test_list_comp ]
1420
<<
term -> factor @ term
1420
^
term -> factor @ term
1420
<=
term -> factor @ term
1420
==
term -> factor @ term
1420
if
term -> factor @ term
1420
|
term -> factor @ term
1420
NEWLINE
term -> factor @ term
1420
!=
term -> factor @ term
1420
or
term -> factor @ term
1420
>
term -> factor @ term
1420
and
term -> factor @ term
1420
>>
term -> factor @ term
1420
is
term -> factor @ term
1420
-
term -> factor @ term
1420
not
term -> factor @ term
1420
+
term -> factor @ term
1420
in
term -> factor @ term
1420
>=
term -> factor @ term
1420
<
term -> factor @ term
1420
,
term -> factor @ term
1420
&
term -> factor @ term
1421
<=
term -> factor % term
1421
is
term -> factor % term
1421
>
term -> factor % term
1421
and
term -> factor % term
1421
in
term -> factor % term
1421
,
term -> factor % term
1421
or
term -> factor % term
1421
<
term -> factor % term
1421
-
term -> factor % term
1421
NEWLINE
term -> factor % term
1421
!=
term -> factor % term
1421
>>
term -> factor % term
1421
^
term -> factor % term
1421
+
term -> factor % term
1421
if
term -> factor % term
1421
<<
term -> factor % term
1421
>=
term -> factor % term
1421
==
term -> factor % term
1421
not
term -> factor % term
1421
|
term -> factor % term
1421
&
term -> factor % term
1422
>>
term -> factor / term
1422
!=
term -> factor / term
1422
<
term -> factor / term
1422
<=
term -> factor / term
1422
|
term -> factor / term
1422
is
term -> factor / term
1422
>=
term -> factor / term
1422
^
term -> factor / term
1422
&
term -> factor / term
1422
+
term -> factor / term
1422
NEWLINE
term -> factor / term
1422
<<
term -> factor / term
1422
and
term -> factor / term
1422
-
term -> factor / term
1422
in
term -> factor / term
1422
>
term -> factor / term
1422
or
term -> factor / term
1422
not
term -> factor / term
1422
==
term -> factor / term
1422
,
term -> factor / term
1422
if
term -> factor / term
1423
is
term -> factor * term
1423
+
term -> factor * term
1423
>=
term -> factor * term
1423
^
term -> factor * term
1423
NEWLINE
term -> factor * term
1423
,
term -> factor * term
1423
<=
term -> factor * term
1423
or
term -> factor * term
1423
<
term -> factor * term
1423
|
term -> factor * term
1423
>>
term -> factor * term
1423
in
term -> factor * term
1423
not
term -> factor * term
1423
==
term -> factor * term
1423
-
term -> factor * term
1423
and
term -> factor * term
1423
!=
term -> factor * term
1423
<<
term -> factor * term
1423
>
term -> factor * term
1423
if
term -> factor * term
1423
&
term -> factor * term
1424
!=
term -> factor // term
1424
or
term -> factor // term
1424
^
term -> factor // term
1424
>
term -> factor // term
1424
is
term -> factor // term
1424
&
term -> factor // term
1424
-
term -> factor // term
1424
in
term -> factor // term
1424
>>
term -> factor // term
1424
|
term -> factor // term
1424
<
term -> factor // term
1424
>=
term -> factor // term
1424
not
term -> factor // term
1424
if
term -> factor // term
1424
==
term -> factor // term
1424
NEWLINE
term -> factor // term
1424
<=
term -> factor // term
1424
,
term -> factor // term
1424
and
term -> factor // term
1424
<<
term -> factor // term
1424
+
term -> factor // term
1425
!=
power -> atom_expr ** factor
1425
@
power -> atom_expr ** factor
1425
|
power -> atom_expr ** factor
1425
in
power -> atom_expr ** factor
1425
==
power -> atom_expr ** factor
1425
if
power -> atom_expr ** factor
1425
NEWLINE
power -> atom_expr ** factor
1425
and
power -> atom_expr ** factor
1425
>=
power -> atom_expr ** factor
1425
/
power -> atom_expr ** factor
1425
not
power -> atom_expr ** factor
1425
^
power -> atom_expr ** factor
1425
//
power -> atom_expr ** factor
1425
>
power -> atom_expr ** factor
1425
+
power -> atom_expr ** factor
1425
%
power -> atom_expr ** factor
1425
-
power -> atom_expr ** factor
1425
is
power -> atom_expr ** factor
1425
<=
power -> atom_expr ** factor
1425
<
power -> atom_expr ** factor
1425
,
power -> atom_expr ** factor
1425
*
power -> atom_expr ** factor
1425
<<
power -> atom_expr ** factor
1425
or
power -> atom_expr ** factor
1425
>>
power -> atom_expr ** factor
1425
&
power -> atom_expr ** factor
1426
not
xor_expr -> and_expr ^ xor_expr
1426
<
xor_expr -> and_expr ^ xor_expr
1426
,
xor_expr -> and_expr ^ xor_expr
1426
>=
xor_expr -> and_expr ^ xor_expr
1426
>
xor_expr -> and_expr ^ xor_expr
1426
is
xor_expr -> and_expr ^ xor_expr
1426
!=
xor_expr -> and_expr ^ xor_expr
1426
and
xor_expr -> and_expr ^ xor_expr
1426
if
xor_expr -> and_expr ^ xor_expr
1426
<=
xor_expr -> and_expr ^ xor_expr
1426
in
xor_expr -> and_expr ^ xor_expr
1426
==
xor_expr -> and_expr ^ xor_expr
1426
|
xor_expr -> and_expr ^ xor_expr
1426
or
xor_expr -> and_expr ^ xor_expr
1426
NEWLINE
xor_expr -> and_expr ^ xor_expr
1427
<
and_expr -> shift_expr & and_expr
1427
if
and_expr -> shift_expr & and_expr
1427
>=
and_expr -> shift_expr & and_expr
1427
NEWLINE
and_expr -> shift_expr & and_expr
1427
not
and_expr -> shift_expr & and_expr
1427
==
and_expr -> shift_expr & and_expr
1427
>
and_expr -> shift_expr & and_expr
1427
in
and_expr -> shift_expr & and_expr
1427
^
and_expr -> shift_expr & and_expr
1427
or
and_expr -> shift_expr & and_expr
1427
and
and_expr -> shift_expr & and_expr
1427
!=
and_expr -> shift_expr & and_expr
1427
,
and_expr -> shift_expr & and_expr
1427
|
and_expr -> shift_expr & and_expr
1427
is
and_expr -> shift_expr & and_expr
1427
<=
and_expr -> shift_expr & and_expr
1428
+
trailer -> ( )
1428
!=
trailer -> ( )
1428
<<
trailer -> ( )
1428
>=
trailer -> ( )
1428
**
trailer -> ( )
1428
not
trailer -> ( )
1428
if
trailer -> ( )
1428
,
trailer -> ( )
1428
|
trailer -> ( )
1428
[
trailer -> ( )
1428
==
trailer -> ( )
1428
%
trailer -> ( )
1428
*
trailer -> ( )
1428
>>
trailer -> ( )
1428
@
trailer -> ( )
1428
>
trailer -> ( )
1428
/
trailer -> ( )
1428
in
trailer -> ( )
1428
(
trailer -> ( )
1428
is
trailer -> ( )
1428
//
trailer -> ( )
1428
<
trailer -> ( )
1428
NEWLINE
trailer -> ( )
1428
or
trailer -> ( )
1428
^
trailer -> ( )
1428
and
trailer -> ( )
1428
<=
trailer -> ( )
1428
.
trailer -> ( )
1428
-
trailer -> ( )
1428
&
trailer -> ( )
1429
)
1901
1430
<=
trailer_expr -> trailer trailer_expr
1430
+
trailer_expr -> trailer trailer_expr
1430
^
trailer_expr -> trailer trailer_expr
1430
or
trailer_expr -> trailer trailer_expr
1430
==
trailer_expr -> trailer trailer_expr
1430
%
trailer_expr -> trailer trailer_expr
1430
@
trailer_expr -> trailer trailer_expr
1430
not
trailer_expr -> trailer trailer_expr
1430
<<
trailer_expr -> trailer trailer_expr
1430
-
trailer_expr -> trailer trailer_expr
1430
//
trailer_expr -> trailer trailer_expr
1430
and
trailer_expr -> trailer trailer_expr
1430
|
trailer_expr -> trailer trailer_expr
1430
if
trailer_expr -> trailer trailer_expr
1430
>
trailer_expr -> trailer trailer_expr
1430
!=
trailer_expr -> trailer trailer_expr
1430
,
trailer_expr -> trailer trailer_expr
1430
<
trailer_expr -> trailer trailer_expr
1430
>>
trailer_expr -> trailer trailer_expr
1430
/
trailer_expr -> trailer trailer_expr
1430
is
trailer_expr -> trailer trailer_expr
1430
NEWLINE
trailer_expr -> trailer trailer_expr
1430
&
trailer_expr -> trailer trailer_expr
1430
in
trailer_expr -> trailer trailer_expr
1430
>=
trailer_expr -> trailer trailer_expr
1430
*
trailer_expr -> trailer trailer_expr
1430
**
trailer_expr -> trailer trailer_expr
1431
.
trailer -> . NAME
1431
not
trailer -> . NAME
1431
if
trailer -> . NAME
1431
NEWLINE
trailer -> . NAME
1431
**
trailer -> . NAME
1431
|
trailer -> . NAME
1431
-
trailer -> . NAME
1431
(
trailer -> . NAME
1431
%
trailer -> . NAME
1431
//
trailer -> . NAME
1431
==
trailer -> . NAME
1431
>>
trailer -> . NAME
1431
is
trailer -> . NAME
1431
!=
trailer -> . NAME
1431
and
trailer -> . NAME
1431
>=
trailer -> . NAME
1431
,
trailer -> . NAME
1431
>
trailer -> . NAME
1431
in
trailer -> . NAME
1431
<<
trailer -> . NAME
1431
&
trailer -> . NAME
1431
/
trailer -> . NAME
1431
^
trailer -> . NAME
1431
[
trailer -> . NAME
1431
<=
trailer -> . NAME
1431
or
trailer -> . NAME
1431
+
trailer -> . NAME
1431
<
trailer -> . NAME
1431
*
trailer -> . NAME
1431
@
trailer -> . NAME
1432
]
1902
1433
==
shift_expr -> arith_expr >> shift_expr
1433
^
shift_expr -> arith_expr >> shift_expr
1433
or
shift_expr -> arith_expr >> shift_expr
1433
if
shift_expr -> arith_expr >> shift_expr
1433
,
shift_expr -> arith_expr >> shift_expr
1433
not
shift_expr -> arith_expr >> shift_expr
1433
|
shift_expr -> arith_expr >> shift_expr
1433
<=
shift_expr -> arith_expr >> shift_expr
1433
is
shift_expr -> arith_expr >> shift_expr
1433
in
shift_expr -> arith_expr >> shift_expr
1433
>=
shift_expr -> arith_expr >> shift_expr
1433
NEWLINE
shift_expr -> arith_expr >> shift_expr
1433
>
shift_expr -> arith_expr >> shift_expr
1433
&
shift_expr -> arith_expr >> shift_expr
1433
<
shift_expr -> arith_expr >> shift_expr
1433
and
shift_expr -> arith_expr >> shift_expr
1433
!=
shift_expr -> arith_expr >> shift_expr
1434
or
shift_expr -> arith_expr << shift_expr
1434
>
shift_expr -> arith_expr << shift_expr
1434
in
shift_expr -> arith_expr << shift_expr
1434
NEWLINE
shift_expr -> arith_expr << shift_expr
1434
&
shift_expr -> arith_expr << shift_expr
1434
is
shift_expr -> arith_expr << shift_expr
1434
<
shift_expr -> arith_expr << shift_expr
1434
<=
shift_expr -> arith_expr << shift_expr
1434
not
shift_expr -> arith_expr << shift_expr
1434
^
shift_expr -> arith_expr << shift_expr
1434
if
shift_expr -> arith_expr << shift_expr
1434
,
shift_expr -> arith_expr << shift_expr
1434
and
shift_expr -> arith_expr << shift_expr
1434
|
shift_expr -> arith_expr << shift_expr
1434
!=
shift_expr -> arith_expr << shift_expr
1434
==
shift_expr -> arith_expr << shift_expr
1434
>=
shift_expr -> arith_expr << shift_expr
1435
>
atom -> ( test_list_comp )
1435
@
atom -> ( test_list_comp )
1435
&
atom -> ( test_list_comp )
1435
[
atom -> ( test_list_comp )
1435
if
atom -> ( test_list_comp )
1435
==
atom -> ( test_list_comp )
1435
>=
atom -> ( test_list_comp )
1435
NEWLINE
atom -> ( test_list_comp )
1435
**
atom -> ( test_list_comp )
1435
not
atom -> ( test_list_comp )
1435
<<
atom -> ( test_list_comp )
1435
>>
atom -> ( test_list_comp )
1435
in
atom -> ( test_list_comp )
1435
or
atom -> ( test_list_comp )
1435
.
atom -> ( test_list_comp )
1435
/
atom -> ( test_list_comp )
1435
^
atom -> ( test_list_comp )
1435
is
atom -> ( test_list_comp )
1435
,
atom -> ( test_list_comp )
1435
and
atom -> ( test_list_comp )
1435
//
atom -> ( test_list_comp )
1435
<
atom -> ( test_list_comp )
1435
*
atom -> ( test_list_comp )
1435
<=
atom -> ( test_list_comp )
1435
(
atom -> ( test_list_comp )
1435
-
atom -> ( test_list_comp )
1435
|
atom -> ( test_list_comp )
1435
!=
atom -> ( test_list_comp )
1435
+
atom -> ( test_list_comp )
1435
%
atom -> ( test_list_comp )
1436
if
or_test -> and_test or or_test
1436
NEWLINE
or_test -> and_test or or_test
1436
,
or_test -> and_test or or_test
1437
^
arith_expr -> term - arith_expr
1437
!=
arith_expr -> term - arith_expr
1437
<
arith_expr -> term - arith_expr
1437
in
arith_expr -> term - arith_expr
1437
==
arith_expr -> term - arith_expr
1437
|
arith_expr -> term - arith_expr
1437
is
arith_expr -> term - arith_expr
1437
&
arith_expr -> term - arith_expr
1437
>>
arith_expr -> term - arith_expr
1437
<<
arith_expr -> term - arith_expr
1437
and
arith_expr -> term - arith_expr
1437
,
arith_expr -> term - arith_expr
1437
>
arith_expr -> term - arith_expr
1437
if
arith_expr -> term - arith_expr
1437
NEWLINE
arith_expr -> term - arith_expr
1437
not
arith_expr -> term - arith_expr
1437
>=
arith_expr -> term - arith_expr
1437
<=
arith_expr -> term - arith_expr
1437
or
arith_expr -> term - arith_expr
1438
>=
arith_expr -> term + arith_expr
1438
>
arith_expr -> term + arith_expr
1438
^
arith_expr -> term + arith_expr
1438
or
arith_expr -> term + arith_expr
1438
==
arith_expr -> term + arith_expr
1438
<=
arith_expr -> term + arith_expr
1438
if
arith_expr -> term + arith_expr
1438
>>
arith_expr -> term + arith_expr
1438
<
arith_expr -> term + arith_expr
1438
not
arith_expr -> term + arith_expr
1438
&
arith_expr -> term + arith_expr
1438
in
arith_expr -> term + arith_expr
1438
and
arith_expr -> term + arith_expr
1438
,
arith_expr -> term + arith_expr
1438
|
arith_expr -> term + arith_expr
1438
!=
arith_expr -> term + arith_expr
1438
NEWLINE
arith_expr -> term + arith_expr
1438
<<
arith_expr -> term + arith_expr
1438
is
arith_expr -> term + arith_expr
1439
>=
expr -> xor_expr | expr
1439
,
expr -> xor_expr | expr
1439
or
expr -> xor_expr | expr
1439
in
expr -> xor_expr | expr
1439
NEWLINE
expr -> xor_expr | expr
1439
and
expr -> xor_expr | expr
1439
==
expr -> xor_expr | expr
1439
>
expr -> xor_expr | expr
1439
<=
expr -> xor_expr | expr
1439
is
expr -> xor_expr | expr
1439
<
expr -> xor_expr | expr
1439
if
expr -> xor_expr | expr
1439
not
expr -> xor_expr | expr
1439
!=
expr -> xor_expr | expr
1440
[
334
1440
factor
335
1440
True
336
1440
atom_expr
337
1440
~
338
1440
and_expr
339
1440
-
340
1440
None
341
1440
shift_expr
342
1440
atom
343
1440
{
344
1440
comparison
345
1440
arith_expr
346
1440
power
347
1440
STRING
348
1440
NAME
349
1440
(
350
1440
NUMBER
351
1440
and_test
352
1440
term
353
1440
+
354
1440
xor_expr
355
1440
not
356
1440
False
357
1440
lambda
358
1440
not_test
359
1440
lambdef
361
1440
expr
362
1440
test
1903
1440
or_test
363
1441
,
lambdef -> lambda : test
1441
NEWLINE
lambdef -> lambda : test
1442
,
and_test -> not_test and and_test
1442
NEWLINE
and_test -> not_test and and_test
1442
if
and_test -> not_test and and_test
1442
or
and_test -> not_test and and_test
1443
or
comparison -> expr comp_op comparison
1443
if
comparison -> expr comp_op comparison
1443
NEWLINE
comparison -> expr comp_op comparison
1443
and
comparison -> expr comp_op comparison
1443
,
comparison -> expr comp_op comparison
1444
else
1904
1445
NEWLINE
test_list -> test , test_list
1446
.
atom -> [ test_list_comp ]
1446
[
atom -> [ test_list_comp ]
1446
@
atom -> [ test_list_comp ]
1446
<=
atom -> [ test_list_comp ]
1446
<
atom -> [ test_list_comp ]
1446
not
atom -> [ test_list_comp ]
1446
in
atom -> [ test_list_comp ]
1446
and
atom -> [ test_list_comp ]
1446
-
atom -> [ test_list_comp ]
1446
if
atom -> [ test_list_comp ]
1446
!=
atom -> [ test_list_comp ]
1446
is
atom -> [ test_list_comp ]
1446
>>
atom -> [ test_list_comp ]
1446
or
atom -> [ test_list_comp ]
1446
from
atom -> [ test_list_comp ]
1446
//
atom -> [ test_list_comp ]
1446
/
atom -> [ test_list_comp ]
1446
|
atom -> [ test_list_comp ]
1446
>
atom -> [ test_list_comp ]
1446
NEWLINE
atom -> [ test_list_comp ]
1446
&
atom -> [ test_list_comp ]
1446
(
atom -> [ test_list_comp ]
1446
%
atom -> [ test_list_comp ]
1446
>=
atom -> [ test_list_comp ]
1446
==
atom -> [ test_list_comp ]
1446
**
atom -> [ test_list_comp ]
1446
<<
atom -> [ test_list_comp ]
1446
^
atom -> [ test_list_comp ]
1446
+
atom -> [ test_list_comp ]
1446
*
atom -> [ test_list_comp ]
1447
!=
power -> atom_expr ** factor
1447
@
power -> atom_expr ** factor
1447
|
power -> atom_expr ** factor
1447
in
power -> atom_expr ** factor
1447
==
power -> atom_expr ** factor
1447
from
power -> atom_expr ** factor
1447
if
power -> atom_expr ** factor
1447
NEWLINE
power -> atom_expr ** factor
1447
and
power -> atom_expr ** factor
1447
>=
power -> atom_expr ** factor
1447
/
power -> atom_expr ** factor
1447
not
power -> atom_expr ** factor
1447
^
power -> atom_expr ** factor
1447
//
power -> atom_expr ** factor
1447
>
power -> atom_expr ** factor
1447
+
power -> atom_expr ** factor
1447
%
power -> atom_expr ** factor
1447
-
power -> atom_expr ** factor
1447
is
power -> atom_expr ** factor
1447
<=
power -> atom_expr ** factor
1447
<
power -> atom_expr ** factor
1447
*
power -> atom_expr ** factor
1447
<<
power -> atom_expr ** factor
1447
or
power -> atom_expr ** factor
1447
>>
power -> atom_expr ** factor
1447
&
power -> atom_expr ** factor
1448
<<
term -> factor @ term
1448
^
term -> factor @ term
1448
from
term -> factor @ term
1448
<=
term -> factor @ term
1448
==
term -> factor @ term
1448
if
term -> factor @ term
1448
|
term -> factor @ term
1448
NEWLINE
term -> factor @ term
1448
!=
term -> factor @ term
1448
or
term -> factor @ term
1448
>
term -> factor @ term
1448
and
term -> factor @ term
1448
>>
term -> factor @ term
1448
is
term -> factor @ term
1448
-
term -> factor @ term
1448
not
term -> factor @ term
1448
+
term -> factor @ term
1448
in
term -> factor @ term
1448
>=
term -> factor @ term
1448
<
term -> factor @ term
1448
&
term -> factor @ term
1449
<=
term -> factor % term
1449
is
term -> factor % term
1449
>
term -> factor % term
1449
and
term -> factor % term
1449
in
term -> factor % term
1449
or
term -> factor % term
1449
<
term -> factor % term
1449
-
term -> factor % term
1449
NEWLINE
term -> factor % term
1449
!=
term -> factor % term
1449
>>
term -> factor % term
1449
^
term -> factor % term
1449
+
term -> factor % term
1449
if
term -> factor % term
1449
<<
term -> factor % term
1449
>=
term -> factor % term
1449
==
term -> factor % term
1449
not
term -> factor % term
1449
|
term -> factor % term
1449
from
term -> factor % term
1449
&
term -> factor % term
1450
>>
term -> factor / term
1450
!=
term -> factor / term
1450
<
term -> factor / term
1450
<=
term -> factor / term
1450
|
term -> factor / term
1450
is
term -> factor / term
1450
>=
term -> factor / term
1450
^
term -> factor / term
1450
&
term -> factor / term
1450
+
term -> factor / term
1450
NEWLINE
term -> factor / term
1450
<<
term -> factor / term
1450
and
term -> factor / term
1450
-
term -> factor / term
1450
in
term -> factor / term
1450
>
term -> factor / term
1450
or
term -> factor / term
1450
not
term -> factor / term
1450
==
term -> factor / term
1450
from
term -> factor / term
1450
if
term -> factor / term
1451
is
term -> factor * term
1451
+
term -> factor * term
1451
>=
term -> factor * term
1451
^
term -> factor * term
1451
NEWLINE
term -> factor * term
1451
<=
term -> factor * term
1451
or
term -> factor * term
1451
<
term -> factor * term
1451
|
term -> factor * term
1451
>>
term -> factor * term
1451
in
term -> factor * term
1451
from
term -> factor * term
1451
not
term -> factor * term
1451
==
term -> factor * term
1451
-
term -> factor * term
1451
and
term -> factor * term
1451
!=
term -> factor * term
1451
<<
term -> factor * term
1451
>
term -> factor * term
1451
if
term -> factor * term
1451
&
term -> factor * term
1452
!=
term -> factor // term
1452
or
term -> factor // term
1452
^
term -> factor // term
1452
>
term -> factor // term
1452
is
term -> factor // term
1452
&
term -> factor // term
1452
-
term -> factor // term
1452
in
term -> factor // term
1452
>>
term -> factor // term
1452
|
term -> factor // term
1452
<
term -> factor // term
1452
>=
term -> factor // term
1452
not
term -> factor // term
1452
if
term -> factor // term
1452
==
term -> factor // term
1452
from
term -> factor // term
1452
NEWLINE
term -> factor // term
1452
<=
term -> factor // term
1452
and
term -> factor // term
1452
<<
term -> factor // term
1452
+
term -> factor // term
1453
not
xor_expr -> and_expr ^ xor_expr
1453
<
xor_expr -> and_expr ^ xor_expr
1453
>=
xor_expr -> and_expr ^ xor_expr
1453
from
xor_expr -> and_expr ^ xor_expr
1453
>
xor_expr -> and_expr ^ xor_expr
1453
is
xor_expr -> and_expr ^ xor_expr
1453
!=
xor_expr -> and_expr ^ xor_expr
1453
and
xor_expr -> and_expr ^ xor_expr
1453
if
xor_expr -> and_expr ^ xor_expr
1453
<=
xor_expr -> and_expr ^ xor_expr
1453
in
xor_expr -> and_expr ^ xor_expr
1453
==
xor_expr -> and_expr ^ xor_expr
1453
|
xor_expr -> and_expr ^ xor_expr
1453
or
xor_expr -> and_expr ^ xor_expr
1453
NEWLINE
xor_expr -> and_expr ^ xor_expr
1454
+
trailer -> ( )
1454
!=
trailer -> ( )
1454
<<
trailer -> ( )
1454
>=
trailer -> ( )
1454
**
trailer -> ( )
1454
not
trailer -> ( )
1454
if
trailer -> ( )
1454
|
trailer -> ( )
1454
[
trailer -> ( )
1454
==
trailer -> ( )
1454
from
trailer -> ( )
1454
%
trailer -> ( )
1454
*
trailer -> ( )
1454
>>
trailer -> ( )
1454
@
trailer -> ( )
1454
>
trailer -> ( )
1454
/
trailer -> ( )
1454
in
trailer -> ( )
1454
(
trailer -> ( )
1454
is
trailer -> ( )
1454
//
trailer -> ( )
1454
<
trailer -> ( )
1454
NEWLINE
trailer -> ( )
1454
or
trailer -> ( )
1454
^
trailer -> ( )
1454
and
trailer -> ( )
1454
<=
trailer -> ( )
1454
.
trailer -> ( )
1454
-
trailer -> ( )
1454
&
trailer -> ( )
1455
)
1905
1456
<=
trailer_expr -> trailer trailer_expr
1456
+
trailer_expr -> trailer trailer_expr
1456
^
trailer_expr -> trailer trailer_expr
1456
or
trailer_expr -> trailer trailer_expr
1456
==
trailer_expr -> trailer trailer_expr
1456
%
trailer_expr -> trailer trailer_expr
1456
@
trailer_expr -> trailer trailer_expr
1456
not
trailer_expr -> trailer trailer_expr
1456
<<
trailer_expr -> trailer trailer_expr
1456
-
trailer_expr -> trailer trailer_expr
1456
//
trailer_expr -> trailer trailer_expr
1456
and
trailer_expr -> trailer trailer_expr
1456
|
trailer_expr -> trailer trailer_expr
1456
if
trailer_expr -> trailer trailer_expr
1456
from
trailer_expr -> trailer trailer_expr
1456
>
trailer_expr -> trailer trailer_expr
1456
!=
trailer_expr -> trailer trailer_expr
1456
<
trailer_expr -> trailer trailer_expr
1456
>>
trailer_expr -> trailer trailer_expr
1456
/
trailer_expr -> trailer trailer_expr
1456
is
trailer_expr -> trailer trailer_expr
1456
NEWLINE
trailer_expr -> trailer trailer_expr
1456
&
trailer_expr -> trailer trailer_expr
1456
in
trailer_expr -> trailer trailer_expr
1456
>=
trailer_expr -> trailer trailer_expr
1456
*
trailer_expr -> trailer trailer_expr
1456
**
trailer_expr -> trailer trailer_expr
1457
.
trailer -> . NAME
1457
not
trailer -> . NAME
1457
if
trailer -> . NAME
1457
NEWLINE
trailer -> . NAME
1457
**
trailer -> . NAME
1457
from
trailer -> . NAME
1457
|
trailer -> . NAME
1457
-
trailer -> . NAME
1457
(
trailer -> . NAME
1457
%
trailer -> . NAME
1457
//
trailer -> . NAME
1457
==
trailer -> . NAME
1457
>>
trailer -> . NAME
1457
is
trailer -> . NAME
1457
!=
trailer -> . NAME
1457
and
trailer -> . NAME
1457
>=
trailer -> . NAME
1457
>
trailer -> . NAME
1457
in
trailer -> . NAME
1457
<<
trailer -> . NAME
1457
&
trailer -> . NAME
1457
/
trailer -> . NAME
1457
^
trailer -> . NAME
1457
[
trailer -> . NAME
1457
<=
trailer -> . NAME
1457
or
trailer -> . NAME
1457
+
trailer -> . NAME
1457
<
trailer -> . NAME
1457
*
trailer -> . NAME
1457
@
trailer -> . NAME
1458
]
1906
1459
or
comparison -> expr comp_op comparison
1459
if
comparison -> expr comp_op comparison
1459
NEWLINE
comparison -> expr comp_op comparison
1459
and
comparison -> expr comp_op comparison
1459
from
comparison -> expr comp_op comparison
1460
==
shift_expr -> arith_expr >> shift_expr
1460
^
shift_expr -> arith_expr >> shift_expr
1460
or
shift_expr -> arith_expr >> shift_expr
1460
if
shift_expr -> arith_expr >> shift_expr
1460
from
shift_expr -> arith_expr >> shift_expr
1460
not
shift_expr -> arith_expr >> shift_expr
1460
|
shift_expr -> arith_expr >> shift_expr
1460
<=
shift_expr -> arith_expr >> shift_expr
1460
is
shift_expr -> arith_expr >> shift_expr
1460
in
shift_expr -> arith_expr >> shift_expr
1460
>=
shift_expr -> arith_expr >> shift_expr
1460
NEWLINE
shift_expr -> arith_expr >> shift_expr
1460
>
shift_expr -> arith_expr >> shift_expr
1460
&
shift_expr -> arith_expr >> shift_expr
1460
<
shift_expr -> arith_expr >> shift_expr
1460
and
shift_expr -> arith_expr >> shift_expr
1460
!=
shift_expr -> arith_expr >> shift_expr
1461
or
shift_expr -> arith_expr << shift_expr
1461
>
shift_expr -> arith_expr << shift_expr
1461
in
shift_expr -> arith_expr << shift_expr
1461
NEWLINE
shift_expr -> arith_expr << shift_expr
1461
&
shift_expr -> arith_expr << shift_expr
1461
is
shift_expr -> arith_expr << shift_expr
1461
<
shift_expr -> arith_expr << shift_expr
1461
<=
shift_expr -> arith_expr << shift_expr
1461
not
shift_expr -> arith_expr << shift_expr
1461
^
shift_expr -> arith_expr << shift_expr
1461
if
shift_expr -> arith_expr << shift_expr
1461
and
shift_expr -> arith_expr << shift_expr
1461
|
shift_expr -> arith_expr << shift_expr
1461
from
shift_expr -> arith_expr << shift_expr
1461
!=
shift_expr -> arith_expr << shift_expr
1461
==
shift_expr -> arith_expr << shift_expr
1461
>=
shift_expr -> arith_expr << shift_expr
1462
>
atom -> ( test_list_comp )
1462
@
atom -> ( test_list_comp )
1462
&
atom -> ( test_list_comp )
1462
[
atom -> ( test_list_comp )
1462
if
atom -> ( test_list_comp )
1462
==
atom -> ( test_list_comp )
1462
>=
atom -> ( test_list_comp )
1462
NEWLINE
atom -> ( test_list_comp )
1462
**
atom -> ( test_list_comp )
1462
not
atom -> ( test_list_comp )
1462
<<
atom -> ( test_list_comp )
1462
>>
atom -> ( test_list_comp )
1462
in
atom -> ( test_list_comp )
1462
or
atom -> ( test_list_comp )
1462
.
atom -> ( test_list_comp )
1462
/
atom -> ( test_list_comp )
1462
^
atom -> ( test_list_comp )
1462
is
atom -> ( test_list_comp )
1462
from
atom -> ( test_list_comp )
1462
and
atom -> ( test_list_comp )
1462
//
atom -> ( test_list_comp )
1462
<
atom -> ( test_list_comp )
1462
*
atom -> ( test_list_comp )
1462
<=
atom -> ( test_list_comp )
1462
(
atom -> ( test_list_comp )
1462
-
atom -> ( test_list_comp )
1462
|
atom -> ( test_list_comp )
1462
!=
atom -> ( test_list_comp )
1462
+
atom -> ( test_list_comp )
1462
%
atom -> ( test_list_comp )
1463
if
or_test -> and_test or or_test
1463
NEWLINE
or_test -> and_test or or_test
1463
from
or_test -> and_test or or_test
1464
^
arith_expr -> term - arith_expr
1464
!=
arith_expr -> term - arith_expr
1464
<
arith_expr -> term - arith_expr
1464
in
arith_expr -> term - arith_expr
1464
==
arith_expr -> term - arith_expr
1464
|
arith_expr -> term - arith_expr
1464
is
arith_expr -> term - arith_expr
1464
&
arith_expr -> term - arith_expr
1464
from
arith_expr -> term - arith_expr
1464
>>
arith_expr -> term - arith_expr
1464
<<
arith_expr -> term - arith_expr
1464
and
arith_expr -> term - arith_expr
1464
>
arith_expr -> term - arith_expr
1464
if
arith_expr -> term - arith_expr
1464
NEWLINE
arith_expr -> term - arith_expr
1464
not
arith_expr -> term - arith_expr
1464
>=
arith_expr -> term - arith_expr
1464
<=
arith_expr -> term - arith_expr
1464
or
arith_expr -> term - arith_expr
1465
>=
arith_expr -> term + arith_expr
1465
>
arith_expr -> term + arith_expr
1465
^
arith_expr -> term + arith_expr
1465
or
arith_expr -> term + arith_expr
1465
==
arith_expr -> term + arith_expr
1465
<=
arith_expr -> term + arith_expr
1465
if
arith_expr -> term + arith_expr
1465
>>
arith_expr -> term + arith_expr
1465
<
arith_expr -> term + arith_expr
1465
from
arith_expr -> term + arith_expr
1465
not
arith_expr -> term + arith_expr
1465
&
arith_expr -> term + arith_expr
1465
in
arith_expr -> term + arith_expr
1465
and
arith_expr -> term + arith_expr
1465
|
arith_expr -> term + arith_expr
1465
!=
arith_expr -> term + arith_expr
1465
NEWLINE
arith_expr -> term + arith_expr
1465
<<
arith_expr -> term + arith_expr
1465
is
arith_expr -> term + arith_expr
1466
>=
expr -> xor_expr | expr
1466
or
expr -> xor_expr | expr
1466
from
expr -> xor_expr | expr
1466
in
expr -> xor_expr | expr
1466
NEWLINE
expr -> xor_expr | expr
1466
and
expr -> xor_expr | expr
1466
==
expr -> xor_expr | expr
1466
>
expr -> xor_expr | expr
1466
<=
expr -> xor_expr | expr
1466
is
expr -> xor_expr | expr
1466
<
expr -> xor_expr | expr
1466
if
expr -> xor_expr | expr
1466
not
expr -> xor_expr | expr
1466
!=
expr -> xor_expr | expr
1467
<
and_expr -> shift_expr & and_expr
1467
if
and_expr -> shift_expr & and_expr
1467
>=
and_expr -> shift_expr & and_expr
1467
NEWLINE
and_expr -> shift_expr & and_expr
1467
not
and_expr -> shift_expr & and_expr
1467
==
and_expr -> shift_expr & and_expr
1467
>
and_expr -> shift_expr & and_expr
1467
from
and_expr -> shift_expr & and_expr
1467
in
and_expr -> shift_expr & and_expr
1467
^
and_expr -> shift_expr & and_expr
1467
or
and_expr -> shift_expr & and_expr
1467
and
and_expr -> shift_expr & and_expr
1467
!=
and_expr -> shift_expr & and_expr
1467
|
and_expr -> shift_expr & and_expr
1467
is
and_expr -> shift_expr & and_expr
1467
<=
and_expr -> shift_expr & and_expr
1468
[
366
1468
atom_expr
367
1468
factor
368
1468
True
369
1468
~
370
1468
and_expr
371
1468
-
372
1468
None
373
1468
atom
374
1468
{
375
1468
expr
376
1468
arith_expr
377
1468
power
378
1468
STRING
379
1468
NAME
380
1468
(
381
1468
NUMBER
382
1468
and_test
383
1468
comparison
384
1468
term
385
1468
+
386
1468
xor_expr
387
1468
test
1907
1468
shift_expr
388
1468
lambda
389
1468
not
391
1468
False
392
1468
not_test
393
1468
lambdef
394
1468
or_test
395
1469
from
lambdef -> lambda : test
1469
NEWLINE
lambdef -> lambda : test
1470
NEWLINE
raise_stmt -> raise test from test
1471
from
and_test -> not_test and and_test
1471
NEWLINE
and_test -> not_test and and_test
1471
if
and_test -> not_test and and_test
1471
or
and_test -> not_test and and_test
1472
else
1908
1473
.
atom -> [ test_list_comp ]
1473
[
atom -> [ test_list_comp ]
1473
@
atom -> [ test_list_comp ]
1473
<=
atom -> [ test_list_comp ]
1473
<
atom -> [ test_list_comp ]
1473
not
atom -> [ test_list_comp ]
1473
in
atom -> [ test_list_comp ]
1473
and
atom -> [ test_list_comp ]
1473
-
atom -> [ test_list_comp ]
1473
if
atom -> [ test_list_comp ]
1473
!=
atom -> [ test_list_comp ]
1473
is
atom -> [ test_list_comp ]
1473
>>
atom -> [ test_list_comp ]
1473
or
atom -> [ test_list_comp ]
1473
//
atom -> [ test_list_comp ]
1473
/
atom -> [ test_list_comp ]
1473
|
atom -> [ test_list_comp ]
1473
>
atom -> [ test_list_comp ]
1473
NEWLINE
atom -> [ test_list_comp ]
1473
&
atom -> [ test_list_comp ]
1473
(
atom -> [ test_list_comp ]
1473
%
atom -> [ test_list_comp ]
1473
>=
atom -> [ test_list_comp ]
1473
==
atom -> [ test_list_comp ]
1473
**
atom -> [ test_list_comp ]
1473
<<
atom -> [ test_list_comp ]
1473
^
atom -> [ test_list_comp ]
1473
+
atom -> [ test_list_comp ]
1473
*
atom -> [ test_list_comp ]
1474
<<
term -> factor @ term
1474
^
term -> factor @ term
1474
<=
term -> factor @ term
1474
==
term -> factor @ term
1474
if
term -> factor @ term
1474
|
term -> factor @ term
1474
NEWLINE
term -> factor @ term
1474
!=
term -> factor @ term
1474
or
term -> factor @ term
1474
>
term -> factor @ term
1474
and
term -> factor @ term
1474
>>
term -> factor @ term
1474
is
term -> factor @ term
1474
-
term -> factor @ term
1474
not
term -> factor @ term
1474
+
term -> factor @ term
1474
in
term -> factor @ term
1474
>=
term -> factor @ term
1474
<
term -> factor @ term
1474
&
term -> factor @ term
1475
<=
term -> factor % term
1475
is
term -> factor % term
1475
>
term -> factor % term
1475
and
term -> factor % term
1475
in
term -> factor % term
1475
or
term -> factor % term
1475
<
term -> factor % term
1475
-
term -> factor % term
1475
NEWLINE
term -> factor % term
1475
!=
term -> factor % term
1475
>>
term -> factor % term
1475
^
term -> factor % term
1475
+
term -> factor % term
1475
if
term -> factor % term
1475
<<
term -> factor % term
1475
>=
term -> factor % term
1475
==
term -> factor % term
1475
not
term -> factor % term
1475
|
term -> factor % term
1475
&
term -> factor % term
1476
>>
term -> factor / term
1476
!=
term -> factor / term
1476
<
term -> factor / term
1476
<=
term -> factor / term
1476
|
term -> factor / term
1476
is
term -> factor / term
1476
>=
term -> factor / term
1476
^
term -> factor / term
1476
&
term -> factor / term
1476
+
term -> factor / term
1476
NEWLINE
term -> factor / term
1476
<<
term -> factor / term
1476
and
term -> factor / term
1476
-
term -> factor / term
1476
in
term -> factor / term
1476
>
term -> factor / term
1476
or
term -> factor / term
1476
not
term -> factor / term
1476
==
term -> factor / term
1476
if
term -> factor / term
1477
is
term -> factor * term
1477
+
term -> factor * term
1477
>=
term -> factor * term
1477
^
term -> factor * term
1477
NEWLINE
term -> factor * term
1477
<=
term -> factor * term
1477
or
term -> factor * term
1477
<
term -> factor * term
1477
|
term -> factor * term
1477
>>
term -> factor * term
1477
in
term -> factor * term
1477
not
term -> factor * term
1477
==
term -> factor * term
1477
-
term -> factor * term
1477
and
term -> factor * term
1477
!=
term -> factor * term
1477
<<
term -> factor * term
1477
>
term -> factor * term
1477
if
term -> factor * term
1477
&
term -> factor * term
1478
!=
term -> factor // term
1478
or
term -> factor // term
1478
^
term -> factor // term
1478
>
term -> factor // term
1478
is
term -> factor // term
1478
&
term -> factor // term
1478
-
term -> factor // term
1478
in
term -> factor // term
1478
>>
term -> factor // term
1478
|
term -> factor // term
1478
<
term -> factor // term
1478
>=
term -> factor // term
1478
not
term -> factor // term
1478
if
term -> factor // term
1478
==
term -> factor // term
1478
NEWLINE
term -> factor // term
1478
<=
term -> factor // term
1478
and
term -> factor // term
1478
<<
term -> factor // term
1478
+
term -> factor // term
1479
!=
power -> atom_expr ** factor
1479
@
power -> atom_expr ** factor
1479
|
power -> atom_expr ** factor
1479
in
power -> atom_expr ** factor
1479
==
power -> atom_expr ** factor
1479
if
power -> atom_expr ** factor
1479
NEWLINE
power -> atom_expr ** factor
1479
and
power -> atom_expr ** factor
1479
>=
power -> atom_expr ** factor
1479
/
power -> atom_expr ** factor
1479
not
power -> atom_expr ** factor
1479
^
power -> atom_expr ** factor
1479
//
power -> atom_expr ** factor
1479
>
power -> atom_expr ** factor
1479
+
power -> atom_expr ** factor
1479
%
power -> atom_expr ** factor
1479
-
power -> atom_expr ** factor
1479
is
power -> atom_expr ** factor
1479
<=
power -> atom_expr ** factor
1479
<
power -> atom_expr ** factor
1479
*
power -> atom_expr ** factor
1479
<<
power -> atom_expr ** factor
1479
or
power -> atom_expr ** factor
1479
>>
power -> atom_expr ** factor
1479
&
power -> atom_expr ** factor
1480
not
xor_expr -> and_expr ^ xor_expr
1480
<
xor_expr -> and_expr ^ xor_expr
1480
>=
xor_expr -> and_expr ^ xor_expr
1480
>
xor_expr -> and_expr ^ xor_expr
1480
is
xor_expr -> and_expr ^ xor_expr
1480
!=
xor_expr -> and_expr ^ xor_expr
1480
and
xor_expr -> and_expr ^ xor_expr
1480
if
xor_expr -> and_expr ^ xor_expr
1480
<=
xor_expr -> and_expr ^ xor_expr
1480
in
xor_expr -> and_expr ^ xor_expr
1480
==
xor_expr -> and_expr ^ xor_expr
1480
|
xor_expr -> and_expr ^ xor_expr
1480
or
xor_expr -> and_expr ^ xor_expr
1480
NEWLINE
xor_expr -> and_expr ^ xor_expr
1481
+
trailer -> ( )
1481
!=
trailer -> ( )
1481
<<
trailer -> ( )
1481
>=
trailer -> ( )
1481
**
trailer -> ( )
1481
not
trailer -> ( )
1481
if
trailer -> ( )
1481
|
trailer -> ( )
1481
[
trailer -> ( )
1481
==
trailer -> ( )
1481
%
trailer -> ( )
1481
*
trailer -> ( )
1481
>>
trailer -> ( )
1481
@
trailer -> ( )
1481
>
trailer -> ( )
1481
/
trailer -> ( )
1481
in
trailer -> ( )
1481
(
trailer -> ( )
1481
is
trailer -> ( )
1481
//
trailer -> ( )
1481
<
trailer -> ( )
1481
NEWLINE
trailer -> ( )
1481
or
trailer -> ( )
1481
^
trailer -> ( )
1481
and
trailer -> ( )
1481
<=
trailer -> ( )
1481
.
trailer -> ( )
1481
-
trailer -> ( )
1481
&
trailer -> ( )
1482
)
1909
1483
<=
trailer_expr -> trailer trailer_expr
1483
+
trailer_expr -> trailer trailer_expr
1483
^
trailer_expr -> trailer trailer_expr
1483
or
trailer_expr -> trailer trailer_expr
1483
==
trailer_expr -> trailer trailer_expr
1483
%
trailer_expr -> trailer trailer_expr
1483
@
trailer_expr -> trailer trailer_expr
1483
not
trailer_expr -> trailer trailer_expr
1483
<<
trailer_expr -> trailer trailer_expr
1483
-
trailer_expr -> trailer trailer_expr
1483
//
trailer_expr -> trailer trailer_expr
1483
and
trailer_expr -> trailer trailer_expr
1483
|
trailer_expr -> trailer trailer_expr
1483
if
trailer_expr -> trailer trailer_expr
1483
>
trailer_expr -> trailer trailer_expr
1483
!=
trailer_expr -> trailer trailer_expr
1483
<
trailer_expr -> trailer trailer_expr
1483
>>
trailer_expr -> trailer trailer_expr
1483
/
trailer_expr -> trailer trailer_expr
1483
is
trailer_expr -> trailer trailer_expr
1483
NEWLINE
trailer_expr -> trailer trailer_expr
1483
&
trailer_expr -> trailer trailer_expr
1483
in
trailer_expr -> trailer trailer_expr
1483
>=
trailer_expr -> trailer trailer_expr
1483
*
trailer_expr -> trailer trailer_expr
1483
**
trailer_expr -> trailer trailer_expr
1484
.
trailer -> . NAME
1484
not
trailer -> . NAME
1484
if
trailer -> . NAME
1484
NEWLINE
trailer -> . NAME
1484
**
trailer -> . NAME
1484
|
trailer -> . NAME
1484
-
trailer -> . NAME
1484
(
trailer -> . NAME
1484
%
trailer -> . NAME
1484
//
trailer -> . NAME
1484
==
trailer -> . NAME
1484
>>
trailer -> . NAME
1484
is
trailer -> . NAME
1484
!=
trailer -> . NAME
1484
and
trailer -> . NAME
1484
>=
trailer -> . NAME
1484
>
trailer -> . NAME
1484
in
trailer -> . NAME
1484
<<
trailer -> . NAME
1484
&
trailer -> . NAME
1484
/
trailer -> . NAME
1484
^
trailer -> . NAME
1484
[
trailer -> . NAME
1484
<=
trailer -> . NAME
1484
or
trailer -> . NAME
1484
+
trailer -> . NAME
1484
<
trailer -> . NAME
1484
*
trailer -> . NAME
1484
@
trailer -> . NAME
1485
]
1910
1486
==
shift_expr -> arith_expr >> shift_expr
1486
^
shift_expr -> arith_expr >> shift_expr
1486
or
shift_expr -> arith_expr >> shift_expr
1486
if
shift_expr -> arith_expr >> shift_expr
1486
not
shift_expr -> arith_expr >> shift_expr
1486
|
shift_expr -> arith_expr >> shift_expr
1486
<=
shift_expr -> arith_expr >> shift_expr
1486
is
shift_expr -> arith_expr >> shift_expr
1486
in
shift_expr -> arith_expr >> shift_expr
1486
>=
shift_expr -> arith_expr >> shift_expr
1486
NEWLINE
shift_expr -> arith_expr >> shift_expr
1486
>
shift_expr -> arith_expr >> shift_expr
1486
&
shift_expr -> arith_expr >> shift_expr
1486
<
shift_expr -> arith_expr >> shift_expr
1486
and
shift_expr -> arith_expr >> shift_expr
1486
!=
shift_expr -> arith_expr >> shift_expr
1487
or
shift_expr -> arith_expr << shift_expr
1487
>
shift_expr -> arith_expr << shift_expr
1487
in
shift_expr -> arith_expr << shift_expr
1487
NEWLINE
shift_expr -> arith_expr << shift_expr
1487
&
shift_expr -> arith_expr << shift_expr
1487
is
shift_expr -> arith_expr << shift_expr
1487
<
shift_expr -> arith_expr << shift_expr
1487
<=
shift_expr -> arith_expr << shift_expr
1487
not
shift_expr -> arith_expr << shift_expr
1487
^
shift_expr -> arith_expr << shift_expr
1487
if
shift_expr -> arith_expr << shift_expr
1487
and
shift_expr -> arith_expr << shift_expr
1487
|
shift_expr -> arith_expr << shift_expr
1487
!=
shift_expr -> arith_expr << shift_expr
1487
==
shift_expr -> arith_expr << shift_expr
1487
>=
shift_expr -> arith_expr << shift_expr
1488
>
atom -> ( test_list_comp )
1488
@
atom -> ( test_list_comp )
1488
&
atom -> ( test_list_comp )
1488
[
atom -> ( test_list_comp )
1488
if
atom -> ( test_list_comp )
1488
==
atom -> ( test_list_comp )
1488
>=
atom -> ( test_list_comp )
1488
NEWLINE
atom -> ( test_list_comp )
1488
**
atom -> ( test_list_comp )
1488
not
atom -> ( test_list_comp )
1488
<<
atom -> ( test_list_comp )
1488
>>
atom -> ( test_list_comp )
1488
in
atom -> ( test_list_comp )
1488
or
atom -> ( test_list_comp )
1488
.
atom -> ( test_list_comp )
1488
/
atom -> ( test_list_comp )
1488
^
atom -> ( test_list_comp )
1488
is
atom -> ( test_list_comp )
1488
and
atom -> ( test_list_comp )
1488
//
atom -> ( test_list_comp )
1488
<
atom -> ( test_list_comp )
1488
*
atom -> ( test_list_comp )
1488
<=
atom -> ( test_list_comp )
1488
(
atom -> ( test_list_comp )
1488
-
atom -> ( test_list_comp )
1488
|
atom -> ( test_list_comp )
1488
!=
atom -> ( test_list_comp )
1488
+
atom -> ( test_list_comp )
1488
%
atom -> ( test_list_comp )
1489
if
or_test -> and_test or or_test
1489
NEWLINE
or_test -> and_test or or_test
1490
>
arith_expr -> term - arith_expr
1490
==
arith_expr -> term - arith_expr
1490
^
arith_expr -> term - arith_expr
1490
is
arith_expr -> term - arith_expr
1490
|
arith_expr -> term - arith_expr
1490
&
arith_expr -> term - arith_expr
1490
NEWLINE
arith_expr -> term - arith_expr
1490
if
arith_expr -> term - arith_expr
1490
<<
arith_expr -> term - arith_expr
1490
>>
arith_expr -> term - arith_expr
1490
!=
arith_expr -> term - arith_expr
1490
not
arith_expr -> term - arith_expr
1490
>=
arith_expr -> term - arith_expr
1490
and
arith_expr -> term - arith_expr
1490
<=
arith_expr -> term - arith_expr
1490
<
arith_expr -> term - arith_expr
1490
or
arith_expr -> term - arith_expr
1490
in
arith_expr -> term - arith_expr
1491
!=
arith_expr -> term + arith_expr
1491
>=
arith_expr -> term + arith_expr
1491
not
arith_expr -> term + arith_expr
1491
>
arith_expr -> term + arith_expr
1491
<
arith_expr -> term + arith_expr
1491
&
arith_expr -> term + arith_expr
1491
NEWLINE
arith_expr -> term + arith_expr
1491
^
arith_expr -> term + arith_expr
1491
>>
arith_expr -> term + arith_expr
1491
in
arith_expr -> term + arith_expr
1491
<<
arith_expr -> term + arith_expr
1491
or
arith_expr -> term + arith_expr
1491
is
arith_expr -> term + arith_expr
1491
and
arith_expr -> term + arith_expr
1491
==
arith_expr -> term + arith_expr
1491
<=
arith_expr -> term + arith_expr
1491
|
arith_expr -> term + arith_expr
1491
if
arith_expr -> term + arith_expr
1492
>=
expr -> xor_expr | expr
1492
or
expr -> xor_expr | expr
1492
in
expr -> xor_expr | expr
1492
NEWLINE
expr -> xor_expr | expr
1492
and
expr -> xor_expr | expr
1492
==
expr -> xor_expr | expr
1492
>
expr -> xor_expr | expr
1492
<=
expr -> xor_expr | expr
1492
is
expr -> xor_expr | expr
1492
<
expr -> xor_expr | expr
1492
if
expr -> xor_expr | expr
1492
not
expr -> xor_expr | expr
1492
!=
expr -> xor_expr | expr
1493
<
and_expr -> shift_expr & and_expr
1493
if
and_expr -> shift_expr & and_expr
1493
>=
and_expr -> shift_expr & and_expr
1493
NEWLINE
and_expr -> shift_expr & and_expr
1493
not
and_expr -> shift_expr & and_expr
1493
==
and_expr -> shift_expr & and_expr
1493
>
and_expr -> shift_expr & and_expr
1493
in
and_expr -> shift_expr & and_expr
1493
^
and_expr -> shift_expr & and_expr
1493
or
and_expr -> shift_expr & and_expr
1493
and
and_expr -> shift_expr & and_expr
1493
!=
and_expr -> shift_expr & and_expr
1493
|
and_expr -> shift_expr & and_expr
1493
is
and_expr -> shift_expr & and_expr
1493
<=
and_expr -> shift_expr & and_expr
1494
NEWLINE
lambdef -> lambda : test
1495
[
397
1495
factor
398
1495
True
399
1495
atom_expr
400
1495
~
401
1495
and_expr
402
1495
-
403
1495
None
404
1495
atom
405
1495
{
406
1495
arith_expr
407
1495
power
408
1495
STRING
409
1495
NAME
410
1495
(
411
1495
NUMBER
412
1495
and_test
413
1495
term
414
1495
+
415
1495
xor_expr
416
1495
shift_expr
417
1495
not
418
1495
False
419
1495
lambda
420
1495
comparison
421
1495
not_test
422
1495
lambdef
423
1495
expr
424
1495
test
1911
1495
or_test
425
1496
NEWLINE
and_test -> not_test and and_test
1496
if
and_test -> not_test and and_test
1496
or
and_test -> not_test and and_test
1497
NEWLINE
comparison -> expr comp_op comparison
1497
and
comparison -> expr comp_op comparison
1497
or
comparison -> expr comp_op comparison
1497
if
comparison -> expr comp_op comparison
1498
else
1912
1499
NEWLINE
namelist -> NAME , namelist
1500
:
1913
1501
:
1914
1502
[
166
1502
factor
167
1502
True
168
1502
atom_expr
169
1502
~
170
1502
not
171
1502
and_expr
172
1502
-
173
1502
{
174
1502
shift_expr
175
1502
atom
176
1502
]
1915
1502
comparison
178
1502
(
179
1502
arith_expr
180
1502
power
181
1502
STRING
182
1502
NAME
183
1502
test
184
1502
and_test
185
1502
term
186
1502
+
187
1502
xor_expr
188
1502
NUMBER
190
1502
test_list_comp
1916
1502
False
191
1502
expr
192
1502
not_test
193
1502
None
194
1502
lambdef
195
1502
lambda
196
1502
or_test
197
1502
test_list
198
1503
as
1917
1503
:
1918
1504
not
term -> factor
1504
@
1919
1504
%
1920
1504
/
1921
1504
*
1922
1504
as
term -> factor
1504
//
1923
1504
<=
term -> factor
1504
>
term -> factor
1504
==
term -> factor
1504
is
term -> factor
1504
or
term -> factor
1504
<
term -> factor
1504
and
term -> factor
1504
<<
term -> factor
1504
^
term -> factor
1504
:
term -> factor
1504
!=
term -> factor
1504
-
term -> factor
1504
&
term -> factor
1504
|
term -> factor
1504
>=
term -> factor
1504
if
term -> factor
1504
+
term -> factor
1504
in
term -> factor
1504
>>
term -> factor
1505
<<
atom -> True
1505
as
atom -> True
1505
&
atom -> True
1505
or
atom -> True
1505
[
atom -> True
1505
if
atom -> True
1505
:
atom -> True
1505
-
atom -> True
1505
*
atom -> True
1505
^
atom -> True
1505
>=
atom -> True
1505
!=
atom -> True
1505
(
atom -> True
1505
not
atom -> True
1505
|
atom -> True
1505
+
atom -> True
1505
**
atom -> True
1505
.
atom -> True
1505
is
atom -> True
1505
//
atom -> True
1505
>
atom -> True
1505
%
atom -> True
1505
in
atom -> True
1505
<=
atom -> True
1505
>>
atom -> True
1505
/
atom -> True
1505
==
atom -> True
1505
and
atom -> True
1505
<
atom -> True
1505
@
atom -> True
1506
**
1924
1506
!=
power -> atom_expr
1506
-
power -> atom_expr
1506
<<
power -> atom_expr
1506
:
power -> atom_expr
1506
/
power -> atom_expr
1506
<=
power -> atom_expr
1506
in
power -> atom_expr
1506
not
power -> atom_expr
1506
%
power -> atom_expr
1506
>
power -> atom_expr
1506
@
power -> atom_expr
1506
|
power -> atom_expr
1506
<
power -> atom_expr
1506
>>
power -> atom_expr
1506
or
power -> atom_expr
1506
and
power -> atom_expr
1506
>=
power -> atom_expr
1506
==
power -> atom_expr
1506
^
power -> atom_expr
1506
*
power -> atom_expr
1506
as
power -> atom_expr
1506
&
power -> atom_expr
1506
is
power -> atom_expr
1506
+
power -> atom_expr
1506
if
power -> atom_expr
1506
//
power -> atom_expr
1507
[
1502
1507
True
1505
1507
atom_expr
1506
1507
-
1509
1507
~
1507
1507
atom
1510
1507
{
1511
1507
power
1514
1507
STRING
1515
1507
NAME
1516
1507
(
1519
1507
+
1522
1507
NUMBER
1524
1507
False
1526
1507
factor
1925
1507
None
1530
1508
>
xor_expr -> and_expr
1508
<=
xor_expr -> and_expr
1508
not
xor_expr -> and_expr
1508
|
xor_expr -> and_expr
1508
^
1926
1508
==
xor_expr -> and_expr
1508
in
xor_expr -> and_expr
1508
!=
xor_expr -> and_expr
1508
:
xor_expr -> and_expr
1508
if
xor_expr -> and_expr
1508
is
xor_expr -> and_expr
1508
<
xor_expr -> and_expr
1508
or
xor_expr -> and_expr
1508
as
xor_expr -> and_expr
1508
and
xor_expr -> and_expr
1508
>=
xor_expr -> and_expr
1509
[
1502
1509
True
1505
1509
atom_expr
1506
1509
~
1507
1509
-
1509
1509
atom
1510
1509
{
1511
1509
power
1514
1509
STRING
1515
1509
NAME
1516
1509
(
1519
1509
factor
1927
1509
+
1522
1509
NUMBER
1524
1509
False
1526
1509
None
1530
1510
>>
trailer_expr -> 
1510
(
1928
1510
trailer
1929
1510
trailer_expr
1930
1510
.
1931
1510
+
trailer_expr -> 
1510
is
trailer_expr -> 
1510
>
trailer_expr -> 
1510
not
trailer_expr -> 
1510
|
trailer_expr -> 
1510
[
1932
1510
&
trailer_expr -> 
1510
/
trailer_expr -> 
1510
@
trailer_expr -> 
1510
!=
trailer_expr -> 
1510
**
trailer_expr -> 
1510
>=
trailer_expr -> 
1510
^
trailer_expr -> 
1510
in
trailer_expr -> 
1510
<<
trailer_expr -> 
1510
and
trailer_expr -> 
1510
or
trailer_expr -> 
1510
as
trailer_expr -> 
1510
if
trailer_expr -> 
1510
:
trailer_expr -> 
1510
//
trailer_expr -> 
1510
%
trailer_expr -> 
1510
<=
trailer_expr -> 
1510
<
trailer_expr -> 
1510
==
trailer_expr -> 
1510
-
trailer_expr -> 
1510
*
trailer_expr -> 
1511
}
1933
1512
if
1934
1512
as
test -> or_test
1512
:
test -> or_test
1513
>>
1935
1513
if
shift_expr -> arith_expr
1513
&
shift_expr -> arith_expr
1513
<<
1936
1513
|
shift_expr -> arith_expr
1513
is
shift_expr -> arith_expr
1513
<
shift_expr -> arith_expr
1513
==
shift_expr -> arith_expr
1513
as
shift_expr -> arith_expr
1513
or
shift_expr -> arith_expr
1513
>
shift_expr -> arith_expr
1513
!=
shift_expr -> arith_expr
1513
>=
shift_expr -> arith_expr
1513
in
shift_expr -> arith_expr
1513
<=
shift_expr -> arith_expr
1513
:
shift_expr -> arith_expr
1513
and
shift_expr -> arith_expr
1513
^
shift_expr -> arith_expr
1513
not
shift_expr -> arith_expr
1514
+
factor -> power
1514
%
factor -> power
1514
:
factor -> power
1514
<
factor -> power
1514
<<
factor -> power
1514
!=
factor -> power
1514
<=
factor -> power
1514
and
factor -> power
1514
/
factor -> power
1514
^
factor -> power
1514
@
factor -> power
1514
>=
factor -> power
1514
not
factor -> power
1514
//
factor -> power
1514
or
factor -> power
1514
==
factor -> power
1514
is
factor -> power
1514
as
factor -> power
1514
|
factor -> power
1514
*
factor -> power
1514
-
factor -> power
1514
if
factor -> power
1514
>
factor -> power
1514
in
factor -> power
1514
>>
factor -> power
1514
&
factor -> power
1515
%
atom -> STRING
1515
>
atom -> STRING
1515
@
atom -> STRING
1515
<<
atom -> STRING
1515
as
atom -> STRING
1515
in
atom -> STRING
1515
[
atom -> STRING
1515
-
atom -> STRING
1515
==
atom -> STRING
1515
>=
atom -> STRING
1515
not
atom -> STRING
1515
/
atom -> STRING
1515
+
atom -> STRING
1515
*
atom -> STRING
1515
(
atom -> STRING
1515
//
atom -> STRING
1515
if
atom -> STRING
1515
.
atom -> STRING
1515
<
atom -> STRING
1515
&
atom -> STRING
1515
<=
atom -> STRING
1515
!=
atom -> STRING
1515
**
atom -> STRING
1515
^
atom -> STRING
1515
:
atom -> STRING
1515
and
atom -> STRING
1515
is
atom -> STRING
1515
|
atom -> STRING
1515
or
atom -> STRING
1515
>>
atom -> STRING
1516
<
atom -> NAME
1516
^
atom -> NAME
1516
+
atom -> NAME
1516
-
atom -> NAME
1516
>=
atom -> NAME
1516
@
atom -> NAME
1516
!=
atom -> NAME
1516
*
atom -> NAME
1516
<=
atom -> NAME
1516
**
atom -> NAME
1516
or
atom -> NAME
1516
not
atom -> NAME
1516
==
atom -> NAME
1516
&
atom -> NAME
1516
>
atom -> NAME
1516
>>
atom -> NAME
1516
%
atom -> NAME
1516
.
atom -> NAME
1516
|
atom -> NAME
1516
is
atom -> NAME
1516
and
atom -> NAME
1516
//
atom -> NAME
1516
[
atom -> NAME
1516
/
atom -> NAME
1516
as
atom -> NAME
1516
(
atom -> NAME
1516
<<
atom -> NAME
1516
if
atom -> NAME
1516
in
atom -> NAME
1516
:
atom -> NAME
1517
^
and_expr -> shift_expr
1517
in
and_expr -> shift_expr
1517
|
and_expr -> shift_expr
1517
&
1937
1517
<
and_expr -> shift_expr
1517
not
and_expr -> shift_expr
1517
>=
and_expr -> shift_expr
1517
<=
and_expr -> shift_expr
1517
or
and_expr -> shift_expr
1517
and
and_expr -> shift_expr
1517
:
and_expr -> shift_expr
1517
!=
and_expr -> shift_expr
1517
as
and_expr -> shift_expr
1517
if
and_expr -> shift_expr
1517
is
and_expr -> shift_expr
1517
==
and_expr -> shift_expr
1517
>
and_expr -> shift_expr
1518
arith_expr
1
1518
small_stmt
1938
1518
factor
17
1518
True
38
1518
atom_expr
31
1518
term
22
1518
-
26
1518
None
55
1518
atom
57
1518
test
5
1518
comparison
49
1518
and_expr
8
1518
power
9
1518
STRING
10
1518
NAME
52
1518
shift_expr
48
1518
NEWLINE
1939
1518
lambdef
15
1518
NUMBER
58
1518
simple_stmt
1940
1518
(
16
1518
expr
47
1518
[
18
1518
not_test
32
1518
{
21
1518
and_test
46
1518
+
27
1518
lambda
29
1518
xor_expr
41
1518
yield
34
1518
suite
1941
1518
not
62
1518
test_list
36
1518
~
37
1518
or_test
53
1518
False
39
1518
sim_stmt
45
1518
nonlocal
72
1518
nonlocal_stmt
73
1518
return
59
1518
break_stmt
60
1518
return_stmt
61
1518
raise_stmt
74
1518
break
63
1518
yield_stmt
75
1518
raise
64
1518
continue
77
1518
expr_stmt
65
1518
endsim
78
1518
del
80
1518
pass_stmt
81
1518
flow_stmt
82
1518
stat_stmt
66
1518
assert_stmt
68
1518
resetstats
84
1518
del_stmt
85
1518
continue_stmt
86
1518
begsim
69
1518
global_stmt
87
1518
pass
88
1518
global
70
1518
assert
71
1519
[
128
1519
factor
129
1519
True
130
1519
atom_expr
131
1519
~
132
1519
and_expr
133
1519
-
134
1519
{
135
1519
test_list_comp
1942
1519
shift_expr
137
1519
atom
138
1519
)
1943
1519
comparison
140
1519
arith_expr
141
1519
power
142
1519
STRING
143
1519
NAME
144
1519
(
145
1519
and_test
146
1519
term
147
1519
+
148
1519
xor_expr
149
1519
or_test
150
1519
NUMBER
151
1519
not
152
1519
False
153
1519
expr
154
1519
not_test
155
1519
None
156
1519
lambdef
157
1519
lambda
158
1519
test
159
1519
test_list
160
1520
as
or_test -> and_test
1520
or
1944
1520
:
or_test -> and_test
1520
if
or_test -> and_test
1521
-
1945
1521
+
1946
1521
>=
arith_expr -> term
1521
|
arith_expr -> term
1521
<=
arith_expr -> term
1521
not
arith_expr -> term
1521
==
arith_expr -> term
1521
in
arith_expr -> term
1521
>>
arith_expr -> term
1521
is
arith_expr -> term
1521
if
arith_expr -> term
1521
or
arith_expr -> term
1521
as
arith_expr -> term
1521
!=
arith_expr -> term
1521
>
arith_expr -> term
1521
:
arith_expr -> term
1521
and
arith_expr -> term
1521
<<
arith_expr -> term
1521
<
arith_expr -> term
1521
^
arith_expr -> term
1521
&
arith_expr -> term
1522
[
1502
1522
True
1505
1522
atom_expr
1506
1522
-
1509
1522
~
1507
1522
atom
1510
1522
{
1511
1522
power
1514
1522
STRING
1515
1522
NAME
1516
1522
(
1519
1522
factor
1947
1522
+
1522
1522
NUMBER
1524
1522
False
1526
1522
None
1530
1523
|
1948
1523
>
expr -> xor_expr
1523
if
expr -> xor_expr
1523
is
expr -> xor_expr
1523
and
expr -> xor_expr
1523
not
expr -> xor_expr
1523
or
expr -> xor_expr
1523
>=
expr -> xor_expr
1523
==
expr -> xor_expr
1523
:
expr -> xor_expr
1523
as
expr -> xor_expr
1523
<
expr -> xor_expr
1523
!=
expr -> xor_expr
1523
<=
expr -> xor_expr
1523
in
expr -> xor_expr
1524
+
atom -> NUMBER
1524
*
atom -> NUMBER
1524
>
atom -> NUMBER
1524
<<
atom -> NUMBER
1524
-
atom -> NUMBER
1524
**
atom -> NUMBER
1524
if
atom -> NUMBER
1524
or
atom -> NUMBER
1524
is
atom -> NUMBER
1524
as
atom -> NUMBER
1524
[
atom -> NUMBER
1524
(
atom -> NUMBER
1524
not
atom -> NUMBER
1524
&
atom -> NUMBER
1524
^
atom -> NUMBER
1524
in
atom -> NUMBER
1524
==
atom -> NUMBER
1524
//
atom -> NUMBER
1524
!=
atom -> NUMBER
1524
and
atom -> NUMBER
1524
%
atom -> NUMBER
1524
<=
atom -> NUMBER
1524
.
atom -> NUMBER
1524
<
atom -> NUMBER
1524
>>
atom -> NUMBER
1524
/
atom -> NUMBER
1524
@
atom -> NUMBER
1524
>=
atom -> NUMBER
1524
|
atom -> NUMBER
1524
:
atom -> NUMBER
1525
[
1502
1525
factor
1504
1525
True
1505
1525
atom_expr
1506
1525
~
1507
1525
and_expr
1508
1525
-
1509
1525
atom
1510
1525
{
1511
1525
arith_expr
1513
1525
power
1514
1525
STRING
1515
1525
NAME
1516
1525
shift_expr
1517
1525
(
1519
1525
term
1521
1525
+
1522
1525
xor_expr
1523
1525
NUMBER
1524
1525
not
1525
1525
False
1526
1525
expr
1527
1525
comparison
1529
1525
not_test
1949
1525
None
1530
1526
(
atom -> False
1526
*
atom -> False
1526
==
atom -> False
1526
as
atom -> False
1526
|
atom -> False
1526
[
atom -> False
1526
in
atom -> False
1526
&
atom -> False
1526
is
atom -> False
1526
not
atom -> False
1526
if
atom -> False
1526
^
atom -> False
1526
+
atom -> False
1526
>
atom -> False
1526
<=
atom -> False
1526
<<
atom -> False
1526
<
atom -> False
1526
>=
atom -> False
1526
:
atom -> False
1526
%
atom -> False
1526
@
atom -> False
1526
and
atom -> False
1526
!=
atom -> False
1526
-
atom -> False
1526
.
atom -> False
1526
//
atom -> False
1526
/
atom -> False
1526
**
atom -> False
1526
>>
atom -> False
1526
or
atom -> False
1527
>
317
1527
is
318
1527
in
319
1527
<=
320
1527
<
321
1527
>=
322
1527
:
comparison -> expr
1527
!=
324
1527
not
325
1527
==
326
1527
comp_op
1950
1527
or
comparison -> expr
1527
if
comparison -> expr
1527
as
comparison -> expr
1527
and
comparison -> expr
1528
and
1951
1528
:
and_test -> not_test
1528
if
and_test -> not_test
1528
as
and_test -> not_test
1528
or
and_test -> not_test
1529
or
not_test -> comparison
1529
:
not_test -> comparison
1529
and
not_test -> comparison
1529
if
not_test -> comparison
1529
as
not_test -> comparison
1530
@
atom -> None
1530
<=
atom -> None
1530
in
atom -> None
1530
and
atom -> None
1530
&
atom -> None
1530
|
atom -> None
1530
>
atom -> None
1530
>=
atom -> None
1530
/
atom -> None
1530
<<
atom -> None
1530
-
atom -> None
1530
!=
atom -> None
1530
**
atom -> None
1530
(
atom -> None
1530
*
atom -> None
1530
.
atom -> None
1530
as
atom -> None
1530
>>
atom -> None
1530
==
atom -> None
1530
is
atom -> None
1530
<
atom -> None
1530
if
atom -> None
1530
^
atom -> None
1530
[
atom -> None
1530
%
atom -> None
1530
+
atom -> None
1530
not
atom -> None
1530
:
atom -> None
1530
or
atom -> None
1530
//
atom -> None
1531
:
test -> lambdef
1531
as
test -> lambdef
1532
vfpdef
234
1532
:
1952
1532
NAME
233
1532
varargslist
1953
1533
:
1954
1534
NAME
1955
1535
yield
stmt -> compound_stmt
1535
modopt
stmt -> compound_stmt
1535
try
stmt -> compound_stmt
1535
-
stmt -> compound_stmt
1535
STRING
stmt -> compound_stmt
1535
begsim
stmt -> compound_stmt
1535
{
stmt -> compound_stmt
1535
True
stmt -> compound_stmt
1535
nonlocal
stmt -> compound_stmt
1535
resetstats
stmt -> compound_stmt
1535
NAME
stmt -> compound_stmt
1535
~
stmt -> compound_stmt
1535
server
stmt -> compound_stmt
1535
lambda
stmt -> compound_stmt
1535
def
stmt -> compound_stmt
1535
servmod
stmt -> compound_stmt
1535
not
stmt -> compound_stmt
1535
NUMBER
stmt -> compound_stmt
1535
DEDENT
stmt -> compound_stmt
1535
global
stmt -> compound_stmt
1535
conf
stmt -> compound_stmt
1535
break
stmt -> compound_stmt
1535
if
stmt -> compound_stmt
1535
(
stmt -> compound_stmt
1535
assert
stmt -> compound_stmt
1535
class
stmt -> compound_stmt
1535
del
stmt -> compound_stmt
1535
pass
stmt -> compound_stmt
1535
False
stmt -> compound_stmt
1535
continue
stmt -> compound_stmt
1535
raise
stmt -> compound_stmt
1535
[
stmt -> compound_stmt
1535
return
stmt -> compound_stmt
1535
for
stmt -> compound_stmt
1535
with
stmt -> compound_stmt
1535
while
stmt -> compound_stmt
1535
None
stmt -> compound_stmt
1535
@
stmt -> compound_stmt
1535
+
stmt -> compound_stmt
1535
endsim
stmt -> compound_stmt
1536
NAME
1956
1537
[
95
1537
factor
96
1537
True
97
1537
atom_expr
98
1537
~
99
1537
and_expr
100
1537
-
101
1537
atom
102
1537
{
103
1537
or_test
104
1537
arith_expr
105
1537
power
106
1537
STRING
107
1537
NAME
108
1537
(
109
1537
and_test
110
1537
term
111
1537
+
112
1537
xor_expr
113
1537
test
1957
1537
shift_expr
115
1537
NUMBER
116
1537
not
117
1537
False
118
1537
expr
119
1537
not_test
120
1537
comparison
121
1537
None
122
1537
lambdef
123
1537
lambda
124
1538
DEDENT
compound_stmt -> decorated
1538
assert
compound_stmt -> decorated
1538
global
compound_stmt -> decorated
1538
conf
compound_stmt -> decorated
1538
nonlocal
compound_stmt -> decorated
1538
modopt
compound_stmt -> decorated
1538
servmod
compound_stmt -> decorated
1538
@
compound_stmt -> decorated
1538
STRING
compound_stmt -> decorated
1538
while
compound_stmt -> decorated
1538
return
compound_stmt -> decorated
1538
del
compound_stmt -> decorated
1538
def
compound_stmt -> decorated
1538
server
compound_stmt -> decorated
1538
resetstats
compound_stmt -> decorated
1538
True
compound_stmt -> decorated
1538
[
compound_stmt -> decorated
1538
(
compound_stmt -> decorated
1538
NAME
compound_stmt -> decorated
1538
raise
compound_stmt -> decorated
1538
try
compound_stmt -> decorated
1538
~
compound_stmt -> decorated
1538
with
compound_stmt -> decorated
1538
{
compound_stmt -> decorated
1538
-
compound_stmt -> decorated
1538
begsim
compound_stmt -> decorated
1538
NUMBER
compound_stmt -> decorated
1538
None
compound_stmt -> decorated
1538
+
compound_stmt -> decorated
1538
continue
compound_stmt -> decorated
1538
False
compound_stmt -> decorated
1538
endsim
compound_stmt -> decorated
1538
not
compound_stmt -> decorated
1538
pass
compound_stmt -> decorated
1538
if
compound_stmt -> decorated
1538
break
compound_stmt -> decorated
1538
yield
compound_stmt -> decorated
1538
for
compound_stmt -> decorated
1538
lambda
compound_stmt -> decorated
1538
class
compound_stmt -> decorated
1539
conf
compound_stmt -> cli_serv_model
1539
NUMBER
compound_stmt -> cli_serv_model
1539
{
compound_stmt -> cli_serv_model
1539
+
compound_stmt -> cli_serv_model
1539
DEDENT
compound_stmt -> cli_serv_model
1539
modopt
compound_stmt -> cli_serv_model
1539
servmod
compound_stmt -> cli_serv_model
1539
continue
compound_stmt -> cli_serv_model
1539
lambda
compound_stmt -> cli_serv_model
1539
NAME
compound_stmt -> cli_serv_model
1539
endsim
compound_stmt -> cli_serv_model
1539
raise
compound_stmt -> cli_serv_model
1539
assert
compound_stmt -> cli_serv_model
1539
begsim
compound_stmt -> cli_serv_model
1539
pass
compound_stmt -> cli_serv_model
1539
nonlocal
compound_stmt -> cli_serv_model
1539
False
compound_stmt -> cli_serv_model
1539
yield
compound_stmt -> cli_serv_model
1539
global
compound_stmt -> cli_serv_model
1539
~
compound_stmt -> cli_serv_model
1539
del
compound_stmt -> cli_serv_model
1539
(
compound_stmt -> cli_serv_model
1539
resetstats
compound_stmt -> cli_serv_model
1539
True
compound_stmt -> cli_serv_model
1539
STRING
compound_stmt -> cli_serv_model
1539
@
compound_stmt -> cli_serv_model
1539
not
compound_stmt -> cli_serv_model
1539
with
compound_stmt -> cli_serv_model
1539
None
compound_stmt -> cli_serv_model
1539
server
compound_stmt -> cli_serv_model
1539
return
compound_stmt -> cli_serv_model
1539
while
compound_stmt -> cli_serv_model
1539
if
compound_stmt -> cli_serv_model
1539
[
compound_stmt -> cli_serv_model
1539
-
compound_stmt -> cli_serv_model
1539
class
compound_stmt -> cli_serv_model
1539
for
compound_stmt -> cli_serv_model
1539
try
compound_stmt -> cli_serv_model
1539
break
compound_stmt -> cli_serv_model
1539
def
compound_stmt -> cli_serv_model
1540
NUMBER
compound_stmt -> try_stmt
1540
for
compound_stmt -> try_stmt
1540
{
compound_stmt -> try_stmt
1540
NAME
compound_stmt -> try_stmt
1540
if
compound_stmt -> try_stmt
1540
yield
compound_stmt -> try_stmt
1540
def
compound_stmt -> try_stmt
1540
del
compound_stmt -> try_stmt
1540
assert
compound_stmt -> try_stmt
1540
@
compound_stmt -> try_stmt
1540
True
compound_stmt -> try_stmt
1540
servmod
compound_stmt -> try_stmt
1540
raise
compound_stmt -> try_stmt
1540
continue
compound_stmt -> try_stmt
1540
[
compound_stmt -> try_stmt
1540
not
compound_stmt -> try_stmt
1540
with
compound_stmt -> try_stmt
1540
begsim
compound_stmt -> try_stmt
1540
class
compound_stmt -> try_stmt
1540
resetstats
compound_stmt -> try_stmt
1540
STRING
compound_stmt -> try_stmt
1540
~
compound_stmt -> try_stmt
1540
DEDENT
compound_stmt -> try_stmt
1540
break
compound_stmt -> try_stmt
1540
server
compound_stmt -> try_stmt
1540
pass
compound_stmt -> try_stmt
1540
nonlocal
compound_stmt -> try_stmt
1540
try
compound_stmt -> try_stmt
1540
False
compound_stmt -> try_stmt
1540
+
compound_stmt -> try_stmt
1540
None
compound_stmt -> try_stmt
1540
(
compound_stmt -> try_stmt
1540
modopt
compound_stmt -> try_stmt
1540
global
compound_stmt -> try_stmt
1540
lambda
compound_stmt -> try_stmt
1540
endsim
compound_stmt -> try_stmt
1540
-
compound_stmt -> try_stmt
1540
return
compound_stmt -> try_stmt
1540
conf
compound_stmt -> try_stmt
1540
while
compound_stmt -> try_stmt
1541
NAME
1958
1542
NEWLINE
1959
1543
NAME
1960
1544
NAME
1961
1545
global
compound_stmt -> while_stmt
1545
modopt
compound_stmt -> while_stmt
1545
[
compound_stmt -> while_stmt
1545
servmod
compound_stmt -> while_stmt
1545
NUMBER
compound_stmt -> while_stmt
1545
True
compound_stmt -> while_stmt
1545
try
compound_stmt -> while_stmt
1545
pass
compound_stmt -> while_stmt
1545
break
compound_stmt -> while_stmt
1545
{
compound_stmt -> while_stmt
1545
False
compound_stmt -> while_stmt
1545
return
compound_stmt -> while_stmt
1545
conf
compound_stmt -> while_stmt
1545
def
compound_stmt -> while_stmt
1545
DEDENT
compound_stmt -> while_stmt
1545
if
compound_stmt -> while_stmt
1545
yield
compound_stmt -> while_stmt
1545
raise
compound_stmt -> while_stmt
1545
STRING
compound_stmt -> while_stmt
1545
NAME
compound_stmt -> while_stmt
1545
lambda
compound_stmt -> while_stmt
1545
for
compound_stmt -> while_stmt
1545
-
compound_stmt -> while_stmt
1545
not
compound_stmt -> while_stmt
1545
@
compound_stmt -> while_stmt
1545
endsim
compound_stmt -> while_stmt
1545
(
compound_stmt -> while_stmt
1545
assert
compound_stmt -> while_stmt
1545
while
compound_stmt -> while_stmt
1545
begsim
compound_stmt -> while_stmt
1545
del
compound_stmt -> while_stmt
1545
class
compound_stmt -> while_stmt
1545
with
compound_stmt -> while_stmt
1545
~
compound_stmt -> while_stmt
1545
continue
compound_stmt -> while_stmt
1545
server
compound_stmt -> while_stmt
1545
None
compound_stmt -> while_stmt
1545
resetstats
compound_stmt -> while_stmt
1545
nonlocal
compound_stmt -> while_stmt
1545
+
compound_stmt -> while_stmt
1546
[
208
1546
{
209
1546
factor
210
1546
expr_list
1962
1546
True
212
1546
~
213
1546
and_expr
214
1546
arith_expr
215
1546
shift_expr
216
1546
atom
217
1546
STRING
218
1546
power
219
1546
NAME
220
1546
(
221
1546
+
222
1546
term
223
1546
None
224
1546
False
225
1546
atom_expr
226
1546
-
227
1546
expr
228
1546
NUMBER
229
1546
xor_expr
230
1547
[
95
1547
factor
96
1547
True
97
1547
atom_expr
98
1547
~
99
1547
and_expr
100
1547
-
101
1547
atom
102
1547
{
103
1547
test
1963
1547
or_test
104
1547
arith_expr
105
1547
power
106
1547
STRING
107
1547
NAME
108
1547
(
109
1547
and_test
110
1547
term
111
1547
+
112
1547
xor_expr
113
1547
shift_expr
115
1547
NUMBER
116
1547
not
117
1547
False
118
1547
expr
119
1547
not_test
120
1547
comparison
121
1547
None
122
1547
lambdef
123
1547
lambda
124
1548
def
1543
1548
class
1541
1548
funcdef
1964
1548
classdef
1965
1549
while
compound_stmt -> if_stmt
1549
lambda
compound_stmt -> if_stmt
1549
~
compound_stmt -> if_stmt
1549
not
compound_stmt -> if_stmt
1549
if
compound_stmt -> if_stmt
1549
modopt
compound_stmt -> if_stmt
1549
+
compound_stmt -> if_stmt
1549
NAME
compound_stmt -> if_stmt
1549
for
compound_stmt -> if_stmt
1549
with
compound_stmt -> if_stmt
1549
yield
compound_stmt -> if_stmt
1549
continue
compound_stmt -> if_stmt
1549
server
compound_stmt -> if_stmt
1549
endsim
compound_stmt -> if_stmt
1549
True
compound_stmt -> if_stmt
1549
None
compound_stmt -> if_stmt
1549
pass
compound_stmt -> if_stmt
1549
{
compound_stmt -> if_stmt
1549
raise
compound_stmt -> if_stmt
1549
STRING
compound_stmt -> if_stmt
1549
servmod
compound_stmt -> if_stmt
1549
del
compound_stmt -> if_stmt
1549
NUMBER
compound_stmt -> if_stmt
1549
(
compound_stmt -> if_stmt
1549
def
compound_stmt -> if_stmt
1549
try
compound_stmt -> if_stmt
1549
assert
compound_stmt -> if_stmt
1549
break
compound_stmt -> if_stmt
1549
DEDENT
compound_stmt -> if_stmt
1549
[
compound_stmt -> if_stmt
1549
@
compound_stmt -> if_stmt
1549
begsim
compound_stmt -> if_stmt
1549
return
compound_stmt -> if_stmt
1549
nonlocal
compound_stmt -> if_stmt
1549
-
compound_stmt -> if_stmt
1549
class
compound_stmt -> if_stmt
1549
conf
compound_stmt -> if_stmt
1549
global
compound_stmt -> if_stmt
1549
False
compound_stmt -> if_stmt
1549
resetstats
compound_stmt -> if_stmt
1550
NAME
1966
1551
{
compound_stmt -> funcdef
1551
None
compound_stmt -> funcdef
1551
del
compound_stmt -> funcdef
1551
STRING
compound_stmt -> funcdef
1551
lambda
compound_stmt -> funcdef
1551
NUMBER
compound_stmt -> funcdef
1551
NAME
compound_stmt -> funcdef
1551
global
compound_stmt -> funcdef
1551
server
compound_stmt -> funcdef
1551
pass
compound_stmt -> funcdef
1551
+
compound_stmt -> funcdef
1551
while
compound_stmt -> funcdef
1551
servmod
compound_stmt -> funcdef
1551
False
compound_stmt -> funcdef
1551
-
compound_stmt -> funcdef
1551
for
compound_stmt -> funcdef
1551
not
compound_stmt -> funcdef
1551
break
compound_stmt -> funcdef
1551
begsim
compound_stmt -> funcdef
1551
resetstats
compound_stmt -> funcdef
1551
endsim
compound_stmt -> funcdef
1551
@
compound_stmt -> funcdef
1551
with
compound_stmt -> funcdef
1551
if
compound_stmt -> funcdef
1551
nonlocal
compound_stmt -> funcdef
1551
continue
compound_stmt -> funcdef
1551
class
compound_stmt -> funcdef
1551
DEDENT
compound_stmt -> funcdef
1551
assert
compound_stmt -> funcdef
1551
True
compound_stmt -> funcdef
1551
try
compound_stmt -> funcdef
1551
~
compound_stmt -> funcdef
1551
conf
compound_stmt -> funcdef
1551
[
compound_stmt -> funcdef
1551
(
compound_stmt -> funcdef
1551
return
compound_stmt -> funcdef
1551
def
compound_stmt -> funcdef
1551
yield
compound_stmt -> funcdef
1551
raise
compound_stmt -> funcdef
1551
modopt
compound_stmt -> funcdef
1552
[
283
1552
factor
284
1552
True
285
1552
atom_expr
286
1552
~
287
1552
and_expr
288
1552
-
289
1552
shift_expr
290
1552
atom
291
1552
{
292
1552
comparison
293
1552
or_test
294
1552
arith_expr
295
1552
power
296
1552
STRING
297
1552
NAME
298
1552
(
299
1552
with_items
1967
1552
and_test
301
1552
term
302
1552
+
303
1552
xor_expr
304
1552
NUMBER
305
1552
not
306
1552
False
307
1552
expr
308
1552
not_test
309
1552
None
310
1552
lambdef
311
1552
test
312
1552
with_item
313
1552
lambda
314
1553
del
compound_stmt -> for_stmt
1553
True
compound_stmt -> for_stmt
1553
try
compound_stmt -> for_stmt
1553
-
compound_stmt -> for_stmt
1553
NAME
compound_stmt -> for_stmt
1553
servmod
compound_stmt -> for_stmt
1553
STRING
compound_stmt -> for_stmt
1553
@
compound_stmt -> for_stmt
1553
for
compound_stmt -> for_stmt
1553
assert
compound_stmt -> for_stmt
1553
False
compound_stmt -> for_stmt
1553
nonlocal
compound_stmt -> for_stmt
1553
DEDENT
compound_stmt -> for_stmt
1553
~
compound_stmt -> for_stmt
1553
resetstats
compound_stmt -> for_stmt
1553
with
compound_stmt -> for_stmt
1553
None
compound_stmt -> for_stmt
1553
pass
compound_stmt -> for_stmt
1553
break
compound_stmt -> for_stmt
1553
if
compound_stmt -> for_stmt
1553
endsim
compound_stmt -> for_stmt
1553
continue
compound_stmt -> for_stmt
1553
[
compound_stmt -> for_stmt
1553
def
compound_stmt -> for_stmt
1553
raise
compound_stmt -> for_stmt
1553
NUMBER
compound_stmt -> for_stmt
1553
yield
compound_stmt -> for_stmt
1553
begsim
compound_stmt -> for_stmt
1553
lambda
compound_stmt -> for_stmt
1553
not
compound_stmt -> for_stmt
1553
conf
compound_stmt -> for_stmt
1553
while
compound_stmt -> for_stmt
1553
global
compound_stmt -> for_stmt
1553
(
compound_stmt -> for_stmt
1553
modopt
compound_stmt -> for_stmt
1553
{
compound_stmt -> for_stmt
1553
class
compound_stmt -> for_stmt
1553
server
compound_stmt -> for_stmt
1553
return
compound_stmt -> for_stmt
1553
+
compound_stmt -> for_stmt
1554
with
compound_stmt -> with_stmt
1554
assert
compound_stmt -> with_stmt
1554
lambda
compound_stmt -> with_stmt
1554
NUMBER
compound_stmt -> with_stmt
1554
~
compound_stmt -> with_stmt
1554
del
compound_stmt -> with_stmt
1554
[
compound_stmt -> with_stmt
1554
resetstats
compound_stmt -> with_stmt
1554
yield
compound_stmt -> with_stmt
1554
None
compound_stmt -> with_stmt
1554
endsim
compound_stmt -> with_stmt
1554
begsim
compound_stmt -> with_stmt
1554
True
compound_stmt -> with_stmt
1554
DEDENT
compound_stmt -> with_stmt
1554
(
compound_stmt -> with_stmt
1554
STRING
compound_stmt -> with_stmt
1554
nonlocal
compound_stmt -> with_stmt
1554
server
compound_stmt -> with_stmt
1554
modopt
compound_stmt -> with_stmt
1554
conf
compound_stmt -> with_stmt
1554
{
compound_stmt -> with_stmt
1554
False
compound_stmt -> with_stmt
1554
try
compound_stmt -> with_stmt
1554
class
compound_stmt -> with_stmt
1554
-
compound_stmt -> with_stmt
1554
return
compound_stmt -> with_stmt
1554
pass
compound_stmt -> with_stmt
1554
NAME
compound_stmt -> with_stmt
1554
break
compound_stmt -> with_stmt
1554
servmod
compound_stmt -> with_stmt
1554
def
compound_stmt -> with_stmt
1554
+
compound_stmt -> with_stmt
1554
if
compound_stmt -> with_stmt
1554
@
compound_stmt -> with_stmt
1554
continue
compound_stmt -> with_stmt
1554
while
compound_stmt -> with_stmt
1554
not
compound_stmt -> with_stmt
1554
for
compound_stmt -> with_stmt
1554
raise
compound_stmt -> with_stmt
1554
global
compound_stmt -> with_stmt
1555
raise
stmt -> simple_stmt
1555
(
stmt -> simple_stmt
1555
nonlocal
stmt -> simple_stmt
1555
while
stmt -> simple_stmt
1555
global
stmt -> simple_stmt
1555
{
stmt -> simple_stmt
1555
conf
stmt -> simple_stmt
1555
server
stmt -> simple_stmt
1555
-
stmt -> simple_stmt
1555
@
stmt -> simple_stmt
1555
def
stmt -> simple_stmt
1555
del
stmt -> simple_stmt
1555
endsim
stmt -> simple_stmt
1555
NUMBER
stmt -> simple_stmt
1555
False
stmt -> simple_stmt
1555
begsim
stmt -> simple_stmt
1555
NAME
stmt -> simple_stmt
1555
if
stmt -> simple_stmt
1555
class
stmt -> simple_stmt
1555
pass
stmt -> simple_stmt
1555
+
stmt -> simple_stmt
1555
~
stmt -> simple_stmt
1555
try
stmt -> simple_stmt
1555
not
stmt -> simple_stmt
1555
STRING
stmt -> simple_stmt
1555
True
stmt -> simple_stmt
1555
assert
stmt -> simple_stmt
1555
[
stmt -> simple_stmt
1555
modopt
stmt -> simple_stmt
1555
DEDENT
stmt -> simple_stmt
1555
yield
stmt -> simple_stmt
1555
resetstats
stmt -> simple_stmt
1555
continue
stmt -> simple_stmt
1555
return
stmt -> simple_stmt
1555
with
stmt -> simple_stmt
1555
lambda
stmt -> simple_stmt
1555
break
stmt -> simple_stmt
1555
for
stmt -> simple_stmt
1555
None
stmt -> simple_stmt
1555
servmod
stmt -> simple_stmt
1556
not
compound_stmt -> confdef
1556
modopt
compound_stmt -> confdef
1556
if
compound_stmt -> confdef
1556
~
compound_stmt -> confdef
1556
try
compound_stmt -> confdef
1556
break
compound_stmt -> confdef
1556
continue
compound_stmt -> confdef
1556
endsim
compound_stmt -> confdef
1556
raise
compound_stmt -> confdef
1556
pass
compound_stmt -> confdef
1556
global
compound_stmt -> confdef
1556
True
compound_stmt -> confdef
1556
servmod
compound_stmt -> confdef
1556
STRING
compound_stmt -> confdef
1556
def
compound_stmt -> confdef
1556
-
compound_stmt -> confdef
1556
False
compound_stmt -> confdef
1556
NUMBER
compound_stmt -> confdef
1556
NAME
compound_stmt -> confdef
1556
resetstats
compound_stmt -> confdef
1556
DEDENT
compound_stmt -> confdef
1556
return
compound_stmt -> confdef
1556
with
compound_stmt -> confdef
1556
[
compound_stmt -> confdef
1556
(
compound_stmt -> confdef
1556
for
compound_stmt -> confdef
1556
lambda
compound_stmt -> confdef
1556
begsim
compound_stmt -> confdef
1556
assert
compound_stmt -> confdef
1556
+
compound_stmt -> confdef
1556
{
compound_stmt -> confdef
1556
while
compound_stmt -> confdef
1556
nonlocal
compound_stmt -> confdef
1556
conf
compound_stmt -> confdef
1556
None
compound_stmt -> confdef
1556
@
compound_stmt -> confdef
1556
class
compound_stmt -> confdef
1556
del
compound_stmt -> confdef
1556
server
compound_stmt -> confdef
1556
yield
compound_stmt -> confdef
1557
with
compound_stmt -> classdef
1557
endsim
compound_stmt -> classdef
1557
(
compound_stmt -> classdef
1557
begsim
compound_stmt -> classdef
1557
if
compound_stmt -> classdef
1557
[
compound_stmt -> classdef
1557
not
compound_stmt -> classdef
1557
pass
compound_stmt -> classdef
1557
{
compound_stmt -> classdef
1557
-
compound_stmt -> classdef
1557
modopt
compound_stmt -> classdef
1557
raise
compound_stmt -> classdef
1557
yield
compound_stmt -> classdef
1557
NAME
compound_stmt -> classdef
1557
class
compound_stmt -> classdef
1557
for
compound_stmt -> classdef
1557
conf
compound_stmt -> classdef
1557
+
compound_stmt -> classdef
1557
lambda
compound_stmt -> classdef
1557
~
compound_stmt -> classdef
1557
NUMBER
compound_stmt -> classdef
1557
True
compound_stmt -> classdef
1557
servmod
compound_stmt -> classdef
1557
continue
compound_stmt -> classdef
1557
break
compound_stmt -> classdef
1557
@
compound_stmt -> classdef
1557
try
compound_stmt -> classdef
1557
return
compound_stmt -> classdef
1557
STRING
compound_stmt -> classdef
1557
None
compound_stmt -> classdef
1557
global
compound_stmt -> classdef
1557
del
compound_stmt -> classdef
1557
nonlocal
compound_stmt -> classdef
1557
DEDENT
compound_stmt -> classdef
1557
assert
compound_stmt -> classdef
1557
def
compound_stmt -> classdef
1557
server
compound_stmt -> classdef
1557
resetstats
compound_stmt -> classdef
1557
False
compound_stmt -> classdef
1557
while
compound_stmt -> classdef
1558
arith_expr
1
1558
try
1533
1558
modopt
1534
1558
compound_stmt
1535
1558
test
5
1558
servmod
1536
1558
while
1537
1558
and_expr
8
1558
power
9
1558
STRING
10
1558
decorated
1538
1558
cli_serv_model
1539
1558
@
13
1558
try_stmt
1540
1558
lambdef
15
1558
(
16
1558
factor
17
1558
[
18
1558
class
1541
1558
small_stmt
1542
1558
{
21
1558
term
22
1558
def
1543
1558
server
1544
1558
while_stmt
1545
1558
-
26
1558
+
27
1558
for
1546
1558
if
1547
1558
lambda
29
1558
decorators
1548
1558
atom_expr
31
1558
not_test
32
1558
if_stmt
1549
1558
yield
34
1558
conf
1550
1558
test_list
36
1558
~
37
1558
True
38
1558
False
39
1558
funcdef
1551
1558
xor_expr
41
1558
with
1552
1558
for_stmt
1553
1558
sim_stmt
45
1558
and_test
46
1558
expr
47
1558
shift_expr
48
1558
comparison
49
1558
with_stmt
1554
1558
simple_stmt
1555
1558
NAME
52
1558
or_test
53
1558
confdef
1556
1558
None
55
1558
classdef
1557
1558
atom
57
1558
NUMBER
58
1558
return
59
1558
break_stmt
60
1558
return_stmt
61
1558
stmt
1558
1558
not
62
1558
break
63
1558
raise
64
1558
expr_stmt
65
1558
DEDENT
stmt_list -> stmt
1558
stat_stmt
66
1558
decorator
67
1558
assert_stmt
68
1558
begsim
69
1558
global
70
1558
stmt_list
1968
1558
assert
71
1558
nonlocal
72
1558
nonlocal_stmt
73
1558
raise_stmt
74
1558
yield_stmt
75
1558
continue
77
1558
endsim
78
1558
del
80
1558
pass_stmt
81
1558
flow_stmt
82
1558
resetstats
84
1558
del_stmt
85
1558
continue_stmt
86
1558
global_stmt
87
1558
pass
88
1559
DEDENT
1969
1560
confbody
1970
1560
NAME
1971
1561
confbody
1972
1561
NAME
1971
1562
.
trailer -> ( arglist )
1562
|
trailer -> ( arglist )
1562
^
trailer -> ( arglist )
1562
==
trailer -> ( arglist )
1562
**
trailer -> ( arglist )
1562
>>
trailer -> ( arglist )
1562
not
trailer -> ( arglist )
1562
<<
trailer -> ( arglist )
1562
>=
trailer -> ( arglist )
1562
!=
trailer -> ( arglist )
1562
in
trailer -> ( arglist )
1562
[
trailer -> ( arglist )
1562
(
trailer -> ( arglist )
1562
>
trailer -> ( arglist )
1562
and
trailer -> ( arglist )
1562
+
trailer -> ( arglist )
1562
%
trailer -> ( arglist )
1562
or
trailer -> ( arglist )
1562
*
trailer -> ( arglist )
1562
is
trailer -> ( arglist )
1562
&
trailer -> ( arglist )
1562
//
trailer -> ( arglist )
1562
:
trailer -> ( arglist )
1562
<
trailer -> ( arglist )
1562
if
trailer -> ( arglist )
1562
<=
trailer -> ( arglist )
1562
-
trailer -> ( arglist )
1562
/
trailer -> ( arglist )
1562
@
trailer -> ( arglist )
1563
<=
trailer -> [ subscriptlist ]
1563
<<
trailer -> [ subscriptlist ]
1563
:
trailer -> [ subscriptlist ]
1563
*
trailer -> [ subscriptlist ]
1563
+
trailer -> [ subscriptlist ]
1563
in
trailer -> [ subscriptlist ]
1563
>>
trailer -> [ subscriptlist ]
1563
//
trailer -> [ subscriptlist ]
1563
.
trailer -> [ subscriptlist ]
1563
and
trailer -> [ subscriptlist ]
1563
**
trailer -> [ subscriptlist ]
1563
@
trailer -> [ subscriptlist ]
1563
<
trailer -> [ subscriptlist ]
1563
not
trailer -> [ subscriptlist ]
1563
-
trailer -> [ subscriptlist ]
1563
!=
trailer -> [ subscriptlist ]
1563
%
trailer -> [ subscriptlist ]
1563
[
trailer -> [ subscriptlist ]
1563
/
trailer -> [ subscriptlist ]
1563
or
trailer -> [ subscriptlist ]
1563
&
trailer -> [ subscriptlist ]
1563
>=
trailer -> [ subscriptlist ]
1563
==
trailer -> [ subscriptlist ]
1563
(
trailer -> [ subscriptlist ]
1563
|
trailer -> [ subscriptlist ]
1563
is
trailer -> [ subscriptlist ]
1563
if
trailer -> [ subscriptlist ]
1563
>
trailer -> [ subscriptlist ]
1563
^
trailer -> [ subscriptlist ]
1564
[
95
1564
factor
96
1564
True
97
1564
atom_expr
98
1564
~
99
1564
and_expr
100
1564
-
101
1564
atom
102
1564
{
103
1564
or_test
104
1564
arith_expr
105
1564
power
106
1564
STRING
107
1564
NAME
108
1564
(
109
1564
and_test
110
1564
term
111
1564
+
112
1564
xor_expr
113
1564
shift_expr
115
1564
NUMBER
116
1564
not
117
1564
False
118
1564
expr
119
1564
not_test
120
1564
comparison
121
1564
None
122
1564
lambdef
123
1564
test
1973
1564
lambda
124
1565
:
1974
1566
del
simple_stmt -> small_stmt NEWLINE
1566
break
simple_stmt -> small_stmt NEWLINE
1566
raise
simple_stmt -> small_stmt NEWLINE
1566
servmod
simple_stmt -> small_stmt NEWLINE
1566
class
simple_stmt -> small_stmt NEWLINE
1566
not
simple_stmt -> small_stmt NEWLINE
1566
-
simple_stmt -> small_stmt NEWLINE
1566
False
simple_stmt -> small_stmt NEWLINE
1566
(
simple_stmt -> small_stmt NEWLINE
1566
endsim
simple_stmt -> small_stmt NEWLINE
1566
+
simple_stmt -> small_stmt NEWLINE
1566
None
simple_stmt -> small_stmt NEWLINE
1566
resetstats
simple_stmt -> small_stmt NEWLINE
1566
conf
simple_stmt -> small_stmt NEWLINE
1566
server
simple_stmt -> small_stmt NEWLINE
1566
STRING
simple_stmt -> small_stmt NEWLINE
1566
$
simple_stmt -> small_stmt NEWLINE
1566
else
simple_stmt -> small_stmt NEWLINE
1566
if
simple_stmt -> small_stmt NEWLINE
1566
NUMBER
simple_stmt -> small_stmt NEWLINE
1566
global
simple_stmt -> small_stmt NEWLINE
1566
@
simple_stmt -> small_stmt NEWLINE
1566
True
simple_stmt -> small_stmt NEWLINE
1566
lambda
simple_stmt -> small_stmt NEWLINE
1566
pass
simple_stmt -> small_stmt NEWLINE
1566
return
simple_stmt -> small_stmt NEWLINE
1566
def
simple_stmt -> small_stmt NEWLINE
1566
with
simple_stmt -> small_stmt NEWLINE
1566
nonlocal
simple_stmt -> small_stmt NEWLINE
1566
assert
simple_stmt -> small_stmt NEWLINE
1566
NAME
simple_stmt -> small_stmt NEWLINE
1566
try
simple_stmt -> small_stmt NEWLINE
1566
begsim
simple_stmt -> small_stmt NEWLINE
1566
while
simple_stmt -> small_stmt NEWLINE
1566
for
simple_stmt -> small_stmt NEWLINE
1566
[
simple_stmt -> small_stmt NEWLINE
1566
modopt
simple_stmt -> small_stmt NEWLINE
1566
yield
simple_stmt -> small_stmt NEWLINE
1566
NEWLINE
simple_stmt -> small_stmt NEWLINE
1566
continue
simple_stmt -> small_stmt NEWLINE
1566
{
simple_stmt -> small_stmt NEWLINE
1566
~
simple_stmt -> small_stmt NEWLINE
1567
arith_expr
1
1567
try
1533
1567
modopt
1534
1567
compound_stmt
1535
1567
test
5
1567
servmod
1536
1567
while
1537
1567
and_expr
8
1567
power
9
1567
STRING
10
1567
decorated
1538
1567
cli_serv_model
1539
1567
@
13
1567
try_stmt
1540
1567
lambdef
15
1567
stmt_list
1975
1567
(
16
1567
factor
17
1567
[
18
1567
class
1541
1567
small_stmt
1542
1567
{
21
1567
term
22
1567
def
1543
1567
server
1544
1567
while_stmt
1545
1567
-
26
1567
+
27
1567
for
1546
1567
if
1547
1567
lambda
29
1567
decorators
1548
1567
atom_expr
31
1567
not_test
32
1567
if_stmt
1549
1567
yield
34
1567
conf
1550
1567
test_list
36
1567
~
37
1567
True
38
1567
False
39
1567
funcdef
1551
1567
xor_expr
41
1567
with
1552
1567
for_stmt
1553
1567
sim_stmt
45
1567
and_test
46
1567
expr
47
1567
shift_expr
48
1567
comparison
49
1567
with_stmt
1554
1567
simple_stmt
1555
1567
NAME
52
1567
or_test
53
1567
confdef
1556
1567
None
55
1567
classdef
1557
1567
atom
57
1567
NUMBER
58
1567
return
59
1567
break_stmt
60
1567
return_stmt
61
1567
stmt
1558
1567
not
62
1567
break
63
1567
raise
64
1567
expr_stmt
65
1567
stat_stmt
66
1567
decorator
67
1567
assert_stmt
68
1567
begsim
69
1567
global
70
1567
assert
71
1567
nonlocal
72
1567
nonlocal_stmt
73
1567
raise_stmt
74
1567
yield_stmt
75
1567
continue
77
1567
endsim
78
1567
del
80
1567
pass_stmt
81
1567
flow_stmt
82
1567
resetstats
84
1567
del_stmt
85
1567
continue_stmt
86
1567
global_stmt
87
1567
pass
88
1568
:
lambdef -> lambda varargslist : test
1569
NEWLINE
1976
1570
def
decorator -> @ dotted_name ( ) NEWLINE
1570
@
decorator -> @ dotted_name ( ) NEWLINE
1570
class
decorator -> @ dotted_name ( ) NEWLINE
1571
,
trailer -> ( arglist )
1571
.
trailer -> ( arglist )
1571
|
trailer -> ( arglist )
1571
^
trailer -> ( arglist )
1571
==
trailer -> ( arglist )
1571
**
trailer -> ( arglist )
1571
>>
trailer -> ( arglist )
1571
not
trailer -> ( arglist )
1571
<<
trailer -> ( arglist )
1571
>=
trailer -> ( arglist )
1571
!=
trailer -> ( arglist )
1571
in
trailer -> ( arglist )
1571
[
trailer -> ( arglist )
1571
(
trailer -> ( arglist )
1571
>
trailer -> ( arglist )
1571
and
trailer -> ( arglist )
1571
+
trailer -> ( arglist )
1571
%
trailer -> ( arglist )
1571
or
trailer -> ( arglist )
1571
*
trailer -> ( arglist )
1571
for
trailer -> ( arglist )
1571
is
trailer -> ( arglist )
1571
&
trailer -> ( arglist )
1571
//
trailer -> ( arglist )
1571
-
trailer -> ( arglist )
1571
)
trailer -> ( arglist )
1571
<
trailer -> ( arglist )
1571
<=
trailer -> ( arglist )
1571
if
trailer -> ( arglist )
1571
/
trailer -> ( arglist )
1571
@
trailer -> ( arglist )
1572
for
trailer -> [ subscriptlist ]
1572
<=
trailer -> [ subscriptlist ]
1572
<<
trailer -> [ subscriptlist ]
1572
*
trailer -> [ subscriptlist ]
1572
+
trailer -> [ subscriptlist ]
1572
in
trailer -> [ subscriptlist ]
1572
>>
trailer -> [ subscriptlist ]
1572
//
trailer -> [ subscriptlist ]
1572
.
trailer -> [ subscriptlist ]
1572
,
trailer -> [ subscriptlist ]
1572
and
trailer -> [ subscriptlist ]
1572
**
trailer -> [ subscriptlist ]
1572
@
trailer -> [ subscriptlist ]
1572
<
trailer -> [ subscriptlist ]
1572
not
trailer -> [ subscriptlist ]
1572
-
trailer -> [ subscriptlist ]
1572
!=
trailer -> [ subscriptlist ]
1572
%
trailer -> [ subscriptlist ]
1572
)
trailer -> [ subscriptlist ]
1572
[
trailer -> [ subscriptlist ]
1572
/
trailer -> [ subscriptlist ]
1572
or
trailer -> [ subscriptlist ]
1572
&
trailer -> [ subscriptlist ]
1572
>=
trailer -> [ subscriptlist ]
1572
==
trailer -> [ subscriptlist ]
1572
(
trailer -> [ subscriptlist ]
1572
|
trailer -> [ subscriptlist ]
1572
is
trailer -> [ subscriptlist ]
1572
if
trailer -> [ subscriptlist ]
1572
>
trailer -> [ subscriptlist ]
1572
^
trailer -> [ subscriptlist ]
1573
[
128
1573
factor
129
1573
True
130
1573
atom_expr
131
1573
~
132
1573
and_expr
133
1573
-
134
1573
{
135
1573
shift_expr
137
1573
atom
138
1573
comparison
140
1573
arith_expr
141
1573
power
142
1573
STRING
143
1573
NAME
144
1573
(
145
1573
and_test
146
1573
term
147
1573
+
148
1573
xor_expr
149
1573
or_test
150
1573
NUMBER
151
1573
not
152
1573
False
153
1573
expr
154
1573
not_test
155
1573
None
156
1573
lambdef
157
1573
test
1977
1573
lambda
158
1574
,
lambdef -> lambda varargslist : test
1574
)
lambdef -> lambda varargslist : test
1574
for
lambdef -> lambda varargslist : test
1575
!=
atom -> [ ]
1575
>>
atom -> [ ]
1575
|
atom -> [ ]
1575
<<
atom -> [ ]
1575
>
atom -> [ ]
1575
.
atom -> [ ]
1575
%
atom -> [ ]
1575
^
atom -> [ ]
1575
-
atom -> [ ]
1575
,
atom -> [ ]
1575
in
atom -> [ ]
1575
or
atom -> [ ]
1575
/
atom -> [ ]
1575
**
atom -> [ ]
1575
//
atom -> [ ]
1575
not
atom -> [ ]
1575
(
atom -> [ ]
1575
)
atom -> [ ]
1575
+
atom -> [ ]
1575
and
atom -> [ ]
1575
==
atom -> [ ]
1575
[
atom -> [ ]
1575
if
atom -> [ ]
1575
<
atom -> [ ]
1575
<=
atom -> [ ]
1575
>=
atom -> [ ]
1575
is
atom -> [ ]
1575
*
atom -> [ ]
1575
@
atom -> [ ]
1575
&
atom -> [ ]
1576
]
1978
1577
term
1979
1577
[
1002
1577
factor
1003
1577
True
1004
1577
atom_expr
1005
1577
~
1006
1577
-
1008
1577
atom
1010
1577
{
1011
1577
power
1014
1577
STRING
1015
1577
NAME
1016
1577
(
1017
1577
+
1020
1577
NUMBER
1023
1577
False
1025
1577
None
1027
1578
[
1002
1578
factor
1003
1578
True
1004
1578
term
1980
1578
~
1006
1578
-
1008
1578
atom_expr
1005
1578
atom
1010
1578
{
1011
1578
power
1014
1578
STRING
1015
1578
NAME
1016
1578
(
1017
1578
+
1020
1578
NUMBER
1023
1578
False
1025
1578
None
1027
1579
[
1002
1579
factor
1003
1579
True
1004
1579
atom_expr
1005
1579
~
1006
1579
-
1008
1579
atom
1010
1579
{
1011
1579
power
1014
1579
STRING
1015
1579
NAME
1016
1579
(
1017
1579
term
1981
1579
+
1020
1579
NUMBER
1023
1579
False
1025
1579
None
1027
1580
[
1002
1580
factor
1003
1580
True
1004
1580
atom_expr
1005
1580
~
1006
1580
-
1008
1580
atom
1010
1580
{
1011
1580
power
1014
1580
STRING
1015
1580
NAME
1016
1580
(
1017
1580
term
1982
1580
+
1020
1580
NUMBER
1023
1580
False
1025
1580
None
1027
1581
[
1002
1581
factor
1003
1581
True
1004
1581
atom_expr
1005
1581
~
1006
1581
-
1008
1581
atom
1010
1581
{
1011
1581
power
1014
1581
STRING
1015
1581
NAME
1016
1581
term
1983
1581
(
1017
1581
+
1020
1581
NUMBER
1023
1581
False
1025
1581
None
1027
1582
[
1002
1582
True
1004
1582
atom_expr
1005
1582
-
1008
1582
~
1006
1582
atom
1010
1582
{
1011
1582
power
1014
1582
STRING
1015
1582
NAME
1016
1582
(
1017
1582
+
1020
1582
NUMBER
1023
1582
False
1025
1582
factor
1984
1582
None
1027
1583
@
factor -> ~ factor
1583
>>
factor -> ~ factor
1583
)
factor -> ~ factor
1583
<=
factor -> ~ factor
1583
and
factor -> ~ factor
1583
+
factor -> ~ factor
1583
*
factor -> ~ factor
1583
!=
factor -> ~ factor
1583
%
factor -> ~ factor
1583
<<
factor -> ~ factor
1583
>=
factor -> ~ factor
1583
,
factor -> ~ factor
1583
&
factor -> ~ factor
1583
is
factor -> ~ factor
1583
==
factor -> ~ factor
1583
//
factor -> ~ factor
1583
<
factor -> ~ factor
1583
/
factor -> ~ factor
1583
not
factor -> ~ factor
1583
-
factor -> ~ factor
1583
or
factor -> ~ factor
1583
|
factor -> ~ factor
1583
>
factor -> ~ factor
1583
^
factor -> ~ factor
1583
if
factor -> ~ factor
1583
in
factor -> ~ factor
1584
[
1002
1584
factor
1003
1584
True
1004
1584
atom_expr
1005
1584
~
1006
1584
and_expr
1007
1584
-
1008
1584
shift_expr
1009
1584
atom
1010
1584
{
1011
1584
xor_expr
1985
1584
arith_expr
1013
1584
power
1014
1584
STRING
1015
1584
NAME
1016
1584
(
1017
1584
term
1019
1584
+
1020
1584
NUMBER
1023
1584
False
1025
1584
None
1027
1585
@
factor -> - factor
1585
<=
factor -> - factor
1585
in
factor -> - factor
1585
>>
factor -> - factor
1585
|
factor -> - factor
1585
is
factor -> - factor
1585
+
factor -> - factor
1585
%
factor -> - factor
1585
<
factor -> - factor
1585
*
factor -> - factor
1585
<<
factor -> - factor
1585
if
factor -> - factor
1585
-
factor -> - factor
1585
>=
factor -> - factor
1585
not
factor -> - factor
1585
and
factor -> - factor
1585
/
factor -> - factor
1585
or
factor -> - factor
1585
^
factor -> - factor
1585
)
factor -> - factor
1585
>
factor -> - factor
1585
!=
factor -> - factor
1585
&
factor -> - factor
1585
==
factor -> - factor
1585
//
factor -> - factor
1585
,
factor -> - factor
1586
[
1002
1586
factor
1003
1586
True
1004
1586
atom_expr
1005
1586
~
1006
1586
-
1008
1586
shift_expr
1009
1586
atom
1010
1586
{
1011
1586
arith_expr
1013
1586
power
1014
1586
STRING
1015
1586
NAME
1016
1586
(
1017
1586
term
1019
1586
+
1020
1586
and_expr
1986
1586
NUMBER
1023
1586
False
1025
1586
None
1027
1587
NAME
1987
1588
[
766
1588
factor
767
1588
True
768
1588
atom_expr
769
1588
~
770
1588
and_expr
771
1588
-
772
1588
{
773
1588
shift_expr
774
1588
atom
775
1588
comparison
776
1588
and_test
777
1588
arith_expr
778
1588
power
779
1588
STRING
780
1588
NAME
781
1588
(
782
1588
term
784
1588
+
785
1588
xor_expr
786
1588
)
1988
1588
or_test
788
1588
arglist
1989
1588
NUMBER
789
1588
not
790
1588
False
791
1588
expr
792
1588
*
793
1588
not_test
794
1588
None
795
1588
lambdef
796
1588
lambda
797
1588
test
798
1588
argument
799
1588
**
800
1589
trailer_expr
1990
1589
>>
trailer_expr -> 
1589
.
1587
1589
(
1588
1589
)
trailer_expr -> 
1589
trailer
1589
1589
+
trailer_expr -> 
1589
[
1591
1589
is
trailer_expr -> 
1589
>
trailer_expr -> 
1589
not
trailer_expr -> 
1589
|
trailer_expr -> 
1589
&
trailer_expr -> 
1589
/
trailer_expr -> 
1589
@
trailer_expr -> 
1589
!=
trailer_expr -> 
1589
**
trailer_expr -> 
1589
>=
trailer_expr -> 
1589
^
trailer_expr -> 
1589
in
trailer_expr -> 
1589
<<
trailer_expr -> 
1589
and
trailer_expr -> 
1589
or
trailer_expr -> 
1589
if
trailer_expr -> 
1589
//
trailer_expr -> 
1589
%
trailer_expr -> 
1589
,
trailer_expr -> 
1589
<=
trailer_expr -> 
1589
<
trailer_expr -> 
1589
==
trailer_expr -> 
1589
-
trailer_expr -> 
1589
*
trailer_expr -> 
1590
^
atom_expr -> atom trailer_expr
1590
or
atom_expr -> atom trailer_expr
1590
&
atom_expr -> atom trailer_expr
1590
@
atom_expr -> atom trailer_expr
1590
|
atom_expr -> atom trailer_expr
1590
-
atom_expr -> atom trailer_expr
1590
*
atom_expr -> atom trailer_expr
1590
%
atom_expr -> atom trailer_expr
1590
==
atom_expr -> atom trailer_expr
1590
**
atom_expr -> atom trailer_expr
1590
and
atom_expr -> atom trailer_expr
1590
is
atom_expr -> atom trailer_expr
1590
in
atom_expr -> atom trailer_expr
1590
<<
atom_expr -> atom trailer_expr
1590
!=
atom_expr -> atom trailer_expr
1590
<=
atom_expr -> atom trailer_expr
1590
/
atom_expr -> atom trailer_expr
1590
)
atom_expr -> atom trailer_expr
1590
//
atom_expr -> atom trailer_expr
1590
<
atom_expr -> atom trailer_expr
1590
>=
atom_expr -> atom trailer_expr
1590
>>
atom_expr -> atom trailer_expr
1590
if
atom_expr -> atom trailer_expr
1590
not
atom_expr -> atom trailer_expr
1590
+
atom_expr -> atom trailer_expr
1590
>
atom_expr -> atom trailer_expr
1590
,
atom_expr -> atom trailer_expr
1591
[
802
1591
factor
803
1591
True
804
1591
atom_expr
810
1591
~
806
1591
not
807
1591
and_expr
808
1591
-
809
1591
shift_expr
811
1591
atom
812
1591
{
813
1591
comparison
814
1591
or_test
815
1591
(
816
1591
arith_expr
817
1591
power
818
1591
STRING
819
1591
NAME
820
1591
and_test
821
1591
subscriptlist
1991
1591
term
822
1591
+
823
1591
xor_expr
824
1591
test
825
1591
NUMBER
826
1591
False
827
1591
subscript
828
1591
expr
829
1591
not_test
830
1591
None
831
1591
lambdef
832
1591
lambda
833
1591
maybe_test
834
1591
:
maybe_test -> 
1592
in
atom -> { }
1592
<=
atom -> { }
1592
*
atom -> { }
1592
>
atom -> { }
1592
+
atom -> { }
1592
@
atom -> { }
1592
,
atom -> { }
1592
>=
atom -> { }
1592
/
atom -> { }
1592
|
atom -> { }
1592
is
atom -> { }
1592
and
atom -> { }
1592
if
atom -> { }
1592
(
atom -> { }
1592
>>
atom -> { }
1592
not
atom -> { }
1592
-
atom -> { }
1592
<<
atom -> { }
1592
**
atom -> { }
1592
or
atom -> { }
1592
<
atom -> { }
1592
!=
atom -> { }
1592
==
atom -> { }
1592
%
atom -> { }
1592
//
atom -> { }
1592
)
atom -> { }
1592
&
atom -> { }
1592
[
atom -> { }
1592
.
atom -> { }
1592
^
atom -> { }
1593
[
1002
1593
factor
1003
1593
True
1004
1593
atom_expr
1005
1593
~
1006
1593
-
1008
1593
atom
1010
1593
{
1011
1593
arith_expr
1013
1593
power
1014
1593
STRING
1015
1593
NAME
1016
1593
shift_expr
1992
1593
(
1017
1593
term
1019
1593
+
1020
1593
NUMBER
1023
1593
False
1025
1593
None
1027
1594
[
1002
1594
factor
1003
1594
True
1004
1594
atom_expr
1005
1594
~
1006
1594
-
1008
1594
atom
1010
1594
{
1011
1594
arith_expr
1013
1594
power
1014
1594
STRING
1015
1594
NAME
1016
1594
shift_expr
1993
1594
(
1017
1594
term
1019
1594
+
1020
1594
NUMBER
1023
1594
False
1025
1594
None
1027
1595
)
1994
1596
or
atom -> ( )
1596
>>
atom -> ( )
1596
(
atom -> ( )
1596
<=
atom -> ( )
1596
.
atom -> ( )
1596
is
atom -> ( )
1596
@
atom -> ( )
1596
,
atom -> ( )
1596
%
atom -> ( )
1596
<<
atom -> ( )
1596
**
atom -> ( )
1596
^
atom -> ( )
1596
/
atom -> ( )
1596
)
atom -> ( )
1596
if
atom -> ( )
1596
not
atom -> ( )
1596
*
atom -> ( )
1596
!=
atom -> ( )
1596
<
atom -> ( )
1596
&
atom -> ( )
1596
-
atom -> ( )
1596
>
atom -> ( )
1596
//
atom -> ( )
1596
==
atom -> ( )
1596
in
atom -> ( )
1596
+
atom -> ( )
1596
[
atom -> ( )
1596
>=
atom -> ( )
1596
and
atom -> ( )
1596
|
atom -> ( )
1597
[
1002
1597
factor
1003
1597
True
1004
1597
atom_expr
1005
1597
~
1006
1597
and_expr
1007
1597
-
1008
1597
shift_expr
1009
1597
atom
1010
1597
{
1011
1597
comparison
1012
1597
arith_expr
1013
1597
power
1014
1597
STRING
1015
1597
NAME
1016
1597
(
1017
1597
and_test
1018
1597
term
1019
1597
+
1020
1597
xor_expr
1021
1597
NUMBER
1023
1597
not
1024
1597
False
1025
1597
not_test
1026
1597
None
1027
1597
expr
1028
1597
or_test
1995
1598
[
1002
1598
factor
1003
1598
True
1004
1598
atom_expr
1005
1598
~
1006
1598
-
1008
1598
arith_expr
1996
1598
atom
1010
1598
{
1011
1598
power
1014
1598
STRING
1015
1598
NAME
1016
1598
(
1017
1598
term
1019
1598
+
1020
1598
NUMBER
1023
1598
False
1025
1598
None
1027
1599
[
1002
1599
factor
1003
1599
True
1004
1599
atom_expr
1005
1599
~
1006
1599
-
1008
1599
atom
1010
1599
{
1011
1599
arith_expr
1997
1599
power
1014
1599
STRING
1015
1599
NAME
1016
1599
(
1017
1599
term
1019
1599
+
1020
1599
NUMBER
1023
1599
False
1025
1599
None
1027
1600
-
factor -> + factor
1600
@
factor -> + factor
1600
<<
factor -> + factor
1600
is
factor -> + factor
1600
and
factor -> + factor
1600
<=
factor -> + factor
1600
or
factor -> + factor
1600
<
factor -> + factor
1600
^
factor -> + factor
1600
not
factor -> + factor
1600
//
factor -> + factor
1600
,
factor -> + factor
1600
*
factor -> + factor
1600
in
factor -> + factor
1600
&
factor -> + factor
1600
+
factor -> + factor
1600
if
factor -> + factor
1600
>>
factor -> + factor
1600
)
factor -> + factor
1600
|
factor -> + factor
1600
%
factor -> + factor
1600
>
factor -> + factor
1600
>=
factor -> + factor
1600
!=
factor -> + factor
1600
/
factor -> + factor
1600
==
factor -> + factor
1601
[
1002
1601
factor
1003
1601
True
1004
1601
atom_expr
1005
1601
~
1006
1601
and_expr
1007
1601
-
1008
1601
shift_expr
1009
1601
atom
1010
1601
{
1011
1601
expr
1998
1601
arith_expr
1013
1601
power
1014
1601
STRING
1015
1601
NAME
1016
1601
(
1017
1601
term
1019
1601
+
1020
1601
xor_expr
1021
1601
NUMBER
1023
1601
False
1025
1601
None
1027
1602
[
738
1602
factor
740
1602
True
741
1602
~
742
1602
and_expr
743
1602
-
744
1602
atom
745
1602
{
746
1602
arith_expr
747
1602
power
748
1602
atom_expr
749
1602
STRING
750
1602
NAME
751
1602
(
752
1602
term
753
1602
+
754
1602
xor_expr
755
1602
shift_expr
756
1602
NUMBER
757
1602
not
758
1602
False
759
1602
comparison
760
1602
not_test
761
1602
None
762
1602
or_test
1999
1602
expr
763
1602
and_test
764
1603
,
not_test -> not not_test
1603
and
not_test -> not not_test
1603
or
not_test -> not not_test
1603
)
not_test -> not not_test
1603
if
not_test -> not not_test
1604
[
1002
1604
factor
1003
1604
True
1004
1604
atom_expr
1005
1604
~
1006
1604
and_expr
1007
1604
-
1008
1604
shift_expr
1009
1604
atom
1010
1604
{
1011
1604
comparison
1012
1604
arith_expr
1013
1604
power
1014
1604
STRING
1015
1604
NAME
1016
1604
(
1017
1604
term
1019
1604
+
1020
1604
xor_expr
1021
1604
NUMBER
1023
1604
not
1024
1604
False
1025
1604
and_test
2000
1604
not_test
1026
1604
None
1027
1604
expr
1028
1605
[
1002
1605
factor
1003
1605
True
1004
1605
atom_expr
1005
1605
~
1006
1605
and_expr
1007
1605
-
1008
1605
shift_expr
1009
1605
atom
1010
1605
{
1011
1605
arith_expr
1013
1605
power
1014
1605
STRING
1015
1605
NAME
1016
1605
(
1017
1605
term
1019
1605
+
1020
1605
xor_expr
1021
1605
NUMBER
1023
1605
False
1025
1605
None
1027
1605
expr
1028
1605
comparison
2001
1606
:
2002
1607
[
1002
1607
factor
1003
1607
True
1004
1607
atom_expr
1005
1607
~
1006
1607
and_expr
1007
1607
-
1008
1607
shift_expr
1009
1607
atom
1010
1607
{
1011
1607
comparison
1012
1607
arith_expr
1013
1607
power
1014
1607
STRING
1015
1607
NAME
1016
1607
(
1017
1607
and_test
1018
1607
term
1019
1607
+
1020
1607
xor_expr
1021
1607
or_test
1022
1607
NUMBER
1023
1607
not
1024
1607
False
1025
1607
not_test
1026
1607
None
1027
1607
expr
1028
1607
lambda
1029
1607
lambdef
1031
1607
test
2003
1608
[
2004
1608
factor
2005
1608
True
2006
1608
atom_expr
2007
1608
~
2008
1608
and_expr
2009
1608
-
2010
1608
{
2011
1608
atom
2012
1608
or_test
2013
1608
arith_expr
2014
1608
power
2015
1608
STRING
2016
1608
NAME
2017
1608
(
2018
1608
and_test
2019
1608
term
2020
1608
+
2021
1608
xor_expr
2022
1608
shift_expr
2023
1608
NUMBER
2024
1608
not
2025
1608
False
2026
1608
expr
2027
1608
comparison
2028
1608
not_test
2029
1608
None
2030
1609
,
trailer -> ( arglist )
1609
.
trailer -> ( arglist )
1609
|
trailer -> ( arglist )
1609
^
trailer -> ( arglist )
1609
==
trailer -> ( arglist )
1609
**
trailer -> ( arglist )
1609
>>
trailer -> ( arglist )
1609
not
trailer -> ( arglist )
1609
<<
trailer -> ( arglist )
1609
>=
trailer -> ( arglist )
1609
!=
trailer -> ( arglist )
1609
in
trailer -> ( arglist )
1609
[
trailer -> ( arglist )
1609
(
trailer -> ( arglist )
1609
]
trailer -> ( arglist )
1609
>
trailer -> ( arglist )
1609
and
trailer -> ( arglist )
1609
+
trailer -> ( arglist )
1609
%
trailer -> ( arglist )
1609
or
trailer -> ( arglist )
1609
*
trailer -> ( arglist )
1609
for
trailer -> ( arglist )
1609
is
trailer -> ( arglist )
1609
&
trailer -> ( arglist )
1609
//
trailer -> ( arglist )
1609
<
trailer -> ( arglist )
1609
if
trailer -> ( arglist )
1609
<=
trailer -> ( arglist )
1609
-
trailer -> ( arglist )
1609
/
trailer -> ( arglist )
1609
@
trailer -> ( arglist )
1610
for
trailer -> [ subscriptlist ]
1610
]
trailer -> [ subscriptlist ]
1610
<=
trailer -> [ subscriptlist ]
1610
<<
trailer -> [ subscriptlist ]
1610
*
trailer -> [ subscriptlist ]
1610
+
trailer -> [ subscriptlist ]
1610
in
trailer -> [ subscriptlist ]
1610
>>
trailer -> [ subscriptlist ]
1610
//
trailer -> [ subscriptlist ]
1610
.
trailer -> [ subscriptlist ]
1610
,
trailer -> [ subscriptlist ]
1610
and
trailer -> [ subscriptlist ]
1610
**
trailer -> [ subscriptlist ]
1610
@
trailer -> [ subscriptlist ]
1610
<
trailer -> [ subscriptlist ]
1610
not
trailer -> [ subscriptlist ]
1610
-
trailer -> [ subscriptlist ]
1610
!=
trailer -> [ subscriptlist ]
1610
%
trailer -> [ subscriptlist ]
1610
[
trailer -> [ subscriptlist ]
1610
/
trailer -> [ subscriptlist ]
1610
or
trailer -> [ subscriptlist ]
1610
&
trailer -> [ subscriptlist ]
1610
>=
trailer -> [ subscriptlist ]
1610
==
trailer -> [ subscriptlist ]
1610
(
trailer -> [ subscriptlist ]
1610
|
trailer -> [ subscriptlist ]
1610
is
trailer -> [ subscriptlist ]
1610
if
trailer -> [ subscriptlist ]
1610
>
trailer -> [ subscriptlist ]
1610
^
trailer -> [ subscriptlist ]
1611
[
2031
1611
factor
2032
1611
True
2033
1611
atom_expr
2034
1611
~
2035
1611
not
2036
1611
and_expr
2037
1611
-
2038
1611
{
2039
1611
atom
2040
1611
(
2041
1611
arith_expr
2042
1611
power
2043
1611
STRING
2044
1611
NAME
2045
1611
and_test
2046
1611
term
2047
1611
+
2048
1611
xor_expr
2049
1611
shift_expr
2050
1611
NUMBER
2051
1611
False
2052
1611
expr
2053
1611
comparison
2054
1611
not_test
2055
1611
None
2056
1611
or_test
2057
1612
!=
atom -> [ ]
1612
>>
atom -> [ ]
1612
|
atom -> [ ]
1612
<<
atom -> [ ]
1612
>
atom -> [ ]
1612
.
atom -> [ ]
1612
%
atom -> [ ]
1612
^
atom -> [ ]
1612
-
atom -> [ ]
1612
,
atom -> [ ]
1612
in
atom -> [ ]
1612
or
atom -> [ ]
1612
/
atom -> [ ]
1612
**
atom -> [ ]
1612
//
atom -> [ ]
1612
not
atom -> [ ]
1612
(
atom -> [ ]
1612
+
atom -> [ ]
1612
and
atom -> [ ]
1612
]
atom -> [ ]
1612
==
atom -> [ ]
1612
[
atom -> [ ]
1612
if
atom -> [ ]
1612
<
atom -> [ ]
1612
<=
atom -> [ ]
1612
>=
atom -> [ ]
1612
is
atom -> [ ]
1612
*
atom -> [ ]
1612
@
atom -> [ ]
1612
&
atom -> [ ]
1613
]
2058
1614
term
2059
1614
[
1052
1614
factor
1053
1614
True
1054
1614
atom_expr
1055
1614
~
1056
1614
-
1059
1614
atom
1061
1614
{
1062
1614
(
1064
1614
power
1066
1614
STRING
1067
1614
NAME
1068
1614
+
1072
1614
NUMBER
1074
1614
False
1075
1614
None
1077
1615
[
1052
1615
factor
1053
1615
True
1054
1615
atom_expr
1055
1615
~
1056
1615
-
1059
1615
atom
1061
1615
{
1062
1615
term
2060
1615
(
1064
1615
power
1066
1615
STRING
1067
1615
NAME
1068
1615
+
1072
1615
NUMBER
1074
1615
False
1075
1615
None
1077
1616
[
1052
1616
factor
1053
1616
True
1054
1616
term
2061
1616
~
1056
1616
-
1059
1616
atom_expr
1055
1616
atom
1061
1616
{
1062
1616
(
1064
1616
power
1066
1616
STRING
1067
1616
NAME
1068
1616
+
1072
1616
NUMBER
1074
1616
False
1075
1616
None
1077
1617
[
1052
1617
factor
1053
1617
True
1054
1617
atom_expr
1055
1617
~
1056
1617
-
1059
1617
atom
1061
1617
{
1062
1617
(
1064
1617
power
1066
1617
STRING
1067
1617
NAME
1068
1617
term
2062
1617
+
1072
1617
NUMBER
1074
1617
False
1075
1617
None
1077
1618
[
1052
1618
factor
1053
1618
True
1054
1618
atom_expr
1055
1618
~
1056
1618
-
1059
1618
atom
1061
1618
{
1062
1618
(
1064
1618
power
1066
1618
STRING
1067
1618
NAME
1068
1618
term
2063
1618
+
1072
1618
NUMBER
1074
1618
False
1075
1618
None
1077
1619
[
1052
1619
True
1054
1619
atom_expr
1055
1619
-
1059
1619
~
1056
1619
atom
1061
1619
{
1062
1619
(
1064
1619
power
1066
1619
STRING
1067
1619
NAME
1068
1619
+
1072
1619
NUMBER
1074
1619
False
1075
1619
factor
2064
1619
None
1077
1620
@
factor -> ~ factor
1620
>>
factor -> ~ factor
1620
<=
factor -> ~ factor
1620
and
factor -> ~ factor
1620
+
factor -> ~ factor
1620
*
factor -> ~ factor
1620
!=
factor -> ~ factor
1620
%
factor -> ~ factor
1620
<<
factor -> ~ factor
1620
>=
factor -> ~ factor
1620
,
factor -> ~ factor
1620
&
factor -> ~ factor
1620
]
factor -> ~ factor
1620
is
factor -> ~ factor
1620
==
factor -> ~ factor
1620
//
factor -> ~ factor
1620
<
factor -> ~ factor
1620
/
factor -> ~ factor
1620
not
factor -> ~ factor
1620
-
factor -> ~ factor
1620
or
factor -> ~ factor
1620
|
factor -> ~ factor
1620
>
factor -> ~ factor
1620
^
factor -> ~ factor
1620
if
factor -> ~ factor
1620
in
factor -> ~ factor
1621
,
not_test -> not not_test
1621
]
not_test -> not not_test
1621
and
not_test -> not not_test
1621
or
not_test -> not not_test
1621
if
not_test -> not not_test
1622
[
1052
1622
factor
1053
1622
True
1054
1622
atom_expr
1055
1622
~
1056
1622
and_expr
1058
1622
-
1059
1622
shift_expr
1060
1622
atom
1061
1622
{
1062
1622
xor_expr
2065
1622
(
1064
1622
arith_expr
1065
1622
power
1066
1622
STRING
1067
1622
NAME
1068
1622
term
1071
1622
+
1072
1622
NUMBER
1074
1622
False
1075
1622
None
1077
1623
@
factor -> - factor
1623
<=
factor -> - factor
1623
in
factor -> - factor
1623
>>
factor -> - factor
1623
|
factor -> - factor
1623
is
factor -> - factor
1623
+
factor -> - factor
1623
%
factor -> - factor
1623
<
factor -> - factor
1623
*
factor -> - factor
1623
<<
factor -> - factor
1623
if
factor -> - factor
1623
-
factor -> - factor
1623
>=
factor -> - factor
1623
not
factor -> - factor
1623
and
factor -> - factor
1623
/
factor -> - factor
1623
or
factor -> - factor
1623
^
factor -> - factor
1623
>
factor -> - factor
1623
!=
factor -> - factor
1623
&
factor -> - factor
1623
==
factor -> - factor
1623
//
factor -> - factor
1623
]
factor -> - factor
1623
,
factor -> - factor
1624
[
1052
1624
factor
1053
1624
True
1054
1624
atom_expr
1055
1624
~
1056
1624
-
1059
1624
shift_expr
1060
1624
atom
1061
1624
{
1062
1624
(
1064
1624
arith_expr
1065
1624
power
1066
1624
STRING
1067
1624
NAME
1068
1624
and_expr
2066
1624
term
1071
1624
+
1072
1624
NUMBER
1074
1624
False
1075
1624
None
1077
1625
[
766
1625
factor
767
1625
True
768
1625
atom_expr
769
1625
~
770
1625
and_expr
771
1625
-
772
1625
{
773
1625
shift_expr
774
1625
atom
775
1625
comparison
776
1625
and_test
777
1625
arith_expr
778
1625
power
779
1625
STRING
780
1625
NAME
781
1625
(
782
1625
term
784
1625
+
785
1625
xor_expr
786
1625
)
2067
1625
or_test
788
1625
arglist
2068
1625
NUMBER
789
1625
not
790
1625
False
791
1625
expr
792
1625
*
793
1625
not_test
794
1625
None
795
1625
lambdef
796
1625
lambda
797
1625
test
798
1625
argument
799
1625
**
800
1626
trailer_expr
2069
1626
>>
trailer_expr -> 
1626
(
1625
1626
trailer
1626
1626
.
1628
1626
+
trailer_expr -> 
1626
[
1629
1626
is
trailer_expr -> 
1626
>
trailer_expr -> 
1626
not
trailer_expr -> 
1626
|
trailer_expr -> 
1626
&
trailer_expr -> 
1626
/
trailer_expr -> 
1626
@
trailer_expr -> 
1626
!=
trailer_expr -> 
1626
**
trailer_expr -> 
1626
>=
trailer_expr -> 
1626
^
trailer_expr -> 
1626
in
trailer_expr -> 
1626
]
trailer_expr -> 
1626
<<
trailer_expr -> 
1626
and
trailer_expr -> 
1626
or
trailer_expr -> 
1626
if
trailer_expr -> 
1626
//
trailer_expr -> 
1626
%
trailer_expr -> 
1626
,
trailer_expr -> 
1626
<=
trailer_expr -> 
1626
<
trailer_expr -> 
1626
==
trailer_expr -> 
1626
-
trailer_expr -> 
1626
*
trailer_expr -> 
1627
^
atom_expr -> atom trailer_expr
1627
or
atom_expr -> atom trailer_expr
1627
&
atom_expr -> atom trailer_expr
1627
@
atom_expr -> atom trailer_expr
1627
|
atom_expr -> atom trailer_expr
1627
-
atom_expr -> atom trailer_expr
1627
*
atom_expr -> atom trailer_expr
1627
%
atom_expr -> atom trailer_expr
1627
==
atom_expr -> atom trailer_expr
1627
**
atom_expr -> atom trailer_expr
1627
and
atom_expr -> atom trailer_expr
1627
is
atom_expr -> atom trailer_expr
1627
in
atom_expr -> atom trailer_expr
1627
<<
atom_expr -> atom trailer_expr
1627
!=
atom_expr -> atom trailer_expr
1627
<=
atom_expr -> atom trailer_expr
1627
/
atom_expr -> atom trailer_expr
1627
//
atom_expr -> atom trailer_expr
1627
<
atom_expr -> atom trailer_expr
1627
>=
atom_expr -> atom trailer_expr
1627
>>
atom_expr -> atom trailer_expr
1627
if
atom_expr -> atom trailer_expr
1627
not
atom_expr -> atom trailer_expr
1627
+
atom_expr -> atom trailer_expr
1627
]
atom_expr -> atom trailer_expr
1627
>
atom_expr -> atom trailer_expr
1627
,
atom_expr -> atom trailer_expr
1628
NAME
2070
1629
[
802
1629
factor
803
1629
True
804
1629
atom_expr
810
1629
~
806
1629
not
807
1629
and_expr
808
1629
-
809
1629
shift_expr
811
1629
atom
812
1629
{
813
1629
comparison
814
1629
or_test
815
1629
(
816
1629
arith_expr
817
1629
power
818
1629
STRING
819
1629
NAME
820
1629
and_test
821
1629
subscriptlist
2071
1629
term
822
1629
+
823
1629
xor_expr
824
1629
test
825
1629
NUMBER
826
1629
False
827
1629
subscript
828
1629
expr
829
1629
not_test
830
1629
None
831
1629
lambdef
832
1629
lambda
833
1629
maybe_test
834
1629
:
maybe_test -> 
1630
in
atom -> { }
1630
<=
atom -> { }
1630
*
atom -> { }
1630
>
atom -> { }
1630
+
atom -> { }
1630
@
atom -> { }
1630
,
atom -> { }
1630
>=
atom -> { }
1630
/
atom -> { }
1630
|
atom -> { }
1630
is
atom -> { }
1630
and
atom -> { }
1630
if
atom -> { }
1630
(
atom -> { }
1630
>>
atom -> { }
1630
]
atom -> { }
1630
not
atom -> { }
1630
-
atom -> { }
1630
<<
atom -> { }
1630
**
atom -> { }
1630
or
atom -> { }
1630
<
atom -> { }
1630
!=
atom -> { }
1630
==
atom -> { }
1630
%
atom -> { }
1630
//
atom -> { }
1630
&
atom -> { }
1630
[
atom -> { }
1630
.
atom -> { }
1630
^
atom -> { }
1631
)
2072
1632
or
atom -> ( )
1632
>>
atom -> ( )
1632
(
atom -> ( )
1632
<=
atom -> ( )
1632
.
atom -> ( )
1632
is
atom -> ( )
1632
@
atom -> ( )
1632
,
atom -> ( )
1632
%
atom -> ( )
1632
<<
atom -> ( )
1632
**
atom -> ( )
1632
^
atom -> ( )
1632
/
atom -> ( )
1632
if
atom -> ( )
1632
not
atom -> ( )
1632
*
atom -> ( )
1632
!=
atom -> ( )
1632
<
atom -> ( )
1632
&
atom -> ( )
1632
-
atom -> ( )
1632
>
atom -> ( )
1632
//
atom -> ( )
1632
==
atom -> ( )
1632
]
atom -> ( )
1632
in
atom -> ( )
1632
+
atom -> ( )
1632
[
atom -> ( )
1632
>=
atom -> ( )
1632
and
atom -> ( )
1632
|
atom -> ( )
1633
[
1052
1633
factor
1053
1633
True
1054
1633
atom_expr
1055
1633
~
1056
1633
-
1059
1633
atom
1061
1633
{
1062
1633
(
1064
1633
arith_expr
1065
1633
power
1066
1633
STRING
1067
1633
NAME
1068
1633
shift_expr
2073
1633
term
1071
1633
+
1072
1633
NUMBER
1074
1633
False
1075
1633
None
1077
1634
[
1052
1634
factor
1053
1634
True
1054
1634
atom_expr
1055
1634
~
1056
1634
-
1059
1634
atom
1061
1634
{
1062
1634
(
1064
1634
arith_expr
1065
1634
power
1066
1634
STRING
1067
1634
NAME
1068
1634
term
1071
1634
+
1072
1634
NUMBER
1074
1634
False
1075
1634
shift_expr
2074
1634
None
1077
1635
[
1052
1635
factor
1053
1635
True
1054
1635
atom_expr
1055
1635
~
1056
1635
not
1057
1635
and_expr
1058
1635
-
1059
1635
shift_expr
1060
1635
atom
1061
1635
{
1062
1635
comparison
1063
1635
(
1064
1635
arith_expr
1065
1635
power
1066
1635
STRING
1067
1635
NAME
1068
1635
or_test
2075
1635
and_test
1069
1635
term
1071
1635
+
1072
1635
xor_expr
1073
1635
NUMBER
1074
1635
False
1075
1635
not_test
1076
1635
None
1077
1635
expr
1078
1636
[
1052
1636
factor
1053
1636
True
1054
1636
atom_expr
1055
1636
~
1056
1636
-
1059
1636
arith_expr
2076
1636
atom
1061
1636
{
1062
1636
(
1064
1636
power
1066
1636
STRING
1067
1636
NAME
1068
1636
term
1071
1636
+
1072
1636
NUMBER
1074
1636
False
1075
1636
None
1077
1637
[
1052
1637
factor
1053
1637
True
1054
1637
atom_expr
1055
1637
~
1056
1637
-
1059
1637
atom
1061
1637
{
1062
1637
arith_expr
2077
1637
(
1064
1637
power
1066
1637
STRING
1067
1637
NAME
1068
1637
term
1071
1637
+
1072
1637
NUMBER
1074
1637
False
1075
1637
None
1077
1638
-
factor -> + factor
1638
@
factor -> + factor
1638
<<
factor -> + factor
1638
is
factor -> + factor
1638
and
factor -> + factor
1638
<=
factor -> + factor
1638
or
factor -> + factor
1638
<
factor -> + factor
1638
^
factor -> + factor
1638
not
factor -> + factor
1638
//
factor -> + factor
1638
,
factor -> + factor
1638
*
factor -> + factor
1638
in
factor -> + factor
1638
&
factor -> + factor
1638
+
factor -> + factor
1638
if
factor -> + factor
1638
>>
factor -> + factor
1638
|
factor -> + factor
1638
%
factor -> + factor
1638
>
factor -> + factor
1638
>=
factor -> + factor
1638
!=
factor -> + factor
1638
]
factor -> + factor
1638
/
factor -> + factor
1638
==
factor -> + factor
1639
[
1052
1639
factor
1053
1639
True
1054
1639
atom_expr
1055
1639
~
1056
1639
and_expr
1058
1639
-
1059
1639
shift_expr
1060
1639
atom
1061
1639
{
1062
1639
expr
2078
1639
(
1064
1639
arith_expr
1065
1639
power
1066
1639
STRING
1067
1639
NAME
1068
1639
term
1071
1639
+
1072
1639
xor_expr
1073
1639
NUMBER
1074
1639
False
1075
1639
None
1077
1640
[
1052
1640
factor
1053
1640
True
1054
1640
atom_expr
1055
1640
~
1056
1640
not
1057
1640
and_expr
1058
1640
-
1059
1640
shift_expr
1060
1640
atom
1061
1640
{
1062
1640
comparison
1063
1640
(
1064
1640
arith_expr
1065
1640
power
1066
1640
STRING
1067
1640
NAME
1068
1640
term
1071
1640
+
1072
1640
xor_expr
1073
1640
NUMBER
1074
1640
False
1075
1640
and_test
2079
1640
not_test
1076
1640
None
1077
1640
expr
1078
1641
[
1052
1641
factor
1053
1641
True
1054
1641
atom_expr
1055
1641
~
1056
1641
and_expr
1058
1641
-
1059
1641
shift_expr
1060
1641
atom
1061
1641
{
1062
1641
(
1064
1641
arith_expr
1065
1641
power
1066
1641
STRING
1067
1641
NAME
1068
1641
term
1071
1641
+
1072
1641
xor_expr
1073
1641
NUMBER
1074
1641
False
1075
1641
None
1077
1641
expr
1078
1641
comparison
2080
1642
:
2081
1643
[
1052
1643
factor
1053
1643
True
1054
1643
atom_expr
1055
1643
~
1056
1643
not
1057
1643
and_expr
1058
1643
-
1059
1643
shift_expr
1060
1643
atom
1061
1643
{
1062
1643
comparison
1063
1643
(
1064
1643
arith_expr
1065
1643
power
1066
1643
STRING
1067
1643
NAME
1068
1643
and_test
1069
1643
term
1071
1643
+
1072
1643
xor_expr
1073
1643
NUMBER
1074
1643
False
1075
1643
not_test
1076
1643
None
1077
1643
expr
1078
1643
lambda
1079
1643
or_test
1080
1643
test
2082
1643
lambdef
1081
1644
[
738
1644
factor
740
1644
True
741
1644
~
742
1644
and_expr
743
1644
-
744
1644
atom
745
1644
{
746
1644
arith_expr
747
1644
power
748
1644
atom_expr
749
1644
STRING
750
1644
NAME
751
1644
(
752
1644
term
753
1644
+
754
1644
xor_expr
755
1644
shift_expr
756
1644
NUMBER
757
1644
not
758
1644
False
759
1644
or_test
2083
1644
comparison
760
1644
not_test
761
1644
None
762
1644
expr
763
1644
and_test
764
1645
,
lambdef -> lambda varargslist : test
1645
]
lambdef -> lambda varargslist : test
1645
for
lambdef -> lambda varargslist : test
1646
[
166
1646
factor
167
1646
True
168
1646
atom_expr
169
1646
~
170
1646
not
171
1646
and_expr
172
1646
-
173
1646
{
174
1646
shift_expr
175
1646
atom
176
1646
comparison
178
1646
(
179
1646
arith_expr
180
1646
power
181
1646
STRING
182
1646
NAME
183
1646
and_test
185
1646
term
186
1646
+
187
1646
xor_expr
188
1646
NUMBER
190
1646
False
191
1646
expr
192
1646
not_test
193
1646
None
194
1646
lambdef
195
1646
test
2084
1646
lambda
196
1646
or_test
197
1647
arith_expr
1
1647
small_stmt
20
1647
factor
17
1647
True
38
1647
atom_expr
31
1647
term
22
1647
-
26
1647
None
55
1647
atom
57
1647
test
5
1647
comparison
49
1647
and_expr
8
1647
power
9
1647
STRING
10
1647
NAME
52
1647
shift_expr
48
1647
lambdef
15
1647
NUMBER
58
1647
simple_stmt
1094
1647
(
16
1647
expr
47
1647
[
18
1647
NEWLINE
1095
1647
not_test
32
1647
{
21
1647
suite
2085
1647
and_test
46
1647
+
27
1647
lambda
29
1647
xor_expr
41
1647
yield
34
1647
not
62
1647
test_list
36
1647
~
37
1647
or_test
53
1647
False
39
1647
sim_stmt
45
1647
nonlocal
72
1647
nonlocal_stmt
73
1647
return
59
1647
break_stmt
60
1647
return_stmt
61
1647
raise_stmt
74
1647
break
63
1647
yield_stmt
75
1647
raise
64
1647
continue
77
1647
expr_stmt
65
1647
endsim
78
1647
del
80
1647
pass_stmt
81
1647
flow_stmt
82
1647
stat_stmt
66
1647
assert_stmt
68
1647
resetstats
84
1647
del_stmt
85
1647
continue_stmt
86
1647
begsim
69
1647
global_stmt
87
1647
pass
88
1647
global
70
1647
assert
71
1648
:
2086
1649
arith_expr
1
1649
try
1533
1649
modopt
1534
1649
compound_stmt
1535
1649
test
5
1649
servmod
1536
1649
while
1537
1649
and_expr
8
1649
power
9
1649
STRING
10
1649
decorated
1538
1649
cli_serv_model
1539
1649
@
13
1649
try_stmt
1540
1649
lambdef
15
1649
stmt_list
2087
1649
(
16
1649
factor
17
1649
[
18
1649
class
1541
1649
small_stmt
1542
1649
{
21
1649
term
22
1649
def
1543
1649
server
1544
1649
while_stmt
1545
1649
-
26
1649
+
27
1649
for
1546
1649
if
1547
1649
lambda
29
1649
decorators
1548
1649
atom_expr
31
1649
not_test
32
1649
if_stmt
1549
1649
yield
34
1649
conf
1550
1649
test_list
36
1649
~
37
1649
True
38
1649
False
39
1649
funcdef
1551
1649
xor_expr
41
1649
with
1552
1649
for_stmt
1553
1649
sim_stmt
45
1649
and_test
46
1649
expr
47
1649
shift_expr
48
1649
comparison
49
1649
with_stmt
1554
1649
simple_stmt
1555
1649
NAME
52
1649
or_test
53
1649
confdef
1556
1649
None
55
1649
classdef
1557
1649
atom
57
1649
NUMBER
58
1649
return
59
1649
break_stmt
60
1649
return_stmt
61
1649
stmt
1558
1649
not
62
1649
break
63
1649
raise
64
1649
expr_stmt
65
1649
stat_stmt
66
1649
decorator
67
1649
assert_stmt
68
1649
begsim
69
1649
global
70
1649
assert
71
1649
nonlocal
72
1649
nonlocal_stmt
73
1649
raise_stmt
74
1649
yield_stmt
75
1649
continue
77
1649
endsim
78
1649
del
80
1649
pass_stmt
81
1649
flow_stmt
82
1649
resetstats
84
1649
del_stmt
85
1649
continue_stmt
86
1649
global_stmt
87
1649
pass
88
1650
:
2088
1651
arith_expr
1
1651
small_stmt
20
1651
factor
17
1651
True
38
1651
atom_expr
31
1651
term
22
1651
-
26
1651
None
55
1651
atom
57
1651
test
5
1651
comparison
49
1651
and_expr
8
1651
power
9
1651
STRING
10
1651
NAME
52
1651
suite
2089
1651
shift_expr
48
1651
lambdef
15
1651
NUMBER
58
1651
simple_stmt
1094
1651
(
16
1651
expr
47
1651
[
18
1651
NEWLINE
1095
1651
not_test
32
1651
{
21
1651
and_test
46
1651
+
27
1651
lambda
29
1651
xor_expr
41
1651
yield
34
1651
not
62
1651
test_list
36
1651
~
37
1651
or_test
53
1651
False
39
1651
sim_stmt
45
1651
nonlocal
72
1651
nonlocal_stmt
73
1651
return
59
1651
break_stmt
60
1651
return_stmt
61
1651
raise_stmt
74
1651
break
63
1651
yield_stmt
75
1651
raise
64
1651
continue
77
1651
expr_stmt
65
1651
endsim
78
1651
del
80
1651
pass_stmt
81
1651
flow_stmt
82
1651
stat_stmt
66
1651
assert_stmt
68
1651
resetstats
84
1651
del_stmt
85
1651
continue_stmt
86
1651
begsim
69
1651
global_stmt
87
1651
pass
88
1651
global
70
1651
assert
71
1652
[
2090
1652
factor
2091
1652
True
2092
1652
atom_expr
2093
1652
~
2094
1652
and_expr
2095
1652
-
2096
1652
shift_expr
2097
1652
atom
2098
1652
{
2099
1652
comparison
2100
1652
and_test
2101
1652
arith_expr
2102
1652
power
2103
1652
STRING
2104
1652
NAME
2105
1652
(
2106
1652
term
2107
1652
+
2108
1652
xor_expr
2109
1652
or_test
2110
1652
NUMBER
2111
1652
not
2112
1652
False
2113
1652
not_test
2114
1652
None
2115
1652
expr
2116
1652
lambda
2117
1652
lambdef
2118
1652
test
2119
1653
)
tfpdef -> NAME
1653
:
2120
1653
,
tfpdef -> NAME
1654
)
param -> ** tfpdef
1654
,
param -> ** tfpdef
1655
[
1002
1655
factor
1003
1655
True
1004
1655
atom_expr
1005
1655
~
1006
1655
and_expr
1007
1655
-
1008
1655
shift_expr
1009
1655
atom
1010
1655
{
1011
1655
comparison
1012
1655
arith_expr
1013
1655
power
1014
1655
STRING
1015
1655
NAME
1016
1655
(
1017
1655
and_test
1018
1655
term
1019
1655
+
1020
1655
xor_expr
1021
1655
or_test
1022
1655
NUMBER
1023
1655
not
1024
1655
False
1025
1655
test
2121
1655
not_test
1026
1655
None
1027
1655
expr
1028
1655
lambda
1029
1655
lambdef
1031
1656
,
param -> * tfpdef
1656
)
param -> * tfpdef
1657
NAME
1099
1657
**
1100
1657
tfpdef
1101
1657
*
1102
1657
param
1103
1657
parameters
2122
1658
confbody
2123
1658
NAME
1971
1659
!=
atom -> [ ]
1659
>>
atom -> [ ]
1659
|
atom -> [ ]
1659
<<
atom -> [ ]
1659
>
atom -> [ ]
1659
.
atom -> [ ]
1659
%
atom -> [ ]
1659
^
atom -> [ ]
1659
-
atom -> [ ]
1659
,
atom -> [ ]
1659
in
atom -> [ ]
1659
:
atom -> [ ]
1659
or
atom -> [ ]
1659
/
atom -> [ ]
1659
**
atom -> [ ]
1659
//
atom -> [ ]
1659
not
atom -> [ ]
1659
(
atom -> [ ]
1659
+
atom -> [ ]
1659
and
atom -> [ ]
1659
==
atom -> [ ]
1659
[
atom -> [ ]
1659
if
atom -> [ ]
1659
<
atom -> [ ]
1659
<=
atom -> [ ]
1659
>=
atom -> [ ]
1659
is
atom -> [ ]
1659
*
atom -> [ ]
1659
@
atom -> [ ]
1659
&
atom -> [ ]
1660
]
2124
1661
term
2125
1661
[
1111
1661
factor
1112
1661
True
1113
1661
atom_expr
1114
1661
~
1115
1661
-
1117
1661
atom
1119
1661
{
1120
1661
power
1124
1661
STRING
1125
1661
NAME
1126
1661
(
1128
1661
+
1131
1661
NUMBER
1133
1661
False
1135
1661
None
1139
1662
[
1111
1662
factor
1112
1662
True
1113
1662
term
2126
1662
~
1115
1662
-
1117
1662
atom_expr
1114
1662
atom
1119
1662
{
1120
1662
power
1124
1662
STRING
1125
1662
NAME
1126
1662
(
1128
1662
+
1131
1662
NUMBER
1133
1662
False
1135
1662
None
1139
1663
[
1111
1663
factor
1112
1663
True
1113
1663
atom_expr
1114
1663
~
1115
1663
-
1117
1663
atom
1119
1663
{
1120
1663
power
1124
1663
STRING
1125
1663
NAME
1126
1663
(
1128
1663
term
2127
1663
+
1131
1663
NUMBER
1133
1663
False
1135
1663
None
1139
1664
[
1111
1664
factor
1112
1664
True
1113
1664
atom_expr
1114
1664
~
1115
1664
-
1117
1664
atom
1119
1664
{
1120
1664
power
1124
1664
STRING
1125
1664
NAME
1126
1664
(
1128
1664
term
2128
1664
+
1131
1664
NUMBER
1133
1664
False
1135
1664
None
1139
1665
[
1111
1665
factor
1112
1665
True
1113
1665
atom_expr
1114
1665
~
1115
1665
-
1117
1665
atom
1119
1665
{
1120
1665
power
1124
1665
STRING
1125
1665
NAME
1126
1665
term
2129
1665
(
1128
1665
+
1131
1665
NUMBER
1133
1665
False
1135
1665
None
1139
1666
[
1111
1666
True
1113
1666
atom_expr
1114
1666
-
1117
1666
~
1115
1666
atom
1119
1666
{
1120
1666
power
1124
1666
STRING
1125
1666
NAME
1126
1666
(
1128
1666
+
1131
1666
NUMBER
1133
1666
False
1135
1666
factor
2130
1666
None
1139
1667
@
factor -> ~ factor
1667
>>
factor -> ~ factor
1667
<=
factor -> ~ factor
1667
and
factor -> ~ factor
1667
+
factor -> ~ factor
1667
:
factor -> ~ factor
1667
*
factor -> ~ factor
1667
!=
factor -> ~ factor
1667
%
factor -> ~ factor
1667
<<
factor -> ~ factor
1667
>=
factor -> ~ factor
1667
,
factor -> ~ factor
1667
&
factor -> ~ factor
1667
is
factor -> ~ factor
1667
==
factor -> ~ factor
1667
//
factor -> ~ factor
1667
<
factor -> ~ factor
1667
/
factor -> ~ factor
1667
not
factor -> ~ factor
1667
-
factor -> ~ factor
1667
or
factor -> ~ factor
1667
|
factor -> ~ factor
1667
>
factor -> ~ factor
1667
^
factor -> ~ factor
1667
if
factor -> ~ factor
1667
in
factor -> ~ factor
1668
[
1111
1668
factor
1112
1668
True
1113
1668
atom_expr
1114
1668
~
1115
1668
and_expr
1116
1668
-
1117
1668
shift_expr
1118
1668
atom
1119
1668
{
1120
1668
xor_expr
2131
1668
arith_expr
1123
1668
power
1124
1668
STRING
1125
1668
NAME
1126
1668
(
1128
1668
term
1130
1668
+
1131
1668
NUMBER
1133
1668
False
1135
1668
None
1139
1669
@
factor -> - factor
1669
<=
factor -> - factor
1669
in
factor -> - factor
1669
>>
factor -> - factor
1669
|
factor -> - factor
1669
is
factor -> - factor
1669
+
factor -> - factor
1669
%
factor -> - factor
1669
<
factor -> - factor
1669
*
factor -> - factor
1669
<<
factor -> - factor
1669
if
factor -> - factor
1669
-
factor -> - factor
1669
>=
factor -> - factor
1669
not
factor -> - factor
1669
and
factor -> - factor
1669
/
factor -> - factor
1669
:
factor -> - factor
1669
or
factor -> - factor
1669
^
factor -> - factor
1669
>
factor -> - factor
1669
!=
factor -> - factor
1669
&
factor -> - factor
1669
==
factor -> - factor
1669
//
factor -> - factor
1669
,
factor -> - factor
1670
[
1111
1670
factor
1112
1670
True
1113
1670
atom_expr
1114
1670
~
1115
1670
-
1117
1670
shift_expr
1118
1670
atom
1119
1670
{
1120
1670
arith_expr
1123
1670
power
1124
1670
STRING
1125
1670
NAME
1126
1670
(
1128
1670
term
1130
1670
+
1131
1670
and_expr
2132
1670
NUMBER
1133
1670
False
1135
1670
None
1139
1671
[
766
1671
factor
767
1671
True
768
1671
atom_expr
769
1671
~
770
1671
and_expr
771
1671
-
772
1671
{
773
1671
shift_expr
774
1671
atom
775
1671
comparison
776
1671
and_test
777
1671
arith_expr
778
1671
power
779
1671
STRING
780
1671
NAME
781
1671
(
782
1671
term
784
1671
+
785
1671
xor_expr
786
1671
)
2133
1671
or_test
788
1671
arglist
2134
1671
NUMBER
789
1671
not
790
1671
False
791
1671
expr
792
1671
*
793
1671
not_test
794
1671
None
795
1671
lambdef
796
1671
lambda
797
1671
test
798
1671
argument
799
1671
**
800
1672
trailer_expr
2135
1672
>>
trailer_expr -> 
1672
(
1671
1672
trailer
1672
1672
.
1674
1672
+
trailer_expr -> 
1672
[
1675
1672
is
trailer_expr -> 
1672
>
trailer_expr -> 
1672
not
trailer_expr -> 
1672
|
trailer_expr -> 
1672
&
trailer_expr -> 
1672
/
trailer_expr -> 
1672
@
trailer_expr -> 
1672
!=
trailer_expr -> 
1672
**
trailer_expr -> 
1672
>=
trailer_expr -> 
1672
^
trailer_expr -> 
1672
in
trailer_expr -> 
1672
<<
trailer_expr -> 
1672
and
trailer_expr -> 
1672
or
trailer_expr -> 
1672
if
trailer_expr -> 
1672
:
trailer_expr -> 
1672
//
trailer_expr -> 
1672
%
trailer_expr -> 
1672
,
trailer_expr -> 
1672
<=
trailer_expr -> 
1672
<
trailer_expr -> 
1672
==
trailer_expr -> 
1672
-
trailer_expr -> 
1672
*
trailer_expr -> 
1673
^
atom_expr -> atom trailer_expr
1673
or
atom_expr -> atom trailer_expr
1673
&
atom_expr -> atom trailer_expr
1673
@
atom_expr -> atom trailer_expr
1673
|
atom_expr -> atom trailer_expr
1673
-
atom_expr -> atom trailer_expr
1673
*
atom_expr -> atom trailer_expr
1673
%
atom_expr -> atom trailer_expr
1673
==
atom_expr -> atom trailer_expr
1673
**
atom_expr -> atom trailer_expr
1673
and
atom_expr -> atom trailer_expr
1673
is
atom_expr -> atom trailer_expr
1673
in
atom_expr -> atom trailer_expr
1673
<<
atom_expr -> atom trailer_expr
1673
!=
atom_expr -> atom trailer_expr
1673
<=
atom_expr -> atom trailer_expr
1673
/
atom_expr -> atom trailer_expr
1673
//
atom_expr -> atom trailer_expr
1673
<
atom_expr -> atom trailer_expr
1673
>=
atom_expr -> atom trailer_expr
1673
>>
atom_expr -> atom trailer_expr
1673
if
atom_expr -> atom trailer_expr
1673
not
atom_expr -> atom trailer_expr
1673
:
atom_expr -> atom trailer_expr
1673
+
atom_expr -> atom trailer_expr
1673
>
atom_expr -> atom trailer_expr
1673
,
atom_expr -> atom trailer_expr
1674
NAME
2136
1675
[
802
1675
factor
803
1675
True
804
1675
atom_expr
810
1675
~
806
1675
not
807
1675
and_expr
808
1675
-
809
1675
shift_expr
811
1675
atom
812
1675
{
813
1675
comparison
814
1675
or_test
815
1675
(
816
1675
arith_expr
817
1675
power
818
1675
STRING
819
1675
NAME
820
1675
and_test
821
1675
subscriptlist
2137
1675
term
822
1675
+
823
1675
xor_expr
824
1675
test
825
1675
NUMBER
826
1675
False
827
1675
subscript
828
1675
expr
829
1675
not_test
830
1675
None
831
1675
lambdef
832
1675
lambda
833
1675
maybe_test
834
1675
:
maybe_test -> 
1676
in
atom -> { }
1676
<=
atom -> { }
1676
*
atom -> { }
1676
>
atom -> { }
1676
+
atom -> { }
1676
@
atom -> { }
1676
,
atom -> { }
1676
>=
atom -> { }
1676
/
atom -> { }
1676
:
atom -> { }
1676
|
atom -> { }
1676
is
atom -> { }
1676
and
atom -> { }
1676
if
atom -> { }
1676
(
atom -> { }
1676
>>
atom -> { }
1676
not
atom -> { }
1676
-
atom -> { }
1676
<<
atom -> { }
1676
**
atom -> { }
1676
or
atom -> { }
1676
<
atom -> { }
1676
!=
atom -> { }
1676
==
atom -> { }
1676
%
atom -> { }
1676
//
atom -> { }
1676
&
atom -> { }
1676
[
atom -> { }
1676
.
atom -> { }
1676
^
atom -> { }
1677
[
738
1677
factor
740
1677
True
741
1677
~
742
1677
and_expr
743
1677
-
744
1677
atom
745
1677
{
746
1677
arith_expr
747
1677
power
748
1677
atom_expr
749
1677
STRING
750
1677
NAME
751
1677
(
752
1677
term
753
1677
+
754
1677
xor_expr
755
1677
shift_expr
756
1677
NUMBER
757
1677
not
758
1677
False
759
1677
or_test
2138
1677
comparison
760
1677
not_test
761
1677
None
762
1677
expr
763
1677
and_test
764
1678
[
1111
1678
factor
1112
1678
True
1113
1678
atom_expr
1114
1678
~
1115
1678
-
1117
1678
atom
1119
1678
{
1120
1678
arith_expr
1123
1678
power
1124
1678
STRING
1125
1678
NAME
1126
1678
shift_expr
2139
1678
(
1128
1678
term
1130
1678
+
1131
1678
NUMBER
1133
1678
False
1135
1678
None
1139
1679
[
1111
1679
factor
1112
1679
True
1113
1679
atom_expr
1114
1679
~
1115
1679
-
1117
1679
atom
1119
1679
{
1120
1679
arith_expr
1123
1679
power
1124
1679
STRING
1125
1679
NAME
1126
1679
(
1128
1679
term
1130
1679
+
1131
1679
NUMBER
1133
1679
False
1135
1679
shift_expr
2140
1679
None
1139
1680
arith_expr
1
1680
small_stmt
965
1680
factor
17
1680
True
38
1680
atom_expr
31
1680
term
22
1680
-
26
1680
None
55
1680
atom
57
1680
test
5
1680
comparison
49
1680
and_expr
8
1680
power
9
1680
STRING
10
1680
NAME
52
1680
shift_expr
48
1680
lambdef
15
1680
suite
2141
1680
NUMBER
58
1680
simple_stmt
966
1680
(
16
1680
expr
47
1680
[
18
1680
NEWLINE
967
1680
not_test
32
1680
{
21
1680
and_test
46
1680
+
27
1680
lambda
29
1680
xor_expr
41
1680
yield
34
1680
not
62
1680
test_list
36
1680
~
37
1680
or_test
53
1680
False
39
1680
sim_stmt
45
1680
nonlocal
72
1680
nonlocal_stmt
73
1680
return
59
1680
break_stmt
60
1680
return_stmt
61
1680
raise_stmt
74
1680
break
63
1680
yield_stmt
75
1680
raise
64
1680
continue
77
1680
expr_stmt
65
1680
endsim
78
1680
del
80
1680
pass_stmt
81
1680
flow_stmt
82
1680
stat_stmt
66
1680
assert_stmt
68
1680
resetstats
84
1680
del_stmt
85
1680
continue_stmt
86
1680
begsim
69
1680
global_stmt
87
1680
pass
88
1680
global
70
1680
assert
71
1681
)
2142
1682
or
atom -> ( )
1682
>>
atom -> ( )
1682
(
atom -> ( )
1682
<=
atom -> ( )
1682
.
atom -> ( )
1682
is
atom -> ( )
1682
@
atom -> ( )
1682
,
atom -> ( )
1682
%
atom -> ( )
1682
<<
atom -> ( )
1682
**
atom -> ( )
1682
^
atom -> ( )
1682
/
atom -> ( )
1682
if
atom -> ( )
1682
not
atom -> ( )
1682
*
atom -> ( )
1682
!=
atom -> ( )
1682
<
atom -> ( )
1682
&
atom -> ( )
1682
-
atom -> ( )
1682
>
atom -> ( )
1682
//
atom -> ( )
1682
:
atom -> ( )
1682
==
atom -> ( )
1682
in
atom -> ( )
1682
+
atom -> ( )
1682
[
atom -> ( )
1682
>=
atom -> ( )
1682
and
atom -> ( )
1682
|
atom -> ( )
1683
[
1111
1683
factor
1112
1683
True
1113
1683
atom_expr
1114
1683
~
1115
1683
and_expr
1116
1683
-
1117
1683
shift_expr
1118
1683
atom
1119
1683
{
1120
1683
comparison
1121
1683
arith_expr
1123
1683
power
1124
1683
STRING
1125
1683
NAME
1126
1683
(
1128
1683
and_test
1129
1683
term
1130
1683
+
1131
1683
xor_expr
1132
1683
NUMBER
1133
1683
not
1134
1683
False
1135
1683
or_test
2143
1683
expr
1136
1683
not_test
1137
1683
None
1139
1684
[
1111
1684
factor
1112
1684
True
1113
1684
atom_expr
1114
1684
~
1115
1684
-
1117
1684
arith_expr
2144
1684
atom
1119
1684
{
1120
1684
power
1124
1684
STRING
1125
1684
NAME
1126
1684
(
1128
1684
term
1130
1684
+
1131
1684
NUMBER
1133
1684
False
1135
1684
None
1139
1685
[
1111
1685
factor
1112
1685
True
1113
1685
atom_expr
1114
1685
~
1115
1685
-
1117
1685
atom
1119
1685
{
1120
1685
arith_expr
2145
1685
power
1124
1685
STRING
1125
1685
NAME
1126
1685
(
1128
1685
term
1130
1685
+
1131
1685
NUMBER
1133
1685
False
1135
1685
None
1139
1686
-
factor -> + factor
1686
@
factor -> + factor
1686
:
factor -> + factor
1686
<<
factor -> + factor
1686
is
factor -> + factor
1686
and
factor -> + factor
1686
<=
factor -> + factor
1686
or
factor -> + factor
1686
<
factor -> + factor
1686
^
factor -> + factor
1686
not
factor -> + factor
1686
//
factor -> + factor
1686
,
factor -> + factor
1686
*
factor -> + factor
1686
in
factor -> + factor
1686
&
factor -> + factor
1686
+
factor -> + factor
1686
if
factor -> + factor
1686
>>
factor -> + factor
1686
|
factor -> + factor
1686
%
factor -> + factor
1686
>
factor -> + factor
1686
>=
factor -> + factor
1686
!=
factor -> + factor
1686
/
factor -> + factor
1686
==
factor -> + factor
1687
[
1111
1687
factor
1112
1687
True
1113
1687
atom_expr
1114
1687
~
1115
1687
and_expr
1116
1687
-
1117
1687
shift_expr
1118
1687
atom
1119
1687
{
1120
1687
expr
2146
1687
arith_expr
1123
1687
power
1124
1687
STRING
1125
1687
NAME
1126
1687
(
1128
1687
term
1130
1687
+
1131
1687
xor_expr
1132
1687
NUMBER
1133
1687
False
1135
1687
None
1139
1688
,
not_test -> not not_test
1688
and
not_test -> not not_test
1688
or
not_test -> not not_test
1688
if
not_test -> not not_test
1688
:
not_test -> not not_test
1689
[
1111
1689
factor
1112
1689
True
1113
1689
atom_expr
1114
1689
~
1115
1689
and_expr
1116
1689
-
1117
1689
shift_expr
1118
1689
atom
1119
1689
{
1120
1689
arith_expr
1123
1689
power
1124
1689
STRING
1125
1689
NAME
1126
1689
(
1128
1689
term
1130
1689
+
1131
1689
xor_expr
1132
1689
NUMBER
1133
1689
False
1135
1689
expr
1136
1689
None
1139
1689
comparison
2147
1690
[
1111
1690
factor
1112
1690
True
1113
1690
atom_expr
1114
1690
~
1115
1690
and_expr
1116
1690
-
1117
1690
shift_expr
1118
1690
atom
1119
1690
{
1120
1690
comparison
1121
1690
arith_expr
1123
1690
power
1124
1690
STRING
1125
1690
NAME
1126
1690
(
1128
1690
term
1130
1690
+
1131
1690
xor_expr
1132
1690
NUMBER
1133
1690
not
1134
1690
False
1135
1690
and_test
2148
1690
expr
1136
1690
not_test
1137
1690
None
1139
1691
[
1111
1691
factor
1112
1691
True
1113
1691
atom_expr
1114
1691
~
1115
1691
and_expr
1116
1691
-
1117
1691
shift_expr
1118
1691
atom
1119
1691
{
1120
1691
comparison
1121
1691
or_test
1122
1691
arith_expr
1123
1691
power
1124
1691
STRING
1125
1691
NAME
1126
1691
(
1128
1691
and_test
1129
1691
term
1130
1691
+
1131
1691
xor_expr
1132
1691
NUMBER
1133
1691
not
1134
1691
False
1135
1691
expr
1136
1691
not_test
1137
1691
test
1138
1691
None
1139
1691
lambdef
1140
1691
lambda
1141
1691
test_list
2149
1692
:
2150
1693
[
1111
1693
factor
1112
1693
True
1113
1693
atom_expr
1114
1693
~
1115
1693
and_expr
1116
1693
-
1117
1693
shift_expr
1118
1693
atom
1119
1693
{
1120
1693
comparison
1121
1693
or_test
1122
1693
arith_expr
1123
1693
power
1124
1693
STRING
1125
1693
NAME
1126
1693
test
2151
1693
(
1128
1693
and_test
1129
1693
term
1130
1693
+
1131
1693
xor_expr
1132
1693
NUMBER
1133
1693
not
1134
1693
False
1135
1693
expr
1136
1693
not_test
1137
1693
None
1139
1693
lambdef
1140
1693
lambda
1141
1694
,
trailer -> ( arglist )
1694
&
trailer -> ( arglist )
1694
//
trailer -> ( arglist )
1694
.
trailer -> ( arglist )
1694
<<
trailer -> ( arglist )
1694
|
trailer -> ( arglist )
1694
%
trailer -> ( arglist )
1694
in
trailer -> ( arglist )
1694
[
trailer -> ( arglist )
1694
(
trailer -> ( arglist )
1694
^
trailer -> ( arglist )
1694
*
trailer -> ( arglist )
1694
**
trailer -> ( arglist )
1694
-
trailer -> ( arglist )
1694
/
trailer -> ( arglist )
1694
@
trailer -> ( arglist )
1694
+
trailer -> ( arglist )
1694
>>
trailer -> ( arglist )
1695
<<
trailer -> [ subscriptlist ]
1695
%
trailer -> [ subscriptlist ]
1695
@
trailer -> [ subscriptlist ]
1695
**
trailer -> [ subscriptlist ]
1695
|
trailer -> [ subscriptlist ]
1695
&
trailer -> [ subscriptlist ]
1695
*
trailer -> [ subscriptlist ]
1695
+
trailer -> [ subscriptlist ]
1695
(
trailer -> [ subscriptlist ]
1695
-
trailer -> [ subscriptlist ]
1695
in
trailer -> [ subscriptlist ]
1695
^
trailer -> [ subscriptlist ]
1695
>>
trailer -> [ subscriptlist ]
1695
[
trailer -> [ subscriptlist ]
1695
//
trailer -> [ subscriptlist ]
1695
/
trailer -> [ subscriptlist ]
1695
.
trailer -> [ subscriptlist ]
1695
,
trailer -> [ subscriptlist ]
1696
,
trailer -> ( arglist )
1696
&
trailer -> ( arglist )
1696
//
trailer -> ( arglist )
1696
.
trailer -> ( arglist )
1696
<<
trailer -> ( arglist )
1696
|
trailer -> ( arglist )
1696
%
trailer -> ( arglist )
1696
[
trailer -> ( arglist )
1696
(
trailer -> ( arglist )
1696
^
trailer -> ( arglist )
1696
NEWLINE
trailer -> ( arglist )
1696
*
trailer -> ( arglist )
1696
**
trailer -> ( arglist )
1696
-
trailer -> ( arglist )
1696
/
trailer -> ( arglist )
1696
@
trailer -> ( arglist )
1696
+
trailer -> ( arglist )
1696
>>
trailer -> ( arglist )
1697
NEWLINE
trailer -> [ subscriptlist ]
1697
<<
trailer -> [ subscriptlist ]
1697
%
trailer -> [ subscriptlist ]
1697
@
trailer -> [ subscriptlist ]
1697
**
trailer -> [ subscriptlist ]
1697
|
trailer -> [ subscriptlist ]
1697
&
trailer -> [ subscriptlist ]
1697
*
trailer -> [ subscriptlist ]
1697
+
trailer -> [ subscriptlist ]
1697
(
trailer -> [ subscriptlist ]
1697
-
trailer -> [ subscriptlist ]
1697
>>
trailer -> [ subscriptlist ]
1697
^
trailer -> [ subscriptlist ]
1697
[
trailer -> [ subscriptlist ]
1697
//
trailer -> [ subscriptlist ]
1697
/
trailer -> [ subscriptlist ]
1697
.
trailer -> [ subscriptlist ]
1697
,
trailer -> [ subscriptlist ]
1698
:
2152
1699
confbody
2153
1699
NAME
1971
1700
NEWLINE
yield_arg -> from test
1701
.
atom -> [ test_list_comp ]
1701
[
atom -> [ test_list_comp ]
1701
@
atom -> [ test_list_comp ]
1701
<=
atom -> [ test_list_comp ]
1701
<
atom -> [ test_list_comp ]
1701
not
atom -> [ test_list_comp ]
1701
in
atom -> [ test_list_comp ]
1701
and
atom -> [ test_list_comp ]
1701
-
atom -> [ test_list_comp ]
1701
if
atom -> [ test_list_comp ]
1701
!=
atom -> [ test_list_comp ]
1701
is
atom -> [ test_list_comp ]
1701
>>
atom -> [ test_list_comp ]
1701
=
atom -> [ test_list_comp ]
1701
or
atom -> [ test_list_comp ]
1701
//
atom -> [ test_list_comp ]
1701
/
atom -> [ test_list_comp ]
1701
,
atom -> [ test_list_comp ]
1701
|
atom -> [ test_list_comp ]
1701
>
atom -> [ test_list_comp ]
1701
NEWLINE
atom -> [ test_list_comp ]
1701
&
atom -> [ test_list_comp ]
1701
(
atom -> [ test_list_comp ]
1701
%
atom -> [ test_list_comp ]
1701
>=
atom -> [ test_list_comp ]
1701
==
atom -> [ test_list_comp ]
1701
**
atom -> [ test_list_comp ]
1701
<<
atom -> [ test_list_comp ]
1701
^
atom -> [ test_list_comp ]
1701
+
atom -> [ test_list_comp ]
1701
*
atom -> [ test_list_comp ]
1702
<<
term -> factor @ term
1702
^
term -> factor @ term
1702
<=
term -> factor @ term
1702
==
term -> factor @ term
1702
if
term -> factor @ term
1702
|
term -> factor @ term
1702
NEWLINE
term -> factor @ term
1702
!=
term -> factor @ term
1702
or
term -> factor @ term
1702
>
term -> factor @ term
1702
and
term -> factor @ term
1702
>>
term -> factor @ term
1702
is
term -> factor @ term
1702
-
term -> factor @ term
1702
not
term -> factor @ term
1702
=
term -> factor @ term
1702
+
term -> factor @ term
1702
in
term -> factor @ term
1702
>=
term -> factor @ term
1702
<
term -> factor @ term
1702
,
term -> factor @ term
1702
&
term -> factor @ term
1703
<=
term -> factor % term
1703
is
term -> factor % term
1703
>
term -> factor % term
1703
and
term -> factor % term
1703
in
term -> factor % term
1703
,
term -> factor % term
1703
or
term -> factor % term
1703
<
term -> factor % term
1703
-
term -> factor % term
1703
NEWLINE
term -> factor % term
1703
!=
term -> factor % term
1703
>>
term -> factor % term
1703
^
term -> factor % term
1703
+
term -> factor % term
1703
if
term -> factor % term
1703
<<
term -> factor % term
1703
>=
term -> factor % term
1703
==
term -> factor % term
1703
not
term -> factor % term
1703
|
term -> factor % term
1703
=
term -> factor % term
1703
&
term -> factor % term
1704
>>
term -> factor / term
1704
!=
term -> factor / term
1704
<
term -> factor / term
1704
<=
term -> factor / term
1704
|
term -> factor / term
1704
is
term -> factor / term
1704
=
term -> factor / term
1704
>=
term -> factor / term
1704
^
term -> factor / term
1704
&
term -> factor / term
1704
+
term -> factor / term
1704
NEWLINE
term -> factor / term
1704
<<
term -> factor / term
1704
and
term -> factor / term
1704
-
term -> factor / term
1704
in
term -> factor / term
1704
>
term -> factor / term
1704
or
term -> factor / term
1704
not
term -> factor / term
1704
==
term -> factor / term
1704
,
term -> factor / term
1704
if
term -> factor / term
1705
is
term -> factor * term
1705
+
term -> factor * term
1705
>=
term -> factor * term
1705
^
term -> factor * term
1705
=
term -> factor * term
1705
NEWLINE
term -> factor * term
1705
,
term -> factor * term
1705
<=
term -> factor * term
1705
or
term -> factor * term
1705
<
term -> factor * term
1705
|
term -> factor * term
1705
>>
term -> factor * term
1705
in
term -> factor * term
1705
not
term -> factor * term
1705
==
term -> factor * term
1705
-
term -> factor * term
1705
and
term -> factor * term
1705
!=
term -> factor * term
1705
<<
term -> factor * term
1705
>
term -> factor * term
1705
if
term -> factor * term
1705
&
term -> factor * term
1706
!=
term -> factor // term
1706
or
term -> factor // term
1706
^
term -> factor // term
1706
>
term -> factor // term
1706
is
term -> factor // term
1706
&
term -> factor // term
1706
-
term -> factor // term
1706
in
term -> factor // term
1706
>>
term -> factor // term
1706
|
term -> factor // term
1706
<
term -> factor // term
1706
>=
term -> factor // term
1706
not
term -> factor // term
1706
if
term -> factor // term
1706
=
term -> factor // term
1706
==
term -> factor // term
1706
NEWLINE
term -> factor // term
1706
<=
term -> factor // term
1706
,
term -> factor // term
1706
and
term -> factor // term
1706
<<
term -> factor // term
1706
+
term -> factor // term
1707
!=
power -> atom_expr ** factor
1707
@
power -> atom_expr ** factor
1707
|
power -> atom_expr ** factor
1707
in
power -> atom_expr ** factor
1707
==
power -> atom_expr ** factor
1707
if
power -> atom_expr ** factor
1707
NEWLINE
power -> atom_expr ** factor
1707
and
power -> atom_expr ** factor
1707
=
power -> atom_expr ** factor
1707
>=
power -> atom_expr ** factor
1707
/
power -> atom_expr ** factor
1707
not
power -> atom_expr ** factor
1707
^
power -> atom_expr ** factor
1707
//
power -> atom_expr ** factor
1707
>
power -> atom_expr ** factor
1707
+
power -> atom_expr ** factor
1707
%
power -> atom_expr ** factor
1707
-
power -> atom_expr ** factor
1707
is
power -> atom_expr ** factor
1707
<=
power -> atom_expr ** factor
1707
<
power -> atom_expr ** factor
1707
,
power -> atom_expr ** factor
1707
*
power -> atom_expr ** factor
1707
<<
power -> atom_expr ** factor
1707
or
power -> atom_expr ** factor
1707
>>
power -> atom_expr ** factor
1707
&
power -> atom_expr ** factor
1708
not
xor_expr -> and_expr ^ xor_expr
1708
<
xor_expr -> and_expr ^ xor_expr
1708
,
xor_expr -> and_expr ^ xor_expr
1708
=
xor_expr -> and_expr ^ xor_expr
1708
>=
xor_expr -> and_expr ^ xor_expr
1708
>
xor_expr -> and_expr ^ xor_expr
1708
is
xor_expr -> and_expr ^ xor_expr
1708
!=
xor_expr -> and_expr ^ xor_expr
1708
and
xor_expr -> and_expr ^ xor_expr
1708
if
xor_expr -> and_expr ^ xor_expr
1708
<=
xor_expr -> and_expr ^ xor_expr
1708
in
xor_expr -> and_expr ^ xor_expr
1708
==
xor_expr -> and_expr ^ xor_expr
1708
|
xor_expr -> and_expr ^ xor_expr
1708
or
xor_expr -> and_expr ^ xor_expr
1708
NEWLINE
xor_expr -> and_expr ^ xor_expr
1709
<
and_expr -> shift_expr & and_expr
1709
if
and_expr -> shift_expr & and_expr
1709
>=
and_expr -> shift_expr & and_expr
1709
=
and_expr -> shift_expr & and_expr
1709
NEWLINE
and_expr -> shift_expr & and_expr
1709
not
and_expr -> shift_expr & and_expr
1709
==
and_expr -> shift_expr & and_expr
1709
>
and_expr -> shift_expr & and_expr
1709
in
and_expr -> shift_expr & and_expr
1709
^
and_expr -> shift_expr & and_expr
1709
or
and_expr -> shift_expr & and_expr
1709
and
and_expr -> shift_expr & and_expr
1709
!=
and_expr -> shift_expr & and_expr
1709
,
and_expr -> shift_expr & and_expr
1709
|
and_expr -> shift_expr & and_expr
1709
is
and_expr -> shift_expr & and_expr
1709
<=
and_expr -> shift_expr & and_expr
1710
+
trailer -> ( )
1710
!=
trailer -> ( )
1710
<<
trailer -> ( )
1710
>=
trailer -> ( )
1710
**
trailer -> ( )
1710
not
trailer -> ( )
1710
=
trailer -> ( )
1710
if
trailer -> ( )
1710
,
trailer -> ( )
1710
|
trailer -> ( )
1710
[
trailer -> ( )
1710
==
trailer -> ( )
1710
%
trailer -> ( )
1710
*
trailer -> ( )
1710
>>
trailer -> ( )
1710
@
trailer -> ( )
1710
>
trailer -> ( )
1710
/
trailer -> ( )
1710
in
trailer -> ( )
1710
(
trailer -> ( )
1710
is
trailer -> ( )
1710
//
trailer -> ( )
1710
<
trailer -> ( )
1710
NEWLINE
trailer -> ( )
1710
or
trailer -> ( )
1710
^
trailer -> ( )
1710
and
trailer -> ( )
1710
<=
trailer -> ( )
1710
.
trailer -> ( )
1710
-
trailer -> ( )
1710
&
trailer -> ( )
1711
)
2154
1712
<=
trailer_expr -> trailer trailer_expr
1712
+
trailer_expr -> trailer trailer_expr
1712
^
trailer_expr -> trailer trailer_expr
1712
or
trailer_expr -> trailer trailer_expr
1712
==
trailer_expr -> trailer trailer_expr
1712
%
trailer_expr -> trailer trailer_expr
1712
@
trailer_expr -> trailer trailer_expr
1712
=
trailer_expr -> trailer trailer_expr
1712
not
trailer_expr -> trailer trailer_expr
1712
<<
trailer_expr -> trailer trailer_expr
1712
-
trailer_expr -> trailer trailer_expr
1712
//
trailer_expr -> trailer trailer_expr
1712
and
trailer_expr -> trailer trailer_expr
1712
|
trailer_expr -> trailer trailer_expr
1712
if
trailer_expr -> trailer trailer_expr
1712
>
trailer_expr -> trailer trailer_expr
1712
!=
trailer_expr -> trailer trailer_expr
1712
,
trailer_expr -> trailer trailer_expr
1712
<
trailer_expr -> trailer trailer_expr
1712
>>
trailer_expr -> trailer trailer_expr
1712
/
trailer_expr -> trailer trailer_expr
1712
is
trailer_expr -> trailer trailer_expr
1712
NEWLINE
trailer_expr -> trailer trailer_expr
1712
&
trailer_expr -> trailer trailer_expr
1712
in
trailer_expr -> trailer trailer_expr
1712
>=
trailer_expr -> trailer trailer_expr
1712
*
trailer_expr -> trailer trailer_expr
1712
**
trailer_expr -> trailer trailer_expr
1713
=
trailer -> . NAME
1713
.
trailer -> . NAME
1713
not
trailer -> . NAME
1713
if
trailer -> . NAME
1713
NEWLINE
trailer -> . NAME
1713
**
trailer -> . NAME
1713
|
trailer -> . NAME
1713
-
trailer -> . NAME
1713
(
trailer -> . NAME
1713
%
trailer -> . NAME
1713
//
trailer -> . NAME
1713
==
trailer -> . NAME
1713
>>
trailer -> . NAME
1713
is
trailer -> . NAME
1713
!=
trailer -> . NAME
1713
and
trailer -> . NAME
1713
>=
trailer -> . NAME
1713
,
trailer -> . NAME
1713
>
trailer -> . NAME
1713
in
trailer -> . NAME
1713
<<
trailer -> . NAME
1713
&
trailer -> . NAME
1713
/
trailer -> . NAME
1713
^
trailer -> . NAME
1713
[
trailer -> . NAME
1713
<=
trailer -> . NAME
1713
or
trailer -> . NAME
1713
+
trailer -> . NAME
1713
<
trailer -> . NAME
1713
*
trailer -> . NAME
1713
@
trailer -> . NAME
1714
]
2155
1715
if
or_test -> and_test or or_test
1715
NEWLINE
or_test -> and_test or or_test
1715
,
or_test -> and_test or or_test
1715
=
or_test -> and_test or or_test
1716
==
shift_expr -> arith_expr >> shift_expr
1716
^
shift_expr -> arith_expr >> shift_expr
1716
or
shift_expr -> arith_expr >> shift_expr
1716
if
shift_expr -> arith_expr >> shift_expr
1716
,
shift_expr -> arith_expr >> shift_expr
1716
not
shift_expr -> arith_expr >> shift_expr
1716
|
shift_expr -> arith_expr >> shift_expr
1716
<=
shift_expr -> arith_expr >> shift_expr
1716
=
shift_expr -> arith_expr >> shift_expr
1716
in
shift_expr -> arith_expr >> shift_expr
1716
is
shift_expr -> arith_expr >> shift_expr
1716
>=
shift_expr -> arith_expr >> shift_expr
1716
NEWLINE
shift_expr -> arith_expr >> shift_expr
1716
>
shift_expr -> arith_expr >> shift_expr
1716
&
shift_expr -> arith_expr >> shift_expr
1716
<
shift_expr -> arith_expr >> shift_expr
1716
and
shift_expr -> arith_expr >> shift_expr
1716
!=
shift_expr -> arith_expr >> shift_expr
1717
or
shift_expr -> arith_expr << shift_expr
1717
>
shift_expr -> arith_expr << shift_expr
1717
in
shift_expr -> arith_expr << shift_expr
1717
NEWLINE
shift_expr -> arith_expr << shift_expr
1717
&
shift_expr -> arith_expr << shift_expr
1717
is
shift_expr -> arith_expr << shift_expr
1717
=
shift_expr -> arith_expr << shift_expr
1717
<
shift_expr -> arith_expr << shift_expr
1717
<=
shift_expr -> arith_expr << shift_expr
1717
not
shift_expr -> arith_expr << shift_expr
1717
^
shift_expr -> arith_expr << shift_expr
1717
if
shift_expr -> arith_expr << shift_expr
1717
,
shift_expr -> arith_expr << shift_expr
1717
and
shift_expr -> arith_expr << shift_expr
1717
|
shift_expr -> arith_expr << shift_expr
1717
!=
shift_expr -> arith_expr << shift_expr
1717
==
shift_expr -> arith_expr << shift_expr
1717
>=
shift_expr -> arith_expr << shift_expr
1718
>
atom -> ( test_list_comp )
1718
@
atom -> ( test_list_comp )
1718
&
atom -> ( test_list_comp )
1718
=
atom -> ( test_list_comp )
1718
[
atom -> ( test_list_comp )
1718
if
atom -> ( test_list_comp )
1718
==
atom -> ( test_list_comp )
1718
>=
atom -> ( test_list_comp )
1718
NEWLINE
atom -> ( test_list_comp )
1718
**
atom -> ( test_list_comp )
1718
not
atom -> ( test_list_comp )
1718
<<
atom -> ( test_list_comp )
1718
>>
atom -> ( test_list_comp )
1718
in
atom -> ( test_list_comp )
1718
or
atom -> ( test_list_comp )
1718
.
atom -> ( test_list_comp )
1718
/
atom -> ( test_list_comp )
1718
^
atom -> ( test_list_comp )
1718
is
atom -> ( test_list_comp )
1718
,
atom -> ( test_list_comp )
1718
and
atom -> ( test_list_comp )
1718
//
atom -> ( test_list_comp )
1718
<
atom -> ( test_list_comp )
1718
*
atom -> ( test_list_comp )
1718
<=
atom -> ( test_list_comp )
1718
(
atom -> ( test_list_comp )
1718
-
atom -> ( test_list_comp )
1718
|
atom -> ( test_list_comp )
1718
!=
atom -> ( test_list_comp )
1718
+
atom -> ( test_list_comp )
1718
%
atom -> ( test_list_comp )
1719
^
arith_expr -> term - arith_expr
1719
!=
arith_expr -> term - arith_expr
1719
<
arith_expr -> term - arith_expr
1719
in
arith_expr -> term - arith_expr
1719
==
arith_expr -> term - arith_expr
1719
|
arith_expr -> term - arith_expr
1719
is
arith_expr -> term - arith_expr
1719
&
arith_expr -> term - arith_expr
1719
>>
arith_expr -> term - arith_expr
1719
<<
arith_expr -> term - arith_expr
1719
=
arith_expr -> term - arith_expr
1719
and
arith_expr -> term - arith_expr
1719
,
arith_expr -> term - arith_expr
1719
>
arith_expr -> term - arith_expr
1719
if
arith_expr -> term - arith_expr
1719
NEWLINE
arith_expr -> term - arith_expr
1719
not
arith_expr -> term - arith_expr
1719
>=
arith_expr -> term - arith_expr
1719
<=
arith_expr -> term - arith_expr
1719
or
arith_expr -> term - arith_expr
1720
>=
arith_expr -> term + arith_expr
1720
>
arith_expr -> term + arith_expr
1720
^
arith_expr -> term + arith_expr
1720
or
arith_expr -> term + arith_expr
1720
==
arith_expr -> term + arith_expr
1720
<=
arith_expr -> term + arith_expr
1720
if
arith_expr -> term + arith_expr
1720
>>
arith_expr -> term + arith_expr
1720
<
arith_expr -> term + arith_expr
1720
not
arith_expr -> term + arith_expr
1720
&
arith_expr -> term + arith_expr
1720
in
arith_expr -> term + arith_expr
1720
and
arith_expr -> term + arith_expr
1720
,
arith_expr -> term + arith_expr
1720
|
arith_expr -> term + arith_expr
1720
!=
arith_expr -> term + arith_expr
1720
NEWLINE
arith_expr -> term + arith_expr
1720
=
arith_expr -> term + arith_expr
1720
<<
arith_expr -> term + arith_expr
1720
is
arith_expr -> term + arith_expr
1721
[
166
1721
factor
167
1721
True
168
1721
atom_expr
169
1721
~
170
1721
not
171
1721
and_expr
172
1721
-
173
1721
{
174
1721
shift_expr
175
1721
atom
176
1721
]
2156
1721
comparison
178
1721
(
179
1721
arith_expr
180
1721
power
181
1721
STRING
182
1721
NAME
183
1721
test
184
1721
and_test
185
1721
term
186
1721
+
187
1721
xor_expr
188
1721
NUMBER
190
1721
test_list_comp
2157
1721
False
191
1721
expr
192
1721
not_test
193
1721
None
194
1721
lambdef
195
1721
lambda
196
1721
or_test
197
1721
test_list
198
1722
not
term -> factor
1722
@
2158
1722
%
2159
1722
/
2160
1722
*
2161
1722
//
2162
1722
<=
term -> factor
1722
NEWLINE
term -> factor
1722
>
term -> factor
1722
==
term -> factor
1722
is
term -> factor
1722
or
term -> factor
1722
<
term -> factor
1722
and
term -> factor
1722
<<
term -> factor
1722
^
term -> factor
1722
!=
term -> factor
1722
-
term -> factor
1722
&
term -> factor
1722
|
term -> factor
1722
>=
term -> factor
1722
if
term -> factor
1722
=
term -> factor
1722
+
term -> factor
1722
in
term -> factor
1722
>>
term -> factor
1723
<<
atom -> True
1723
&
atom -> True
1723
or
atom -> True
1723
[
atom -> True
1723
if
atom -> True
1723
NEWLINE
atom -> True
1723
-
atom -> True
1723
*
atom -> True
1723
^
atom -> True
1723
>=
atom -> True
1723
!=
atom -> True
1723
=
atom -> True
1723
(
atom -> True
1723
not
atom -> True
1723
|
atom -> True
1723
+
atom -> True
1723
**
atom -> True
1723
.
atom -> True
1723
is
atom -> True
1723
//
atom -> True
1723
>
atom -> True
1723
%
atom -> True
1723
in
atom -> True
1723
<=
atom -> True
1723
>>
atom -> True
1723
/
atom -> True
1723
==
atom -> True
1723
and
atom -> True
1723
<
atom -> True
1723
@
atom -> True
1724
=
power -> atom_expr
1724
**
2163
1724
!=
power -> atom_expr
1724
-
power -> atom_expr
1724
<<
power -> atom_expr
1724
not
power -> atom_expr
1724
/
power -> atom_expr
1724
<=
power -> atom_expr
1724
in
power -> atom_expr
1724
%
power -> atom_expr
1724
>
power -> atom_expr
1724
@
power -> atom_expr
1724
|
power -> atom_expr
1724
NEWLINE
power -> atom_expr
1724
<
power -> atom_expr
1724
>>
power -> atom_expr
1724
or
power -> atom_expr
1724
and
power -> atom_expr
1724
>=
power -> atom_expr
1724
==
power -> atom_expr
1724
^
power -> atom_expr
1724
*
power -> atom_expr
1724
&
power -> atom_expr
1724
is
power -> atom_expr
1724
+
power -> atom_expr
1724
if
power -> atom_expr
1724
//
power -> atom_expr
1725
[
1721
1725
True
1723
1725
atom_expr
1724
1725
-
1727
1725
~
1725
1725
None
1728
1725
atom
1729
1725
{
1730
1725
power
1733
1725
STRING
1734
1725
NAME
1735
1725
(
1736
1725
NUMBER
1737
1725
+
1739
1725
False
1743
1725
factor
2164
1726
NEWLINE
xor_expr -> and_expr
1726
>
xor_expr -> and_expr
1726
<=
xor_expr -> and_expr
1726
not
xor_expr -> and_expr
1726
|
xor_expr -> and_expr
1726
^
2165
1726
==
xor_expr -> and_expr
1726
in
xor_expr -> and_expr
1726
!=
xor_expr -> and_expr
1726
if
xor_expr -> and_expr
1726
is
xor_expr -> and_expr
1726
<
xor_expr -> and_expr
1726
or
xor_expr -> and_expr
1726
=
xor_expr -> and_expr
1726
and
xor_expr -> and_expr
1726
>=
xor_expr -> and_expr
1727
[
1721
1727
True
1723
1727
atom_expr
1724
1727
~
1725
1727
-
1727
1727
None
1728
1727
atom
1729
1727
{
1730
1727
power
1733
1727
STRING
1734
1727
NAME
1735
1727
(
1736
1727
NUMBER
1737
1727
factor
2166
1727
+
1739
1727
False
1743
1728
@
atom -> None
1728
NEWLINE
atom -> None
1728
<=
atom -> None
1728
in
atom -> None
1728
and
atom -> None
1728
&
atom -> None
1728
|
atom -> None
1728
>
atom -> None
1728
>=
atom -> None
1728
/
atom -> None
1728
<<
atom -> None
1728
-
atom -> None
1728
!=
atom -> None
1728
**
atom -> None
1728
(
atom -> None
1728
*
atom -> None
1728
=
atom -> None
1728
.
atom -> None
1728
>>
atom -> None
1728
==
atom -> None
1728
is
atom -> None
1728
<
atom -> None
1728
if
atom -> None
1728
^
atom -> None
1728
[
atom -> None
1728
%
atom -> None
1728
+
atom -> None
1728
not
atom -> None
1728
or
atom -> None
1728
//
atom -> None
1729
>>
trailer_expr -> 
1729
(
2167
1729
trailer
2168
1729
trailer_expr
2169
1729
.
2170
1729
+
trailer_expr -> 
1729
[
2171
1729
is
trailer_expr -> 
1729
>
trailer_expr -> 
1729
not
trailer_expr -> 
1729
|
trailer_expr -> 
1729
NEWLINE
trailer_expr -> 
1729
=
trailer_expr -> 
1729
&
trailer_expr -> 
1729
/
trailer_expr -> 
1729
@
trailer_expr -> 
1729
!=
trailer_expr -> 
1729
**
trailer_expr -> 
1729
>=
trailer_expr -> 
1729
^
trailer_expr -> 
1729
in
trailer_expr -> 
1729
<<
trailer_expr -> 
1729
and
trailer_expr -> 
1729
or
trailer_expr -> 
1729
if
trailer_expr -> 
1729
//
trailer_expr -> 
1729
%
trailer_expr -> 
1729
<=
trailer_expr -> 
1729
<
trailer_expr -> 
1729
==
trailer_expr -> 
1729
-
trailer_expr -> 
1729
*
trailer_expr -> 
1730
}
2172
1731
=
or_test -> and_test
1731
or
2173
1731
if
or_test -> and_test
1731
NEWLINE
or_test -> and_test
1732
>>
2174
1732
if
shift_expr -> arith_expr
1732
&
shift_expr -> arith_expr
1732
<<
2175
1732
|
shift_expr -> arith_expr
1732
is
shift_expr -> arith_expr
1732
<
shift_expr -> arith_expr
1732
==
shift_expr -> arith_expr
1732
=
shift_expr -> arith_expr
1732
NEWLINE
shift_expr -> arith_expr
1732
or
shift_expr -> arith_expr
1732
>
shift_expr -> arith_expr
1732
!=
shift_expr -> arith_expr
1732
>=
shift_expr -> arith_expr
1732
in
shift_expr -> arith_expr
1732
<=
shift_expr -> arith_expr
1732
and
shift_expr -> arith_expr
1732
^
shift_expr -> arith_expr
1732
not
shift_expr -> arith_expr
1733
+
factor -> power
1733
%
factor -> power
1733
=
factor -> power
1733
<
factor -> power
1733
<<
factor -> power
1733
!=
factor -> power
1733
<=
factor -> power
1733
and
factor -> power
1733
/
factor -> power
1733
^
factor -> power
1733
@
factor -> power
1733
>=
factor -> power
1733
not
factor -> power
1733
//
factor -> power
1733
or
factor -> power
1733
==
factor -> power
1733
is
factor -> power
1733
|
factor -> power
1733
NEWLINE
factor -> power
1733
*
factor -> power
1733
-
factor -> power
1733
if
factor -> power
1733
>
factor -> power
1733
in
factor -> power
1733
>>
factor -> power
1733
&
factor -> power
1734
%
atom -> STRING
1734
>
atom -> STRING
1734
@
atom -> STRING
1734
<<
atom -> STRING
1734
in
atom -> STRING
1734
[
atom -> STRING
1734
-
atom -> STRING
1734
==
atom -> STRING
1734
>=
atom -> STRING
1734
not
atom -> STRING
1734
/
atom -> STRING
1734
+
atom -> STRING
1734
=
atom -> STRING
1734
NEWLINE
atom -> STRING
1734
*
atom -> STRING
1734
(
atom -> STRING
1734
//
atom -> STRING
1734
if
atom -> STRING
1734
.
atom -> STRING
1734
<
atom -> STRING
1734
&
atom -> STRING
1734
<=
atom -> STRING
1734
!=
atom -> STRING
1734
**
atom -> STRING
1734
^
atom -> STRING
1734
and
atom -> STRING
1734
is
atom -> STRING
1734
|
atom -> STRING
1734
or
atom -> STRING
1734
>>
atom -> STRING
1735
<
atom -> NAME
1735
^
atom -> NAME
1735
+
atom -> NAME
1735
-
atom -> NAME
1735
>=
atom -> NAME
1735
@
atom -> NAME
1735
!=
atom -> NAME
1735
*
atom -> NAME
1735
=
atom -> NAME
1735
<=
atom -> NAME
1735
**
atom -> NAME
1735
or
atom -> NAME
1735
NEWLINE
atom -> NAME
1735
not
atom -> NAME
1735
==
atom -> NAME
1735
&
atom -> NAME
1735
>
atom -> NAME
1735
>>
atom -> NAME
1735
%
atom -> NAME
1735
.
atom -> NAME
1735
|
atom -> NAME
1735
is
atom -> NAME
1735
and
atom -> NAME
1735
//
atom -> NAME
1735
[
atom -> NAME
1735
/
atom -> NAME
1735
(
atom -> NAME
1735
<<
atom -> NAME
1735
if
atom -> NAME
1735
in
atom -> NAME
1736
[
128
1736
factor
129
1736
True
130
1736
atom_expr
131
1736
~
132
1736
and_expr
133
1736
-
134
1736
{
135
1736
test_list_comp
2176
1736
shift_expr
137
1736
atom
138
1736
)
2177
1736
comparison
140
1736
arith_expr
141
1736
power
142
1736
STRING
143
1736
NAME
144
1736
(
145
1736
and_test
146
1736
term
147
1736
+
148
1736
xor_expr
149
1736
or_test
150
1736
NUMBER
151
1736
not
152
1736
False
153
1736
expr
154
1736
not_test
155
1736
None
156
1736
lambdef
157
1736
lambda
158
1736
test
159
1736
test_list
160
1737
+
atom -> NUMBER
1737
*
atom -> NUMBER
1737
>
atom -> NUMBER
1737
<<
atom -> NUMBER
1737
-
atom -> NUMBER
1737
**
atom -> NUMBER
1737
if
atom -> NUMBER
1737
or
atom -> NUMBER
1737
is
atom -> NUMBER
1737
=
atom -> NUMBER
1737
[
atom -> NUMBER
1737
(
atom -> NUMBER
1737
not
atom -> NUMBER
1737
&
atom -> NUMBER
1737
^
atom -> NUMBER
1737
in
atom -> NUMBER
1737
==
atom -> NUMBER
1737
//
atom -> NUMBER
1737
!=
atom -> NUMBER
1737
and
atom -> NUMBER
1737
NEWLINE
atom -> NUMBER
1737
%
atom -> NUMBER
1737
<=
atom -> NUMBER
1737
.
atom -> NUMBER
1737
<
atom -> NUMBER
1737
>>
atom -> NUMBER
1737
/
atom -> NUMBER
1737
@
atom -> NUMBER
1737
>=
atom -> NUMBER
1737
|
atom -> NUMBER
1738
-
2178
1738
+
2179
1738
|
arith_expr -> term
1738
>=
arith_expr -> term
1738
<=
arith_expr -> term
1738
not
arith_expr -> term
1738
==
arith_expr -> term
1738
in
arith_expr -> term
1738
>>
arith_expr -> term
1738
is
arith_expr -> term
1738
if
arith_expr -> term
1738
or
arith_expr -> term
1738
!=
arith_expr -> term
1738
>
arith_expr -> term
1738
=
arith_expr -> term
1738
and
arith_expr -> term
1738
<<
arith_expr -> term
1738
<
arith_expr -> term
1738
^
arith_expr -> term
1738
NEWLINE
arith_expr -> term
1738
&
arith_expr -> term
1739
[
1721
1739
True
1723
1739
atom_expr
1724
1739
-
1727
1739
~
1725
1739
None
1728
1739
atom
1729
1739
{
1730
1739
power
1733
1739
STRING
1734
1739
NAME
1735
1739
(
1736
1739
NUMBER
1737
1739
factor
2180
1739
+
1739
1739
False
1743
1740
|
2181
1740
>
expr -> xor_expr
1740
if
expr -> xor_expr
1740
NEWLINE
expr -> xor_expr
1740
is
expr -> xor_expr
1740
and
expr -> xor_expr
1740
=
expr -> xor_expr
1740
not
expr -> xor_expr
1740
or
expr -> xor_expr
1740
>=
expr -> xor_expr
1740
==
expr -> xor_expr
1740
<
expr -> xor_expr
1740
!=
expr -> xor_expr
1740
<=
expr -> xor_expr
1740
in
expr -> xor_expr
1741
^
and_expr -> shift_expr
1741
in
and_expr -> shift_expr
1741
|
and_expr -> shift_expr
1741
&
2182
1741
<
and_expr -> shift_expr
1741
not
and_expr -> shift_expr
1741
>=
and_expr -> shift_expr
1741
<=
and_expr -> shift_expr
1741
or
and_expr -> shift_expr
1741
and
and_expr -> shift_expr
1741
!=
and_expr -> shift_expr
1741
if
and_expr -> shift_expr
1741
is
and_expr -> shift_expr
1741
==
and_expr -> shift_expr
1741
NEWLINE
and_expr -> shift_expr
1741
>
and_expr -> shift_expr
1741
=
and_expr -> shift_expr
1742
[
1721
1742
factor
1722
1742
True
1723
1742
atom_expr
1724
1742
~
1725
1742
and_expr
1726
1742
-
1727
1742
None
1728
1742
atom
1729
1742
{
1730
1742
arith_expr
1732
1742
power
1733
1742
STRING
1734
1742
NAME
1735
1742
(
1736
1742
NUMBER
1737
1742
term
1738
1742
+
1739
1742
xor_expr
1740
1742
shift_expr
1741
1742
not
1742
1742
False
1743
1742
comparison
1745
1742
not_test
2183
1742
expr
1749
1743
(
atom -> False
1743
*
atom -> False
1743
==
atom -> False
1743
|
atom -> False
1743
[
atom -> False
1743
in
atom -> False
1743
&
atom -> False
1743
=
atom -> False
1743
NEWLINE
atom -> False
1743
not
atom -> False
1743
is
atom -> False
1743
if
atom -> False
1743
^
atom -> False
1743
+
atom -> False
1743
>
atom -> False
1743
<=
atom -> False
1743
<<
atom -> False
1743
<
atom -> False
1743
>=
atom -> False
1743
%
atom -> False
1743
@
atom -> False
1743
and
atom -> False
1743
!=
atom -> False
1743
-
atom -> False
1743
.
atom -> False
1743
//
atom -> False
1743
/
atom -> False
1743
**
atom -> False
1743
>>
atom -> False
1743
or
atom -> False
1744
vfpdef
234
1744
:
2184
1744
varargslist
2185
1744
NAME
233
1745
or
not_test -> comparison
1745
NEWLINE
not_test -> comparison
1745
=
not_test -> comparison
1745
and
not_test -> comparison
1745
if
not_test -> comparison
1746
and
2186
1746
NEWLINE
and_test -> not_test
1746
if
and_test -> not_test
1746
or
and_test -> not_test
1746
=
and_test -> not_test
1747
NEWLINE
test -> or_test
1747
if
2187
1747
=
test -> or_test
1748
=
test -> lambdef
1748
NEWLINE
test -> lambdef
1749
>
317
1749
is
318
1749
in
319
1749
<=
320
1749
<
321
1749
>=
322
1749
NEWLINE
comparison -> expr
1749
!=
324
1749
not
325
1749
==
326
1749
comp_op
2188
1749
=
comparison -> expr
1749
or
comparison -> expr
1749
if
comparison -> expr
1749
and
comparison -> expr
1750
NEWLINE
yield_arg -> from test
1750
=
yield_arg -> from test
1751
>=
expr -> xor_expr | expr
1751
=
expr -> xor_expr | expr
1751
,
expr -> xor_expr | expr
1751
or
expr -> xor_expr | expr
1751
in
expr -> xor_expr | expr
1751
NEWLINE
expr -> xor_expr | expr
1751
and
expr -> xor_expr | expr
1751
==
expr -> xor_expr | expr
1751
>
expr -> xor_expr | expr
1751
<=
expr -> xor_expr | expr
1751
is
expr -> xor_expr | expr
1751
<
expr -> xor_expr | expr
1751
if
expr -> xor_expr | expr
1751
not
expr -> xor_expr | expr
1751
!=
expr -> xor_expr | expr
1752
=
test_list -> test , test_list
1752
NEWLINE
test_list -> test , test_list
1753
[
632
1753
factor
633
1753
True
634
1753
atom_expr
635
1753
~
636
1753
and_expr
637
1753
-
638
1753
None
639
1753
shift_expr
640
1753
atom
641
1753
{
642
1753
comparison
643
1753
and_test
644
1753
arith_expr
645
1753
power
646
1753
STRING
647
1753
NAME
648
1753
(
649
1753
NUMBER
650
1753
term
651
1753
+
652
1753
xor_expr
654
1753
not
656
1753
False
657
1753
lambda
658
1753
not_test
659
1753
or_test
661
1753
lambdef
662
1753
expr
663
1753
test
2189
1754
,
lambdef -> lambda : test
1754
NEWLINE
lambdef -> lambda : test
1754
=
lambdef -> lambda : test
1755
NEWLINE
and_test -> not_test and and_test
1755
or
and_test -> not_test and and_test
1755
if
and_test -> not_test and and_test
1755
=
and_test -> not_test and and_test
1755
,
and_test -> not_test and and_test
1756
else
2190
1757
or
comparison -> expr comp_op comparison
1757
and
comparison -> expr comp_op comparison
1757
if
comparison -> expr comp_op comparison
1757
NEWLINE
comparison -> expr comp_op comparison
1757
=
comparison -> expr comp_op comparison
1757
,
comparison -> expr comp_op comparison
1758
.
atom -> [ test_list_comp ]
1758
[
atom -> [ test_list_comp ]
1758
@
atom -> [ test_list_comp ]
1758
<=
atom -> [ test_list_comp ]
1758
<
atom -> [ test_list_comp ]
1758
not
atom -> [ test_list_comp ]
1758
in
atom -> [ test_list_comp ]
1758
and
atom -> [ test_list_comp ]
1758
-
atom -> [ test_list_comp ]
1758
if
atom -> [ test_list_comp ]
1758
!=
atom -> [ test_list_comp ]
1758
is
atom -> [ test_list_comp ]
1758
>>
atom -> [ test_list_comp ]
1758
=
atom -> [ test_list_comp ]
1758
or
atom -> [ test_list_comp ]
1758
//
atom -> [ test_list_comp ]
1758
/
atom -> [ test_list_comp ]
1758
|
atom -> [ test_list_comp ]
1758
>
atom -> [ test_list_comp ]
1758
&
atom -> [ test_list_comp ]
1758
(
atom -> [ test_list_comp ]
1758
%
atom -> [ test_list_comp ]
1758
>=
atom -> [ test_list_comp ]
1758
==
atom -> [ test_list_comp ]
1758
**
atom -> [ test_list_comp ]
1758
<<
atom -> [ test_list_comp ]
1758
^
atom -> [ test_list_comp ]
1758
+
atom -> [ test_list_comp ]
1758
*
atom -> [ test_list_comp ]
1759
<<
term -> factor @ term
1759
^
term -> factor @ term
1759
<=
term -> factor @ term
1759
==
term -> factor @ term
1759
if
term -> factor @ term
1759
|
term -> factor @ term
1759
!=
term -> factor @ term
1759
or
term -> factor @ term
1759
>
term -> factor @ term
1759
and
term -> factor @ term
1759
>>
term -> factor @ term
1759
is
term -> factor @ term
1759
-
term -> factor @ term
1759
not
term -> factor @ term
1759
=
term -> factor @ term
1759
+
term -> factor @ term
1759
in
term -> factor @ term
1759
>=
term -> factor @ term
1759
<
term -> factor @ term
1759
&
term -> factor @ term
1760
<=
term -> factor % term
1760
is
term -> factor % term
1760
>
term -> factor % term
1760
and
term -> factor % term
1760
in
term -> factor % term
1760
or
term -> factor % term
1760
<
term -> factor % term
1760
-
term -> factor % term
1760
!=
term -> factor % term
1760
>>
term -> factor % term
1760
^
term -> factor % term
1760
+
term -> factor % term
1760
if
term -> factor % term
1760
<<
term -> factor % term
1760
>=
term -> factor % term
1760
==
term -> factor % term
1760
not
term -> factor % term
1760
|
term -> factor % term
1760
=
term -> factor % term
1760
&
term -> factor % term
1761
>>
term -> factor / term
1761
!=
term -> factor / term
1761
<
term -> factor / term
1761
<=
term -> factor / term
1761
|
term -> factor / term
1761
is
term -> factor / term
1761
=
term -> factor / term
1761
>=
term -> factor / term
1761
^
term -> factor / term
1761
&
term -> factor / term
1761
+
term -> factor / term
1761
<<
term -> factor / term
1761
and
term -> factor / term
1761
-
term -> factor / term
1761
in
term -> factor / term
1761
>
term -> factor / term
1761
or
term -> factor / term
1761
not
term -> factor / term
1761
==
term -> factor / term
1761
if
term -> factor / term
1762
is
term -> factor * term
1762
+
term -> factor * term
1762
>=
term -> factor * term
1762
^
term -> factor * term
1762
=
term -> factor * term
1762
<=
term -> factor * term
1762
or
term -> factor * term
1762
<
term -> factor * term
1762
|
term -> factor * term
1762
>>
term -> factor * term
1762
in
term -> factor * term
1762
not
term -> factor * term
1762
==
term -> factor * term
1762
-
term -> factor * term
1762
and
term -> factor * term
1762
!=
term -> factor * term
1762
<<
term -> factor * term
1762
>
term -> factor * term
1762
if
term -> factor * term
1762
&
term -> factor * term
1763
!=
term -> factor // term
1763
or
term -> factor // term
1763
^
term -> factor // term
1763
>
term -> factor // term
1763
is
term -> factor // term
1763
&
term -> factor // term
1763
-
term -> factor // term
1763
in
term -> factor // term
1763
>>
term -> factor // term
1763
|
term -> factor // term
1763
<
term -> factor // term
1763
>=
term -> factor // term
1763
not
term -> factor // term
1763
if
term -> factor // term
1763
=
term -> factor // term
1763
==
term -> factor // term
1763
<=
term -> factor // term
1763
and
term -> factor // term
1763
<<
term -> factor // term
1763
+
term -> factor // term
1764
!=
power -> atom_expr ** factor
1764
@
power -> atom_expr ** factor
1764
|
power -> atom_expr ** factor
1764
in
power -> atom_expr ** factor
1764
==
power -> atom_expr ** factor
1764
if
power -> atom_expr ** factor
1764
and
power -> atom_expr ** factor
1764
=
power -> atom_expr ** factor
1764
>=
power -> atom_expr ** factor
1764
/
power -> atom_expr ** factor
1764
not
power -> atom_expr ** factor
1764
^
power -> atom_expr ** factor
1764
//
power -> atom_expr ** factor
1764
>
power -> atom_expr ** factor
1764
+
power -> atom_expr ** factor
1764
%
power -> atom_expr ** factor
1764
-
power -> atom_expr ** factor
1764
is
power -> atom_expr ** factor
1764
<=
power -> atom_expr ** factor
1764
<
power -> atom_expr ** factor
1764
*
power -> atom_expr ** factor
1764
<<
power -> atom_expr ** factor
1764
or
power -> atom_expr ** factor
1764
>>
power -> atom_expr ** factor
1764
&
power -> atom_expr ** factor
1765
not
xor_expr -> and_expr ^ xor_expr
1765
<
xor_expr -> and_expr ^ xor_expr
1765
=
xor_expr -> and_expr ^ xor_expr
1765
>=
xor_expr -> and_expr ^ xor_expr
1765
>
xor_expr -> and_expr ^ xor_expr
1765
is
xor_expr -> and_expr ^ xor_expr
1765
!=
xor_expr -> and_expr ^ xor_expr
1765
and
xor_expr -> and_expr ^ xor_expr
1765
if
xor_expr -> and_expr ^ xor_expr
1765
<=
xor_expr -> and_expr ^ xor_expr
1765
in
xor_expr -> and_expr ^ xor_expr
1765
==
xor_expr -> and_expr ^ xor_expr
1765
|
xor_expr -> and_expr ^ xor_expr
1765
or
xor_expr -> and_expr ^ xor_expr
1766
+
trailer -> ( )
1766
!=
trailer -> ( )
1766
<<
trailer -> ( )
1766
>=
trailer -> ( )
1766
**
trailer -> ( )
1766
not
trailer -> ( )
1766
=
trailer -> ( )
1766
if
trailer -> ( )
1766
|
trailer -> ( )
1766
[
trailer -> ( )
1766
==
trailer -> ( )
1766
%
trailer -> ( )
1766
*
trailer -> ( )
1766
>>
trailer -> ( )
1766
@
trailer -> ( )
1766
>
trailer -> ( )
1766
/
trailer -> ( )
1766
in
trailer -> ( )
1766
(
trailer -> ( )
1766
is
trailer -> ( )
1766
//
trailer -> ( )
1766
<
trailer -> ( )
1766
or
trailer -> ( )
1766
^
trailer -> ( )
1766
and
trailer -> ( )
1766
<=
trailer -> ( )
1766
.
trailer -> ( )
1766
-
trailer -> ( )
1766
&
trailer -> ( )
1767
)
2191
1768
<=
trailer_expr -> trailer trailer_expr
1768
+
trailer_expr -> trailer trailer_expr
1768
^
trailer_expr -> trailer trailer_expr
1768
or
trailer_expr -> trailer trailer_expr
1768
==
trailer_expr -> trailer trailer_expr
1768
%
trailer_expr -> trailer trailer_expr
1768
@
trailer_expr -> trailer trailer_expr
1768
=
trailer_expr -> trailer trailer_expr
1768
not
trailer_expr -> trailer trailer_expr
1768
<<
trailer_expr -> trailer trailer_expr
1768
-
trailer_expr -> trailer trailer_expr
1768
//
trailer_expr -> trailer trailer_expr
1768
and
trailer_expr -> trailer trailer_expr
1768
|
trailer_expr -> trailer trailer_expr
1768
if
trailer_expr -> trailer trailer_expr
1768
>
trailer_expr -> trailer trailer_expr
1768
!=
trailer_expr -> trailer trailer_expr
1768
<
trailer_expr -> trailer trailer_expr
1768
>>
trailer_expr -> trailer trailer_expr
1768
/
trailer_expr -> trailer trailer_expr
1768
is
trailer_expr -> trailer trailer_expr
1768
&
trailer_expr -> trailer trailer_expr
1768
in
trailer_expr -> trailer trailer_expr
1768
>=
trailer_expr -> trailer trailer_expr
1768
*
trailer_expr -> trailer trailer_expr
1768
**
trailer_expr -> trailer trailer_expr
1769
=
trailer -> . NAME
1769
.
trailer -> . NAME
1769
not
trailer -> . NAME
1769
if
trailer -> . NAME
1769
**
trailer -> . NAME
1769
|
trailer -> . NAME
1769
-
trailer -> . NAME
1769
(
trailer -> . NAME
1769
%
trailer -> . NAME
1769
//
trailer -> . NAME
1769
==
trailer -> . NAME
1769
>>
trailer -> . NAME
1769
is
trailer -> . NAME
1769
!=
trailer -> . NAME
1769
and
trailer -> . NAME
1769
>=
trailer -> . NAME
1769
>
trailer -> . NAME
1769
in
trailer -> . NAME
1769
<<
trailer -> . NAME
1769
&
trailer -> . NAME
1769
/
trailer -> . NAME
1769
^
trailer -> . NAME
1769
[
trailer -> . NAME
1769
<=
trailer -> . NAME
1769
or
trailer -> . NAME
1769
+
trailer -> . NAME
1769
<
trailer -> . NAME
1769
*
trailer -> . NAME
1769
@
trailer -> . NAME
1770
]
2192
1771
if
or_test -> and_test or or_test
1771
=
or_test -> and_test or or_test
1772
==
shift_expr -> arith_expr >> shift_expr
1772
^
shift_expr -> arith_expr >> shift_expr
1772
or
shift_expr -> arith_expr >> shift_expr
1772
if
shift_expr -> arith_expr >> shift_expr
1772
not
shift_expr -> arith_expr >> shift_expr
1772
|
shift_expr -> arith_expr >> shift_expr
1772
<=
shift_expr -> arith_expr >> shift_expr
1772
=
shift_expr -> arith_expr >> shift_expr
1772
in
shift_expr -> arith_expr >> shift_expr
1772
is
shift_expr -> arith_expr >> shift_expr
1772
>=
shift_expr -> arith_expr >> shift_expr
1772
>
shift_expr -> arith_expr >> shift_expr
1772
&
shift_expr -> arith_expr >> shift_expr
1772
<
shift_expr -> arith_expr >> shift_expr
1772
and
shift_expr -> arith_expr >> shift_expr
1772
!=
shift_expr -> arith_expr >> shift_expr
1773
or
shift_expr -> arith_expr << shift_expr
1773
>
shift_expr -> arith_expr << shift_expr
1773
in
shift_expr -> arith_expr << shift_expr
1773
&
shift_expr -> arith_expr << shift_expr
1773
is
shift_expr -> arith_expr << shift_expr
1773
=
shift_expr -> arith_expr << shift_expr
1773
<
shift_expr -> arith_expr << shift_expr
1773
<=
shift_expr -> arith_expr << shift_expr
1773
not
shift_expr -> arith_expr << shift_expr
1773
^
shift_expr -> arith_expr << shift_expr
1773
if
shift_expr -> arith_expr << shift_expr
1773
and
shift_expr -> arith_expr << shift_expr
1773
|
shift_expr -> arith_expr << shift_expr
1773
!=
shift_expr -> arith_expr << shift_expr
1773
==
shift_expr -> arith_expr << shift_expr
1773
>=
shift_expr -> arith_expr << shift_expr
1774
>
atom -> ( test_list_comp )
1774
@
atom -> ( test_list_comp )
1774
&
atom -> ( test_list_comp )
1774
=
atom -> ( test_list_comp )
1774
[
atom -> ( test_list_comp )
1774
if
atom -> ( test_list_comp )
1774
==
atom -> ( test_list_comp )
1774
>=
atom -> ( test_list_comp )
1774
**
atom -> ( test_list_comp )
1774
not
atom -> ( test_list_comp )
1774
<<
atom -> ( test_list_comp )
1774
>>
atom -> ( test_list_comp )
1774
in
atom -> ( test_list_comp )
1774
or
atom -> ( test_list_comp )
1774
.
atom -> ( test_list_comp )
1774
/
atom -> ( test_list_comp )
1774
^
atom -> ( test_list_comp )
1774
is
atom -> ( test_list_comp )
1774
and
atom -> ( test_list_comp )
1774
//
atom -> ( test_list_comp )
1774
<
atom -> ( test_list_comp )
1774
*
atom -> ( test_list_comp )
1774
<=
atom -> ( test_list_comp )
1774
(
atom -> ( test_list_comp )
1774
-
atom -> ( test_list_comp )
1774
|
atom -> ( test_list_comp )
1774
!=
atom -> ( test_list_comp )
1774
+
atom -> ( test_list_comp )
1774
%
atom -> ( test_list_comp )
1775
>
arith_expr -> term - arith_expr
1775
==
arith_expr -> term - arith_expr
1775
^
arith_expr -> term - arith_expr
1775
is
arith_expr -> term - arith_expr
1775
|
arith_expr -> term - arith_expr
1775
&
arith_expr -> term - arith_expr
1775
if
arith_expr -> term - arith_expr
1775
<<
arith_expr -> term - arith_expr
1775
>>
arith_expr -> term - arith_expr
1775
!=
arith_expr -> term - arith_expr
1775
not
arith_expr -> term - arith_expr
1775
=
arith_expr -> term - arith_expr
1775
>=
arith_expr -> term - arith_expr
1775
and
arith_expr -> term - arith_expr
1775
<=
arith_expr -> term - arith_expr
1775
<
arith_expr -> term - arith_expr
1775
or
arith_expr -> term - arith_expr
1775
in
arith_expr -> term - arith_expr
1776
!=
arith_expr -> term + arith_expr
1776
>=
arith_expr -> term + arith_expr
1776
not
arith_expr -> term + arith_expr
1776
>
arith_expr -> term + arith_expr
1776
<
arith_expr -> term + arith_expr
1776
&
arith_expr -> term + arith_expr
1776
^
arith_expr -> term + arith_expr
1776
=
arith_expr -> term + arith_expr
1776
>>
arith_expr -> term + arith_expr
1776
in
arith_expr -> term + arith_expr
1776
<<
arith_expr -> term + arith_expr
1776
or
arith_expr -> term + arith_expr
1776
is
arith_expr -> term + arith_expr
1776
and
arith_expr -> term + arith_expr
1776
==
arith_expr -> term + arith_expr
1776
<=
arith_expr -> term + arith_expr
1776
|
arith_expr -> term + arith_expr
1776
if
arith_expr -> term + arith_expr
1777
>=
expr -> xor_expr | expr
1777
=
expr -> xor_expr | expr
1777
or
expr -> xor_expr | expr
1777
in
expr -> xor_expr | expr
1777
and
expr -> xor_expr | expr
1777
==
expr -> xor_expr | expr
1777
>
expr -> xor_expr | expr
1777
<=
expr -> xor_expr | expr
1777
is
expr -> xor_expr | expr
1777
<
expr -> xor_expr | expr
1777
if
expr -> xor_expr | expr
1777
not
expr -> xor_expr | expr
1777
!=
expr -> xor_expr | expr
1778
<
and_expr -> shift_expr & and_expr
1778
if
and_expr -> shift_expr & and_expr
1778
>=
and_expr -> shift_expr & and_expr
1778
=
and_expr -> shift_expr & and_expr
1778
not
and_expr -> shift_expr & and_expr
1778
==
and_expr -> shift_expr & and_expr
1778
>
and_expr -> shift_expr & and_expr
1778
in
and_expr -> shift_expr & and_expr
1778
^
and_expr -> shift_expr & and_expr
1778
or
and_expr -> shift_expr & and_expr
1778
and
and_expr -> shift_expr & and_expr
1778
!=
and_expr -> shift_expr & and_expr
1778
|
and_expr -> shift_expr & and_expr
1778
is
and_expr -> shift_expr & and_expr
1778
<=
and_expr -> shift_expr & and_expr
1779
NEWLINE
annassign -> : test = test
1780
if
and_test -> not_test and and_test
1780
=
and_test -> not_test and and_test
1780
or
and_test -> not_test and and_test
1781
else
2193
1782
and
comparison -> expr comp_op comparison
1782
=
comparison -> expr comp_op comparison
1782
or
comparison -> expr comp_op comparison
1782
if
comparison -> expr comp_op comparison
1783
=
lambdef -> lambda : test
1784
[
665
1784
factor
666
1784
True
667
1784
atom_expr
668
1784
~
669
1784
and_expr
670
1784
-
671
1784
atom
672
1784
{
673
1784
and_test
674
1784
arith_expr
675
1784
power
676
1784
STRING
677
1784
NAME
678
1784
(
679
1784
term
680
1784
+
681
1784
xor_expr
682
1784
shift_expr
683
1784
NUMBER
684
1784
not
685
1784
False
687
1784
comparison
688
1784
not_test
689
1784
None
690
1784
or_test
691
1784
expr
692
1784
lambda
693
1784
test
2194
1784
lambdef
694
1785
,
trailer -> ( arglist )
1785
.
trailer -> ( arglist )
1785
|
trailer -> ( arglist )
1785
^
trailer -> ( arglist )
1785
==
trailer -> ( arglist )
1785
**
trailer -> ( arglist )
1785
>>
trailer -> ( arglist )
1785
not
trailer -> ( arglist )
1785
<<
trailer -> ( arglist )
1785
>=
trailer -> ( arglist )
1785
!=
trailer -> ( arglist )
1785
in
trailer -> ( arglist )
1785
[
trailer -> ( arglist )
1785
(
trailer -> ( arglist )
1785
>
trailer -> ( arglist )
1785
and
trailer -> ( arglist )
1785
+
trailer -> ( arglist )
1785
%
trailer -> ( arglist )
1785
or
trailer -> ( arglist )
1785
*
trailer -> ( arglist )
1785
is
trailer -> ( arglist )
1785
&
trailer -> ( arglist )
1785
//
trailer -> ( arglist )
1785
:
trailer -> ( arglist )
1785
-
trailer -> ( arglist )
1785
<
trailer -> ( arglist )
1785
as
trailer -> ( arglist )
1785
<=
trailer -> ( arglist )
1785
if
trailer -> ( arglist )
1785
/
trailer -> ( arglist )
1785
@
trailer -> ( arglist )
1786
<=
trailer -> [ subscriptlist ]
1786
<<
trailer -> [ subscriptlist ]
1786
:
trailer -> [ subscriptlist ]
1786
*
trailer -> [ subscriptlist ]
1786
+
trailer -> [ subscriptlist ]
1786
in
trailer -> [ subscriptlist ]
1786
>>
trailer -> [ subscriptlist ]
1786
//
trailer -> [ subscriptlist ]
1786
.
trailer -> [ subscriptlist ]
1786
,
trailer -> [ subscriptlist ]
1786
and
trailer -> [ subscriptlist ]
1786
**
trailer -> [ subscriptlist ]
1786
@
trailer -> [ subscriptlist ]
1786
<
trailer -> [ subscriptlist ]
1786
not
trailer -> [ subscriptlist ]
1786
-
trailer -> [ subscriptlist ]
1786
!=
trailer -> [ subscriptlist ]
1786
%
trailer -> [ subscriptlist ]
1786
as
trailer -> [ subscriptlist ]
1786
[
trailer -> [ subscriptlist ]
1786
/
trailer -> [ subscriptlist ]
1786
or
trailer -> [ subscriptlist ]
1786
&
trailer -> [ subscriptlist ]
1786
>=
trailer -> [ subscriptlist ]
1786
==
trailer -> [ subscriptlist ]
1786
(
trailer -> [ subscriptlist ]
1786
|
trailer -> [ subscriptlist ]
1786
is
trailer -> [ subscriptlist ]
1786
if
trailer -> [ subscriptlist ]
1786
>
trailer -> [ subscriptlist ]
1786
^
trailer -> [ subscriptlist ]
1787
[
283
1787
factor
284
1787
True
285
1787
atom_expr
286
1787
~
287
1787
and_expr
288
1787
-
289
1787
shift_expr
290
1787
atom
291
1787
{
292
1787
comparison
293
1787
or_test
294
1787
arith_expr
295
1787
power
296
1787
STRING
297
1787
NAME
298
1787
(
299
1787
and_test
301
1787
term
302
1787
+
303
1787
xor_expr
304
1787
NUMBER
305
1787
not
306
1787
False
307
1787
expr
308
1787
not_test
309
1787
None
310
1787
lambdef
311
1787
test
2195
1787
lambda
314
1788
^
atom -> [ ]
1788
(
atom -> [ ]
1788
>>
atom -> [ ]
1788
-
atom -> [ ]
1788
+
atom -> [ ]
1788
,
atom -> [ ]
1788
|
atom -> [ ]
1788
:
atom -> [ ]
1788
//
atom -> [ ]
1788
*
atom -> [ ]
1788
<<
atom -> [ ]
1788
@
atom -> [ ]
1788
.
atom -> [ ]
1788
%
atom -> [ ]
1788
/
atom -> [ ]
1788
**
atom -> [ ]
1788
[
atom -> [ ]
1788
&
atom -> [ ]
1789
]
2196
1790
/
atom -> { }
1790
@
atom -> { }
1790
:
atom -> { }
1790
|
atom -> { }
1790
**
atom -> { }
1790
,
atom -> { }
1790
*
atom -> { }
1790
%
atom -> { }
1790
^
atom -> { }
1790
//
atom -> { }
1790
>>
atom -> { }
1790
(
atom -> { }
1790
&
atom -> { }
1790
.
atom -> { }
1790
[
atom -> { }
1790
-
atom -> { }
1790
<<
atom -> { }
1790
+
atom -> { }
1791
[
1283
1791
{
1284
1791
factor
1285
1791
True
1286
1791
~
1287
1791
atom
1291
1791
STRING
1292
1791
power
1293
1791
NAME
1294
1791
(
1295
1791
+
1296
1791
None
1298
1791
False
1299
1791
atom_expr
1300
1791
-
1301
1791
term
2197
1791
NUMBER
1302
1792
[
1283
1792
{
1284
1792
factor
1285
1792
True
1286
1792
~
1287
1792
atom
1291
1792
STRING
1292
1792
power
1293
1792
NAME
1294
1792
(
1295
1792
+
1296
1792
term
2198
1792
None
1298
1792
False
1299
1792
atom_expr
1300
1792
-
1301
1792
NUMBER
1302
1793
[
1283
1793
{
1284
1793
factor
1285
1793
True
1286
1793
~
1287
1793
atom
1291
1793
STRING
1292
1793
power
1293
1793
NAME
1294
1793
(
1295
1793
+
1296
1793
None
1298
1793
False
1299
1793
atom_expr
1300
1793
-
1301
1793
NUMBER
1302
1793
term
2199
1794
[
1283
1794
{
1284
1794
factor
1285
1794
True
1286
1794
~
1287
1794
atom
1291
1794
STRING
1292
1794
power
1293
1794
NAME
1294
1794
(
1295
1794
+
1296
1794
None
1298
1794
False
1299
1794
atom_expr
1300
1794
-
1301
1794
term
2200
1794
NUMBER
1302
1795
[
1283
1795
{
1284
1795
factor
1285
1795
True
1286
1795
~
1287
1795
atom
1291
1795
STRING
1292
1795
power
1293
1795
NAME
1294
1795
(
1295
1795
term
2201
1795
+
1296
1795
None
1298
1795
False
1299
1795
atom_expr
1300
1795
-
1301
1795
NUMBER
1302
1796
:
factor -> ~ factor
1796
<<
factor -> ~ factor
1796
-
factor -> ~ factor
1796
@
factor -> ~ factor
1796
,
factor -> ~ factor
1796
|
factor -> ~ factor
1796
*
factor -> ~ factor
1796
&
factor -> ~ factor
1796
>>
factor -> ~ factor
1796
//
factor -> ~ factor
1796
%
factor -> ~ factor
1796
/
factor -> ~ factor
1796
^
factor -> ~ factor
1796
+
factor -> ~ factor
1797
[
1283
1797
{
1284
1797
factor
1285
1797
True
1286
1797
~
1287
1797
and_expr
1288
1797
arith_expr
1289
1797
shift_expr
1290
1797
atom
1291
1797
STRING
1292
1797
power
1293
1797
NAME
1294
1797
(
1295
1797
+
1296
1797
term
1297
1797
None
1298
1797
False
1299
1797
atom_expr
1300
1797
-
1301
1797
xor_expr
2202
1797
NUMBER
1302
1798
[
1283
1798
{
1284
1798
factor
1285
1798
True
1286
1798
~
1287
1798
arith_expr
1289
1798
atom
1291
1798
STRING
1292
1798
power
1293
1798
NAME
1294
1798
(
1295
1798
+
1296
1798
term
1297
1798
None
1298
1798
False
1299
1798
atom_expr
1300
1798
shift_expr
2203
1798
-
1301
1798
NUMBER
1302
1799
[
1283
1799
{
1284
1799
factor
1285
1799
True
1286
1799
~
1287
1799
arith_expr
1289
1799
atom
1291
1799
STRING
1292
1799
power
1293
1799
NAME
1294
1799
(
1295
1799
+
1296
1799
term
1297
1799
None
1298
1799
False
1299
1799
atom_expr
1300
1799
-
1301
1799
NUMBER
1302
1799
shift_expr
2204
1800
[
1283
1800
{
1284
1800
factor
1285
1800
True
1286
1800
~
1287
1800
arith_expr
1289
1800
shift_expr
1290
1800
atom
1291
1800
STRING
1292
1800
power
1293
1800
NAME
1294
1800
(
1295
1800
+
1296
1800
term
1297
1800
None
1298
1800
False
1299
1800
atom_expr
1300
1800
-
1301
1800
NUMBER
1302
1800
and_expr
2205
1801
[
766
1801
factor
767
1801
True
768
1801
atom_expr
769
1801
~
770
1801
and_expr
771
1801
-
772
1801
{
773
1801
shift_expr
774
1801
atom
775
1801
comparison
776
1801
and_test
777
1801
arith_expr
778
1801
power
779
1801
STRING
780
1801
NAME
781
1801
(
782
1801
term
784
1801
+
785
1801
xor_expr
786
1801
)
2206
1801
or_test
788
1801
arglist
2207
1801
NUMBER
789
1801
not
790
1801
False
791
1801
expr
792
1801
*
793
1801
not_test
794
1801
None
795
1801
lambdef
796
1801
lambda
797
1801
test
798
1801
argument
799
1801
**
800
1802
[
802
1802
factor
803
1802
True
804
1802
atom_expr
810
1802
~
806
1802
not
807
1802
and_expr
808
1802
-
809
1802
shift_expr
811
1802
atom
812
1802
{
813
1802
comparison
814
1802
or_test
815
1802
(
816
1802
arith_expr
817
1802
power
818
1802
STRING
819
1802
NAME
820
1802
and_test
821
1802
subscriptlist
2208
1802
term
822
1802
+
823
1802
xor_expr
824
1802
test
825
1802
NUMBER
826
1802
False
827
1802
subscript
828
1802
expr
829
1802
not_test
830
1802
None
831
1802
lambdef
832
1802
lambda
833
1802
maybe_test
834
1802
:
maybe_test -> 
1803
trailer_expr
2209
1803
>>
trailer_expr -> 
1803
(
1801
1803
[
1802
1803
trailer
1803
1803
.
1804
1803
+
trailer_expr -> 
1803
<<
trailer_expr -> 
1803
|
trailer_expr -> 
1803
:
trailer_expr -> 
1803
//
trailer_expr -> 
1803
%
trailer_expr -> 
1803
,
trailer_expr -> 
1803
&
trailer_expr -> 
1803
/
trailer_expr -> 
1803
@
trailer_expr -> 
1803
**
trailer_expr -> 
1803
-
trailer_expr -> 
1803
^
trailer_expr -> 
1803
*
trailer_expr -> 
1804
NAME
2210
1805
**
atom_expr -> atom trailer_expr
1805
>>
atom_expr -> atom trailer_expr
1805
*
atom_expr -> atom trailer_expr
1805
^
atom_expr -> atom trailer_expr
1805
@
atom_expr -> atom trailer_expr
1805
/
atom_expr -> atom trailer_expr
1805
&
atom_expr -> atom trailer_expr
1805
:
atom_expr -> atom trailer_expr
1805
|
atom_expr -> atom trailer_expr
1805
+
atom_expr -> atom trailer_expr
1805
-
atom_expr -> atom trailer_expr
1805
,
atom_expr -> atom trailer_expr
1805
<<
atom_expr -> atom trailer_expr
1805
%
atom_expr -> atom trailer_expr
1805
//
atom_expr -> atom trailer_expr
1806
)
2211
1807
@
atom -> ( )
1807
>>
atom -> ( )
1807
^
atom -> ( )
1807
**
atom -> ( )
1807
/
atom -> ( )
1807
&
atom -> ( )
1807
(
atom -> ( )
1807
+
atom -> ( )
1807
[
atom -> ( )
1807
-
atom -> ( )
1807
.
atom -> ( )
1807
%
atom -> ( )
1807
,
atom -> ( )
1807
//
atom -> ( )
1807
:
atom -> ( )
1807
*
atom -> ( )
1807
<<
atom -> ( )
1807
|
atom -> ( )
1808
^
factor -> + factor
1808
*
factor -> + factor
1808
@
factor -> + factor
1808
|
factor -> + factor
1808
%
factor -> + factor
1808
/
factor -> + factor
1808
&
factor -> + factor
1808
//
factor -> + factor
1808
+
factor -> + factor
1808
:
factor -> + factor
1808
<<
factor -> + factor
1808
-
factor -> + factor
1808
>>
factor -> + factor
1808
,
factor -> + factor
1809
[
1283
1809
{
1284
1809
factor
1285
1809
True
1286
1809
~
1287
1809
atom
1291
1809
STRING
1292
1809
power
1293
1809
NAME
1294
1809
(
1295
1809
+
1296
1809
term
1297
1809
None
1298
1809
False
1299
1809
atom_expr
1300
1809
-
1301
1809
NUMBER
1302
1809
arith_expr
2212
1810
[
1283
1810
{
1284
1810
factor
1285
1810
True
1286
1810
~
1287
1810
atom
1291
1810
STRING
1292
1810
power
1293
1810
arith_expr
2213
1810
NAME
1294
1810
(
1295
1810
+
1296
1810
term
1297
1810
None
1298
1810
False
1299
1810
atom_expr
1300
1810
-
1301
1810
NUMBER
1302
1811
[
1283
1811
{
1284
1811
True
1286
1811
~
1287
1811
atom
1291
1811
STRING
1292
1811
power
1293
1811
NAME
1294
1811
(
1295
1811
+
1296
1811
factor
2214
1811
None
1298
1811
False
1299
1811
atom_expr
1300
1811
-
1301
1811
NUMBER
1302
1812
%
factor -> - factor
1812
/
factor -> - factor
1812
*
factor -> - factor
1812
:
factor -> - factor
1812
@
factor -> - factor
1812
^
factor -> - factor
1812
>>
factor -> - factor
1812
&
factor -> - factor
1812
|
factor -> - factor
1812
<<
factor -> - factor
1812
//
factor -> - factor
1812
+
factor -> - factor
1812
-
factor -> - factor
1812
,
factor -> - factor
1813
[
1283
1813
{
1284
1813
factor
1285
1813
True
1286
1813
~
1287
1813
and_expr
1288
1813
arith_expr
1289
1813
shift_expr
1290
1813
atom
1291
1813
STRING
1292
1813
power
1293
1813
NAME
1294
1813
(
1295
1813
+
1296
1813
term
1297
1813
None
1298
1813
False
1299
1813
atom_expr
1300
1813
-
1301
1813
NUMBER
1302
1813
expr
2215
1813
xor_expr
1303
1814
,
lambdef -> lambda varargslist : test
1814
as
lambdef -> lambda varargslist : test
1814
:
lambdef -> lambda varargslist : test
1815
del
simple_stmt -> small_stmt NEWLINE
1815
elif
simple_stmt -> small_stmt NEWLINE
1815
break
simple_stmt -> small_stmt NEWLINE
1815
raise
simple_stmt -> small_stmt NEWLINE
1815
servmod
simple_stmt -> small_stmt NEWLINE
1815
class
simple_stmt -> small_stmt NEWLINE
1815
not
simple_stmt -> small_stmt NEWLINE
1815
-
simple_stmt -> small_stmt NEWLINE
1815
False
simple_stmt -> small_stmt NEWLINE
1815
(
simple_stmt -> small_stmt NEWLINE
1815
endsim
simple_stmt -> small_stmt NEWLINE
1815
+
simple_stmt -> small_stmt NEWLINE
1815
None
simple_stmt -> small_stmt NEWLINE
1815
resetstats
simple_stmt -> small_stmt NEWLINE
1815
conf
simple_stmt -> small_stmt NEWLINE
1815
server
simple_stmt -> small_stmt NEWLINE
1815
STRING
simple_stmt -> small_stmt NEWLINE
1815
$
simple_stmt -> small_stmt NEWLINE
1815
else
simple_stmt -> small_stmt NEWLINE
1815
if
simple_stmt -> small_stmt NEWLINE
1815
NUMBER
simple_stmt -> small_stmt NEWLINE
1815
global
simple_stmt -> small_stmt NEWLINE
1815
@
simple_stmt -> small_stmt NEWLINE
1815
True
simple_stmt -> small_stmt NEWLINE
1815
lambda
simple_stmt -> small_stmt NEWLINE
1815
pass
simple_stmt -> small_stmt NEWLINE
1815
return
simple_stmt -> small_stmt NEWLINE
1815
def
simple_stmt -> small_stmt NEWLINE
1815
with
simple_stmt -> small_stmt NEWLINE
1815
nonlocal
simple_stmt -> small_stmt NEWLINE
1815
assert
simple_stmt -> small_stmt NEWLINE
1815
NAME
simple_stmt -> small_stmt NEWLINE
1815
try
simple_stmt -> small_stmt NEWLINE
1815
begsim
simple_stmt -> small_stmt NEWLINE
1815
while
simple_stmt -> small_stmt NEWLINE
1815
for
simple_stmt -> small_stmt NEWLINE
1815
[
simple_stmt -> small_stmt NEWLINE
1815
modopt
simple_stmt -> small_stmt NEWLINE
1815
yield
simple_stmt -> small_stmt NEWLINE
1815
NEWLINE
simple_stmt -> small_stmt NEWLINE
1815
continue
simple_stmt -> small_stmt NEWLINE
1815
{
simple_stmt -> small_stmt NEWLINE
1815
~
simple_stmt -> small_stmt NEWLINE
1816
del
if_stmt -> if test : suite elif_clause
1816
else
2216
1816
def
if_stmt -> if test : suite elif_clause
1816
for
if_stmt -> if test : suite elif_clause
1816
(
if_stmt -> if test : suite elif_clause
1816
None
if_stmt -> if test : suite elif_clause
1816
servmod
if_stmt -> if test : suite elif_clause
1816
conf
if_stmt -> if test : suite elif_clause
1816
yield
if_stmt -> if test : suite elif_clause
1816
True
if_stmt -> if test : suite elif_clause
1816
endsim
if_stmt -> if test : suite elif_clause
1816
with
if_stmt -> if test : suite elif_clause
1816
NUMBER
if_stmt -> if test : suite elif_clause
1816
server
if_stmt -> if test : suite elif_clause
1816
break
if_stmt -> if test : suite elif_clause
1816
raise
if_stmt -> if test : suite elif_clause
1816
NEWLINE
if_stmt -> if test : suite elif_clause
1816
$
if_stmt -> if test : suite elif_clause
1816
assert
if_stmt -> if test : suite elif_clause
1816
+
if_stmt -> if test : suite elif_clause
1816
{
if_stmt -> if test : suite elif_clause
1816
global
if_stmt -> if test : suite elif_clause
1816
[
if_stmt -> if test : suite elif_clause
1816
STRING
if_stmt -> if test : suite elif_clause
1816
~
if_stmt -> if test : suite elif_clause
1816
if
if_stmt -> if test : suite elif_clause
1816
return
if_stmt -> if test : suite elif_clause
1816
-
if_stmt -> if test : suite elif_clause
1816
lambda
if_stmt -> if test : suite elif_clause
1816
@
if_stmt -> if test : suite elif_clause
1816
nonlocal
if_stmt -> if test : suite elif_clause
1816
begsim
if_stmt -> if test : suite elif_clause
1816
False
if_stmt -> if test : suite elif_clause
1816
NAME
if_stmt -> if test : suite elif_clause
1816
not
if_stmt -> if test : suite elif_clause
1816
continue
if_stmt -> if test : suite elif_clause
1816
modopt
if_stmt -> if test : suite elif_clause
1816
resetstats
if_stmt -> if test : suite elif_clause
1816
pass
if_stmt -> if test : suite elif_clause
1816
while
if_stmt -> if test : suite elif_clause
1816
try
if_stmt -> if test : suite elif_clause
1816
class
if_stmt -> if test : suite elif_clause
1817
[
95
1817
factor
96
1817
True
97
1817
atom_expr
98
1817
~
99
1817
and_expr
100
1817
-
101
1817
atom
102
1817
{
103
1817
or_test
104
1817
arith_expr
105
1817
power
106
1817
STRING
107
1817
NAME
108
1817
(
109
1817
test
2217
1817
and_test
110
1817
term
111
1817
+
112
1817
xor_expr
113
1817
shift_expr
115
1817
NUMBER
116
1817
not
117
1817
False
118
1817
expr
119
1817
not_test
120
1817
comparison
121
1817
None
122
1817
lambdef
123
1817
lambda
124
1818
arith_expr
1
1818
try
1533
1818
modopt
1534
1818
compound_stmt
1535
1818
test
5
1818
servmod
1536
1818
while
1537
1818
and_expr
8
1818
power
9
1818
STRING
10
1818
decorated
1538
1818
cli_serv_model
1539
1818
@
13
1818
try_stmt
1540
1818
lambdef
15
1818
stmt_list
2218
1818
(
16
1818
factor
17
1818
[
18
1818
class
1541
1818
small_stmt
1542
1818
{
21
1818
term
22
1818
def
1543
1818
server
1544
1818
while_stmt
1545
1818
-
26
1818
+
27
1818
for
1546
1818
if
1547
1818
lambda
29
1818
decorators
1548
1818
atom_expr
31
1818
not_test
32
1818
if_stmt
1549
1818
yield
34
1818
conf
1550
1818
test_list
36
1818
~
37
1818
True
38
1818
False
39
1818
funcdef
1551
1818
xor_expr
41
1818
with
1552
1818
for_stmt
1553
1818
sim_stmt
45
1818
and_test
46
1818
expr
47
1818
shift_expr
48
1818
comparison
49
1818
with_stmt
1554
1818
simple_stmt
1555
1818
NAME
52
1818
or_test
53
1818
confdef
1556
1818
None
55
1818
classdef
1557
1818
atom
57
1818
NUMBER
58
1818
return
59
1818
break_stmt
60
1818
return_stmt
61
1818
stmt
1558
1818
not
62
1818
break
63
1818
raise
64
1818
expr_stmt
65
1818
stat_stmt
66
1818
decorator
67
1818
assert_stmt
68
1818
begsim
69
1818
global
70
1818
assert
71
1818
nonlocal
72
1818
nonlocal_stmt
73
1818
raise_stmt
74
1818
yield_stmt
75
1818
continue
77
1818
endsim
78
1818
del
80
1818
pass_stmt
81
1818
flow_stmt
82
1818
resetstats
84
1818
del_stmt
85
1818
continue_stmt
86
1818
global_stmt
87
1818
pass
88
1819
.
atom -> [ test_list_comp ]
1819
[
atom -> [ test_list_comp ]
1819
@
atom -> [ test_list_comp ]
1819
<=
atom -> [ test_list_comp ]
1819
<
atom -> [ test_list_comp ]
1819
not
atom -> [ test_list_comp ]
1819
in
atom -> [ test_list_comp ]
1819
and
atom -> [ test_list_comp ]
1819
-
atom -> [ test_list_comp ]
1819
!=
atom -> [ test_list_comp ]
1819
is
atom -> [ test_list_comp ]
1819
>>
atom -> [ test_list_comp ]
1819
else
atom -> [ test_list_comp ]
1819
or
atom -> [ test_list_comp ]
1819
//
atom -> [ test_list_comp ]
1819
/
atom -> [ test_list_comp ]
1819
|
atom -> [ test_list_comp ]
1819
>
atom -> [ test_list_comp ]
1819
&
atom -> [ test_list_comp ]
1819
(
atom -> [ test_list_comp ]
1819
%
atom -> [ test_list_comp ]
1819
>=
atom -> [ test_list_comp ]
1819
==
atom -> [ test_list_comp ]
1819
**
atom -> [ test_list_comp ]
1819
<<
atom -> [ test_list_comp ]
1819
^
atom -> [ test_list_comp ]
1819
+
atom -> [ test_list_comp ]
1819
*
atom -> [ test_list_comp ]
1820
&=
test -> or_test if or_test else test
1820
@=
test -> or_test if or_test else test
1820
/=
test -> or_test if or_test else test
1820
**=
test -> or_test if or_test else test
1820
,
test -> or_test if or_test else test
1820
%=
test -> or_test if or_test else test
1820
|=
test -> or_test if or_test else test
1820
//=
test -> or_test if or_test else test
1820
<<=
test -> or_test if or_test else test
1820
*=
test -> or_test if or_test else test
1820
=
test -> or_test if or_test else test
1820
^=
test -> or_test if or_test else test
1820
:
test -> or_test if or_test else test
1820
NEWLINE
test -> or_test if or_test else test
1820
>>=
test -> or_test if or_test else test
1820
+=
test -> or_test if or_test else test
1820
-=
test -> or_test if or_test else test
1821
<<
term -> factor @ term
1821
^
term -> factor @ term
1821
<=
term -> factor @ term
1821
==
term -> factor @ term
1821
|
term -> factor @ term
1821
!=
term -> factor @ term
1821
else
term -> factor @ term
1821
or
term -> factor @ term
1821
>
term -> factor @ term
1821
and
term -> factor @ term
1821
>>
term -> factor @ term
1821
is
term -> factor @ term
1821
-
term -> factor @ term
1821
not
term -> factor @ term
1821
+
term -> factor @ term
1821
in
term -> factor @ term
1821
>=
term -> factor @ term
1821
<
term -> factor @ term
1821
&
term -> factor @ term
1822
<=
term -> factor % term
1822
is
term -> factor % term
1822
else
term -> factor % term
1822
>
term -> factor % term
1822
and
term -> factor % term
1822
in
term -> factor % term
1822
or
term -> factor % term
1822
<
term -> factor % term
1822
-
term -> factor % term
1822
!=
term -> factor % term
1822
>>
term -> factor % term
1822
^
term -> factor % term
1822
+
term -> factor % term
1822
<<
term -> factor % term
1822
>=
term -> factor % term
1822
==
term -> factor % term
1822
not
term -> factor % term
1822
|
term -> factor % term
1822
&
term -> factor % term
1823
else
term -> factor / term
1823
>>
term -> factor / term
1823
!=
term -> factor / term
1823
<
term -> factor / term
1823
<=
term -> factor / term
1823
|
term -> factor / term
1823
is
term -> factor / term
1823
>=
term -> factor / term
1823
^
term -> factor / term
1823
&
term -> factor / term
1823
+
term -> factor / term
1823
<<
term -> factor / term
1823
and
term -> factor / term
1823
-
term -> factor / term
1823
in
term -> factor / term
1823
>
term -> factor / term
1823
or
term -> factor / term
1823
not
term -> factor / term
1823
==
term -> factor / term
1824
is
term -> factor * term
1824
+
term -> factor * term
1824
>=
term -> factor * term
1824
^
term -> factor * term
1824
<=
term -> factor * term
1824
or
term -> factor * term
1824
<
term -> factor * term
1824
|
term -> factor * term
1824
>>
term -> factor * term
1824
in
term -> factor * term
1824
not
term -> factor * term
1824
==
term -> factor * term
1824
else
term -> factor * term
1824
-
term -> factor * term
1824
and
term -> factor * term
1824
!=
term -> factor * term
1824
<<
term -> factor * term
1824
>
term -> factor * term
1824
&
term -> factor * term
1825
!=
term -> factor // term
1825
or
term -> factor // term
1825
^
term -> factor // term
1825
>
term -> factor // term
1825
is
term -> factor // term
1825
&
term -> factor // term
1825
-
term -> factor // term
1825
in
term -> factor // term
1825
>>
term -> factor // term
1825
|
term -> factor // term
1825
<
term -> factor // term
1825
>=
term -> factor // term
1825
not
term -> factor // term
1825
==
term -> factor // term
1825
<=
term -> factor // term
1825
else
term -> factor // term
1825
and
term -> factor // term
1825
<<
term -> factor // term
1825
+
term -> factor // term
1826
not
xor_expr -> and_expr ^ xor_expr
1826
<
xor_expr -> and_expr ^ xor_expr
1826
>=
xor_expr -> and_expr ^ xor_expr
1826
else
xor_expr -> and_expr ^ xor_expr
1826
>
xor_expr -> and_expr ^ xor_expr
1826
is
xor_expr -> and_expr ^ xor_expr
1826
!=
xor_expr -> and_expr ^ xor_expr
1826
and
xor_expr -> and_expr ^ xor_expr
1826
<=
xor_expr -> and_expr ^ xor_expr
1826
in
xor_expr -> and_expr ^ xor_expr
1826
==
xor_expr -> and_expr ^ xor_expr
1826
|
xor_expr -> and_expr ^ xor_expr
1826
or
xor_expr -> and_expr ^ xor_expr
1827
+
trailer -> ( )
1827
!=
trailer -> ( )
1827
<<
trailer -> ( )
1827
>=
trailer -> ( )
1827
**
trailer -> ( )
1827
not
trailer -> ( )
1827
else
trailer -> ( )
1827
[
trailer -> ( )
1827
|
trailer -> ( )
1827
==
trailer -> ( )
1827
%
trailer -> ( )
1827
*
trailer -> ( )
1827
>>
trailer -> ( )
1827
@
trailer -> ( )
1827
>
trailer -> ( )
1827
/
trailer -> ( )
1827
in
trailer -> ( )
1827
(
trailer -> ( )
1827
is
trailer -> ( )
1827
//
trailer -> ( )
1827
<
trailer -> ( )
1827
or
trailer -> ( )
1827
^
trailer -> ( )
1827
and
trailer -> ( )
1827
<=
trailer -> ( )
1827
.
trailer -> ( )
1827
-
trailer -> ( )
1827
&
trailer -> ( )
1828
)
2219
1829
else
trailer_expr -> trailer trailer_expr
1829
<=
trailer_expr -> trailer trailer_expr
1829
+
trailer_expr -> trailer trailer_expr
1829
^
trailer_expr -> trailer trailer_expr
1829
or
trailer_expr -> trailer trailer_expr
1829
==
trailer_expr -> trailer trailer_expr
1829
%
trailer_expr -> trailer trailer_expr
1829
@
trailer_expr -> trailer trailer_expr
1829
not
trailer_expr -> trailer trailer_expr
1829
<<
trailer_expr -> trailer trailer_expr
1829
-
trailer_expr -> trailer trailer_expr
1829
//
trailer_expr -> trailer trailer_expr
1829
and
trailer_expr -> trailer trailer_expr
1829
|
trailer_expr -> trailer trailer_expr
1829
>
trailer_expr -> trailer trailer_expr
1829
!=
trailer_expr -> trailer trailer_expr
1829
<
trailer_expr -> trailer trailer_expr
1829
>>
trailer_expr -> trailer trailer_expr
1829
/
trailer_expr -> trailer trailer_expr
1829
is
trailer_expr -> trailer trailer_expr
1829
&
trailer_expr -> trailer trailer_expr
1829
in
trailer_expr -> trailer trailer_expr
1829
>=
trailer_expr -> trailer trailer_expr
1829
*
trailer_expr -> trailer trailer_expr
1829
**
trailer_expr -> trailer trailer_expr
1830
.
trailer -> . NAME
1830
not
trailer -> . NAME
1830
**
trailer -> . NAME
1830
|
trailer -> . NAME
1830
-
trailer -> . NAME
1830
(
trailer -> . NAME
1830
%
trailer -> . NAME
1830
//
trailer -> . NAME
1830
else
trailer -> . NAME
1830
==
trailer -> . NAME
1830
>>
trailer -> . NAME
1830
is
trailer -> . NAME
1830
!=
trailer -> . NAME
1830
and
trailer -> . NAME
1830
>=
trailer -> . NAME
1830
>
trailer -> . NAME
1830
in
trailer -> . NAME
1830
<<
trailer -> . NAME
1830
&
trailer -> . NAME
1830
/
trailer -> . NAME
1830
^
trailer -> . NAME
1830
[
trailer -> . NAME
1830
<=
trailer -> . NAME
1830
or
trailer -> . NAME
1830
+
trailer -> . NAME
1830
<
trailer -> . NAME
1830
*
trailer -> . NAME
1830
@
trailer -> . NAME
1831
]
2220
1832
else
shift_expr -> arith_expr >> shift_expr
1832
==
shift_expr -> arith_expr >> shift_expr
1832
^
shift_expr -> arith_expr >> shift_expr
1832
or
shift_expr -> arith_expr >> shift_expr
1832
not
shift_expr -> arith_expr >> shift_expr
1832
|
shift_expr -> arith_expr >> shift_expr
1832
<=
shift_expr -> arith_expr >> shift_expr
1832
is
shift_expr -> arith_expr >> shift_expr
1832
in
shift_expr -> arith_expr >> shift_expr
1832
>=
shift_expr -> arith_expr >> shift_expr
1832
>
shift_expr -> arith_expr >> shift_expr
1832
&
shift_expr -> arith_expr >> shift_expr
1832
<
shift_expr -> arith_expr >> shift_expr
1832
and
shift_expr -> arith_expr >> shift_expr
1832
!=
shift_expr -> arith_expr >> shift_expr
1833
or
shift_expr -> arith_expr << shift_expr
1833
>
shift_expr -> arith_expr << shift_expr
1833
in
shift_expr -> arith_expr << shift_expr
1833
&
shift_expr -> arith_expr << shift_expr
1833
is
shift_expr -> arith_expr << shift_expr
1833
<
shift_expr -> arith_expr << shift_expr
1833
<=
shift_expr -> arith_expr << shift_expr
1833
not
shift_expr -> arith_expr << shift_expr
1833
^
shift_expr -> arith_expr << shift_expr
1833
and
shift_expr -> arith_expr << shift_expr
1833
|
shift_expr -> arith_expr << shift_expr
1833
!=
shift_expr -> arith_expr << shift_expr
1833
else
shift_expr -> arith_expr << shift_expr
1833
==
shift_expr -> arith_expr << shift_expr
1833
>=
shift_expr -> arith_expr << shift_expr
1834
!=
power -> atom_expr ** factor
1834
@
power -> atom_expr ** factor
1834
|
power -> atom_expr ** factor
1834
in
power -> atom_expr ** factor
1834
==
power -> atom_expr ** factor
1834
and
power -> atom_expr ** factor
1834
>=
power -> atom_expr ** factor
1834
/
power -> atom_expr ** factor
1834
not
power -> atom_expr ** factor
1834
^
power -> atom_expr ** factor
1834
//
power -> atom_expr ** factor
1834
else
power -> atom_expr ** factor
1834
>
power -> atom_expr ** factor
1834
+
power -> atom_expr ** factor
1834
%
power -> atom_expr ** factor
1834
-
power -> atom_expr ** factor
1834
is
power -> atom_expr ** factor
1834
<=
power -> atom_expr ** factor
1834
<
power -> atom_expr ** factor
1834
*
power -> atom_expr ** factor
1834
<<
power -> atom_expr ** factor
1834
or
power -> atom_expr ** factor
1834
>>
power -> atom_expr ** factor
1834
&
power -> atom_expr ** factor
1835
>
atom -> ( test_list_comp )
1835
@
atom -> ( test_list_comp )
1835
&
atom -> ( test_list_comp )
1835
[
atom -> ( test_list_comp )
1835
==
atom -> ( test_list_comp )
1835
else
atom -> ( test_list_comp )
1835
>=
atom -> ( test_list_comp )
1835
**
atom -> ( test_list_comp )
1835
not
atom -> ( test_list_comp )
1835
<<
atom -> ( test_list_comp )
1835
>>
atom -> ( test_list_comp )
1835
in
atom -> ( test_list_comp )
1835
or
atom -> ( test_list_comp )
1835
.
atom -> ( test_list_comp )
1835
/
atom -> ( test_list_comp )
1835
^
atom -> ( test_list_comp )
1835
is
atom -> ( test_list_comp )
1835
and
atom -> ( test_list_comp )
1835
//
atom -> ( test_list_comp )
1835
<
atom -> ( test_list_comp )
1835
*
atom -> ( test_list_comp )
1835
<=
atom -> ( test_list_comp )
1835
(
atom -> ( test_list_comp )
1835
-
atom -> ( test_list_comp )
1835
|
atom -> ( test_list_comp )
1835
!=
atom -> ( test_list_comp )
1835
+
atom -> ( test_list_comp )
1835
%
atom -> ( test_list_comp )
1836
!=
arith_expr -> term + arith_expr
1836
>=
arith_expr -> term + arith_expr
1836
not
arith_expr -> term + arith_expr
1836
else
arith_expr -> term + arith_expr
1836
>
arith_expr -> term + arith_expr
1836
<
arith_expr -> term + arith_expr
1836
&
arith_expr -> term + arith_expr
1836
^
arith_expr -> term + arith_expr
1836
>>
arith_expr -> term + arith_expr
1836
in
arith_expr -> term + arith_expr
1836
<<
arith_expr -> term + arith_expr
1836
or
arith_expr -> term + arith_expr
1836
is
arith_expr -> term + arith_expr
1836
and
arith_expr -> term + arith_expr
1836
<=
arith_expr -> term + arith_expr
1836
|
arith_expr -> term + arith_expr
1836
==
arith_expr -> term + arith_expr
1837
>
arith_expr -> term - arith_expr
1837
==
arith_expr -> term - arith_expr
1837
^
arith_expr -> term - arith_expr
1837
is
arith_expr -> term - arith_expr
1837
|
arith_expr -> term - arith_expr
1837
&
arith_expr -> term - arith_expr
1837
else
arith_expr -> term - arith_expr
1837
<<
arith_expr -> term - arith_expr
1837
>>
arith_expr -> term - arith_expr
1837
!=
arith_expr -> term - arith_expr
1837
not
arith_expr -> term - arith_expr
1837
>=
arith_expr -> term - arith_expr
1837
and
arith_expr -> term - arith_expr
1837
<=
arith_expr -> term - arith_expr
1837
<
arith_expr -> term - arith_expr
1837
or
arith_expr -> term - arith_expr
1837
in
arith_expr -> term - arith_expr
1838
>=
expr -> xor_expr | expr
1838
or
expr -> xor_expr | expr
1838
in
expr -> xor_expr | expr
1838
and
expr -> xor_expr | expr
1838
else
expr -> xor_expr | expr
1838
==
expr -> xor_expr | expr
1838
>
expr -> xor_expr | expr
1838
<=
expr -> xor_expr | expr
1838
is
expr -> xor_expr | expr
1838
<
expr -> xor_expr | expr
1838
not
expr -> xor_expr | expr
1838
!=
expr -> xor_expr | expr
1839
<
and_expr -> shift_expr & and_expr
1839
>=
and_expr -> shift_expr & and_expr
1839
not
and_expr -> shift_expr & and_expr
1839
==
and_expr -> shift_expr & and_expr
1839
>
and_expr -> shift_expr & and_expr
1839
in
and_expr -> shift_expr & and_expr
1839
^
and_expr -> shift_expr & and_expr
1839
else
and_expr -> shift_expr & and_expr
1839
or
and_expr -> shift_expr & and_expr
1839
!=
and_expr -> shift_expr & and_expr
1839
and
and_expr -> shift_expr & and_expr
1839
|
and_expr -> shift_expr & and_expr
1839
is
and_expr -> shift_expr & and_expr
1839
<=
and_expr -> shift_expr & and_expr
1840
else
and_test -> not_test and and_test
1840
or
and_test -> not_test and and_test
1841
and
comparison -> expr comp_op comparison
1841
or
comparison -> expr comp_op comparison
1841
else
comparison -> expr comp_op comparison
1842
else
or_test -> and_test or or_test
1843
.
atom -> [ test_list_comp ]
1843
[
atom -> [ test_list_comp ]
1843
@
atom -> [ test_list_comp ]
1843
<=
atom -> [ test_list_comp ]
1843
<
atom -> [ test_list_comp ]
1843
not
atom -> [ test_list_comp ]
1843
for
atom -> [ test_list_comp ]
1843
in
atom -> [ test_list_comp ]
1843
and
atom -> [ test_list_comp ]
1843
-
atom -> [ test_list_comp ]
1843
if
atom -> [ test_list_comp ]
1843
!=
atom -> [ test_list_comp ]
1843
is
atom -> [ test_list_comp ]
1843
>>
atom -> [ test_list_comp ]
1843
=
atom -> [ test_list_comp ]
1843
or
atom -> [ test_list_comp ]
1843
//
atom -> [ test_list_comp ]
1843
/
atom -> [ test_list_comp ]
1843
,
atom -> [ test_list_comp ]
1843
|
atom -> [ test_list_comp ]
1843
>
atom -> [ test_list_comp ]
1843
&
atom -> [ test_list_comp ]
1843
(
atom -> [ test_list_comp ]
1843
%
atom -> [ test_list_comp ]
1843
>=
atom -> [ test_list_comp ]
1843
)
atom -> [ test_list_comp ]
1843
==
atom -> [ test_list_comp ]
1843
**
atom -> [ test_list_comp ]
1843
<<
atom -> [ test_list_comp ]
1843
^
atom -> [ test_list_comp ]
1843
+
atom -> [ test_list_comp ]
1843
*
atom -> [ test_list_comp ]
1844
for
term -> factor @ term
1844
<<
term -> factor @ term
1844
^
term -> factor @ term
1844
<=
term -> factor @ term
1844
==
term -> factor @ term
1844
if
term -> factor @ term
1844
|
term -> factor @ term
1844
!=
term -> factor @ term
1844
or
term -> factor @ term
1844
>
term -> factor @ term
1844
and
term -> factor @ term
1844
>>
term -> factor @ term
1844
is
term -> factor @ term
1844
-
term -> factor @ term
1844
not
term -> factor @ term
1844
=
term -> factor @ term
1844
+
term -> factor @ term
1844
in
term -> factor @ term
1844
>=
term -> factor @ term
1844
<
term -> factor @ term
1844
,
term -> factor @ term
1844
&
term -> factor @ term
1844
)
term -> factor @ term
1845
<=
term -> factor % term
1845
is
term -> factor % term
1845
>
term -> factor % term
1845
and
term -> factor % term
1845
in
term -> factor % term
1845
,
term -> factor % term
1845
or
term -> factor % term
1845
<
term -> factor % term
1845
-
term -> factor % term
1845
!=
term -> factor % term
1845
>>
term -> factor % term
1845
^
term -> factor % term
1845
+
term -> factor % term
1845
if
term -> factor % term
1845
<<
term -> factor % term
1845
>=
term -> factor % term
1845
==
term -> factor % term
1845
not
term -> factor % term
1845
|
term -> factor % term
1845
=
term -> factor % term
1845
)
term -> factor % term
1845
&
term -> factor % term
1845
for
term -> factor % term
1846
>>
term -> factor / term
1846
!=
term -> factor / term
1846
<
term -> factor / term
1846
<=
term -> factor / term
1846
|
term -> factor / term
1846
is
term -> factor / term
1846
=
term -> factor / term
1846
>=
term -> factor / term
1846
^
term -> factor / term
1846
&
term -> factor / term
1846
+
term -> factor / term
1846
for
term -> factor / term
1846
<<
term -> factor / term
1846
and
term -> factor / term
1846
-
term -> factor / term
1846
in
term -> factor / term
1846
>
term -> factor / term
1846
or
term -> factor / term
1846
not
term -> factor / term
1846
==
term -> factor / term
1846
,
term -> factor / term
1846
if
term -> factor / term
1846
)
term -> factor / term
1847
is
term -> factor * term
1847
+
term -> factor * term
1847
>=
term -> factor * term
1847
^
term -> factor * term
1847
=
term -> factor * term
1847
,
term -> factor * term
1847
<=
term -> factor * term
1847
or
term -> factor * term
1847
)
term -> factor * term
1847
for
term -> factor * term
1847
<
term -> factor * term
1847
|
term -> factor * term
1847
>>
term -> factor * term
1847
in
term -> factor * term
1847
not
term -> factor * term
1847
==
term -> factor * term
1847
-
term -> factor * term
1847
and
term -> factor * term
1847
!=
term -> factor * term
1847
<<
term -> factor * term
1847
>
term -> factor * term
1847
if
term -> factor * term
1847
&
term -> factor * term
1848
for
term -> factor // term
1848
!=
term -> factor // term
1848
or
term -> factor // term
1848
^
term -> factor // term
1848
>
term -> factor // term
1848
is
term -> factor // term
1848
&
term -> factor // term
1848
-
term -> factor // term
1848
in
term -> factor // term
1848
>>
term -> factor // term
1848
|
term -> factor // term
1848
<
term -> factor // term
1848
>=
term -> factor // term
1848
not
term -> factor // term
1848
if
term -> factor // term
1848
=
term -> factor // term
1848
==
term -> factor // term
1848
)
term -> factor // term
1848
<=
term -> factor // term
1848
,
term -> factor // term
1848
and
term -> factor // term
1848
<<
term -> factor // term
1848
+
term -> factor // term
1849
!=
power -> atom_expr ** factor
1849
@
power -> atom_expr ** factor
1849
for
power -> atom_expr ** factor
1849
|
power -> atom_expr ** factor
1849
in
power -> atom_expr ** factor
1849
==
power -> atom_expr ** factor
1849
if
power -> atom_expr ** factor
1849
and
power -> atom_expr ** factor
1849
=
power -> atom_expr ** factor
1849
>=
power -> atom_expr ** factor
1849
/
power -> atom_expr ** factor
1849
not
power -> atom_expr ** factor
1849
^
power -> atom_expr ** factor
1849
//
power -> atom_expr ** factor
1849
>
power -> atom_expr ** factor
1849
+
power -> atom_expr ** factor
1849
%
power -> atom_expr ** factor
1849
)
power -> atom_expr ** factor
1849
-
power -> atom_expr ** factor
1849
is
power -> atom_expr ** factor
1849
<=
power -> atom_expr ** factor
1849
<
power -> atom_expr ** factor
1849
,
power -> atom_expr ** factor
1849
*
power -> atom_expr ** factor
1849
<<
power -> atom_expr ** factor
1849
or
power -> atom_expr ** factor
1849
>>
power -> atom_expr ** factor
1849
&
power -> atom_expr ** factor
1850
not
xor_expr -> and_expr ^ xor_expr
1850
<
xor_expr -> and_expr ^ xor_expr
1850
,
xor_expr -> and_expr ^ xor_expr
1850
=
xor_expr -> and_expr ^ xor_expr
1850
>=
xor_expr -> and_expr ^ xor_expr
1850
>
xor_expr -> and_expr ^ xor_expr
1850
)
xor_expr -> and_expr ^ xor_expr
1850
!=
xor_expr -> and_expr ^ xor_expr
1850
is
xor_expr -> and_expr ^ xor_expr
1850
and
xor_expr -> and_expr ^ xor_expr
1850
if
xor_expr -> and_expr ^ xor_expr
1850
<=
xor_expr -> and_expr ^ xor_expr
1850
in
xor_expr -> and_expr ^ xor_expr
1850
==
xor_expr -> and_expr ^ xor_expr
1850
for
xor_expr -> and_expr ^ xor_expr
1850
|
xor_expr -> and_expr ^ xor_expr
1850
or
xor_expr -> and_expr ^ xor_expr
1851
<
and_expr -> shift_expr & and_expr
1851
if
and_expr -> shift_expr & and_expr
1851
>=
and_expr -> shift_expr & and_expr
1851
=
and_expr -> shift_expr & and_expr
1851
not
and_expr -> shift_expr & and_expr
1851
==
and_expr -> shift_expr & and_expr
1851
>
and_expr -> shift_expr & and_expr
1851
in
and_expr -> shift_expr & and_expr
1851
^
and_expr -> shift_expr & and_expr
1851
or
and_expr -> shift_expr & and_expr
1851
and
and_expr -> shift_expr & and_expr
1851
!=
and_expr -> shift_expr & and_expr
1851
,
and_expr -> shift_expr & and_expr
1851
for
and_expr -> shift_expr & and_expr
1851
<=
and_expr -> shift_expr & and_expr
1851
|
and_expr -> shift_expr & and_expr
1851
is
and_expr -> shift_expr & and_expr
1851
)
and_expr -> shift_expr & and_expr
1852
=
trailer -> . NAME
1852
.
trailer -> . NAME
1852
not
trailer -> . NAME
1852
if
trailer -> . NAME
1852
**
trailer -> . NAME
1852
|
trailer -> . NAME
1852
-
trailer -> . NAME
1852
(
trailer -> . NAME
1852
%
trailer -> . NAME
1852
//
trailer -> . NAME
1852
==
trailer -> . NAME
1852
>>
trailer -> . NAME
1852
is
trailer -> . NAME
1852
!=
trailer -> . NAME
1852
)
trailer -> . NAME
1852
and
trailer -> . NAME
1852
>=
trailer -> . NAME
1852
,
trailer -> . NAME
1852
>
trailer -> . NAME
1852
in
trailer -> . NAME
1852
<<
trailer -> . NAME
1852
&
trailer -> . NAME
1852
/
trailer -> . NAME
1852
^
trailer -> . NAME
1852
[
trailer -> . NAME
1852
<=
trailer -> . NAME
1852
or
trailer -> . NAME
1852
+
trailer -> . NAME
1852
for
trailer -> . NAME
1852
<
trailer -> . NAME
1852
*
trailer -> . NAME
1852
@
trailer -> . NAME
1853
)
trailer -> ( )
1853
+
trailer -> ( )
1853
!=
trailer -> ( )
1853
<<
trailer -> ( )
1853
>=
trailer -> ( )
1853
**
trailer -> ( )
1853
not
trailer -> ( )
1853
=
trailer -> ( )
1853
if
trailer -> ( )
1853
,
trailer -> ( )
1853
|
trailer -> ( )
1853
[
trailer -> ( )
1853
==
trailer -> ( )
1853
%
trailer -> ( )
1853
*
trailer -> ( )
1853
>>
trailer -> ( )
1853
for
trailer -> ( )
1853
@
trailer -> ( )
1853
>
trailer -> ( )
1853
/
trailer -> ( )
1853
in
trailer -> ( )
1853
(
trailer -> ( )
1853
is
trailer -> ( )
1853
//
trailer -> ( )
1853
<
trailer -> ( )
1853
or
trailer -> ( )
1853
^
trailer -> ( )
1853
and
trailer -> ( )
1853
<=
trailer -> ( )
1853
.
trailer -> ( )
1853
-
trailer -> ( )
1853
&
trailer -> ( )
1854
)
2221
1855
<=
trailer_expr -> trailer trailer_expr
1855
+
trailer_expr -> trailer trailer_expr
1855
^
trailer_expr -> trailer trailer_expr
1855
for
trailer_expr -> trailer trailer_expr
1855
or
trailer_expr -> trailer trailer_expr
1855
==
trailer_expr -> trailer trailer_expr
1855
%
trailer_expr -> trailer trailer_expr
1855
@
trailer_expr -> trailer trailer_expr
1855
=
trailer_expr -> trailer trailer_expr
1855
not
trailer_expr -> trailer trailer_expr
1855
<<
trailer_expr -> trailer trailer_expr
1855
-
trailer_expr -> trailer trailer_expr
1855
//
trailer_expr -> trailer trailer_expr
1855
and
trailer_expr -> trailer trailer_expr
1855
|
trailer_expr -> trailer trailer_expr
1855
if
trailer_expr -> trailer trailer_expr
1855
>
trailer_expr -> trailer trailer_expr
1855
!=
trailer_expr -> trailer trailer_expr
1855
,
trailer_expr -> trailer trailer_expr
1855
<
trailer_expr -> trailer trailer_expr
1855
>>
trailer_expr -> trailer trailer_expr
1855
/
trailer_expr -> trailer trailer_expr
1855
is
trailer_expr -> trailer trailer_expr
1855
&
trailer_expr -> trailer trailer_expr
1855
in
trailer_expr -> trailer trailer_expr
1855
>=
trailer_expr -> trailer trailer_expr
1855
*
trailer_expr -> trailer trailer_expr
1855
)
trailer_expr -> trailer trailer_expr
1855
**
trailer_expr -> trailer trailer_expr
1856
]
2222
1857
if
or_test -> and_test or or_test
1857
=
or_test -> and_test or or_test
1857
)
or_test -> and_test or or_test
1857
,
or_test -> and_test or or_test
1857
for
or_test -> and_test or or_test
1858
==
shift_expr -> arith_expr >> shift_expr
1858
,
shift_expr -> arith_expr >> shift_expr
1858
|
shift_expr -> arith_expr >> shift_expr
1858
)
shift_expr -> arith_expr >> shift_expr
1858
>
shift_expr -> arith_expr >> shift_expr
1858
<=
shift_expr -> arith_expr >> shift_expr
1858
!=
shift_expr -> arith_expr >> shift_expr
1858
for
shift_expr -> arith_expr >> shift_expr
1858
not
shift_expr -> arith_expr >> shift_expr
1858
^
shift_expr -> arith_expr >> shift_expr
1858
and
shift_expr -> arith_expr >> shift_expr
1858
or
shift_expr -> arith_expr >> shift_expr
1858
if
shift_expr -> arith_expr >> shift_expr
1858
=
shift_expr -> arith_expr >> shift_expr
1858
in
shift_expr -> arith_expr >> shift_expr
1858
is
shift_expr -> arith_expr >> shift_expr
1858
>=
shift_expr -> arith_expr >> shift_expr
1858
&
shift_expr -> arith_expr >> shift_expr
1858
<
shift_expr -> arith_expr >> shift_expr
1859
&
shift_expr -> arith_expr << shift_expr
1859
is
shift_expr -> arith_expr << shift_expr
1859
=
shift_expr -> arith_expr << shift_expr
1859
)
shift_expr -> arith_expr << shift_expr
1859
>=
shift_expr -> arith_expr << shift_expr
1859
or
shift_expr -> arith_expr << shift_expr
1859
>
shift_expr -> arith_expr << shift_expr
1859
<
shift_expr -> arith_expr << shift_expr
1859
not
shift_expr -> arith_expr << shift_expr
1859
!=
shift_expr -> arith_expr << shift_expr
1859
for
shift_expr -> arith_expr << shift_expr
1859
^
shift_expr -> arith_expr << shift_expr
1859
and
shift_expr -> arith_expr << shift_expr
1859
in
shift_expr -> arith_expr << shift_expr
1859
if
shift_expr -> arith_expr << shift_expr
1859
,
shift_expr -> arith_expr << shift_expr
1859
|
shift_expr -> arith_expr << shift_expr
1859
==
shift_expr -> arith_expr << shift_expr
1859
<=
shift_expr -> arith_expr << shift_expr
1860
>
atom -> ( test_list_comp )
1860
@
atom -> ( test_list_comp )
1860
&
atom -> ( test_list_comp )
1860
=
atom -> ( test_list_comp )
1860
[
atom -> ( test_list_comp )
1860
)
atom -> ( test_list_comp )
1860
if
atom -> ( test_list_comp )
1860
==
atom -> ( test_list_comp )
1860
>=
atom -> ( test_list_comp )
1860
**
atom -> ( test_list_comp )
1860
not
atom -> ( test_list_comp )
1860
<<
atom -> ( test_list_comp )
1860
>>
atom -> ( test_list_comp )
1860
in
atom -> ( test_list_comp )
1860
or
atom -> ( test_list_comp )
1860
.
atom -> ( test_list_comp )
1860
/
atom -> ( test_list_comp )
1860
^
atom -> ( test_list_comp )
1860
is
atom -> ( test_list_comp )
1860
,
atom -> ( test_list_comp )
1860
and
atom -> ( test_list_comp )
1860
//
atom -> ( test_list_comp )
1860
<
atom -> ( test_list_comp )
1860
*
atom -> ( test_list_comp )
1860
<=
atom -> ( test_list_comp )
1860
(
atom -> ( test_list_comp )
1860
for
atom -> ( test_list_comp )
1860
-
atom -> ( test_list_comp )
1860
!=
atom -> ( test_list_comp )
1860
|
atom -> ( test_list_comp )
1860
+
atom -> ( test_list_comp )
1860
%
atom -> ( test_list_comp )
1861
^
arith_expr -> term - arith_expr
1861
!=
arith_expr -> term - arith_expr
1861
<
arith_expr -> term - arith_expr
1861
in
arith_expr -> term - arith_expr
1861
==
arith_expr -> term - arith_expr
1861
|
arith_expr -> term - arith_expr
1861
is
arith_expr -> term - arith_expr
1861
&
arith_expr -> term - arith_expr
1861
>>
arith_expr -> term - arith_expr
1861
<<
arith_expr -> term - arith_expr
1861
=
arith_expr -> term - arith_expr
1861
and
arith_expr -> term - arith_expr
1861
,
arith_expr -> term - arith_expr
1861
>
arith_expr -> term - arith_expr
1861
if
arith_expr -> term - arith_expr
1861
for
arith_expr -> term - arith_expr
1861
not
arith_expr -> term - arith_expr
1861
)
arith_expr -> term - arith_expr
1861
>=
arith_expr -> term - arith_expr
1861
<=
arith_expr -> term - arith_expr
1861
or
arith_expr -> term - arith_expr
1862
>=
arith_expr -> term + arith_expr
1862
>
arith_expr -> term + arith_expr
1862
^
arith_expr -> term + arith_expr
1862
or
arith_expr -> term + arith_expr
1862
==
arith_expr -> term + arith_expr
1862
<=
arith_expr -> term + arith_expr
1862
if
arith_expr -> term + arith_expr
1862
>>
arith_expr -> term + arith_expr
1862
<
arith_expr -> term + arith_expr
1862
not
arith_expr -> term + arith_expr
1862
&
arith_expr -> term + arith_expr
1862
in
arith_expr -> term + arith_expr
1862
and
arith_expr -> term + arith_expr
1862
,
arith_expr -> term + arith_expr
1862
|
arith_expr -> term + arith_expr
1862
!=
arith_expr -> term + arith_expr
1862
)
arith_expr -> term + arith_expr
1862
=
arith_expr -> term + arith_expr
1862
<<
arith_expr -> term + arith_expr
1862
for
arith_expr -> term + arith_expr
1862
is
arith_expr -> term + arith_expr
1863
>=
expr -> xor_expr | expr
1863
=
expr -> xor_expr | expr
1863
,
expr -> xor_expr | expr
1863
or
expr -> xor_expr | expr
1863
in
expr -> xor_expr | expr
1863
!=
expr -> xor_expr | expr
1863
and
expr -> xor_expr | expr
1863
==
expr -> xor_expr | expr
1863
>
expr -> xor_expr | expr
1863
<=
expr -> xor_expr | expr
1863
is
expr -> xor_expr | expr
1863
)
expr -> xor_expr | expr
1863
<
expr -> xor_expr | expr
1863
if
expr -> xor_expr | expr
1863
not
expr -> xor_expr | expr
1863
for
expr -> xor_expr | expr
1864
else
2223
1865
for
comparison -> expr comp_op comparison
1865
)
comparison -> expr comp_op comparison
1865
or
comparison -> expr comp_op comparison
1865
if
comparison -> expr comp_op comparison
1865
and
comparison -> expr comp_op comparison
1865
=
comparison -> expr comp_op comparison
1865
,
comparison -> expr comp_op comparison
1866
for
and_test -> not_test and and_test
1866
or
and_test -> not_test and and_test
1866
)
and_test -> not_test and and_test
1866
if
and_test -> not_test and and_test
1866
=
and_test -> not_test and and_test
1866
,
and_test -> not_test and and_test
1867
[
766
1867
factor
767
1867
True
768
1867
atom_expr
769
1867
~
770
1867
and_expr
771
1867
-
772
1867
{
773
1867
shift_expr
774
1867
atom
775
1867
comparison
776
1867
and_test
777
1867
arith_expr
778
1867
power
779
1867
STRING
780
1867
NAME
781
1867
(
782
1867
term
784
1867
+
785
1867
xor_expr
786
1867
or_test
788
1867
NUMBER
789
1867
not
790
1867
False
791
1867
expr
792
1867
not_test
794
1867
None
795
1867
test
2224
1867
lambdef
796
1867
lambda
797
1868
,
lambdef -> lambda : test
1868
for
lambdef -> lambda : test
1868
=
lambdef -> lambda : test
1868
)
lambdef -> lambda : test
1869
,
argument -> test = test
1869
)
argument -> test = test
1870
in
2225
1871
)
arglist -> argument , arglist
1872
.
atom -> [ test_list_comp ]
1872
[
atom -> [ test_list_comp ]
1872
@
atom -> [ test_list_comp ]
1872
<=
atom -> [ test_list_comp ]
1872
<
atom -> [ test_list_comp ]
1872
not
atom -> [ test_list_comp ]
1872
]
atom -> [ test_list_comp ]
1872
in
atom -> [ test_list_comp ]
1872
and
atom -> [ test_list_comp ]
1872
-
atom -> [ test_list_comp ]
1872
if
atom -> [ test_list_comp ]
1872
!=
atom -> [ test_list_comp ]
1872
is
atom -> [ test_list_comp ]
1872
>>
atom -> [ test_list_comp ]
1872
or
atom -> [ test_list_comp ]
1872
//
atom -> [ test_list_comp ]
1872
/
atom -> [ test_list_comp ]
1872
,
atom -> [ test_list_comp ]
1872
|
atom -> [ test_list_comp ]
1872
>
atom -> [ test_list_comp ]
1872
&
atom -> [ test_list_comp ]
1872
(
atom -> [ test_list_comp ]
1872
%
atom -> [ test_list_comp ]
1872
>=
atom -> [ test_list_comp ]
1872
==
atom -> [ test_list_comp ]
1872
**
atom -> [ test_list_comp ]
1872
:
atom -> [ test_list_comp ]
1872
<<
atom -> [ test_list_comp ]
1872
+
atom -> [ test_list_comp ]
1872
*
atom -> [ test_list_comp ]
1872
^
atom -> [ test_list_comp ]
1873
]
term -> factor @ term
1873
<<
term -> factor @ term
1873
^
term -> factor @ term
1873
<=
term -> factor @ term
1873
&
term -> factor @ term
1873
==
term -> factor @ term
1873
if
term -> factor @ term
1873
|
term -> factor @ term
1873
!=
term -> factor @ term
1873
or
term -> factor @ term
1873
>
term -> factor @ term
1873
and
term -> factor @ term
1873
>>
term -> factor @ term
1873
is
term -> factor @ term
1873
-
term -> factor @ term
1873
not
term -> factor @ term
1873
+
term -> factor @ term
1873
in
term -> factor @ term
1873
>=
term -> factor @ term
1873
<
term -> factor @ term
1873
,
term -> factor @ term
1873
:
term -> factor @ term
1874
!=
term -> factor // term
1874
or
term -> factor // term
1874
^
term -> factor // term
1874
>
term -> factor // term
1874
is
term -> factor // term
1874
&
term -> factor // term
1874
-
term -> factor // term
1874
:
term -> factor // term
1874
in
term -> factor // term
1874
>>
term -> factor // term
1874
|
term -> factor // term
1874
<
term -> factor // term
1874
>=
term -> factor // term
1874
not
term -> factor // term
1874
if
term -> factor // term
1874
==
term -> factor // term
1874
]
term -> factor // term
1874
<=
term -> factor // term
1874
,
term -> factor // term
1874
and
term -> factor // term
1874
<<
term -> factor // term
1874
+
term -> factor // term
1875
<=
term -> factor % term
1875
is
term -> factor % term
1875
>
term -> factor % term
1875
and
term -> factor % term
1875
in
term -> factor % term
1875
,
term -> factor % term
1875
or
term -> factor % term
1875
<
term -> factor % term
1875
:
term -> factor % term
1875
-
term -> factor % term
1875
]
term -> factor % term
1875
!=
term -> factor % term
1875
>>
term -> factor % term
1875
^
term -> factor % term
1875
+
term -> factor % term
1875
if
term -> factor % term
1875
<<
term -> factor % term
1875
>=
term -> factor % term
1875
==
term -> factor % term
1875
not
term -> factor % term
1875
|
term -> factor % term
1875
&
term -> factor % term
1876
>>
term -> factor / term
1876
!=
term -> factor / term
1876
<
term -> factor / term
1876
<=
term -> factor / term
1876
|
term -> factor / term
1876
is
term -> factor / term
1876
>=
term -> factor / term
1876
^
term -> factor / term
1876
&
term -> factor / term
1876
]
term -> factor / term
1876
+
term -> factor / term
1876
<<
term -> factor / term
1876
and
term -> factor / term
1876
-
term -> factor / term
1876
in
term -> factor / term
1876
>
term -> factor / term
1876
or
term -> factor / term
1876
not
term -> factor / term
1876
==
term -> factor / term
1876
,
term -> factor / term
1876
:
term -> factor / term
1876
if
term -> factor / term
1877
is
term -> factor * term
1877
+
term -> factor * term
1877
>=
term -> factor * term
1877
^
term -> factor * term
1877
,
term -> factor * term
1877
<=
term -> factor * term
1877
or
term -> factor * term
1877
]
term -> factor * term
1877
<
term -> factor * term
1877
|
term -> factor * term
1877
>>
term -> factor * term
1877
in
term -> factor * term
1877
not
term -> factor * term
1877
==
term -> factor * term
1877
:
term -> factor * term
1877
-
term -> factor * term
1877
and
term -> factor * term
1877
!=
term -> factor * term
1877
<<
term -> factor * term
1877
>
term -> factor * term
1877
if
term -> factor * term
1877
&
term -> factor * term
1878
not
xor_expr -> and_expr ^ xor_expr
1878
<
xor_expr -> and_expr ^ xor_expr
1878
,
xor_expr -> and_expr ^ xor_expr
1878
>=
xor_expr -> and_expr ^ xor_expr
1878
>
xor_expr -> and_expr ^ xor_expr
1878
is
xor_expr -> and_expr ^ xor_expr
1878
]
xor_expr -> and_expr ^ xor_expr
1878
!=
xor_expr -> and_expr ^ xor_expr
1878
and
xor_expr -> and_expr ^ xor_expr
1878
:
xor_expr -> and_expr ^ xor_expr
1878
if
xor_expr -> and_expr ^ xor_expr
1878
<=
xor_expr -> and_expr ^ xor_expr
1878
in
xor_expr -> and_expr ^ xor_expr
1878
==
xor_expr -> and_expr ^ xor_expr
1878
|
xor_expr -> and_expr ^ xor_expr
1878
or
xor_expr -> and_expr ^ xor_expr
1879
:
power -> atom_expr ** factor
1879
!=
power -> atom_expr ** factor
1879
@
power -> atom_expr ** factor
1879
|
power -> atom_expr ** factor
1879
in
power -> atom_expr ** factor
1879
==
power -> atom_expr ** factor
1879
if
power -> atom_expr ** factor
1879
and
power -> atom_expr ** factor
1879
>=
power -> atom_expr ** factor
1879
/
power -> atom_expr ** factor
1879
not
power -> atom_expr ** factor
1879
^
power -> atom_expr ** factor
1879
]
power -> atom_expr ** factor
1879
//
power -> atom_expr ** factor
1879
>
power -> atom_expr ** factor
1879
+
power -> atom_expr ** factor
1879
%
power -> atom_expr ** factor
1879
-
power -> atom_expr ** factor
1879
is
power -> atom_expr ** factor
1879
<=
power -> atom_expr ** factor
1879
<
power -> atom_expr ** factor
1879
,
power -> atom_expr ** factor
1879
*
power -> atom_expr ** factor
1879
<<
power -> atom_expr ** factor
1879
or
power -> atom_expr ** factor
1879
>>
power -> atom_expr ** factor
1879
&
power -> atom_expr ** factor
1880
<
and_expr -> shift_expr & and_expr
1880
if
and_expr -> shift_expr & and_expr
1880
>=
and_expr -> shift_expr & and_expr
1880
|
and_expr -> shift_expr & and_expr
1880
not
and_expr -> shift_expr & and_expr
1880
==
and_expr -> shift_expr & and_expr
1880
>
and_expr -> shift_expr & and_expr
1880
]
and_expr -> shift_expr & and_expr
1880
in
and_expr -> shift_expr & and_expr
1880
^
and_expr -> shift_expr & and_expr
1880
or
and_expr -> shift_expr & and_expr
1880
and
and_expr -> shift_expr & and_expr
1880
!=
and_expr -> shift_expr & and_expr
1880
,
and_expr -> shift_expr & and_expr
1880
:
and_expr -> shift_expr & and_expr
1880
is
and_expr -> shift_expr & and_expr
1880
<=
and_expr -> shift_expr & and_expr
1881
+
trailer -> ( )
1881
!=
trailer -> ( )
1881
<<
trailer -> ( )
1881
>=
trailer -> ( )
1881
**
trailer -> ( )
1881
not
trailer -> ( )
1881
if
trailer -> ( )
1881
,
trailer -> ( )
1881
|
trailer -> ( )
1881
[
trailer -> ( )
1881
==
trailer -> ( )
1881
%
trailer -> ( )
1881
*
trailer -> ( )
1881
>>
trailer -> ( )
1881
@
trailer -> ( )
1881
>
trailer -> ( )
1881
/
trailer -> ( )
1881
in
trailer -> ( )
1881
(
trailer -> ( )
1881
]
trailer -> ( )
1881
is
trailer -> ( )
1881
//
trailer -> ( )
1881
<
trailer -> ( )
1881
:
trailer -> ( )
1881
or
trailer -> ( )
1881
^
trailer -> ( )
1881
and
trailer -> ( )
1881
<=
trailer -> ( )
1881
.
trailer -> ( )
1881
-
trailer -> ( )
1881
&
trailer -> ( )
1882
)
2226
1883
<=
trailer_expr -> trailer trailer_expr
1883
+
trailer_expr -> trailer trailer_expr
1883
^
trailer_expr -> trailer trailer_expr
1883
or
trailer_expr -> trailer trailer_expr
1883
==
trailer_expr -> trailer trailer_expr
1883
%
trailer_expr -> trailer trailer_expr
1883
@
trailer_expr -> trailer trailer_expr
1883
]
trailer_expr -> trailer trailer_expr
1883
not
trailer_expr -> trailer trailer_expr
1883
<<
trailer_expr -> trailer trailer_expr
1883
-
trailer_expr -> trailer trailer_expr
1883
//
trailer_expr -> trailer trailer_expr
1883
and
trailer_expr -> trailer trailer_expr
1883
|
trailer_expr -> trailer trailer_expr
1883
if
trailer_expr -> trailer trailer_expr
1883
>
trailer_expr -> trailer trailer_expr
1883
!=
trailer_expr -> trailer trailer_expr
1883
,
trailer_expr -> trailer trailer_expr
1883
<
trailer_expr -> trailer trailer_expr
1883
>>
trailer_expr -> trailer trailer_expr
1883
/
trailer_expr -> trailer trailer_expr
1883
:
trailer_expr -> trailer trailer_expr
1883
is
trailer_expr -> trailer trailer_expr
1883
&
trailer_expr -> trailer trailer_expr
1883
in
trailer_expr -> trailer trailer_expr
1883
>=
trailer_expr -> trailer trailer_expr
1883
*
trailer_expr -> trailer trailer_expr
1883
**
trailer_expr -> trailer trailer_expr
1884
.
trailer -> . NAME
1884
not
trailer -> . NAME
1884
if
trailer -> . NAME
1884
**
trailer -> . NAME
1884
:
trailer -> . NAME
1884
|
trailer -> . NAME
1884
-
trailer -> . NAME
1884
(
trailer -> . NAME
1884
%
trailer -> . NAME
1884
//
trailer -> . NAME
1884
==
trailer -> . NAME
1884
>>
trailer -> . NAME
1884
is
trailer -> . NAME
1884
!=
trailer -> . NAME
1884
and
trailer -> . NAME
1884
>=
trailer -> . NAME
1884
,
trailer -> . NAME
1884
>
trailer -> . NAME
1884
in
trailer -> . NAME
1884
<<
trailer -> . NAME
1884
&
trailer -> . NAME
1884
/
trailer -> . NAME
1884
^
trailer -> . NAME
1884
[
trailer -> . NAME
1884
<=
trailer -> . NAME
1884
]
trailer -> . NAME
1884
or
trailer -> . NAME
1884
+
trailer -> . NAME
1884
<
trailer -> . NAME
1884
*
trailer -> . NAME
1884
@
trailer -> . NAME
1885
]
2227
1886
else
2228
1887
>
atom -> ( test_list_comp )
1887
@
atom -> ( test_list_comp )
1887
&
atom -> ( test_list_comp )
1887
[
atom -> ( test_list_comp )
1887
if
atom -> ( test_list_comp )
1887
==
atom -> ( test_list_comp )
1887
>=
atom -> ( test_list_comp )
1887
**
atom -> ( test_list_comp )
1887
not
atom -> ( test_list_comp )
1887
<<
atom -> ( test_list_comp )
1887
>>
atom -> ( test_list_comp )
1887
in
atom -> ( test_list_comp )
1887
or
atom -> ( test_list_comp )
1887
]
atom -> ( test_list_comp )
1887
/
atom -> ( test_list_comp )
1887
.
atom -> ( test_list_comp )
1887
^
atom -> ( test_list_comp )
1887
is
atom -> ( test_list_comp )
1887
,
atom -> ( test_list_comp )
1887
and
atom -> ( test_list_comp )
1887
//
atom -> ( test_list_comp )
1887
<
atom -> ( test_list_comp )
1887
*
atom -> ( test_list_comp )
1887
<=
atom -> ( test_list_comp )
1887
(
atom -> ( test_list_comp )
1887
-
atom -> ( test_list_comp )
1887
|
atom -> ( test_list_comp )
1887
!=
atom -> ( test_list_comp )
1887
:
atom -> ( test_list_comp )
1887
+
atom -> ( test_list_comp )
1887
%
atom -> ( test_list_comp )
1888
==
shift_expr -> arith_expr >> shift_expr
1888
^
shift_expr -> arith_expr >> shift_expr
1888
or
shift_expr -> arith_expr >> shift_expr
1888
if
shift_expr -> arith_expr >> shift_expr
1888
,
shift_expr -> arith_expr >> shift_expr
1888
not
shift_expr -> arith_expr >> shift_expr
1888
|
shift_expr -> arith_expr >> shift_expr
1888
<=
shift_expr -> arith_expr >> shift_expr
1888
]
shift_expr -> arith_expr >> shift_expr
1888
in
shift_expr -> arith_expr >> shift_expr
1888
is
shift_expr -> arith_expr >> shift_expr
1888
>=
shift_expr -> arith_expr >> shift_expr
1888
>
shift_expr -> arith_expr >> shift_expr
1888
:
shift_expr -> arith_expr >> shift_expr
1888
&
shift_expr -> arith_expr >> shift_expr
1888
<
shift_expr -> arith_expr >> shift_expr
1888
and
shift_expr -> arith_expr >> shift_expr
1888
!=
shift_expr -> arith_expr >> shift_expr
1889
or
shift_expr -> arith_expr << shift_expr
1889
]
shift_expr -> arith_expr << shift_expr
1889
in
shift_expr -> arith_expr << shift_expr
1889
>
shift_expr -> arith_expr << shift_expr
1889
&
shift_expr -> arith_expr << shift_expr
1889
:
shift_expr -> arith_expr << shift_expr
1889
is
shift_expr -> arith_expr << shift_expr
1889
<
shift_expr -> arith_expr << shift_expr
1889
<=
shift_expr -> arith_expr << shift_expr
1889
not
shift_expr -> arith_expr << shift_expr
1889
^
shift_expr -> arith_expr << shift_expr
1889
if
shift_expr -> arith_expr << shift_expr
1889
,
shift_expr -> arith_expr << shift_expr
1889
and
shift_expr -> arith_expr << shift_expr
1889
|
shift_expr -> arith_expr << shift_expr
1889
!=
shift_expr -> arith_expr << shift_expr
1889
==
shift_expr -> arith_expr << shift_expr
1889
>=
shift_expr -> arith_expr << shift_expr
1890
:
or_test -> and_test or or_test
1890
]
or_test -> and_test or or_test
1890
,
or_test -> and_test or or_test
1890
if
or_test -> and_test or or_test
1891
^
arith_expr -> term - arith_expr
1891
!=
arith_expr -> term - arith_expr
1891
<
arith_expr -> term - arith_expr
1891
in
arith_expr -> term - arith_expr
1891
==
arith_expr -> term - arith_expr
1891
|
arith_expr -> term - arith_expr
1891
is
arith_expr -> term - arith_expr
1891
&
arith_expr -> term - arith_expr
1891
>>
arith_expr -> term - arith_expr
1891
]
arith_expr -> term - arith_expr
1891
<<
arith_expr -> term - arith_expr
1891
and
arith_expr -> term - arith_expr
1891
,
arith_expr -> term - arith_expr
1891
>
arith_expr -> term - arith_expr
1891
if
arith_expr -> term - arith_expr
1891
not
arith_expr -> term - arith_expr
1891
>=
arith_expr -> term - arith_expr
1891
<=
arith_expr -> term - arith_expr
1891
or
arith_expr -> term - arith_expr
1891
:
arith_expr -> term - arith_expr
1892
>=
arith_expr -> term + arith_expr
1892
>
arith_expr -> term + arith_expr
1892
^
arith_expr -> term + arith_expr
1892
or
arith_expr -> term + arith_expr
1892
==
arith_expr -> term + arith_expr
1892
<=
arith_expr -> term + arith_expr
1892
if
arith_expr -> term + arith_expr
1892
]
arith_expr -> term + arith_expr
1892
>>
arith_expr -> term + arith_expr
1892
<
arith_expr -> term + arith_expr
1892
not
arith_expr -> term + arith_expr
1892
&
arith_expr -> term + arith_expr
1892
in
arith_expr -> term + arith_expr
1892
and
arith_expr -> term + arith_expr
1892
,
arith_expr -> term + arith_expr
1892
|
arith_expr -> term + arith_expr
1892
!=
arith_expr -> term + arith_expr
1892
:
arith_expr -> term + arith_expr
1892
<<
arith_expr -> term + arith_expr
1892
is
arith_expr -> term + arith_expr
1893
>=
expr -> xor_expr | expr
1893
,
expr -> xor_expr | expr
1893
or
expr -> xor_expr | expr
1893
in
expr -> xor_expr | expr
1893
]
expr -> xor_expr | expr
1893
and
expr -> xor_expr | expr
1893
==
expr -> xor_expr | expr
1893
:
expr -> xor_expr | expr
1893
>
expr -> xor_expr | expr
1893
<=
expr -> xor_expr | expr
1893
is
expr -> xor_expr | expr
1893
<
expr -> xor_expr | expr
1893
if
expr -> xor_expr | expr
1893
not
expr -> xor_expr | expr
1893
!=
expr -> xor_expr | expr
1894
]
subscriptlist -> subscript , subscriptlist
1895
or
comparison -> expr comp_op comparison
1895
:
comparison -> expr comp_op comparison
1895
if
comparison -> expr comp_op comparison
1895
and
comparison -> expr comp_op comparison
1895
]
comparison -> expr comp_op comparison
1895
,
comparison -> expr comp_op comparison
1896
or
and_test -> not_test and and_test
1896
]
and_test -> not_test and and_test
1896
if
and_test -> not_test and and_test
1896
,
and_test -> not_test and and_test
1896
:
and_test -> not_test and and_test
1897
[
802
1897
factor
803
1897
True
804
1897
atom_expr
810
1897
~
806
1897
not
807
1897
and_expr
808
1897
-
809
1897
shift_expr
811
1897
atom
812
1897
{
813
1897
comparison
814
1897
or_test
815
1897
(
816
1897
arith_expr
817
1897
power
818
1897
STRING
819
1897
NAME
820
1897
and_test
821
1897
term
822
1897
+
823
1897
xor_expr
824
1897
NUMBER
826
1897
False
827
1897
expr
829
1897
not_test
830
1897
None
831
1897
lambdef
832
1897
lambda
833
1897
test
2229
1898
,
lambdef -> lambda : test
1898
]
lambdef -> lambda : test
1898
:
lambdef -> lambda : test
1899
]
sliceop -> 
1899
sliceop
2230
1899
:
2231
1899
,
sliceop -> 
1900
:
maybe_test -> test
1900
,
maybe_test -> test
1900
]
maybe_test -> test
1901
,
trailer -> ( arglist )
1901
.
trailer -> ( arglist )
1901
|
trailer -> ( arglist )
1901
^
trailer -> ( arglist )
1901
==
trailer -> ( arglist )
1901
**
trailer -> ( arglist )
1901
>>
trailer -> ( arglist )
1901
not
trailer -> ( arglist )
1901
<<
trailer -> ( arglist )
1901
>=
trailer -> ( arglist )
1901
!=
trailer -> ( arglist )
1901
in
trailer -> ( arglist )
1901
[
trailer -> ( arglist )
1901
(
trailer -> ( arglist )
1901
NEWLINE
trailer -> ( arglist )
1901
>
trailer -> ( arglist )
1901
and
trailer -> ( arglist )
1901
+
trailer -> ( arglist )
1901
%
trailer -> ( arglist )
1901
or
trailer -> ( arglist )
1901
*
trailer -> ( arglist )
1901
is
trailer -> ( arglist )
1901
&
trailer -> ( arglist )
1901
//
trailer -> ( arglist )
1901
<
trailer -> ( arglist )
1901
if
trailer -> ( arglist )
1901
<=
trailer -> ( arglist )
1901
-
trailer -> ( arglist )
1901
/
trailer -> ( arglist )
1901
@
trailer -> ( arglist )
1902
<=
trailer -> [ subscriptlist ]
1902
NEWLINE
trailer -> [ subscriptlist ]
1902
<<
trailer -> [ subscriptlist ]
1902
*
trailer -> [ subscriptlist ]
1902
+
trailer -> [ subscriptlist ]
1902
in
trailer -> [ subscriptlist ]
1902
>>
trailer -> [ subscriptlist ]
1902
//
trailer -> [ subscriptlist ]
1902
.
trailer -> [ subscriptlist ]
1902
,
trailer -> [ subscriptlist ]
1902
and
trailer -> [ subscriptlist ]
1902
**
trailer -> [ subscriptlist ]
1902
@
trailer -> [ subscriptlist ]
1902
<
trailer -> [ subscriptlist ]
1902
not
trailer -> [ subscriptlist ]
1902
-
trailer -> [ subscriptlist ]
1902
!=
trailer -> [ subscriptlist ]
1902
%
trailer -> [ subscriptlist ]
1902
[
trailer -> [ subscriptlist ]
1902
/
trailer -> [ subscriptlist ]
1902
or
trailer -> [ subscriptlist ]
1902
&
trailer -> [ subscriptlist ]
1902
>=
trailer -> [ subscriptlist ]
1902
==
trailer -> [ subscriptlist ]
1902
(
trailer -> [ subscriptlist ]
1902
|
trailer -> [ subscriptlist ]
1902
is
trailer -> [ subscriptlist ]
1902
if
trailer -> [ subscriptlist ]
1902
>
trailer -> [ subscriptlist ]
1902
^
trailer -> [ subscriptlist ]
1903
,
lambdef -> lambda varargslist : test
1903
NEWLINE
lambdef -> lambda varargslist : test
1904
[
334
1904
factor
335
1904
True
336
1904
atom_expr
337
1904
~
338
1904
and_expr
339
1904
-
340
1904
None
341
1904
shift_expr
342
1904
atom
343
1904
{
344
1904
comparison
345
1904
arith_expr
346
1904
power
347
1904
STRING
348
1904
NAME
349
1904
(
350
1904
NUMBER
351
1904
and_test
352
1904
term
353
1904
+
354
1904
xor_expr
355
1904
not
356
1904
False
357
1904
lambda
358
1904
test
2232
1904
not_test
359
1904
lambdef
361
1904
expr
362
1904
or_test
363
1905
.
trailer -> ( arglist )
1905
|
trailer -> ( arglist )
1905
^
trailer -> ( arglist )
1905
==
trailer -> ( arglist )
1905
**
trailer -> ( arglist )
1905
>>
trailer -> ( arglist )
1905
not
trailer -> ( arglist )
1905
<<
trailer -> ( arglist )
1905
>=
trailer -> ( arglist )
1905
!=
trailer -> ( arglist )
1905
in
trailer -> ( arglist )
1905
[
trailer -> ( arglist )
1905
(
trailer -> ( arglist )
1905
NEWLINE
trailer -> ( arglist )
1905
>
trailer -> ( arglist )
1905
and
trailer -> ( arglist )
1905
+
trailer -> ( arglist )
1905
%
trailer -> ( arglist )
1905
from
trailer -> ( arglist )
1905
or
trailer -> ( arglist )
1905
*
trailer -> ( arglist )
1905
is
trailer -> ( arglist )
1905
&
trailer -> ( arglist )
1905
//
trailer -> ( arglist )
1905
<
trailer -> ( arglist )
1905
if
trailer -> ( arglist )
1905
<=
trailer -> ( arglist )
1905
-
trailer -> ( arglist )
1905
/
trailer -> ( arglist )
1905
@
trailer -> ( arglist )
1906
<=
trailer -> [ subscriptlist ]
1906
NEWLINE
trailer -> [ subscriptlist ]
1906
<<
trailer -> [ subscriptlist ]
1906
*
trailer -> [ subscriptlist ]
1906
+
trailer -> [ subscriptlist ]
1906
in
trailer -> [ subscriptlist ]
1906
>>
trailer -> [ subscriptlist ]
1906
//
trailer -> [ subscriptlist ]
1906
.
trailer -> [ subscriptlist ]
1906
and
trailer -> [ subscriptlist ]
1906
**
trailer -> [ subscriptlist ]
1906
@
trailer -> [ subscriptlist ]
1906
<
trailer -> [ subscriptlist ]
1906
not
trailer -> [ subscriptlist ]
1906
-
trailer -> [ subscriptlist ]
1906
!=
trailer -> [ subscriptlist ]
1906
%
trailer -> [ subscriptlist ]
1906
from
trailer -> [ subscriptlist ]
1906
[
trailer -> [ subscriptlist ]
1906
/
trailer -> [ subscriptlist ]
1906
or
trailer -> [ subscriptlist ]
1906
&
trailer -> [ subscriptlist ]
1906
>=
trailer -> [ subscriptlist ]
1906
==
trailer -> [ subscriptlist ]
1906
(
trailer -> [ subscriptlist ]
1906
|
trailer -> [ subscriptlist ]
1906
is
trailer -> [ subscriptlist ]
1906
if
trailer -> [ subscriptlist ]
1906
>
trailer -> [ subscriptlist ]
1906
^
trailer -> [ subscriptlist ]
1907
from
lambdef -> lambda varargslist : test
1907
NEWLINE
lambdef -> lambda varargslist : test
1908
[
366
1908
atom_expr
367
1908
factor
368
1908
True
369
1908
~
370
1908
and_expr
371
1908
-
372
1908
None
373
1908
atom
374
1908
{
375
1908
expr
376
1908
arith_expr
377
1908
power
378
1908
STRING
379
1908
NAME
380
1908
(
381
1908
NUMBER
382
1908
and_test
383
1908
comparison
384
1908
term
385
1908
+
386
1908
xor_expr
387
1908
shift_expr
388
1908
lambda
389
1908
not
391
1908
False
392
1908
test
2233
1908
not_test
393
1908
lambdef
394
1908
or_test
395
1909
.
trailer -> ( arglist )
1909
|
trailer -> ( arglist )
1909
^
trailer -> ( arglist )
1909
==
trailer -> ( arglist )
1909
**
trailer -> ( arglist )
1909
>>
trailer -> ( arglist )
1909
not
trailer -> ( arglist )
1909
<<
trailer -> ( arglist )
1909
>=
trailer -> ( arglist )
1909
!=
trailer -> ( arglist )
1909
in
trailer -> ( arglist )
1909
[
trailer -> ( arglist )
1909
(
trailer -> ( arglist )
1909
NEWLINE
trailer -> ( arglist )
1909
>
trailer -> ( arglist )
1909
and
trailer -> ( arglist )
1909
+
trailer -> ( arglist )
1909
%
trailer -> ( arglist )
1909
or
trailer -> ( arglist )
1909
*
trailer -> ( arglist )
1909
is
trailer -> ( arglist )
1909
&
trailer -> ( arglist )
1909
//
trailer -> ( arglist )
1909
<
trailer -> ( arglist )
1909
if
trailer -> ( arglist )
1909
<=
trailer -> ( arglist )
1909
-
trailer -> ( arglist )
1909
/
trailer -> ( arglist )
1909
@
trailer -> ( arglist )
1910
<=
trailer -> [ subscriptlist ]
1910
NEWLINE
trailer -> [ subscriptlist ]
1910
<<
trailer -> [ subscriptlist ]
1910
*
trailer -> [ subscriptlist ]
1910
+
trailer -> [ subscriptlist ]
1910
in
trailer -> [ subscriptlist ]
1910
>>
trailer -> [ subscriptlist ]
1910
//
trailer -> [ subscriptlist ]
1910
.
trailer -> [ subscriptlist ]
1910
and
trailer -> [ subscriptlist ]
1910
**
trailer -> [ subscriptlist ]
1910
@
trailer -> [ subscriptlist ]
1910
<
trailer -> [ subscriptlist ]
1910
not
trailer -> [ subscriptlist ]
1910
-
trailer -> [ subscriptlist ]
1910
!=
trailer -> [ subscriptlist ]
1910
%
trailer -> [ subscriptlist ]
1910
[
trailer -> [ subscriptlist ]
1910
/
trailer -> [ subscriptlist ]
1910
or
trailer -> [ subscriptlist ]
1910
&
trailer -> [ subscriptlist ]
1910
>=
trailer -> [ subscriptlist ]
1910
==
trailer -> [ subscriptlist ]
1910
(
trailer -> [ subscriptlist ]
1910
|
trailer -> [ subscriptlist ]
1910
is
trailer -> [ subscriptlist ]
1910
if
trailer -> [ subscriptlist ]
1910
>
trailer -> [ subscriptlist ]
1910
^
trailer -> [ subscriptlist ]
1911
NEWLINE
lambdef -> lambda varargslist : test
1912
[
397
1912
factor
398
1912
True
399
1912
atom_expr
400
1912
~
401
1912
and_expr
402
1912
-
403
1912
None
404
1912
atom
405
1912
{
406
1912
arith_expr
407
1912
power
408
1912
STRING
409
1912
NAME
410
1912
(
411
1912
NUMBER
412
1912
and_test
413
1912
term
414
1912
+
415
1912
xor_expr
416
1912
shift_expr
417
1912
not
418
1912
False
419
1912
lambda
420
1912
test
2234
1912
comparison
421
1912
not_test
422
1912
lambdef
423
1912
expr
424
1912
or_test
425
1913
arith_expr
1
1913
small_stmt
20
1913
factor
17
1913
True
38
1913
atom_expr
31
1913
term
22
1913
-
26
1913
None
55
1913
atom
57
1913
test
5
1913
comparison
49
1913
and_expr
8
1913
power
9
1913
STRING
10
1913
NAME
52
1913
shift_expr
48
1913
lambdef
15
1913
NUMBER
58
1913
simple_stmt
1094
1913
(
16
1913
expr
47
1913
[
18
1913
NEWLINE
1095
1913
not_test
32
1913
{
21
1913
and_test
46
1913
+
27
1913
lambda
29
1913
xor_expr
41
1913
suite
2235
1913
yield
34
1913
not
62
1913
test_list
36
1913
~
37
1913
or_test
53
1913
False
39
1913
sim_stmt
45
1913
nonlocal
72
1913
nonlocal_stmt
73
1913
return
59
1913
break_stmt
60
1913
return_stmt
61
1913
raise_stmt
74
1913
break
63
1913
yield_stmt
75
1913
raise
64
1913
continue
77
1913
expr_stmt
65
1913
endsim
78
1913
del
80
1913
pass_stmt
81
1913
flow_stmt
82
1913
stat_stmt
66
1913
assert_stmt
68
1913
resetstats
84
1913
del_stmt
85
1913
continue_stmt
86
1913
begsim
69
1913
global_stmt
87
1913
pass
88
1913
global
70
1913
assert
71
1914
arith_expr
1
1914
small_stmt
2236
1914
factor
17
1914
True
38
1914
atom_expr
31
1914
term
22
1914
-
26
1914
None
55
1914
atom
57
1914
test
5
1914
comparison
49
1914
and_expr
8
1914
power
9
1914
STRING
10
1914
NAME
52
1914
shift_expr
48
1914
NEWLINE
2237
1914
lambdef
15
1914
NUMBER
58
1914
simple_stmt
2238
1914
(
16
1914
expr
47
1914
[
18
1914
not_test
32
1914
{
21
1914
suite
2239
1914
and_test
46
1914
+
27
1914
lambda
29
1914
xor_expr
41
1914
yield
34
1914
not
62
1914
test_list
36
1914
~
37
1914
or_test
53
1914
False
39
1914
sim_stmt
45
1914
nonlocal
72
1914
nonlocal_stmt
73
1914
return
59
1914
break_stmt
60
1914
return_stmt
61
1914
raise_stmt
74
1914
break
63
1914
yield_stmt
75
1914
raise
64
1914
continue
77
1914
expr_stmt
65
1914
endsim
78
1914
del
80
1914
pass_stmt
81
1914
flow_stmt
82
1914
stat_stmt
66
1914
assert_stmt
68
1914
resetstats
84
1914
del_stmt
85
1914
continue_stmt
86
1914
begsim
69
1914
global_stmt
87
1914
pass
88
1914
global
70
1914
assert
71
1915
!=
atom -> [ ]
1915
>>
atom -> [ ]
1915
as
atom -> [ ]
1915
|
atom -> [ ]
1915
<<
atom -> [ ]
1915
>
atom -> [ ]
1915
.
atom -> [ ]
1915
%
atom -> [ ]
1915
^
atom -> [ ]
1915
-
atom -> [ ]
1915
in
atom -> [ ]
1915
:
atom -> [ ]
1915
or
atom -> [ ]
1915
/
atom -> [ ]
1915
**
atom -> [ ]
1915
//
atom -> [ ]
1915
not
atom -> [ ]
1915
(
atom -> [ ]
1915
+
atom -> [ ]
1915
and
atom -> [ ]
1915
==
atom -> [ ]
1915
[
atom -> [ ]
1915
if
atom -> [ ]
1915
<
atom -> [ ]
1915
<=
atom -> [ ]
1915
>=
atom -> [ ]
1915
is
atom -> [ ]
1915
*
atom -> [ ]
1915
@
atom -> [ ]
1915
&
atom -> [ ]
1916
]
2240
1917
NAME
2241
1918
arith_expr
1
1918
small_stmt
1938
1918
factor
17
1918
True
38
1918
atom_expr
31
1918
term
22
1918
-
26
1918
None
55
1918
atom
57
1918
test
5
1918
comparison
49
1918
and_expr
8
1918
power
9
1918
STRING
10
1918
NAME
52
1918
shift_expr
48
1918
NEWLINE
1939
1918
lambdef
15
1918
NUMBER
58
1918
simple_stmt
1940
1918
(
16
1918
expr
47
1918
[
18
1918
not_test
32
1918
{
21
1918
suite
2242
1918
and_test
46
1918
+
27
1918
lambda
29
1918
xor_expr
41
1918
yield
34
1918
not
62
1918
test_list
36
1918
~
37
1918
or_test
53
1918
False
39
1918
sim_stmt
45
1918
nonlocal
72
1918
nonlocal_stmt
73
1918
return
59
1918
break_stmt
60
1918
return_stmt
61
1918
raise_stmt
74
1918
break
63
1918
yield_stmt
75
1918
raise
64
1918
continue
77
1918
expr_stmt
65
1918
endsim
78
1918
del
80
1918
pass_stmt
81
1918
flow_stmt
82
1918
stat_stmt
66
1918
assert_stmt
68
1918
resetstats
84
1918
del_stmt
85
1918
continue_stmt
86
1918
begsim
69
1918
global_stmt
87
1918
pass
88
1918
global
70
1918
assert
71
1919
term
2243
1919
[
1502
1919
factor
1504
1919
True
1505
1919
atom_expr
1506
1919
~
1507
1919
-
1509
1919
atom
1510
1919
{
1511
1919
power
1514
1919
STRING
1515
1919
NAME
1516
1919
(
1519
1919
+
1522
1919
NUMBER
1524
1919
False
1526
1919
None
1530
1920
[
1502
1920
factor
1504
1920
True
1505
1920
term
2244
1920
~
1507
1920
-
1509
1920
atom_expr
1506
1920
atom
1510
1920
{
1511
1920
power
1514
1920
STRING
1515
1920
NAME
1516
1920
(
1519
1920
+
1522
1920
NUMBER
1524
1920
False
1526
1920
None
1530
1921
[
1502
1921
factor
1504
1921
True
1505
1921
atom_expr
1506
1921
~
1507
1921
-
1509
1921
atom
1510
1921
{
1511
1921
power
1514
1921
STRING
1515
1921
NAME
1516
1921
(
1519
1921
term
2245
1921
+
1522
1921
NUMBER
1524
1921
False
1526
1921
None
1530
1922
[
1502
1922
factor
1504
1922
True
1505
1922
atom_expr
1506
1922
~
1507
1922
-
1509
1922
atom
1510
1922
{
1511
1922
power
1514
1922
STRING
1515
1922
NAME
1516
1922
(
1519
1922
term
2246
1922
+
1522
1922
NUMBER
1524
1922
False
1526
1922
None
1530
1923
[
1502
1923
factor
1504
1923
True
1505
1923
atom_expr
1506
1923
~
1507
1923
-
1509
1923
atom
1510
1923
{
1511
1923
power
1514
1923
STRING
1515
1923
NAME
1516
1923
term
2247
1923
(
1519
1923
+
1522
1923
NUMBER
1524
1923
False
1526
1923
None
1530
1924
[
1502
1924
True
1505
1924
atom_expr
1506
1924
-
1509
1924
~
1507
1924
atom
1510
1924
{
1511
1924
power
1514
1924
STRING
1515
1924
NAME
1516
1924
(
1519
1924
+
1522
1924
NUMBER
1524
1924
False
1526
1924
factor
2248
1924
None
1530
1925
@
factor -> ~ factor
1925
as
factor -> ~ factor
1925
>>
factor -> ~ factor
1925
<=
factor -> ~ factor
1925
and
factor -> ~ factor
1925
+
factor -> ~ factor
1925
:
factor -> ~ factor
1925
*
factor -> ~ factor
1925
!=
factor -> ~ factor
1925
%
factor -> ~ factor
1925
<<
factor -> ~ factor
1925
>=
factor -> ~ factor
1925
&
factor -> ~ factor
1925
is
factor -> ~ factor
1925
==
factor -> ~ factor
1925
//
factor -> ~ factor
1925
<
factor -> ~ factor
1925
/
factor -> ~ factor
1925
not
factor -> ~ factor
1925
-
factor -> ~ factor
1925
or
factor -> ~ factor
1925
|
factor -> ~ factor
1925
>
factor -> ~ factor
1925
^
factor -> ~ factor
1925
if
factor -> ~ factor
1925
in
factor -> ~ factor
1926
[
1502
1926
factor
1504
1926
True
1505
1926
atom_expr
1506
1926
~
1507
1926
and_expr
1508
1926
-
1509
1926
atom
1510
1926
{
1511
1926
xor_expr
2249
1926
arith_expr
1513
1926
power
1514
1926
STRING
1515
1926
NAME
1516
1926
shift_expr
1517
1926
(
1519
1926
term
1521
1926
+
1522
1926
NUMBER
1524
1926
False
1526
1926
None
1530
1927
@
factor -> - factor
1927
<=
factor -> - factor
1927
in
factor -> - factor
1927
as
factor -> - factor
1927
>>
factor -> - factor
1927
|
factor -> - factor
1927
is
factor -> - factor
1927
+
factor -> - factor
1927
%
factor -> - factor
1927
<
factor -> - factor
1927
*
factor -> - factor
1927
<<
factor -> - factor
1927
if
factor -> - factor
1927
-
factor -> - factor
1927
>=
factor -> - factor
1927
not
factor -> - factor
1927
and
factor -> - factor
1927
/
factor -> - factor
1927
:
factor -> - factor
1927
or
factor -> - factor
1927
^
factor -> - factor
1927
>
factor -> - factor
1927
!=
factor -> - factor
1927
&
factor -> - factor
1927
==
factor -> - factor
1927
//
factor -> - factor
1928
[
766
1928
factor
767
1928
True
768
1928
atom_expr
769
1928
~
770
1928
and_expr
771
1928
-
772
1928
{
773
1928
shift_expr
774
1928
atom
775
1928
comparison
776
1928
and_test
777
1928
arith_expr
778
1928
power
779
1928
STRING
780
1928
NAME
781
1928
(
782
1928
term
784
1928
+
785
1928
xor_expr
786
1928
)
2250
1928
or_test
788
1928
arglist
2251
1928
NUMBER
789
1928
not
790
1928
False
791
1928
expr
792
1928
*
793
1928
not_test
794
1928
None
795
1928
lambdef
796
1928
lambda
797
1928
test
798
1928
argument
799
1928
**
800
1929
trailer_expr
2252
1929
>>
trailer_expr -> 
1929
(
1928
1929
trailer
1929
1929
.
1931
1929
+
trailer_expr -> 
1929
is
trailer_expr -> 
1929
>
trailer_expr -> 
1929
not
trailer_expr -> 
1929
|
trailer_expr -> 
1929
[
1932
1929
&
trailer_expr -> 
1929
/
trailer_expr -> 
1929
@
trailer_expr -> 
1929
!=
trailer_expr -> 
1929
**
trailer_expr -> 
1929
>=
trailer_expr -> 
1929
^
trailer_expr -> 
1929
in
trailer_expr -> 
1929
<<
trailer_expr -> 
1929
and
trailer_expr -> 
1929
or
trailer_expr -> 
1929
as
trailer_expr -> 
1929
if
trailer_expr -> 
1929
:
trailer_expr -> 
1929
//
trailer_expr -> 
1929
%
trailer_expr -> 
1929
<=
trailer_expr -> 
1929
<
trailer_expr -> 
1929
==
trailer_expr -> 
1929
-
trailer_expr -> 
1929
*
trailer_expr -> 
1930
as
atom_expr -> atom trailer_expr
1930
^
atom_expr -> atom trailer_expr
1930
or
atom_expr -> atom trailer_expr
1930
&
atom_expr -> atom trailer_expr
1930
@
atom_expr -> atom trailer_expr
1930
|
atom_expr -> atom trailer_expr
1930
-
atom_expr -> atom trailer_expr
1930
*
atom_expr -> atom trailer_expr
1930
%
atom_expr -> atom trailer_expr
1930
==
atom_expr -> atom trailer_expr
1930
**
atom_expr -> atom trailer_expr
1930
and
atom_expr -> atom trailer_expr
1930
is
atom_expr -> atom trailer_expr
1930
in
atom_expr -> atom trailer_expr
1930
<<
atom_expr -> atom trailer_expr
1930
!=
atom_expr -> atom trailer_expr
1930
<=
atom_expr -> atom trailer_expr
1930
/
atom_expr -> atom trailer_expr
1930
//
atom_expr -> atom trailer_expr
1930
<
atom_expr -> atom trailer_expr
1930
>=
atom_expr -> atom trailer_expr
1930
>>
atom_expr -> atom trailer_expr
1930
if
atom_expr -> atom trailer_expr
1930
not
atom_expr -> atom trailer_expr
1930
:
atom_expr -> atom trailer_expr
1930
+
atom_expr -> atom trailer_expr
1930
>
atom_expr -> atom trailer_expr
1931
NAME
2253
1932
[
802
1932
factor
803
1932
True
804
1932
atom_expr
810
1932
~
806
1932
not
807
1932
and_expr
808
1932
-
809
1932
shift_expr
811
1932
atom
812
1932
{
813
1932
comparison
814
1932
or_test
815
1932
(
816
1932
arith_expr
817
1932
power
818
1932
STRING
819
1932
NAME
820
1932
and_test
821
1932
term
822
1932
+
823
1932
xor_expr
824
1932
subscriptlist
2254
1932
test
825
1932
NUMBER
826
1932
False
827
1932
subscript
828
1932
expr
829
1932
not_test
830
1932
None
831
1932
lambdef
832
1932
lambda
833
1932
maybe_test
834
1932
:
maybe_test -> 
1933
in
atom -> { }
1933
<=
atom -> { }
1933
*
atom -> { }
1933
>
atom -> { }
1933
+
atom -> { }
1933
@
atom -> { }
1933
>=
atom -> { }
1933
as
atom -> { }
1933
/
atom -> { }
1933
:
atom -> { }
1933
|
atom -> { }
1933
is
atom -> { }
1933
and
atom -> { }
1933
if
atom -> { }
1933
(
atom -> { }
1933
>>
atom -> { }
1933
not
atom -> { }
1933
-
atom -> { }
1933
<<
atom -> { }
1933
**
atom -> { }
1933
or
atom -> { }
1933
<
atom -> { }
1933
!=
atom -> { }
1933
==
atom -> { }
1933
%
atom -> { }
1933
//
atom -> { }
1933
&
atom -> { }
1933
[
atom -> { }
1933
.
atom -> { }
1933
^
atom -> { }
1934
[
738
1934
factor
740
1934
True
741
1934
~
742
1934
and_expr
743
1934
-
744
1934
atom
745
1934
{
746
1934
arith_expr
747
1934
power
748
1934
atom_expr
749
1934
STRING
750
1934
NAME
751
1934
(
752
1934
term
753
1934
+
754
1934
xor_expr
755
1934
shift_expr
756
1934
NUMBER
757
1934
not
758
1934
False
759
1934
or_test
2255
1934
comparison
760
1934
not_test
761
1934
None
762
1934
expr
763
1934
and_test
764
1935
[
1502
1935
factor
1504
1935
True
1505
1935
atom_expr
1506
1935
~
1507
1935
-
1509
1935
atom
1510
1935
{
1511
1935
arith_expr
1513
1935
power
1514
1935
STRING
1515
1935
NAME
1516
1935
shift_expr
2256
1935
(
1519
1935
term
1521
1935
+
1522
1935
NUMBER
1524
1935
False
1526
1935
None
1530
1936
[
1502
1936
factor
1504
1936
True
1505
1936
atom_expr
1506
1936
~
1507
1936
-
1509
1936
atom
1510
1936
{
1511
1936
arith_expr
1513
1936
power
1514
1936
STRING
1515
1936
NAME
1516
1936
(
1519
1936
term
1521
1936
+
1522
1936
NUMBER
1524
1936
False
1526
1936
shift_expr
2257
1936
None
1530
1937
[
1502
1937
factor
1504
1937
True
1505
1937
atom_expr
1506
1937
~
1507
1937
-
1509
1937
atom
1510
1937
{
1511
1937
arith_expr
1513
1937
power
1514
1937
STRING
1515
1937
NAME
1516
1937
shift_expr
1517
1937
(
1519
1937
term
1521
1937
+
1522
1937
and_expr
2258
1937
NUMBER
1524
1937
False
1526
1937
None
1530
1938
NEWLINE
2259
1939
INDENT
2260
1940
modopt
suite -> simple_stmt
1940
~
suite -> simple_stmt
1940
False
suite -> simple_stmt
1940
@
suite -> simple_stmt
1940
except
suite -> simple_stmt
1940
begsim
suite -> simple_stmt
1940
NUMBER
suite -> simple_stmt
1940
conf
suite -> simple_stmt
1940
class
suite -> simple_stmt
1940
finally
suite -> simple_stmt
1940
if
suite -> simple_stmt
1940
yield
suite -> simple_stmt
1940
try
suite -> simple_stmt
1940
pass
suite -> simple_stmt
1940
NEWLINE
suite -> simple_stmt
1940
else
suite -> simple_stmt
1940
[
suite -> simple_stmt
1940
break
suite -> simple_stmt
1940
True
suite -> simple_stmt
1940
None
suite -> simple_stmt
1940
server
suite -> simple_stmt
1940
assert
suite -> simple_stmt
1940
$
suite -> simple_stmt
1940
servmod
suite -> simple_stmt
1940
raise
suite -> simple_stmt
1940
nonlocal
suite -> simple_stmt
1940
lambda
suite -> simple_stmt
1940
return
suite -> simple_stmt
1940
+
suite -> simple_stmt
1940
-
suite -> simple_stmt
1940
NAME
suite -> simple_stmt
1940
while
suite -> simple_stmt
1940
def
suite -> simple_stmt
1940
with
suite -> simple_stmt
1940
del
suite -> simple_stmt
1940
STRING
suite -> simple_stmt
1940
for
suite -> simple_stmt
1940
resetstats
suite -> simple_stmt
1940
global
suite -> simple_stmt
1940
continue
suite -> simple_stmt
1940
endsim
suite -> simple_stmt
1940
not
suite -> simple_stmt
1940
{
suite -> simple_stmt
1940
(
suite -> simple_stmt
1941
except
938
1941
None
maybe_except_clause -> 
1941
if
maybe_except_clause -> 
1941
while
maybe_except_clause -> 
1941
maybe_except_clause
2261
1941
continue
maybe_except_clause -> 
1941
return
maybe_except_clause -> 
1941
except_clause
2262
1941
server
maybe_except_clause -> 
1941
nonlocal
maybe_except_clause -> 
1941
def
maybe_except_clause -> 
1941
servmod
maybe_except_clause -> 
1941
endsim
maybe_except_clause -> 
1941
else
maybe_except_clause -> 
1941
global
maybe_except_clause -> 
1941
conf
maybe_except_clause -> 
1941
pass
maybe_except_clause -> 
1941
True
maybe_except_clause -> 
1941
NUMBER
maybe_except_clause -> 
1941
NEWLINE
maybe_except_clause -> 
1941
try
maybe_except_clause -> 
1941
False
maybe_except_clause -> 
1941
~
maybe_except_clause -> 
1941
with
maybe_except_clause -> 
1941
not
maybe_except_clause -> 
1941
NAME
maybe_except_clause -> 
1941
@
maybe_except_clause -> 
1941
(
maybe_except_clause -> 
1941
yield
maybe_except_clause -> 
1941
[
maybe_except_clause -> 
1941
finally
maybe_except_clause -> 
1941
-
maybe_except_clause -> 
1941
raise
maybe_except_clause -> 
1941
{
maybe_except_clause -> 
1941
assert
maybe_except_clause -> 
1941
$
maybe_except_clause -> 
1941
class
maybe_except_clause -> 
1941
break
maybe_except_clause -> 
1941
+
maybe_except_clause -> 
1941
STRING
maybe_except_clause -> 
1941
del
maybe_except_clause -> 
1941
begsim
maybe_except_clause -> 
1941
lambda
maybe_except_clause -> 
1941
resetstats
maybe_except_clause -> 
1941
for
maybe_except_clause -> 
1941
modopt
maybe_except_clause -> 
1942
)
2263
1943
or
atom -> ( )
1943
>>
atom -> ( )
1943
(
atom -> ( )
1943
<=
atom -> ( )
1943
.
atom -> ( )
1943
is
atom -> ( )
1943
@
atom -> ( )
1943
%
atom -> ( )
1943
<<
atom -> ( )
1943
**
atom -> ( )
1943
^
atom -> ( )
1943
/
atom -> ( )
1943
if
atom -> ( )
1943
not
atom -> ( )
1943
*
atom -> ( )
1943
!=
atom -> ( )
1943
<
atom -> ( )
1943
&
atom -> ( )
1943
-
atom -> ( )
1943
>
atom -> ( )
1943
//
atom -> ( )
1943
:
atom -> ( )
1943
==
atom -> ( )
1943
in
atom -> ( )
1943
+
atom -> ( )
1943
[
atom -> ( )
1943
as
atom -> ( )
1943
>=
atom -> ( )
1943
and
atom -> ( )
1943
|
atom -> ( )
1944
[
1502
1944
factor
1504
1944
True
1505
1944
atom_expr
1506
1944
~
1507
1944
and_expr
1508
1944
-
1509
1944
atom
1510
1944
{
1511
1944
arith_expr
1513
1944
power
1514
1944
STRING
1515
1944
NAME
1516
1944
shift_expr
1517
1944
(
1519
1944
and_test
1520
1944
term
1521
1944
+
1522
1944
xor_expr
1523
1944
NUMBER
1524
1944
not
1525
1944
False
1526
1944
or_test
2264
1944
expr
1527
1944
not_test
1528
1944
comparison
1529
1944
None
1530
1945
[
1502
1945
factor
1504
1945
True
1505
1945
atom_expr
1506
1945
~
1507
1945
-
1509
1945
arith_expr
2265
1945
atom
1510
1945
{
1511
1945
power
1514
1945
STRING
1515
1945
NAME
1516
1945
(
1519
1945
term
1521
1945
+
1522
1945
NUMBER
1524
1945
False
1526
1945
None
1530
1946
[
1502
1946
factor
1504
1946
True
1505
1946
atom_expr
1506
1946
~
1507
1946
-
1509
1946
atom
1510
1946
{
1511
1946
arith_expr
2266
1946
power
1514
1946
STRING
1515
1946
NAME
1516
1946
(
1519
1946
term
1521
1946
+
1522
1946
NUMBER
1524
1946
False
1526
1946
None
1530
1947
-
factor -> + factor
1947
@
factor -> + factor
1947
:
factor -> + factor
1947
<<
factor -> + factor
1947
is
factor -> + factor
1947
and
factor -> + factor
1947
<=
factor -> + factor
1947
or
factor -> + factor
1947
<
factor -> + factor
1947
^
factor -> + factor
1947
not
factor -> + factor
1947
//
factor -> + factor
1947
*
factor -> + factor
1947
in
factor -> + factor
1947
&
factor -> + factor
1947
as
factor -> + factor
1947
+
factor -> + factor
1947
if
factor -> + factor
1947
>>
factor -> + factor
1947
|
factor -> + factor
1947
%
factor -> + factor
1947
>
factor -> + factor
1947
>=
factor -> + factor
1947
!=
factor -> + factor
1947
/
factor -> + factor
1947
==
factor -> + factor
1948
[
1502
1948
factor
1504
1948
True
1505
1948
atom_expr
1506
1948
~
1507
1948
and_expr
1508
1948
-
1509
1948
atom
1510
1948
{
1511
1948
expr
2267
1948
arith_expr
1513
1948
power
1514
1948
STRING
1515
1948
NAME
1516
1948
shift_expr
1517
1948
(
1519
1948
term
1521
1948
+
1522
1948
xor_expr
1523
1948
NUMBER
1524
1948
False
1526
1948
None
1530
1949
and
not_test -> not not_test
1949
or
not_test -> not not_test
1949
as
not_test -> not not_test
1949
if
not_test -> not not_test
1949
:
not_test -> not not_test
1950
[
1502
1950
factor
1504
1950
True
1505
1950
atom_expr
1506
1950
~
1507
1950
and_expr
1508
1950
-
1509
1950
atom
1510
1950
{
1511
1950
arith_expr
1513
1950
power
1514
1950
STRING
1515
1950
NAME
1516
1950
shift_expr
1517
1950
(
1519
1950
term
1521
1950
+
1522
1950
xor_expr
1523
1950
NUMBER
1524
1950
False
1526
1950
expr
1527
1950
None
1530
1950
comparison
2268
1951
[
1502
1951
factor
1504
1951
True
1505
1951
atom_expr
1506
1951
~
1507
1951
and_expr
1508
1951
-
1509
1951
atom
1510
1951
{
1511
1951
arith_expr
1513
1951
power
1514
1951
STRING
1515
1951
NAME
1516
1951
shift_expr
1517
1951
(
1519
1951
term
1521
1951
+
1522
1951
xor_expr
1523
1951
NUMBER
1524
1951
not
1525
1951
False
1526
1951
and_test
2269
1951
expr
1527
1951
not_test
1528
1951
comparison
1529
1951
None
1530
1952
[
1502
1952
factor
1504
1952
True
1505
1952
atom_expr
1506
1952
~
1507
1952
and_expr
1508
1952
-
1509
1952
atom
1510
1952
{
1511
1952
or_test
1512
1952
arith_expr
1513
1952
power
1514
1952
STRING
1515
1952
NAME
1516
1952
shift_expr
1517
1952
test
2270
1952
(
1519
1952
and_test
1520
1952
term
1521
1952
+
1522
1952
xor_expr
1523
1952
NUMBER
1524
1952
not
1525
1952
False
1526
1952
expr
1527
1952
not_test
1528
1952
comparison
1529
1952
None
1530
1952
lambdef
1531
1952
lambda
1532
1953
:
2271
1954
arith_expr
1
1954
suite
2272
1954
factor
17
1954
True
38
1954
atom_expr
31
1954
term
22
1954
-
26
1954
None
55
1954
atom
57
1954
test
5
1954
comparison
49
1954
and_expr
8
1954
power
9
1954
STRING
10
1954
NAME
52
1954
shift_expr
48
1954
lambdef
15
1954
NUMBER
58
1954
(
16
1954
expr
47
1954
[
18
1954
not_test
32
1954
{
21
1954
and_test
46
1954
+
27
1954
lambda
29
1954
xor_expr
41
1954
yield
34
1954
not
62
1954
test_list
36
1954
~
37
1954
or_test
53
1954
False
39
1954
sim_stmt
45
1954
nonlocal
72
1954
nonlocal_stmt
73
1954
NEWLINE
437
1954
return
59
1954
break_stmt
60
1954
return_stmt
61
1954
raise_stmt
74
1954
break
63
1954
yield_stmt
75
1954
raise
64
1954
continue
77
1954
expr_stmt
65
1954
endsim
78
1954
del
80
1954
pass_stmt
81
1954
flow_stmt
82
1954
stat_stmt
66
1954
simple_stmt
438
1954
assert_stmt
68
1954
resetstats
84
1954
del_stmt
85
1954
continue_stmt
86
1954
small_stmt
439
1954
begsim
69
1954
global_stmt
87
1954
pass
88
1954
global
70
1954
assert
71
1955
:
2273
1956
:
2274
1957
:
2275
1958
(
2276
1958
:
2277
1959
del
simple_stmt -> small_stmt NEWLINE
1959
break
simple_stmt -> small_stmt NEWLINE
1959
raise
simple_stmt -> small_stmt NEWLINE
1959
servmod
simple_stmt -> small_stmt NEWLINE
1959
class
simple_stmt -> small_stmt NEWLINE
1959
not
simple_stmt -> small_stmt NEWLINE
1959
-
simple_stmt -> small_stmt NEWLINE
1959
False
simple_stmt -> small_stmt NEWLINE
1959
(
simple_stmt -> small_stmt NEWLINE
1959
endsim
simple_stmt -> small_stmt NEWLINE
1959
+
simple_stmt -> small_stmt NEWLINE
1959
None
simple_stmt -> small_stmt NEWLINE
1959
resetstats
simple_stmt -> small_stmt NEWLINE
1959
conf
simple_stmt -> small_stmt NEWLINE
1959
server
simple_stmt -> small_stmt NEWLINE
1959
STRING
simple_stmt -> small_stmt NEWLINE
1959
if
simple_stmt -> small_stmt NEWLINE
1959
NUMBER
simple_stmt -> small_stmt NEWLINE
1959
global
simple_stmt -> small_stmt NEWLINE
1959
@
simple_stmt -> small_stmt NEWLINE
1959
True
simple_stmt -> small_stmt NEWLINE
1959
lambda
simple_stmt -> small_stmt NEWLINE
1959
pass
simple_stmt -> small_stmt NEWLINE
1959
return
simple_stmt -> small_stmt NEWLINE
1959
def
simple_stmt -> small_stmt NEWLINE
1959
with
simple_stmt -> small_stmt NEWLINE
1959
nonlocal
simple_stmt -> small_stmt NEWLINE
1959
assert
simple_stmt -> small_stmt NEWLINE
1959
NAME
simple_stmt -> small_stmt NEWLINE
1959
try
simple_stmt -> small_stmt NEWLINE
1959
begsim
simple_stmt -> small_stmt NEWLINE
1959
while
simple_stmt -> small_stmt NEWLINE
1959
for
simple_stmt -> small_stmt NEWLINE
1959
[
simple_stmt -> small_stmt NEWLINE
1959
modopt
simple_stmt -> small_stmt NEWLINE
1959
yield
simple_stmt -> small_stmt NEWLINE
1959
DEDENT
simple_stmt -> small_stmt NEWLINE
1959
continue
simple_stmt -> small_stmt NEWLINE
1959
{
simple_stmt -> small_stmt NEWLINE
1959
~
simple_stmt -> small_stmt NEWLINE
1960
(
2278
1961
:
2279
1962
in
2280
1963
:
2281
1964
NAME
decorated -> decorators funcdef
1964
continue
decorated -> decorators funcdef
1964
with
decorated -> decorators funcdef
1964
break
decorated -> decorators funcdef
1964
return
decorated -> decorators funcdef
1964
raise
decorated -> decorators funcdef
1964
{
decorated -> decorators funcdef
1964
None
decorated -> decorators funcdef
1964
modopt
decorated -> decorators funcdef
1964
endsim
decorated -> decorators funcdef
1964
begsim
decorated -> decorators funcdef
1964
del
decorated -> decorators funcdef
1964
lambda
decorated -> decorators funcdef
1964
pass
decorated -> decorators funcdef
1964
servmod
decorated -> decorators funcdef
1964
class
decorated -> decorators funcdef
1964
[
decorated -> decorators funcdef
1964
~
decorated -> decorators funcdef
1964
yield
decorated -> decorators funcdef
1964
def
decorated -> decorators funcdef
1964
if
decorated -> decorators funcdef
1964
True
decorated -> decorators funcdef
1964
assert
decorated -> decorators funcdef
1964
+
decorated -> decorators funcdef
1964
global
decorated -> decorators funcdef
1964
(
decorated -> decorators funcdef
1964
STRING
decorated -> decorators funcdef
1964
conf
decorated -> decorators funcdef
1964
-
decorated -> decorators funcdef
1964
DEDENT
decorated -> decorators funcdef
1964
@
decorated -> decorators funcdef
1964
nonlocal
decorated -> decorators funcdef
1964
not
decorated -> decorators funcdef
1964
server
decorated -> decorators funcdef
1964
for
decorated -> decorators funcdef
1964
try
decorated -> decorators funcdef
1964
NUMBER
decorated -> decorators funcdef
1964
resetstats
decorated -> decorators funcdef
1964
False
decorated -> decorators funcdef
1964
while
decorated -> decorators funcdef
1965
STRING
decorated -> decorators classdef
1965
servmod
decorated -> decorators classdef
1965
continue
decorated -> decorators classdef
1965
None
decorated -> decorators classdef
1965
global
decorated -> decorators classdef
1965
True
decorated -> decorators classdef
1965
[
decorated -> decorators classdef
1965
class
decorated -> decorators classdef
1965
begsim
decorated -> decorators classdef
1965
nonlocal
decorated -> decorators classdef
1965
conf
decorated -> decorators classdef
1965
NUMBER
decorated -> decorators classdef
1965
+
decorated -> decorators classdef
1965
yield
decorated -> decorators classdef
1965
resetstats
decorated -> decorators classdef
1965
assert
decorated -> decorators classdef
1965
raise
decorated -> decorators classdef
1965
break
decorated -> decorators classdef
1965
@
decorated -> decorators classdef
1965
DEDENT
decorated -> decorators classdef
1965
server
decorated -> decorators classdef
1965
with
decorated -> decorators classdef
1965
pass
decorated -> decorators classdef
1965
endsim
decorated -> decorators classdef
1965
not
decorated -> decorators classdef
1965
for
decorated -> decorators classdef
1965
(
decorated -> decorators classdef
1965
lambda
decorated -> decorators classdef
1965
{
decorated -> decorators classdef
1965
False
decorated -> decorators classdef
1965
while
decorated -> decorators classdef
1965
try
decorated -> decorators classdef
1965
return
decorated -> decorators classdef
1965
def
decorated -> decorators classdef
1965
if
decorated -> decorators classdef
1965
NAME
decorated -> decorators classdef
1965
del
decorated -> decorators classdef
1965
-
decorated -> decorators classdef
1965
modopt
decorated -> decorators classdef
1965
~
decorated -> decorators classdef
1966
(
2282
1966
:
2283
1967
:
2284
1968
DEDENT
stmt_list -> stmt stmt_list
1969
except
suite -> NEWLINE INDENT stmt_list DEDENT
1970
DEDENT
2285
1971
[
397
1971
factor
398
1971
True
399
1971
atom_expr
400
1971
~
401
1971
and_expr
402
1971
-
403
1971
None
404
1971
atom
405
1971
{
406
1971
arith_expr
407
1971
power
408
1971
STRING
409
1971
NAME
410
1971
(
411
1971
NUMBER
412
1971
and_test
413
1971
term
414
1971
+
415
1971
xor_expr
416
1971
shift_expr
417
1971
not
418
1971
False
419
1971
lambda
420
1971
test
2286
1971
comparison
421
1971
not_test
422
1971
lambdef
423
1971
expr
424
1971
or_test
425
1972
DEDENT
2287
1973
:
test -> or_test if or_test else test
1974
arith_expr
1
1974
small_stmt
20
1974
factor
17
1974
True
38
1974
atom_expr
31
1974
term
22
1974
-
26
1974
None
55
1974
atom
57
1974
test
5
1974
comparison
49
1974
and_expr
8
1974
power
9
1974
STRING
10
1974
NAME
52
1974
shift_expr
48
1974
lambdef
15
1974
NUMBER
58
1974
simple_stmt
1094
1974
(
16
1974
expr
47
1974
[
18
1974
NEWLINE
1095
1974
not_test
32
1974
{
21
1974
and_test
46
1974
+
27
1974
lambda
29
1974
xor_expr
41
1974
yield
34
1974
not
62
1974
test_list
36
1974
~
37
1974
or_test
53
1974
False
39
1974
sim_stmt
45
1974
suite
2288
1974
nonlocal
72
1974
nonlocal_stmt
73
1974
return
59
1974
break_stmt
60
1974
return_stmt
61
1974
raise_stmt
74
1974
break
63
1974
yield_stmt
75
1974
raise
64
1974
continue
77
1974
expr_stmt
65
1974
endsim
78
1974
del
80
1974
pass_stmt
81
1974
flow_stmt
82
1974
stat_stmt
66
1974
assert_stmt
68
1974
resetstats
84
1974
del_stmt
85
1974
continue_stmt
86
1974
begsim
69
1974
global_stmt
87
1974
pass
88
1974
global
70
1974
assert
71
1975
DEDENT
2289
1976
def
decorator -> @ dotted_name ( arglist ) NEWLINE
1976
@
decorator -> @ dotted_name ( arglist ) NEWLINE
1976
class
decorator -> @ dotted_name ( arglist ) NEWLINE
1977
for
test -> or_test if or_test else test
1977
,
test -> or_test if or_test else test
1977
)
test -> or_test if or_test else test
1978
.
atom -> [ test_list_comp ]
1978
[
atom -> [ test_list_comp ]
1978
@
atom -> [ test_list_comp ]
1978
<=
atom -> [ test_list_comp ]
1978
<
atom -> [ test_list_comp ]
1978
not
atom -> [ test_list_comp ]
1978
in
atom -> [ test_list_comp ]
1978
and
atom -> [ test_list_comp ]
1978
-
atom -> [ test_list_comp ]
1978
if
atom -> [ test_list_comp ]
1978
!=
atom -> [ test_list_comp ]
1978
is
atom -> [ test_list_comp ]
1978
>>
atom -> [ test_list_comp ]
1978
or
atom -> [ test_list_comp ]
1978
//
atom -> [ test_list_comp ]
1978
/
atom -> [ test_list_comp ]
1978
,
atom -> [ test_list_comp ]
1978
|
atom -> [ test_list_comp ]
1978
>
atom -> [ test_list_comp ]
1978
&
atom -> [ test_list_comp ]
1978
(
atom -> [ test_list_comp ]
1978
%
atom -> [ test_list_comp ]
1978
>=
atom -> [ test_list_comp ]
1978
)
atom -> [ test_list_comp ]
1978
==
atom -> [ test_list_comp ]
1978
**
atom -> [ test_list_comp ]
1978
<<
atom -> [ test_list_comp ]
1978
^
atom -> [ test_list_comp ]
1978
+
atom -> [ test_list_comp ]
1978
*
atom -> [ test_list_comp ]
1979
<<
term -> factor @ term
1979
^
term -> factor @ term
1979
<=
term -> factor @ term
1979
==
term -> factor @ term
1979
if
term -> factor @ term
1979
|
term -> factor @ term
1979
!=
term -> factor @ term
1979
or
term -> factor @ term
1979
>
term -> factor @ term
1979
and
term -> factor @ term
1979
>>
term -> factor @ term
1979
is
term -> factor @ term
1979
-
term -> factor @ term
1979
not
term -> factor @ term
1979
+
term -> factor @ term
1979
in
term -> factor @ term
1979
>=
term -> factor @ term
1979
<
term -> factor @ term
1979
,
term -> factor @ term
1979
&
term -> factor @ term
1979
)
term -> factor @ term
1980
<=
term -> factor % term
1980
is
term -> factor % term
1980
>
term -> factor % term
1980
and
term -> factor % term
1980
in
term -> factor % term
1980
,
term -> factor % term
1980
or
term -> factor % term
1980
<
term -> factor % term
1980
-
term -> factor % term
1980
!=
term -> factor % term
1980
>>
term -> factor % term
1980
^
term -> factor % term
1980
+
term -> factor % term
1980
if
term -> factor % term
1980
<<
term -> factor % term
1980
>=
term -> factor % term
1980
==
term -> factor % term
1980
not
term -> factor % term
1980
|
term -> factor % term
1980
)
term -> factor % term
1980
&
term -> factor % term
1981
>>
term -> factor / term
1981
!=
term -> factor / term
1981
<
term -> factor / term
1981
<=
term -> factor / term
1981
|
term -> factor / term
1981
is
term -> factor / term
1981
>=
term -> factor / term
1981
^
term -> factor / term
1981
&
term -> factor / term
1981
+
term -> factor / term
1981
<<
term -> factor / term
1981
and
term -> factor / term
1981
-
term -> factor / term
1981
in
term -> factor / term
1981
>
term -> factor / term
1981
or
term -> factor / term
1981
not
term -> factor / term
1981
==
term -> factor / term
1981
,
term -> factor / term
1981
if
term -> factor / term
1981
)
term -> factor / term
1982
is
term -> factor * term
1982
+
term -> factor * term
1982
>=
term -> factor * term
1982
^
term -> factor * term
1982
,
term -> factor * term
1982
<=
term -> factor * term
1982
or
term -> factor * term
1982
)
term -> factor * term
1982
<
term -> factor * term
1982
|
term -> factor * term
1982
>>
term -> factor * term
1982
in
term -> factor * term
1982
not
term -> factor * term
1982
==
term -> factor * term
1982
-
term -> factor * term
1982
and
term -> factor * term
1982
!=
term -> factor * term
1982
<<
term -> factor * term
1982
>
term -> factor * term
1982
if
term -> factor * term
1982
&
term -> factor * term
1983
!=
term -> factor // term
1983
or
term -> factor // term
1983
^
term -> factor // term
1983
>
term -> factor // term
1983
is
term -> factor // term
1983
&
term -> factor // term
1983
-
term -> factor // term
1983
in
term -> factor // term
1983
>>
term -> factor // term
1983
|
term -> factor // term
1983
<
term -> factor // term
1983
>=
term -> factor // term
1983
not
term -> factor // term
1983
if
term -> factor // term
1983
==
term -> factor // term
1983
)
term -> factor // term
1983
<=
term -> factor // term
1983
,
term -> factor // term
1983
and
term -> factor // term
1983
<<
term -> factor // term
1983
+
term -> factor // term
1984
!=
power -> atom_expr ** factor
1984
@
power -> atom_expr ** factor
1984
|
power -> atom_expr ** factor
1984
in
power -> atom_expr ** factor
1984
==
power -> atom_expr ** factor
1984
if
power -> atom_expr ** factor
1984
and
power -> atom_expr ** factor
1984
>=
power -> atom_expr ** factor
1984
/
power -> atom_expr ** factor
1984
not
power -> atom_expr ** factor
1984
^
power -> atom_expr ** factor
1984
//
power -> atom_expr ** factor
1984
>
power -> atom_expr ** factor
1984
+
power -> atom_expr ** factor
1984
%
power -> atom_expr ** factor
1984
)
power -> atom_expr ** factor
1984
-
power -> atom_expr ** factor
1984
is
power -> atom_expr ** factor
1984
<=
power -> atom_expr ** factor
1984
<
power -> atom_expr ** factor
1984
,
power -> atom_expr ** factor
1984
*
power -> atom_expr ** factor
1984
<<
power -> atom_expr ** factor
1984
or
power -> atom_expr ** factor
1984
>>
power -> atom_expr ** factor
1984
&
power -> atom_expr ** factor
1985
not
xor_expr -> and_expr ^ xor_expr
1985
<
xor_expr -> and_expr ^ xor_expr
1985
,
xor_expr -> and_expr ^ xor_expr
1985
>=
xor_expr -> and_expr ^ xor_expr
1985
>
xor_expr -> and_expr ^ xor_expr
1985
)
xor_expr -> and_expr ^ xor_expr
1985
!=
xor_expr -> and_expr ^ xor_expr
1985
is
xor_expr -> and_expr ^ xor_expr
1985
and
xor_expr -> and_expr ^ xor_expr
1985
if
xor_expr -> and_expr ^ xor_expr
1985
<=
xor_expr -> and_expr ^ xor_expr
1985
in
xor_expr -> and_expr ^ xor_expr
1985
==
xor_expr -> and_expr ^ xor_expr
1985
|
xor_expr -> and_expr ^ xor_expr
1985
or
xor_expr -> and_expr ^ xor_expr
1986
<
and_expr -> shift_expr & and_expr
1986
if
and_expr -> shift_expr & and_expr
1986
>=
and_expr -> shift_expr & and_expr
1986
not
and_expr -> shift_expr & and_expr
1986
==
and_expr -> shift_expr & and_expr
1986
>
and_expr -> shift_expr & and_expr
1986
in
and_expr -> shift_expr & and_expr
1986
^
and_expr -> shift_expr & and_expr
1986
or
and_expr -> shift_expr & and_expr
1986
and
and_expr -> shift_expr & and_expr
1986
!=
and_expr -> shift_expr & and_expr
1986
,
and_expr -> shift_expr & and_expr
1986
<=
and_expr -> shift_expr & and_expr
1986
|
and_expr -> shift_expr & and_expr
1986
is
and_expr -> shift_expr & and_expr
1986
)
and_expr -> shift_expr & and_expr
1987
.
trailer -> . NAME
1987
not
trailer -> . NAME
1987
if
trailer -> . NAME
1987
**
trailer -> . NAME
1987
|
trailer -> . NAME
1987
-
trailer -> . NAME
1987
(
trailer -> . NAME
1987
%
trailer -> . NAME
1987
//
trailer -> . NAME
1987
==
trailer -> . NAME
1987
>>
trailer -> . NAME
1987
is
trailer -> . NAME
1987
!=
trailer -> . NAME
1987
)
trailer -> . NAME
1987
and
trailer -> . NAME
1987
>=
trailer -> . NAME
1987
,
trailer -> . NAME
1987
>
trailer -> . NAME
1987
in
trailer -> . NAME
1987
<<
trailer -> . NAME
1987
&
trailer -> . NAME
1987
/
trailer -> . NAME
1987
^
trailer -> . NAME
1987
[
trailer -> . NAME
1987
<=
trailer -> . NAME
1987
or
trailer -> . NAME
1987
+
trailer -> . NAME
1987
<
trailer -> . NAME
1987
*
trailer -> . NAME
1987
@
trailer -> . NAME
1988
)
trailer -> ( )
1988
+
trailer -> ( )
1988
!=
trailer -> ( )
1988
<<
trailer -> ( )
1988
>=
trailer -> ( )
1988
**
trailer -> ( )
1988
not
trailer -> ( )
1988
if
trailer -> ( )
1988
,
trailer -> ( )
1988
|
trailer -> ( )
1988
[
trailer -> ( )
1988
==
trailer -> ( )
1988
%
trailer -> ( )
1988
*
trailer -> ( )
1988
>>
trailer -> ( )
1988
@
trailer -> ( )
1988
>
trailer -> ( )
1988
/
trailer -> ( )
1988
in
trailer -> ( )
1988
(
trailer -> ( )
1988
is
trailer -> ( )
1988
//
trailer -> ( )
1988
<
trailer -> ( )
1988
or
trailer -> ( )
1988
^
trailer -> ( )
1988
and
trailer -> ( )
1988
<=
trailer -> ( )
1988
.
trailer -> ( )
1988
-
trailer -> ( )
1988
&
trailer -> ( )
1989
)
2290
1990
<=
trailer_expr -> trailer trailer_expr
1990
+
trailer_expr -> trailer trailer_expr
1990
^
trailer_expr -> trailer trailer_expr
1990
or
trailer_expr -> trailer trailer_expr
1990
==
trailer_expr -> trailer trailer_expr
1990
%
trailer_expr -> trailer trailer_expr
1990
@
trailer_expr -> trailer trailer_expr
1990
not
trailer_expr -> trailer trailer_expr
1990
<<
trailer_expr -> trailer trailer_expr
1990
-
trailer_expr -> trailer trailer_expr
1990
//
trailer_expr -> trailer trailer_expr
1990
and
trailer_expr -> trailer trailer_expr
1990
|
trailer_expr -> trailer trailer_expr
1990
if
trailer_expr -> trailer trailer_expr
1990
>
trailer_expr -> trailer trailer_expr
1990
!=
trailer_expr -> trailer trailer_expr
1990
,
trailer_expr -> trailer trailer_expr
1990
<
trailer_expr -> trailer trailer_expr
1990
>>
trailer_expr -> trailer trailer_expr
1990
/
trailer_expr -> trailer trailer_expr
1990
is
trailer_expr -> trailer trailer_expr
1990
&
trailer_expr -> trailer trailer_expr
1990
in
trailer_expr -> trailer trailer_expr
1990
>=
trailer_expr -> trailer trailer_expr
1990
*
trailer_expr -> trailer trailer_expr
1990
)
trailer_expr -> trailer trailer_expr
1990
**
trailer_expr -> trailer trailer_expr
1991
]
2291
1992
==
shift_expr -> arith_expr >> shift_expr
1992
^
shift_expr -> arith_expr >> shift_expr
1992
or
shift_expr -> arith_expr >> shift_expr
1992
if
shift_expr -> arith_expr >> shift_expr
1992
,
shift_expr -> arith_expr >> shift_expr
1992
not
shift_expr -> arith_expr >> shift_expr
1992
<
shift_expr -> arith_expr >> shift_expr
1992
|
shift_expr -> arith_expr >> shift_expr
1992
<=
shift_expr -> arith_expr >> shift_expr
1992
is
shift_expr -> arith_expr >> shift_expr
1992
in
shift_expr -> arith_expr >> shift_expr
1992
>=
shift_expr -> arith_expr >> shift_expr
1992
)
shift_expr -> arith_expr >> shift_expr
1992
&
shift_expr -> arith_expr >> shift_expr
1992
>
shift_expr -> arith_expr >> shift_expr
1992
and
shift_expr -> arith_expr >> shift_expr
1992
!=
shift_expr -> arith_expr >> shift_expr
1993
or
shift_expr -> arith_expr << shift_expr
1993
>
shift_expr -> arith_expr << shift_expr
1993
in
shift_expr -> arith_expr << shift_expr
1993
&
shift_expr -> arith_expr << shift_expr
1993
is
shift_expr -> arith_expr << shift_expr
1993
<
shift_expr -> arith_expr << shift_expr
1993
)
shift_expr -> arith_expr << shift_expr
1993
<=
shift_expr -> arith_expr << shift_expr
1993
not
shift_expr -> arith_expr << shift_expr
1993
if
shift_expr -> arith_expr << shift_expr
1993
,
shift_expr -> arith_expr << shift_expr
1993
and
shift_expr -> arith_expr << shift_expr
1993
^
shift_expr -> arith_expr << shift_expr
1993
|
shift_expr -> arith_expr << shift_expr
1993
!=
shift_expr -> arith_expr << shift_expr
1993
==
shift_expr -> arith_expr << shift_expr
1993
>=
shift_expr -> arith_expr << shift_expr
1994
>
atom -> ( test_list_comp )
1994
@
atom -> ( test_list_comp )
1994
&
atom -> ( test_list_comp )
1994
[
atom -> ( test_list_comp )
1994
)
atom -> ( test_list_comp )
1994
if
atom -> ( test_list_comp )
1994
==
atom -> ( test_list_comp )
1994
>=
atom -> ( test_list_comp )
1994
**
atom -> ( test_list_comp )
1994
not
atom -> ( test_list_comp )
1994
<<
atom -> ( test_list_comp )
1994
>>
atom -> ( test_list_comp )
1994
in
atom -> ( test_list_comp )
1994
or
atom -> ( test_list_comp )
1994
.
atom -> ( test_list_comp )
1994
/
atom -> ( test_list_comp )
1994
^
atom -> ( test_list_comp )
1994
is
atom -> ( test_list_comp )
1994
,
atom -> ( test_list_comp )
1994
and
atom -> ( test_list_comp )
1994
//
atom -> ( test_list_comp )
1994
<
atom -> ( test_list_comp )
1994
*
atom -> ( test_list_comp )
1994
<=
atom -> ( test_list_comp )
1994
(
atom -> ( test_list_comp )
1994
-
atom -> ( test_list_comp )
1994
|
atom -> ( test_list_comp )
1994
!=
atom -> ( test_list_comp )
1994
+
atom -> ( test_list_comp )
1994
%
atom -> ( test_list_comp )
1995
if
or_test -> and_test or or_test
1995
)
or_test -> and_test or or_test
1995
,
or_test -> and_test or or_test
1996
^
arith_expr -> term - arith_expr
1996
!=
arith_expr -> term - arith_expr
1996
<
arith_expr -> term - arith_expr
1996
in
arith_expr -> term - arith_expr
1996
==
arith_expr -> term - arith_expr
1996
|
arith_expr -> term - arith_expr
1996
is
arith_expr -> term - arith_expr
1996
&
arith_expr -> term - arith_expr
1996
>>
arith_expr -> term - arith_expr
1996
<<
arith_expr -> term - arith_expr
1996
and
arith_expr -> term - arith_expr
1996
,
arith_expr -> term - arith_expr
1996
>
arith_expr -> term - arith_expr
1996
if
arith_expr -> term - arith_expr
1996
not
arith_expr -> term - arith_expr
1996
)
arith_expr -> term - arith_expr
1996
>=
arith_expr -> term - arith_expr
1996
<=
arith_expr -> term - arith_expr
1996
or
arith_expr -> term - arith_expr
1997
>=
arith_expr -> term + arith_expr
1997
>
arith_expr -> term + arith_expr
1997
^
arith_expr -> term + arith_expr
1997
or
arith_expr -> term + arith_expr
1997
==
arith_expr -> term + arith_expr
1997
<=
arith_expr -> term + arith_expr
1997
if
arith_expr -> term + arith_expr
1997
>>
arith_expr -> term + arith_expr
1997
<
arith_expr -> term + arith_expr
1997
not
arith_expr -> term + arith_expr
1997
&
arith_expr -> term + arith_expr
1997
in
arith_expr -> term + arith_expr
1997
and
arith_expr -> term + arith_expr
1997
,
arith_expr -> term + arith_expr
1997
|
arith_expr -> term + arith_expr
1997
!=
arith_expr -> term + arith_expr
1997
)
arith_expr -> term + arith_expr
1997
<<
arith_expr -> term + arith_expr
1997
is
arith_expr -> term + arith_expr
1998
>=
expr -> xor_expr | expr
1998
,
expr -> xor_expr | expr
1998
or
expr -> xor_expr | expr
1998
in
expr -> xor_expr | expr
1998
and
expr -> xor_expr | expr
1998
==
expr -> xor_expr | expr
1998
>
expr -> xor_expr | expr
1998
<=
expr -> xor_expr | expr
1998
is
expr -> xor_expr | expr
1998
)
expr -> xor_expr | expr
1998
<
expr -> xor_expr | expr
1998
if
expr -> xor_expr | expr
1998
not
expr -> xor_expr | expr
1998
!=
expr -> xor_expr | expr
1999
else
2292
2000
,
and_test -> not_test and and_test
2000
if
and_test -> not_test and and_test
2000
or
and_test -> not_test and and_test
2000
)
and_test -> not_test and and_test
2001
)
comparison -> expr comp_op comparison
2001
or
comparison -> expr comp_op comparison
2001
if
comparison -> expr comp_op comparison
2001
and
comparison -> expr comp_op comparison
2001
,
comparison -> expr comp_op comparison
2002
[
1002
2002
factor
1003
2002
True
1004
2002
atom_expr
1005
2002
~
1006
2002
and_expr
1007
2002
-
1008
2002
shift_expr
1009
2002
atom
1010
2002
{
1011
2002
comparison
1012
2002
arith_expr
1013
2002
power
1014
2002
STRING
1015
2002
NAME
1016
2002
(
1017
2002
and_test
1018
2002
term
1019
2002
+
1020
2002
xor_expr
1021
2002
or_test
1022
2002
NUMBER
1023
2002
not
1024
2002
False
1025
2002
not_test
1026
2002
None
1027
2002
test
2293
2002
expr
1028
2002
lambda
1029
2002
lambdef
1031
2003
,
lambdef -> lambda : test
2003
)
lambdef -> lambda : test
2004
[
166
2004
factor
167
2004
True
168
2004
atom_expr
169
2004
~
170
2004
not
171
2004
and_expr
172
2004
-
173
2004
{
174
2004
shift_expr
175
2004
atom
176
2004
]
2294
2004
comparison
178
2004
(
179
2004
arith_expr
180
2004
power
181
2004
STRING
182
2004
NAME
183
2004
test
184
2004
and_test
185
2004
term
186
2004
+
187
2004
xor_expr
188
2004
NUMBER
190
2004
test_list_comp
2295
2004
False
191
2004
expr
192
2004
not_test
193
2004
None
194
2004
lambdef
195
2004
lambda
196
2004
or_test
197
2004
test_list
198
2005
not
term -> factor
2005
@
2296
2005
%
2297
2005
/
2298
2005
*
2299
2005
//
2300
2005
<=
term -> factor
2005
for
term -> factor
2005
)
term -> factor
2005
>
term -> factor
2005
==
term -> factor
2005
is
term -> factor
2005
or
term -> factor
2005
<
term -> factor
2005
and
term -> factor
2005
<<
term -> factor
2005
^
term -> factor
2005
!=
term -> factor
2005
-
term -> factor
2005
&
term -> factor
2005
|
term -> factor
2005
>=
term -> factor
2005
if
term -> factor
2005
+
term -> factor
2005
in
term -> factor
2005
>>
term -> factor
2006
<<
atom -> True
2006
&
atom -> True
2006
or
atom -> True
2006
[
atom -> True
2006
if
atom -> True
2006
-
atom -> True
2006
*
atom -> True
2006
^
atom -> True
2006
>=
atom -> True
2006
!=
atom -> True
2006
(
atom -> True
2006
not
atom -> True
2006
for
atom -> True
2006
|
atom -> True
2006
)
atom -> True
2006
+
atom -> True
2006
**
atom -> True
2006
.
atom -> True
2006
is
atom -> True
2006
//
atom -> True
2006
>
atom -> True
2006
%
atom -> True
2006
in
atom -> True
2006
<=
atom -> True
2006
>>
atom -> True
2006
/
atom -> True
2006
==
atom -> True
2006
and
atom -> True
2006
<
atom -> True
2006
@
atom -> True
2007
**
2301
2007
)
power -> atom_expr
2007
!=
power -> atom_expr
2007
-
power -> atom_expr
2007
<<
power -> atom_expr
2007
not
power -> atom_expr
2007
/
power -> atom_expr
2007
<=
power -> atom_expr
2007
in
power -> atom_expr
2007
%
power -> atom_expr
2007
>
power -> atom_expr
2007
@
power -> atom_expr
2007
|
power -> atom_expr
2007
<
power -> atom_expr
2007
>>
power -> atom_expr
2007
or
power -> atom_expr
2007
and
power -> atom_expr
2007
>=
power -> atom_expr
2007
==
power -> atom_expr
2007
^
power -> atom_expr
2007
*
power -> atom_expr
2007
for
power -> atom_expr
2007
&
power -> atom_expr
2007
is
power -> atom_expr
2007
+
power -> atom_expr
2007
if
power -> atom_expr
2007
//
power -> atom_expr
2008
[
2004
2008
True
2006
2008
atom_expr
2007
2008
-
2010
2008
~
2008
2008
{
2011
2008
atom
2012
2008
power
2015
2008
STRING
2016
2008
NAME
2017
2008
(
2018
2008
+
2021
2008
NUMBER
2024
2008
False
2026
2008
factor
2302
2008
None
2030
2009
>
xor_expr -> and_expr
2009
^
2303
2009
<=
xor_expr -> and_expr
2009
not
xor_expr -> and_expr
2009
|
xor_expr -> and_expr
2009
==
xor_expr -> and_expr
2009
in
xor_expr -> and_expr
2009
!=
xor_expr -> and_expr
2009
if
xor_expr -> and_expr
2009
for
xor_expr -> and_expr
2009
is
xor_expr -> and_expr
2009
<
xor_expr -> and_expr
2009
or
xor_expr -> and_expr
2009
)
xor_expr -> and_expr
2009
and
xor_expr -> and_expr
2009
>=
xor_expr -> and_expr
2010
[
2004
2010
True
2006
2010
atom_expr
2007
2010
~
2008
2010
-
2010
2010
{
2011
2010
atom
2012
2010
power
2015
2010
STRING
2016
2010
NAME
2017
2010
(
2018
2010
factor
2304
2010
+
2021
2010
NUMBER
2024
2010
False
2026
2010
None
2030
2011
}
2305
2012
>>
trailer_expr -> 
2012
.
2306
2012
(
2307
2012
trailer
2308
2012
)
trailer_expr -> 
2012
trailer_expr
2309
2012
+
trailer_expr -> 
2012
is
trailer_expr -> 
2012
>
trailer_expr -> 
2012
not
trailer_expr -> 
2012
|
trailer_expr -> 
2012
[
2310
2012
&
trailer_expr -> 
2012
/
trailer_expr -> 
2012
@
trailer_expr -> 
2012
!=
trailer_expr -> 
2012
**
trailer_expr -> 
2012
>=
trailer_expr -> 
2012
^
trailer_expr -> 
2012
in
trailer_expr -> 
2012
<<
trailer_expr -> 
2012
and
trailer_expr -> 
2012
or
trailer_expr -> 
2012
if
trailer_expr -> 
2012
//
trailer_expr -> 
2012
%
trailer_expr -> 
2012
<=
trailer_expr -> 
2012
<
trailer_expr -> 
2012
==
trailer_expr -> 
2012
for
trailer_expr -> 
2012
-
trailer_expr -> 
2012
*
trailer_expr -> 
2013
if
2311
2013
for
517
2013
)
comp_iter -> 
2013
comp_for
2312
2013
comp_iter
2313
2013
comp_if
2314
2014
>>
2315
2014
if
shift_expr -> arith_expr
2014
&
shift_expr -> arith_expr
2014
<<
2316
2014
|
shift_expr -> arith_expr
2014
is
shift_expr -> arith_expr
2014
<
shift_expr -> arith_expr
2014
==
shift_expr -> arith_expr
2014
or
shift_expr -> arith_expr
2014
>
shift_expr -> arith_expr
2014
)
shift_expr -> arith_expr
2014
!=
shift_expr -> arith_expr
2014
for
shift_expr -> arith_expr
2014
>=
shift_expr -> arith_expr
2014
in
shift_expr -> arith_expr
2014
<=
shift_expr -> arith_expr
2014
and
shift_expr -> arith_expr
2014
^
shift_expr -> arith_expr
2014
not
shift_expr -> arith_expr
2015
+
factor -> power
2015
%
factor -> power
2015
<
factor -> power
2015
<<
factor -> power
2015
!=
factor -> power
2015
<=
factor -> power
2015
and
factor -> power
2015
/
factor -> power
2015
^
factor -> power
2015
for
factor -> power
2015
@
factor -> power
2015
>=
factor -> power
2015
not
factor -> power
2015
//
factor -> power
2015
or
factor -> power
2015
==
factor -> power
2015
is
factor -> power
2015
|
factor -> power
2015
)
factor -> power
2015
*
factor -> power
2015
-
factor -> power
2015
if
factor -> power
2015
>
factor -> power
2015
in
factor -> power
2015
>>
factor -> power
2015
&
factor -> power
2016
%
atom -> STRING
2016
>
atom -> STRING
2016
@
atom -> STRING
2016
<<
atom -> STRING
2016
in
atom -> STRING
2016
[
atom -> STRING
2016
-
atom -> STRING
2016
==
atom -> STRING
2016
>=
atom -> STRING
2016
not
atom -> STRING
2016
/
atom -> STRING
2016
+
atom -> STRING
2016
*
atom -> STRING
2016
)
atom -> STRING
2016
(
atom -> STRING
2016
//
atom -> STRING
2016
if
atom -> STRING
2016
.
atom -> STRING
2016
<
atom -> STRING
2016
&
atom -> STRING
2016
<=
atom -> STRING
2016
for
atom -> STRING
2016
!=
atom -> STRING
2016
**
atom -> STRING
2016
^
atom -> STRING
2016
and
atom -> STRING
2016
is
atom -> STRING
2016
|
atom -> STRING
2016
or
atom -> STRING
2016
>>
atom -> STRING
2017
)
atom -> NAME
2017
<
atom -> NAME
2017
^
atom -> NAME
2017
+
atom -> NAME
2017
-
atom -> NAME
2017
>=
atom -> NAME
2017
@
atom -> NAME
2017
!=
atom -> NAME
2017
for
atom -> NAME
2017
*
atom -> NAME
2017
<=
atom -> NAME
2017
**
atom -> NAME
2017
or
atom -> NAME
2017
not
atom -> NAME
2017
==
atom -> NAME
2017
&
atom -> NAME
2017
>
atom -> NAME
2017
%
atom -> NAME
2017
>>
atom -> NAME
2017
.
atom -> NAME
2017
|
atom -> NAME
2017
is
atom -> NAME
2017
and
atom -> NAME
2017
//
atom -> NAME
2017
[
atom -> NAME
2017
/
atom -> NAME
2017
(
atom -> NAME
2017
<<
atom -> NAME
2017
if
atom -> NAME
2017
in
atom -> NAME
2018
[
128
2018
factor
129
2018
True
130
2018
atom_expr
131
2018
~
132
2018
and_expr
133
2018
-
134
2018
{
135
2018
test_list_comp
2317
2018
shift_expr
137
2018
atom
138
2018
)
2318
2018
comparison
140
2018
arith_expr
141
2018
power
142
2018
STRING
143
2018
NAME
144
2018
(
145
2018
and_test
146
2018
term
147
2018
+
148
2018
xor_expr
149
2018
or_test
150
2018
NUMBER
151
2018
not
152
2018
False
153
2018
expr
154
2018
not_test
155
2018
None
156
2018
lambdef
157
2018
lambda
158
2018
test
159
2018
test_list
160
2019
for
or_test -> and_test
2019
or
2319
2019
if
or_test -> and_test
2019
)
or_test -> and_test
2020
-
2320
2020
+
2321
2020
>=
arith_expr -> term
2020
|
arith_expr -> term
2020
<=
arith_expr -> term
2020
not
arith_expr -> term
2020
==
arith_expr -> term
2020
)
arith_expr -> term
2020
for
arith_expr -> term
2020
in
arith_expr -> term
2020
>>
arith_expr -> term
2020
is
arith_expr -> term
2020
if
arith_expr -> term
2020
or
arith_expr -> term
2020
!=
arith_expr -> term
2020
>
arith_expr -> term
2020
and
arith_expr -> term
2020
<<
arith_expr -> term
2020
<
arith_expr -> term
2020
^
arith_expr -> term
2020
&
arith_expr -> term
2021
[
2004
2021
True
2006
2021
atom_expr
2007
2021
-
2010
2021
~
2008
2021
{
2011
2021
atom
2012
2021
power
2015
2021
STRING
2016
2021
NAME
2017
2021
(
2018
2021
factor
2322
2021
+
2021
2021
NUMBER
2024
2021
False
2026
2021
None
2030
2022
|
2323
2022
>
expr -> xor_expr
2022
if
expr -> xor_expr
2022
for
expr -> xor_expr
2022
is
expr -> xor_expr
2022
and
expr -> xor_expr
2022
)
expr -> xor_expr
2022
not
expr -> xor_expr
2022
or
expr -> xor_expr
2022
>=
expr -> xor_expr
2022
==
expr -> xor_expr
2022
<
expr -> xor_expr
2022
!=
expr -> xor_expr
2022
<=
expr -> xor_expr
2022
in
expr -> xor_expr
2023
^
and_expr -> shift_expr
2023
in
and_expr -> shift_expr
2023
|
and_expr -> shift_expr
2023
&
2324
2023
<
and_expr -> shift_expr
2023
not
and_expr -> shift_expr
2023
>=
and_expr -> shift_expr
2023
for
and_expr -> shift_expr
2023
<=
and_expr -> shift_expr
2023
or
and_expr -> shift_expr
2023
and
and_expr -> shift_expr
2023
!=
and_expr -> shift_expr
2023
if
and_expr -> shift_expr
2023
is
and_expr -> shift_expr
2023
==
and_expr -> shift_expr
2023
>
and_expr -> shift_expr
2023
)
and_expr -> shift_expr
2024
+
atom -> NUMBER
2024
*
atom -> NUMBER
2024
>
atom -> NUMBER
2024
<<
atom -> NUMBER
2024
for
atom -> NUMBER
2024
-
atom -> NUMBER
2024
**
atom -> NUMBER
2024
if
atom -> NUMBER
2024
or
atom -> NUMBER
2024
is
atom -> NUMBER
2024
[
atom -> NUMBER
2024
(
atom -> NUMBER
2024
not
atom -> NUMBER
2024
&
atom -> NUMBER
2024
)
atom -> NUMBER
2024
^
atom -> NUMBER
2024
in
atom -> NUMBER
2024
==
atom -> NUMBER
2024
//
atom -> NUMBER
2024
!=
atom -> NUMBER
2024
and
atom -> NUMBER
2024
%
atom -> NUMBER
2024
<=
atom -> NUMBER
2024
.
atom -> NUMBER
2024
<
atom -> NUMBER
2024
>>
atom -> NUMBER
2024
/
atom -> NUMBER
2024
@
atom -> NUMBER
2024
>=
atom -> NUMBER
2024
|
atom -> NUMBER
2025
[
2004
2025
factor
2005
2025
True
2006
2025
atom_expr
2007
2025
~
2008
2025
and_expr
2009
2025
-
2010
2025
{
2011
2025
atom
2012
2025
arith_expr
2014
2025
power
2015
2025
STRING
2016
2025
NAME
2017
2025
(
2018
2025
term
2020
2025
+
2021
2025
xor_expr
2022
2025
shift_expr
2023
2025
NUMBER
2024
2025
not
2025
2025
False
2026
2025
expr
2027
2025
comparison
2028
2025
not_test
2325
2025
None
2030
2026
for
atom -> False
2026
(
atom -> False
2026
*
atom -> False
2026
==
atom -> False
2026
|
atom -> False
2026
[
atom -> False
2026
in
atom -> False
2026
&
atom -> False
2026
is
atom -> False
2026
not
atom -> False
2026
if
atom -> False
2026
^
atom -> False
2026
+
atom -> False
2026
)
atom -> False
2026
>
atom -> False
2026
<=
atom -> False
2026
<<
atom -> False
2026
<
atom -> False
2026
>=
atom -> False
2026
%
atom -> False
2026
@
atom -> False
2026
and
atom -> False
2026
!=
atom -> False
2026
-
atom -> False
2026
.
atom -> False
2026
//
atom -> False
2026
/
atom -> False
2026
**
atom -> False
2026
>>
atom -> False
2026
or
atom -> False
2027
>
317
2027
is
318
2027
in
319
2027
<=
320
2027
<
321
2027
>=
322
2027
!=
324
2027
not
325
2027
==
326
2027
comp_op
2326
2027
for
comparison -> expr
2027
or
comparison -> expr
2027
if
comparison -> expr
2027
)
comparison -> expr
2027
and
comparison -> expr
2028
or
not_test -> comparison
2028
)
not_test -> comparison
2028
for
not_test -> comparison
2028
and
not_test -> comparison
2028
if
not_test -> comparison
2029
and
2327
2029
if
and_test -> not_test
2029
)
and_test -> not_test
2029
for
and_test -> not_test
2029
or
and_test -> not_test
2030
@
atom -> None
2030
<=
atom -> None
2030
in
atom -> None
2030
and
atom -> None
2030
for
atom -> None
2030
&
atom -> None
2030
|
atom -> None
2030
>
atom -> None
2030
)
atom -> None
2030
>=
atom -> None
2030
/
atom -> None
2030
<<
atom -> None
2030
-
atom -> None
2030
!=
atom -> None
2030
**
atom -> None
2030
(
atom -> None
2030
*
atom -> None
2030
.
atom -> None
2030
>>
atom -> None
2030
==
atom -> None
2030
is
atom -> None
2030
<
atom -> None
2030
if
atom -> None
2030
^
atom -> None
2030
[
atom -> None
2030
%
atom -> None
2030
+
atom -> None
2030
not
atom -> None
2030
or
atom -> None
2030
//
atom -> None
2031
[
166
2031
factor
167
2031
True
168
2031
atom_expr
169
2031
~
170
2031
not
171
2031
and_expr
172
2031
-
173
2031
{
174
2031
shift_expr
175
2031
atom
176
2031
]
2328
2031
comparison
178
2031
(
179
2031
arith_expr
180
2031
power
181
2031
STRING
182
2031
NAME
183
2031
test
184
2031
and_test
185
2031
term
186
2031
+
187
2031
xor_expr
188
2031
NUMBER
190
2031
test_list_comp
2329
2031
False
191
2031
expr
192
2031
not_test
193
2031
None
194
2031
lambdef
195
2031
lambda
196
2031
or_test
197
2031
test_list
198
2032
not
term -> factor
2032
@
2330
2032
//
2331
2032
%
2332
2032
/
2333
2032
*
2334
2032
<=
term -> factor
2032
for
term -> factor
2032
>
term -> factor
2032
==
term -> factor
2032
is
term -> factor
2032
or
term -> factor
2032
<
term -> factor
2032
and
term -> factor
2032
<<
term -> factor
2032
^
term -> factor
2032
!=
term -> factor
2032
-
term -> factor
2032
&
term -> factor
2032
|
term -> factor
2032
>=
term -> factor
2032
if
term -> factor
2032
+
term -> factor
2032
in
term -> factor
2032
>>
term -> factor
2032
]
term -> factor
2033
<<
atom -> True
2033
&
atom -> True
2033
or
atom -> True
2033
[
atom -> True
2033
if
atom -> True
2033
-
atom -> True
2033
*
atom -> True
2033
^
atom -> True
2033
>=
atom -> True
2033
!=
atom -> True
2033
(
atom -> True
2033
not
atom -> True
2033
for
atom -> True
2033
|
atom -> True
2033
]
atom -> True
2033
+
atom -> True
2033
**
atom -> True
2033
.
atom -> True
2033
is
atom -> True
2033
//
atom -> True
2033
>
atom -> True
2033
%
atom -> True
2033
in
atom -> True
2033
<=
atom -> True
2033
>>
atom -> True
2033
/
atom -> True
2033
==
atom -> True
2033
and
atom -> True
2033
<
atom -> True
2033
@
atom -> True
2034
**
2335
2034
!=
power -> atom_expr
2034
-
power -> atom_expr
2034
<<
power -> atom_expr
2034
not
power -> atom_expr
2034
/
power -> atom_expr
2034
<=
power -> atom_expr
2034
in
power -> atom_expr
2034
%
power -> atom_expr
2034
>
power -> atom_expr
2034
@
power -> atom_expr
2034
|
power -> atom_expr
2034
<
power -> atom_expr
2034
>>
power -> atom_expr
2034
]
power -> atom_expr
2034
or
power -> atom_expr
2034
and
power -> atom_expr
2034
>=
power -> atom_expr
2034
==
power -> atom_expr
2034
^
power -> atom_expr
2034
*
power -> atom_expr
2034
for
power -> atom_expr
2034
&
power -> atom_expr
2034
is
power -> atom_expr
2034
+
power -> atom_expr
2034
if
power -> atom_expr
2034
//
power -> atom_expr
2035
[
2031
2035
True
2033
2035
atom_expr
2034
2035
-
2038
2035
~
2035
2035
{
2039
2035
atom
2040
2035
(
2041
2035
power
2043
2035
STRING
2044
2035
NAME
2045
2035
+
2048
2035
NUMBER
2051
2035
False
2052
2035
factor
2336
2035
None
2056
2036
[
2031
2036
factor
2032
2036
True
2033
2036
atom_expr
2034
2036
~
2035
2036
not
2036
2036
and_expr
2037
2036
-
2038
2036
{
2039
2036
atom
2040
2036
(
2041
2036
arith_expr
2042
2036
power
2043
2036
STRING
2044
2036
NAME
2045
2036
term
2047
2036
+
2048
2036
xor_expr
2049
2036
shift_expr
2050
2036
NUMBER
2051
2036
False
2052
2036
expr
2053
2036
comparison
2054
2036
not_test
2337
2036
None
2056
2037
>
xor_expr -> and_expr
2037
<=
xor_expr -> and_expr
2037
not
xor_expr -> and_expr
2037
|
xor_expr -> and_expr
2037
^
2338
2037
==
xor_expr -> and_expr
2037
in
xor_expr -> and_expr
2037
!=
xor_expr -> and_expr
2037
if
xor_expr -> and_expr
2037
for
xor_expr -> and_expr
2037
is
xor_expr -> and_expr
2037
<
xor_expr -> and_expr
2037
or
xor_expr -> and_expr
2037
]
xor_expr -> and_expr
2037
and
xor_expr -> and_expr
2037
>=
xor_expr -> and_expr
2038
[
2031
2038
True
2033
2038
atom_expr
2034
2038
~
2035
2038
-
2038
2038
{
2039
2038
atom
2040
2038
(
2041
2038
power
2043
2038
STRING
2044
2038
NAME
2045
2038
factor
2339
2038
+
2048
2038
NUMBER
2051
2038
False
2052
2038
None
2056
2039
}
2340
2040
>>
trailer_expr -> 
2040
(
2341
2040
trailer
2342
2040
trailer_expr
2343
2040
.
2344
2040
+
trailer_expr -> 
2040
[
2345
2040
is
trailer_expr -> 
2040
>
trailer_expr -> 
2040
not
trailer_expr -> 
2040
|
trailer_expr -> 
2040
&
trailer_expr -> 
2040
/
trailer_expr -> 
2040
@
trailer_expr -> 
2040
!=
trailer_expr -> 
2040
**
trailer_expr -> 
2040
>=
trailer_expr -> 
2040
^
trailer_expr -> 
2040
in
trailer_expr -> 
2040
]
trailer_expr -> 
2040
<<
trailer_expr -> 
2040
and
trailer_expr -> 
2040
or
trailer_expr -> 
2040
if
trailer_expr -> 
2040
//
trailer_expr -> 
2040
%
trailer_expr -> 
2040
<=
trailer_expr -> 
2040
<
trailer_expr -> 
2040
==
trailer_expr -> 
2040
for
trailer_expr -> 
2040
-
trailer_expr -> 
2040
*
trailer_expr -> 
2041
[
128
2041
factor
129
2041
True
130
2041
atom_expr
131
2041
~
132
2041
and_expr
133
2041
-
134
2041
{
135
2041
test_list_comp
2346
2041
shift_expr
137
2041
atom
138
2041
)
2347
2041
comparison
140
2041
arith_expr
141
2041
power
142
2041
STRING
143
2041
NAME
144
2041
(
145
2041
and_test
146
2041
term
147
2041
+
148
2041
xor_expr
149
2041
or_test
150
2041
NUMBER
151
2041
not
152
2041
False
153
2041
expr
154
2041
not_test
155
2041
None
156
2041
lambdef
157
2041
lambda
158
2041
test
159
2041
test_list
160
2042
>>
2348
2042
<<
2349
2042
if
shift_expr -> arith_expr
2042
&
shift_expr -> arith_expr
2042
|
shift_expr -> arith_expr
2042
is
shift_expr -> arith_expr
2042
<
shift_expr -> arith_expr
2042
==
shift_expr -> arith_expr
2042
or
shift_expr -> arith_expr
2042
>
shift_expr -> arith_expr
2042
!=
shift_expr -> arith_expr
2042
for
shift_expr -> arith_expr
2042
>=
shift_expr -> arith_expr
2042
]
shift_expr -> arith_expr
2042
in
shift_expr -> arith_expr
2042
<=
shift_expr -> arith_expr
2042
and
shift_expr -> arith_expr
2042
^
shift_expr -> arith_expr
2042
not
shift_expr -> arith_expr
2043
+
factor -> power
2043
%
factor -> power
2043
<
factor -> power
2043
<<
factor -> power
2043
!=
factor -> power
2043
<=
factor -> power
2043
and
factor -> power
2043
/
factor -> power
2043
^
factor -> power
2043
for
factor -> power
2043
@
factor -> power
2043
>=
factor -> power
2043
not
factor -> power
2043
//
factor -> power
2043
or
factor -> power
2043
==
factor -> power
2043
is
factor -> power
2043
]
factor -> power
2043
|
factor -> power
2043
*
factor -> power
2043
-
factor -> power
2043
if
factor -> power
2043
>
factor -> power
2043
in
factor -> power
2043
>>
factor -> power
2043
&
factor -> power
2044
%
atom -> STRING
2044
>
atom -> STRING
2044
@
atom -> STRING
2044
<<
atom -> STRING
2044
in
atom -> STRING
2044
[
atom -> STRING
2044
-
atom -> STRING
2044
==
atom -> STRING
2044
>=
atom -> STRING
2044
not
atom -> STRING
2044
/
atom -> STRING
2044
+
atom -> STRING
2044
*
atom -> STRING
2044
(
atom -> STRING
2044
//
atom -> STRING
2044
if
atom -> STRING
2044
.
atom -> STRING
2044
<
atom -> STRING
2044
&
atom -> STRING
2044
<=
atom -> STRING
2044
for
atom -> STRING
2044
!=
atom -> STRING
2044
**
atom -> STRING
2044
^
atom -> STRING
2044
and
atom -> STRING
2044
]
atom -> STRING
2044
is
atom -> STRING
2044
|
atom -> STRING
2044
or
atom -> STRING
2044
>>
atom -> STRING
2045
<
atom -> NAME
2045
^
atom -> NAME
2045
+
atom -> NAME
2045
-
atom -> NAME
2045
>=
atom -> NAME
2045
@
atom -> NAME
2045
!=
atom -> NAME
2045
for
atom -> NAME
2045
*
atom -> NAME
2045
<=
atom -> NAME
2045
**
atom -> NAME
2045
or
atom -> NAME
2045
not
atom -> NAME
2045
==
atom -> NAME
2045
&
atom -> NAME
2045
]
atom -> NAME
2045
>
atom -> NAME
2045
%
atom -> NAME
2045
>>
atom -> NAME
2045
.
atom -> NAME
2045
|
atom -> NAME
2045
is
atom -> NAME
2045
and
atom -> NAME
2045
//
atom -> NAME
2045
[
atom -> NAME
2045
/
atom -> NAME
2045
(
atom -> NAME
2045
<<
atom -> NAME
2045
if
atom -> NAME
2045
in
atom -> NAME
2046
]
or_test -> and_test
2046
for
or_test -> and_test
2046
or
2350
2046
if
or_test -> and_test
2047
-
2351
2047
+
2352
2047
]
arith_expr -> term
2047
|
arith_expr -> term
2047
>=
arith_expr -> term
2047
<=
arith_expr -> term
2047
not
arith_expr -> term
2047
==
arith_expr -> term
2047
for
arith_expr -> term
2047
in
arith_expr -> term
2047
>>
arith_expr -> term
2047
is
arith_expr -> term
2047
if
arith_expr -> term
2047
or
arith_expr -> term
2047
!=
arith_expr -> term
2047
>
arith_expr -> term
2047
and
arith_expr -> term
2047
<<
arith_expr -> term
2047
<
arith_expr -> term
2047
^
arith_expr -> term
2047
&
arith_expr -> term
2048
[
2031
2048
True
2033
2048
atom_expr
2034
2048
-
2038
2048
~
2035
2048
{
2039
2048
atom
2040
2048
(
2041
2048
power
2043
2048
STRING
2044
2048
NAME
2045
2048
factor
2353
2048
+
2048
2048
NUMBER
2051
2048
False
2052
2048
None
2056
2049
|
2354
2049
]
expr -> xor_expr
2049
>
expr -> xor_expr
2049
if
expr -> xor_expr
2049
for
expr -> xor_expr
2049
is
expr -> xor_expr
2049
and
expr -> xor_expr
2049
not
expr -> xor_expr
2049
or
expr -> xor_expr
2049
>=
expr -> xor_expr
2049
==
expr -> xor_expr
2049
<
expr -> xor_expr
2049
!=
expr -> xor_expr
2049
<=
expr -> xor_expr
2049
in
expr -> xor_expr
2050
^
and_expr -> shift_expr
2050
in
and_expr -> shift_expr
2050
|
and_expr -> shift_expr
2050
&
2355
2050
<
and_expr -> shift_expr
2050
not
and_expr -> shift_expr
2050
>=
and_expr -> shift_expr
2050
]
and_expr -> shift_expr
2050
for
and_expr -> shift_expr
2050
<=
and_expr -> shift_expr
2050
or
and_expr -> shift_expr
2050
and
and_expr -> shift_expr
2050
!=
and_expr -> shift_expr
2050
if
and_expr -> shift_expr
2050
is
and_expr -> shift_expr
2050
==
and_expr -> shift_expr
2050
>
and_expr -> shift_expr
2051
+
atom -> NUMBER
2051
*
atom -> NUMBER
2051
>
atom -> NUMBER
2051
<<
atom -> NUMBER
2051
for
atom -> NUMBER
2051
-
atom -> NUMBER
2051
**
atom -> NUMBER
2051
if
atom -> NUMBER
2051
or
atom -> NUMBER
2051
is
atom -> NUMBER
2051
[
atom -> NUMBER
2051
(
atom -> NUMBER
2051
not
atom -> NUMBER
2051
&
atom -> NUMBER
2051
^
atom -> NUMBER
2051
in
atom -> NUMBER
2051
==
atom -> NUMBER
2051
//
atom -> NUMBER
2051
!=
atom -> NUMBER
2051
and
atom -> NUMBER
2051
]
atom -> NUMBER
2051
%
atom -> NUMBER
2051
<=
atom -> NUMBER
2051
.
atom -> NUMBER
2051
<
atom -> NUMBER
2051
>>
atom -> NUMBER
2051
/
atom -> NUMBER
2051
@
atom -> NUMBER
2051
>=
atom -> NUMBER
2051
|
atom -> NUMBER
2052
for
atom -> False
2052
(
atom -> False
2052
*
atom -> False
2052
==
atom -> False
2052
|
atom -> False
2052
]
atom -> False
2052
[
atom -> False
2052
in
atom -> False
2052
&
atom -> False
2052
is
atom -> False
2052
not
atom -> False
2052
if
atom -> False
2052
^
atom -> False
2052
+
atom -> False
2052
>
atom -> False
2052
<=
atom -> False
2052
<<
atom -> False
2052
<
atom -> False
2052
>=
atom -> False
2052
%
atom -> False
2052
@
atom -> False
2052
and
atom -> False
2052
!=
atom -> False
2052
-
atom -> False
2052
.
atom -> False
2052
//
atom -> False
2052
/
atom -> False
2052
**
atom -> False
2052
>>
atom -> False
2052
or
atom -> False
2053
>
317
2053
is
318
2053
in
319
2053
<=
320
2053
<
321
2053
>=
322
2053
!=
324
2053
not
325
2053
==
326
2053
comp_op
2356
2053
for
comparison -> expr
2053
or
comparison -> expr
2053
if
comparison -> expr
2053
]
comparison -> expr
2053
and
comparison -> expr
2054
or
not_test -> comparison
2054
for
not_test -> comparison
2054
]
not_test -> comparison
2054
and
not_test -> comparison
2054
if
not_test -> comparison
2055
]
and_test -> not_test
2055
and
2357
2055
if
and_test -> not_test
2055
for
and_test -> not_test
2055
or
and_test -> not_test
2056
@
atom -> None
2056
<=
atom -> None
2056
in
atom -> None
2056
and
atom -> None
2056
for
atom -> None
2056
&
atom -> None
2056
|
atom -> None
2056
>
atom -> None
2056
>=
atom -> None
2056
/
atom -> None
2056
<<
atom -> None
2056
-
atom -> None
2056
!=
atom -> None
2056
**
atom -> None
2056
(
atom -> None
2056
]
atom -> None
2056
*
atom -> None
2056
.
atom -> None
2056
>>
atom -> None
2056
==
atom -> None
2056
is
atom -> None
2056
<
atom -> None
2056
if
atom -> None
2056
^
atom -> None
2056
[
atom -> None
2056
%
atom -> None
2056
+
atom -> None
2056
not
atom -> None
2056
or
atom -> None
2056
//
atom -> None
2057
comp_if
2358
2057
comp_iter
2359
2057
for
547
2057
comp_for
2360
2057
]
comp_iter -> 
2057
if
2361
2058
.
atom -> [ test_list_comp ]
2058
[
atom -> [ test_list_comp ]
2058
@
atom -> [ test_list_comp ]
2058
<=
atom -> [ test_list_comp ]
2058
<
atom -> [ test_list_comp ]
2058
not
atom -> [ test_list_comp ]
2058
]
atom -> [ test_list_comp ]
2058
in
atom -> [ test_list_comp ]
2058
and
atom -> [ test_list_comp ]
2058
-
atom -> [ test_list_comp ]
2058
if
atom -> [ test_list_comp ]
2058
!=
atom -> [ test_list_comp ]
2058
is
atom -> [ test_list_comp ]
2058
>>
atom -> [ test_list_comp ]
2058
or
atom -> [ test_list_comp ]
2058
//
atom -> [ test_list_comp ]
2058
/
atom -> [ test_list_comp ]
2058
,
atom -> [ test_list_comp ]
2058
|
atom -> [ test_list_comp ]
2058
>
atom -> [ test_list_comp ]
2058
&
atom -> [ test_list_comp ]
2058
(
atom -> [ test_list_comp ]
2058
%
atom -> [ test_list_comp ]
2058
>=
atom -> [ test_list_comp ]
2058
==
atom -> [ test_list_comp ]
2058
**
atom -> [ test_list_comp ]
2058
<<
atom -> [ test_list_comp ]
2058
^
atom -> [ test_list_comp ]
2058
+
atom -> [ test_list_comp ]
2058
*
atom -> [ test_list_comp ]
2059
]
term -> factor @ term
2059
<<
term -> factor @ term
2059
^
term -> factor @ term
2059
<=
term -> factor @ term
2059
==
term -> factor @ term
2059
if
term -> factor @ term
2059
|
term -> factor @ term
2059
!=
term -> factor @ term
2059
or
term -> factor @ term
2059
>
term -> factor @ term
2059
and
term -> factor @ term
2059
>>
term -> factor @ term
2059
is
term -> factor @ term
2059
-
term -> factor @ term
2059
not
term -> factor @ term
2059
+
term -> factor @ term
2059
in
term -> factor @ term
2059
>=
term -> factor @ term
2059
<
term -> factor @ term
2059
,
term -> factor @ term
2059
&
term -> factor @ term
2060
!=
term -> factor // term
2060
or
term -> factor // term
2060
^
term -> factor // term
2060
>
term -> factor // term
2060
is
term -> factor // term
2060
&
term -> factor // term
2060
-
term -> factor // term
2060
in
term -> factor // term
2060
>>
term -> factor // term
2060
|
term -> factor // term
2060
<
term -> factor // term
2060
>=
term -> factor // term
2060
not
term -> factor // term
2060
if
term -> factor // term
2060
==
term -> factor // term
2060
]
term -> factor // term
2060
<=
term -> factor // term
2060
,
term -> factor // term
2060
and
term -> factor // term
2060
<<
term -> factor // term
2060
+
term -> factor // term
2061
<=
term -> factor % term
2061
is
term -> factor % term
2061
>
term -> factor % term
2061
and
term -> factor % term
2061
in
term -> factor % term
2061
,
term -> factor % term
2061
or
term -> factor % term
2061
<
term -> factor % term
2061
-
term -> factor % term
2061
]
term -> factor % term
2061
!=
term -> factor % term
2061
>>
term -> factor % term
2061
^
term -> factor % term
2061
+
term -> factor % term
2061
if
term -> factor % term
2061
<<
term -> factor % term
2061
>=
term -> factor % term
2061
==
term -> factor % term
2061
not
term -> factor % term
2061
|
term -> factor % term
2061
&
term -> factor % term
2062
>>
term -> factor / term
2062
!=
term -> factor / term
2062
<
term -> factor / term
2062
<=
term -> factor / term
2062
|
term -> factor / term
2062
is
term -> factor / term
2062
>=
term -> factor / term
2062
^
term -> factor / term
2062
&
term -> factor / term
2062
]
term -> factor / term
2062
+
term -> factor / term
2062
<<
term -> factor / term
2062
and
term -> factor / term
2062
-
term -> factor / term
2062
in
term -> factor / term
2062
>
term -> factor / term
2062
or
term -> factor / term
2062
not
term -> factor / term
2062
==
term -> factor / term
2062
,
term -> factor / term
2062
if
term -> factor / term
2063
is
term -> factor * term
2063
+
term -> factor * term
2063
>=
term -> factor * term
2063
^
term -> factor * term
2063
,
term -> factor * term
2063
<=
term -> factor * term
2063
or
term -> factor * term
2063
]
term -> factor * term
2063
<
term -> factor * term
2063
|
term -> factor * term
2063
>>
term -> factor * term
2063
in
term -> factor * term
2063
not
term -> factor * term
2063
==
term -> factor * term
2063
-
term -> factor * term
2063
and
term -> factor * term
2063
!=
term -> factor * term
2063
<<
term -> factor * term
2063
>
term -> factor * term
2063
if
term -> factor * term
2063
&
term -> factor * term
2064
!=
power -> atom_expr ** factor
2064
@
power -> atom_expr ** factor
2064
|
power -> atom_expr ** factor
2064
in
power -> atom_expr ** factor
2064
==
power -> atom_expr ** factor
2064
if
power -> atom_expr ** factor
2064
and
power -> atom_expr ** factor
2064
>=
power -> atom_expr ** factor
2064
/
power -> atom_expr ** factor
2064
not
power -> atom_expr ** factor
2064
^
power -> atom_expr ** factor
2064
]
power -> atom_expr ** factor
2064
//
power -> atom_expr ** factor
2064
>
power -> atom_expr ** factor
2064
+
power -> atom_expr ** factor
2064
%
power -> atom_expr ** factor
2064
-
power -> atom_expr ** factor
2064
is
power -> atom_expr ** factor
2064
<=
power -> atom_expr ** factor
2064
<
power -> atom_expr ** factor
2064
,
power -> atom_expr ** factor
2064
*
power -> atom_expr ** factor
2064
<<
power -> atom_expr ** factor
2064
or
power -> atom_expr ** factor
2064
>>
power -> atom_expr ** factor
2064
&
power -> atom_expr ** factor
2065
not
xor_expr -> and_expr ^ xor_expr
2065
<
xor_expr -> and_expr ^ xor_expr
2065
,
xor_expr -> and_expr ^ xor_expr
2065
>=
xor_expr -> and_expr ^ xor_expr
2065
>
xor_expr -> and_expr ^ xor_expr
2065
is
xor_expr -> and_expr ^ xor_expr
2065
]
xor_expr -> and_expr ^ xor_expr
2065
!=
xor_expr -> and_expr ^ xor_expr
2065
and
xor_expr -> and_expr ^ xor_expr
2065
if
xor_expr -> and_expr ^ xor_expr
2065
<=
xor_expr -> and_expr ^ xor_expr
2065
in
xor_expr -> and_expr ^ xor_expr
2065
==
xor_expr -> and_expr ^ xor_expr
2065
|
xor_expr -> and_expr ^ xor_expr
2065
or
xor_expr -> and_expr ^ xor_expr
2066
<
and_expr -> shift_expr & and_expr
2066
if
and_expr -> shift_expr & and_expr
2066
>=
and_expr -> shift_expr & and_expr
2066
not
and_expr -> shift_expr & and_expr
2066
==
and_expr -> shift_expr & and_expr
2066
>
and_expr -> shift_expr & and_expr
2066
]
and_expr -> shift_expr & and_expr
2066
in
and_expr -> shift_expr & and_expr
2066
^
and_expr -> shift_expr & and_expr
2066
or
and_expr -> shift_expr & and_expr
2066
and
and_expr -> shift_expr & and_expr
2066
!=
and_expr -> shift_expr & and_expr
2066
,
and_expr -> shift_expr & and_expr
2066
|
and_expr -> shift_expr & and_expr
2066
is
and_expr -> shift_expr & and_expr
2066
<=
and_expr -> shift_expr & and_expr
2067
+
trailer -> ( )
2067
!=
trailer -> ( )
2067
<<
trailer -> ( )
2067
>=
trailer -> ( )
2067
**
trailer -> ( )
2067
not
trailer -> ( )
2067
if
trailer -> ( )
2067
,
trailer -> ( )
2067
|
trailer -> ( )
2067
[
trailer -> ( )
2067
==
trailer -> ( )
2067
%
trailer -> ( )
2067
*
trailer -> ( )
2067
>>
trailer -> ( )
2067
@
trailer -> ( )
2067
>
trailer -> ( )
2067
/
trailer -> ( )
2067
in
trailer -> ( )
2067
(
trailer -> ( )
2067
]
trailer -> ( )
2067
is
trailer -> ( )
2067
//
trailer -> ( )
2067
<
trailer -> ( )
2067
or
trailer -> ( )
2067
^
trailer -> ( )
2067
and
trailer -> ( )
2067
<=
trailer -> ( )
2067
.
trailer -> ( )
2067
-
trailer -> ( )
2067
&
trailer -> ( )
2068
)
2362
2069
<=
trailer_expr -> trailer trailer_expr
2069
+
trailer_expr -> trailer trailer_expr
2069
^
trailer_expr -> trailer trailer_expr
2069
or
trailer_expr -> trailer trailer_expr
2069
==
trailer_expr -> trailer trailer_expr
2069
%
trailer_expr -> trailer trailer_expr
2069
@
trailer_expr -> trailer trailer_expr
2069
]
trailer_expr -> trailer trailer_expr
2069
not
trailer_expr -> trailer trailer_expr
2069
<<
trailer_expr -> trailer trailer_expr
2069
-
trailer_expr -> trailer trailer_expr
2069
//
trailer_expr -> trailer trailer_expr
2069
and
trailer_expr -> trailer trailer_expr
2069
|
trailer_expr -> trailer trailer_expr
2069
if
trailer_expr -> trailer trailer_expr
2069
>
trailer_expr -> trailer trailer_expr
2069
!=
trailer_expr -> trailer trailer_expr
2069
,
trailer_expr -> trailer trailer_expr
2069
<
trailer_expr -> trailer trailer_expr
2069
>>
trailer_expr -> trailer trailer_expr
2069
/
trailer_expr -> trailer trailer_expr
2069
is
trailer_expr -> trailer trailer_expr
2069
&
trailer_expr -> trailer trailer_expr
2069
in
trailer_expr -> trailer trailer_expr
2069
>=
trailer_expr -> trailer trailer_expr
2069
*
trailer_expr -> trailer trailer_expr
2069
**
trailer_expr -> trailer trailer_expr
2070
.
trailer -> . NAME
2070
not
trailer -> . NAME
2070
if
trailer -> . NAME
2070
**
trailer -> . NAME
2070
|
trailer -> . NAME
2070
-
trailer -> . NAME
2070
(
trailer -> . NAME
2070
%
trailer -> . NAME
2070
//
trailer -> . NAME
2070
==
trailer -> . NAME
2070
>>
trailer -> . NAME
2070
is
trailer -> . NAME
2070
!=
trailer -> . NAME
2070
and
trailer -> . NAME
2070
>=
trailer -> . NAME
2070
,
trailer -> . NAME
2070
>
trailer -> . NAME
2070
in
trailer -> . NAME
2070
<<
trailer -> . NAME
2070
&
trailer -> . NAME
2070
/
trailer -> . NAME
2070
^
trailer -> . NAME
2070
[
trailer -> . NAME
2070
<=
trailer -> . NAME
2070
]
trailer -> . NAME
2070
or
trailer -> . NAME
2070
+
trailer -> . NAME
2070
<
trailer -> . NAME
2070
*
trailer -> . NAME
2070
@
trailer -> . NAME
2071
]
2363
2072
>
atom -> ( test_list_comp )
2072
@
atom -> ( test_list_comp )
2072
&
atom -> ( test_list_comp )
2072
[
atom -> ( test_list_comp )
2072
if
atom -> ( test_list_comp )
2072
==
atom -> ( test_list_comp )
2072
>=
atom -> ( test_list_comp )
2072
**
atom -> ( test_list_comp )
2072
not
atom -> ( test_list_comp )
2072
<<
atom -> ( test_list_comp )
2072
>>
atom -> ( test_list_comp )
2072
in
atom -> ( test_list_comp )
2072
or
atom -> ( test_list_comp )
2072
]
atom -> ( test_list_comp )
2072
/
atom -> ( test_list_comp )
2072
.
atom -> ( test_list_comp )
2072
^
atom -> ( test_list_comp )
2072
is
atom -> ( test_list_comp )
2072
,
atom -> ( test_list_comp )
2072
and
atom -> ( test_list_comp )
2072
//
atom -> ( test_list_comp )
2072
<
atom -> ( test_list_comp )
2072
*
atom -> ( test_list_comp )
2072
<=
atom -> ( test_list_comp )
2072
(
atom -> ( test_list_comp )
2072
-
atom -> ( test_list_comp )
2072
|
atom -> ( test_list_comp )
2072
!=
atom -> ( test_list_comp )
2072
+
atom -> ( test_list_comp )
2072
%
atom -> ( test_list_comp )
2073
==
shift_expr -> arith_expr >> shift_expr
2073
^
shift_expr -> arith_expr >> shift_expr
2073
or
shift_expr -> arith_expr >> shift_expr
2073
if
shift_expr -> arith_expr >> shift_expr
2073
,
shift_expr -> arith_expr >> shift_expr
2073
not
shift_expr -> arith_expr >> shift_expr
2073
|
shift_expr -> arith_expr >> shift_expr
2073
<=
shift_expr -> arith_expr >> shift_expr
2073
]
shift_expr -> arith_expr >> shift_expr
2073
in
shift_expr -> arith_expr >> shift_expr
2073
is
shift_expr -> arith_expr >> shift_expr
2073
>=
shift_expr -> arith_expr >> shift_expr
2073
>
shift_expr -> arith_expr >> shift_expr
2073
&
shift_expr -> arith_expr >> shift_expr
2073
<
shift_expr -> arith_expr >> shift_expr
2073
and
shift_expr -> arith_expr >> shift_expr
2073
!=
shift_expr -> arith_expr >> shift_expr
2074
or
shift_expr -> arith_expr << shift_expr
2074
]
shift_expr -> arith_expr << shift_expr
2074
in
shift_expr -> arith_expr << shift_expr
2074
>
shift_expr -> arith_expr << shift_expr
2074
&
shift_expr -> arith_expr << shift_expr
2074
is
shift_expr -> arith_expr << shift_expr
2074
<
shift_expr -> arith_expr << shift_expr
2074
<=
shift_expr -> arith_expr << shift_expr
2074
not
shift_expr -> arith_expr << shift_expr
2074
^
shift_expr -> arith_expr << shift_expr
2074
if
shift_expr -> arith_expr << shift_expr
2074
,
shift_expr -> arith_expr << shift_expr
2074
and
shift_expr -> arith_expr << shift_expr
2074
|
shift_expr -> arith_expr << shift_expr
2074
!=
shift_expr -> arith_expr << shift_expr
2074
==
shift_expr -> arith_expr << shift_expr
2074
>=
shift_expr -> arith_expr << shift_expr
2075
if
or_test -> and_test or or_test
2075
]
or_test -> and_test or or_test
2075
,
or_test -> and_test or or_test
2076
^
arith_expr -> term - arith_expr
2076
!=
arith_expr -> term - arith_expr
2076
<
arith_expr -> term - arith_expr
2076
in
arith_expr -> term - arith_expr
2076
==
arith_expr -> term - arith_expr
2076
|
arith_expr -> term - arith_expr
2076
is
arith_expr -> term - arith_expr
2076
&
arith_expr -> term - arith_expr
2076
>>
arith_expr -> term - arith_expr
2076
]
arith_expr -> term - arith_expr
2076
<<
arith_expr -> term - arith_expr
2076
and
arith_expr -> term - arith_expr
2076
,
arith_expr -> term - arith_expr
2076
>
arith_expr -> term - arith_expr
2076
if
arith_expr -> term - arith_expr
2076
not
arith_expr -> term - arith_expr
2076
>=
arith_expr -> term - arith_expr
2076
<=
arith_expr -> term - arith_expr
2076
or
arith_expr -> term - arith_expr
2077
>=
arith_expr -> term + arith_expr
2077
>
arith_expr -> term + arith_expr
2077
^
arith_expr -> term + arith_expr
2077
or
arith_expr -> term + arith_expr
2077
==
arith_expr -> term + arith_expr
2077
<=
arith_expr -> term + arith_expr
2077
if
arith_expr -> term + arith_expr
2077
]
arith_expr -> term + arith_expr
2077
>>
arith_expr -> term + arith_expr
2077
<
arith_expr -> term + arith_expr
2077
not
arith_expr -> term + arith_expr
2077
&
arith_expr -> term + arith_expr
2077
in
arith_expr -> term + arith_expr
2077
and
arith_expr -> term + arith_expr
2077
,
arith_expr -> term + arith_expr
2077
|
arith_expr -> term + arith_expr
2077
!=
arith_expr -> term + arith_expr
2077
<<
arith_expr -> term + arith_expr
2077
is
arith_expr -> term + arith_expr
2078
>=
expr -> xor_expr | expr
2078
,
expr -> xor_expr | expr
2078
or
expr -> xor_expr | expr
2078
in
expr -> xor_expr | expr
2078
]
expr -> xor_expr | expr
2078
and
expr -> xor_expr | expr
2078
==
expr -> xor_expr | expr
2078
>
expr -> xor_expr | expr
2078
<=
expr -> xor_expr | expr
2078
is
expr -> xor_expr | expr
2078
<
expr -> xor_expr | expr
2078
if
expr -> xor_expr | expr
2078
not
expr -> xor_expr | expr
2078
!=
expr -> xor_expr | expr
2079
,
and_test -> not_test and and_test
2079
if
and_test -> not_test and and_test
2079
or
and_test -> not_test and and_test
2079
]
and_test -> not_test and and_test
2080
or
comparison -> expr comp_op comparison
2080
if
comparison -> expr comp_op comparison
2080
and
comparison -> expr comp_op comparison
2080
]
comparison -> expr comp_op comparison
2080
,
comparison -> expr comp_op comparison
2081
[
1052
2081
factor
1053
2081
True
1054
2081
atom_expr
1055
2081
~
1056
2081
not
1057
2081
and_expr
1058
2081
-
1059
2081
shift_expr
1060
2081
atom
1061
2081
{
1062
2081
comparison
1063
2081
(
1064
2081
arith_expr
1065
2081
power
1066
2081
STRING
1067
2081
NAME
1068
2081
and_test
1069
2081
term
1071
2081
+
1072
2081
xor_expr
1073
2081
NUMBER
1074
2081
False
1075
2081
not_test
1076
2081
None
1077
2081
expr
1078
2081
lambda
1079
2081
or_test
1080
2081
lambdef
1081
2081
test
2364
2082
,
lambdef -> lambda : test
2082
]
lambdef -> lambda : test
2083
else
2365
2084
for
test -> or_test if or_test else test
2084
,
test -> or_test if or_test else test
2084
]
test -> or_test if or_test else test
2085
endsim
classdef -> class NAME ( ) : suite
2085
conf
classdef -> class NAME ( ) : suite
2085
servmod
classdef -> class NAME ( ) : suite
2085
+
classdef -> class NAME ( ) : suite
2085
@
classdef -> class NAME ( ) : suite
2085
NAME
classdef -> class NAME ( ) : suite
2085
~
classdef -> class NAME ( ) : suite
2085
[
classdef -> class NAME ( ) : suite
2085
break
classdef -> class NAME ( ) : suite
2085
modopt
classdef -> class NAME ( ) : suite
2085
for
classdef -> class NAME ( ) : suite
2085
begsim
classdef -> class NAME ( ) : suite
2085
if
classdef -> class NAME ( ) : suite
2085
assert
classdef -> class NAME ( ) : suite
2085
class
classdef -> class NAME ( ) : suite
2085
continue
classdef -> class NAME ( ) : suite
2085
pass
classdef -> class NAME ( ) : suite
2085
-
classdef -> class NAME ( ) : suite
2085
raise
classdef -> class NAME ( ) : suite
2085
None
classdef -> class NAME ( ) : suite
2085
return
classdef -> class NAME ( ) : suite
2085
yield
classdef -> class NAME ( ) : suite
2085
NEWLINE
classdef -> class NAME ( ) : suite
2085
def
classdef -> class NAME ( ) : suite
2085
$
classdef -> class NAME ( ) : suite
2085
del
classdef -> class NAME ( ) : suite
2085
while
classdef -> class NAME ( ) : suite
2085
{
classdef -> class NAME ( ) : suite
2085
resetstats
classdef -> class NAME ( ) : suite
2085
lambda
classdef -> class NAME ( ) : suite
2085
with
classdef -> class NAME ( ) : suite
2085
(
classdef -> class NAME ( ) : suite
2085
try
classdef -> class NAME ( ) : suite
2085
STRING
classdef -> class NAME ( ) : suite
2085
not
classdef -> class NAME ( ) : suite
2085
nonlocal
classdef -> class NAME ( ) : suite
2085
server
classdef -> class NAME ( ) : suite
2085
True
classdef -> class NAME ( ) : suite
2085
global
classdef -> class NAME ( ) : suite
2085
NUMBER
classdef -> class NAME ( ) : suite
2085
False
classdef -> class NAME ( ) : suite
2086
arith_expr
1
2086
suite
2366
2086
small_stmt
20
2086
factor
17
2086
atom_expr
31
2086
term
22
2086
-
26
2086
True
38
2086
None
55
2086
atom
57
2086
test
5
2086
comparison
49
2086
and_expr
8
2086
power
9
2086
STRING
10
2086
NAME
52
2086
shift_expr
48
2086
lambdef
15
2086
NUMBER
58
2086
simple_stmt
1094
2086
(
16
2086
expr
47
2086
[
18
2086
NEWLINE
1095
2086
not_test
32
2086
{
21
2086
and_test
46
2086
+
27
2086
lambda
29
2086
xor_expr
41
2086
yield
34
2086
not
62
2086
test_list
36
2086
~
37
2086
or_test
53
2086
False
39
2086
sim_stmt
45
2086
nonlocal
72
2086
nonlocal_stmt
73
2086
return
59
2086
break_stmt
60
2086
return_stmt
61
2086
raise_stmt
74
2086
break
63
2086
yield_stmt
75
2086
raise
64
2086
continue
77
2086
expr_stmt
65
2086
endsim
78
2086
del
80
2086
pass_stmt
81
2086
flow_stmt
82
2086
stat_stmt
66
2086
assert_stmt
68
2086
resetstats
84
2086
del_stmt
85
2086
continue_stmt
86
2086
begsim
69
2086
global_stmt
87
2086
pass
88
2086
global
70
2086
assert
71
2087
DEDENT
2367
2088
arith_expr
1
2088
small_stmt
20
2088
factor
17
2088
True
38
2088
atom_expr
31
2088
term
22
2088
-
26
2088
None
55
2088
atom
57
2088
test
5
2088
comparison
49
2088
and_expr
8
2088
power
9
2088
STRING
10
2088
NAME
52
2088
shift_expr
48
2088
lambdef
15
2088
NUMBER
58
2088
simple_stmt
1094
2088
(
16
2088
expr
47
2088
[
18
2088
NEWLINE
1095
2088
not_test
32
2088
{
21
2088
and_test
46
2088
suite
2368
2088
+
27
2088
lambda
29
2088
xor_expr
41
2088
yield
34
2088
not
62
2088
test_list
36
2088
~
37
2088
or_test
53
2088
False
39
2088
sim_stmt
45
2088
nonlocal
72
2088
nonlocal_stmt
73
2088
return
59
2088
break_stmt
60
2088
return_stmt
61
2088
raise_stmt
74
2088
break
63
2088
yield_stmt
75
2088
raise
64
2088
continue
77
2088
expr_stmt
65
2088
endsim
78
2088
del
80
2088
pass_stmt
81
2088
flow_stmt
82
2088
stat_stmt
66
2088
assert_stmt
68
2088
resetstats
84
2088
del_stmt
85
2088
continue_stmt
86
2088
begsim
69
2088
global_stmt
87
2088
pass
88
2088
global
70
2088
assert
71
2089
{
funcdef -> def NAME ( ) : suite
2089
conf
funcdef -> def NAME ( ) : suite
2089
try
funcdef -> def NAME ( ) : suite
2089
yield
funcdef -> def NAME ( ) : suite
2089
server
funcdef -> def NAME ( ) : suite
2089
STRING
funcdef -> def NAME ( ) : suite
2089
while
funcdef -> def NAME ( ) : suite
2089
servmod
funcdef -> def NAME ( ) : suite
2089
(
funcdef -> def NAME ( ) : suite
2089
lambda
funcdef -> def NAME ( ) : suite
2089
False
funcdef -> def NAME ( ) : suite
2089
continue
funcdef -> def NAME ( ) : suite
2089
begsim
funcdef -> def NAME ( ) : suite
2089
class
funcdef -> def NAME ( ) : suite
2089
[
funcdef -> def NAME ( ) : suite
2089
$
funcdef -> def NAME ( ) : suite
2089
~
funcdef -> def NAME ( ) : suite
2089
del
funcdef -> def NAME ( ) : suite
2089
NUMBER
funcdef -> def NAME ( ) : suite
2089
assert
funcdef -> def NAME ( ) : suite
2089
resetstats
funcdef -> def NAME ( ) : suite
2089
return
funcdef -> def NAME ( ) : suite
2089
with
funcdef -> def NAME ( ) : suite
2089
raise
funcdef -> def NAME ( ) : suite
2089
for
funcdef -> def NAME ( ) : suite
2089
def
funcdef -> def NAME ( ) : suite
2089
endsim
funcdef -> def NAME ( ) : suite
2089
NAME
funcdef -> def NAME ( ) : suite
2089
nonlocal
funcdef -> def NAME ( ) : suite
2089
global
funcdef -> def NAME ( ) : suite
2089
NEWLINE
funcdef -> def NAME ( ) : suite
2089
True
funcdef -> def NAME ( ) : suite
2089
if
funcdef -> def NAME ( ) : suite
2089
modopt
funcdef -> def NAME ( ) : suite
2089
not
funcdef -> def NAME ( ) : suite
2089
-
funcdef -> def NAME ( ) : suite
2089
None
funcdef -> def NAME ( ) : suite
2089
+
funcdef -> def NAME ( ) : suite
2089
@
funcdef -> def NAME ( ) : suite
2089
break
funcdef -> def NAME ( ) : suite
2089
pass
funcdef -> def NAME ( ) : suite
2090
[
166
2090
factor
167
2090
True
168
2090
atom_expr
169
2090
~
170
2090
not
171
2090
and_expr
172
2090
-
173
2090
{
174
2090
shift_expr
175
2090
atom
176
2090
]
2369
2090
comparison
178
2090
(
179
2090
arith_expr
180
2090
power
181
2090
STRING
182
2090
NAME
183
2090
test
184
2090
and_test
185
2090
term
186
2090
+
187
2090
xor_expr
188
2090
NUMBER
190
2090
test_list_comp
2370
2090
False
191
2090
expr
192
2090
not_test
193
2090
None
194
2090
lambdef
195
2090
lambda
196
2090
or_test
197
2090
test_list
198
2091
not
term -> factor
2091
@
2371
2091
%
2372
2091
/
2373
2091
*
2374
2091
//
2375
2091
<=
term -> factor
2091
)
term -> factor
2091
>
term -> factor
2091
==
term -> factor
2091
is
term -> factor
2091
or
term -> factor
2091
<
term -> factor
2091
and
term -> factor
2091
<<
term -> factor
2091
^
term -> factor
2091
!=
term -> factor
2091
-
term -> factor
2091
&
term -> factor
2091
|
term -> factor
2091
,
term -> factor
2091
>=
term -> factor
2091
if
term -> factor
2091
=
term -> factor
2091
+
term -> factor
2091
in
term -> factor
2091
>>
term -> factor
2092
<<
atom -> True
2092
&
atom -> True
2092
or
atom -> True
2092
[
atom -> True
2092
if
atom -> True
2092
-
atom -> True
2092
*
atom -> True
2092
^
atom -> True
2092
,
atom -> True
2092
>=
atom -> True
2092
!=
atom -> True
2092
=
atom -> True
2092
(
atom -> True
2092
not
atom -> True
2092
|
atom -> True
2092
)
atom -> True
2092
+
atom -> True
2092
**
atom -> True
2092
.
atom -> True
2092
is
atom -> True
2092
//
atom -> True
2092
>
atom -> True
2092
%
atom -> True
2092
in
atom -> True
2092
<=
atom -> True
2092
>>
atom -> True
2092
/
atom -> True
2092
==
atom -> True
2092
and
atom -> True
2092
<
atom -> True
2092
@
atom -> True
2093
=
power -> atom_expr
2093
**
2376
2093
,
power -> atom_expr
2093
)
power -> atom_expr
2093
!=
power -> atom_expr
2093
-
power -> atom_expr
2093
<<
power -> atom_expr
2093
not
power -> atom_expr
2093
/
power -> atom_expr
2093
<=
power -> atom_expr
2093
in
power -> atom_expr
2093
%
power -> atom_expr
2093
>
power -> atom_expr
2093
@
power -> atom_expr
2093
|
power -> atom_expr
2093
<
power -> atom_expr
2093
>>
power -> atom_expr
2093
or
power -> atom_expr
2093
and
power -> atom_expr
2093
>=
power -> atom_expr
2093
==
power -> atom_expr
2093
^
power -> atom_expr
2093
*
power -> atom_expr
2093
&
power -> atom_expr
2093
is
power -> atom_expr
2093
+
power -> atom_expr
2093
if
power -> atom_expr
2093
//
power -> atom_expr
2094
[
2090
2094
True
2092
2094
atom_expr
2093
2094
-
2096
2094
~
2094
2094
atom
2098
2094
{
2099
2094
power
2103
2094
STRING
2104
2094
NAME
2105
2094
(
2106
2094
+
2108
2094
NUMBER
2111
2094
False
2113
2094
factor
2377
2094
None
2115
2095
>
xor_expr -> and_expr
2095
^
2378
2095
<=
xor_expr -> and_expr
2095
not
xor_expr -> and_expr
2095
|
xor_expr -> and_expr
2095
==
xor_expr -> and_expr
2095
,
xor_expr -> and_expr
2095
in
xor_expr -> and_expr
2095
!=
xor_expr -> and_expr
2095
if
xor_expr -> and_expr
2095
is
xor_expr -> and_expr
2095
<
xor_expr -> and_expr
2095
or
xor_expr -> and_expr
2095
=
xor_expr -> and_expr
2095
)
xor_expr -> and_expr
2095
and
xor_expr -> and_expr
2095
>=
xor_expr -> and_expr
2096
[
2090
2096
True
2092
2096
atom_expr
2093
2096
~
2094
2096
-
2096
2096
atom
2098
2096
{
2099
2096
power
2103
2096
STRING
2104
2096
NAME
2105
2096
(
2106
2096
factor
2379
2096
+
2108
2096
NUMBER
2111
2096
False
2113
2096
None
2115
2097
^
and_expr -> shift_expr
2097
in
and_expr -> shift_expr
2097
|
and_expr -> shift_expr
2097
&
2380
2097
<
and_expr -> shift_expr
2097
not
and_expr -> shift_expr
2097
>=
and_expr -> shift_expr
2097
<=
and_expr -> shift_expr
2097
or
and_expr -> shift_expr
2097
and
and_expr -> shift_expr
2097
,
and_expr -> shift_expr
2097
!=
and_expr -> shift_expr
2097
if
and_expr -> shift_expr
2097
is
and_expr -> shift_expr
2097
==
and_expr -> shift_expr
2097
>
and_expr -> shift_expr
2097
)
and_expr -> shift_expr
2097
=
and_expr -> shift_expr
2098
>>
trailer_expr -> 
2098
.
2381
2098
(
2382
2098
trailer
2383
2098
)
trailer_expr -> 
2098
trailer_expr
2384
2098
+
trailer_expr -> 
2098
[
2385
2098
is
trailer_expr -> 
2098
>
trailer_expr -> 
2098
not
trailer_expr -> 
2098
|
trailer_expr -> 
2098
=
trailer_expr -> 
2098
&
trailer_expr -> 
2098
/
trailer_expr -> 
2098
@
trailer_expr -> 
2098
!=
trailer_expr -> 
2098
**
trailer_expr -> 
2098
>=
trailer_expr -> 
2098
^
trailer_expr -> 
2098
in
trailer_expr -> 
2098
<<
trailer_expr -> 
2098
and
trailer_expr -> 
2098
or
trailer_expr -> 
2098
if
trailer_expr -> 
2098
//
trailer_expr -> 
2098
%
trailer_expr -> 
2098
,
trailer_expr -> 
2098
<=
trailer_expr -> 
2098
<
trailer_expr -> 
2098
==
trailer_expr -> 
2098
-
trailer_expr -> 
2098
*
trailer_expr -> 
2099
}
2386
2100
or
not_test -> comparison
2100
)
not_test -> comparison
2100
,
not_test -> comparison
2100
=
not_test -> comparison
2100
and
not_test -> comparison
2100
if
not_test -> comparison
2101
=
or_test -> and_test
2101
or
2387
2101
,
or_test -> and_test
2101
if
or_test -> and_test
2101
)
or_test -> and_test
2102
>>
2388
2102
if
shift_expr -> arith_expr
2102
&
shift_expr -> arith_expr
2102
<<
2389
2102
|
shift_expr -> arith_expr
2102
is
shift_expr -> arith_expr
2102
<
shift_expr -> arith_expr
2102
==
shift_expr -> arith_expr
2102
=
shift_expr -> arith_expr
2102
or
shift_expr -> arith_expr
2102
>
shift_expr -> arith_expr
2102
)
shift_expr -> arith_expr
2102
!=
shift_expr -> arith_expr
2102
>=
shift_expr -> arith_expr
2102
in
shift_expr -> arith_expr
2102
,
shift_expr -> arith_expr
2102
<=
shift_expr -> arith_expr
2102
and
shift_expr -> arith_expr
2102
^
shift_expr -> arith_expr
2102
not
shift_expr -> arith_expr
2103
+
factor -> power
2103
%
factor -> power
2103
=
factor -> power
2103
,
factor -> power
2103
<
factor -> power
2103
<<
factor -> power
2103
!=
factor -> power
2103
<=
factor -> power
2103
and
factor -> power
2103
/
factor -> power
2103
^
factor -> power
2103
@
factor -> power
2103
>=
factor -> power
2103
not
factor -> power
2103
//
factor -> power
2103
or
factor -> power
2103
==
factor -> power
2103
is
factor -> power
2103
|
factor -> power
2103
)
factor -> power
2103
*
factor -> power
2103
-
factor -> power
2103
if
factor -> power
2103
>
factor -> power
2103
in
factor -> power
2103
>>
factor -> power
2103
&
factor -> power
2104
%
atom -> STRING
2104
>
atom -> STRING
2104
@
atom -> STRING
2104
<<
atom -> STRING
2104
in
atom -> STRING
2104
[
atom -> STRING
2104
-
atom -> STRING
2104
==
atom -> STRING
2104
>=
atom -> STRING
2104
not
atom -> STRING
2104
/
atom -> STRING
2104
+
atom -> STRING
2104
=
atom -> STRING
2104
*
atom -> STRING
2104
)
atom -> STRING
2104
(
atom -> STRING
2104
//
atom -> STRING
2104
if
atom -> STRING
2104
.
atom -> STRING
2104
<
atom -> STRING
2104
,
atom -> STRING
2104
&
atom -> STRING
2104
<=
atom -> STRING
2104
!=
atom -> STRING
2104
**
atom -> STRING
2104
^
atom -> STRING
2104
and
atom -> STRING
2104
is
atom -> STRING
2104
|
atom -> STRING
2104
or
atom -> STRING
2104
>>
atom -> STRING
2105
)
atom -> NAME
2105
<
atom -> NAME
2105
,
atom -> NAME
2105
^
atom -> NAME
2105
+
atom -> NAME
2105
-
atom -> NAME
2105
>=
atom -> NAME
2105
@
atom -> NAME
2105
!=
atom -> NAME
2105
*
atom -> NAME
2105
=
atom -> NAME
2105
<=
atom -> NAME
2105
**
atom -> NAME
2105
or
atom -> NAME
2105
not
atom -> NAME
2105
==
atom -> NAME
2105
&
atom -> NAME
2105
>
atom -> NAME
2105
%
atom -> NAME
2105
>>
atom -> NAME
2105
.
atom -> NAME
2105
|
atom -> NAME
2105
is
atom -> NAME
2105
and
atom -> NAME
2105
//
atom -> NAME
2105
[
atom -> NAME
2105
/
atom -> NAME
2105
(
atom -> NAME
2105
<<
atom -> NAME
2105
if
atom -> NAME
2105
in
atom -> NAME
2106
[
128
2106
factor
129
2106
True
130
2106
atom_expr
131
2106
~
132
2106
and_expr
133
2106
-
134
2106
{
135
2106
test_list_comp
2390
2106
shift_expr
137
2106
atom
138
2106
)
2391
2106
comparison
140
2106
arith_expr
141
2106
power
142
2106
STRING
143
2106
NAME
144
2106
(
145
2106
and_test
146
2106
term
147
2106
+
148
2106
xor_expr
149
2106
or_test
150
2106
NUMBER
151
2106
not
152
2106
False
153
2106
expr
154
2106
not_test
155
2106
None
156
2106
lambdef
157
2106
lambda
158
2106
test
159
2106
test_list
160
2107
-
2392
2107
+
2393
2107
|
arith_expr -> term
2107
>=
arith_expr -> term
2107
<=
arith_expr -> term
2107
not
arith_expr -> term
2107
,
arith_expr -> term
2107
==
arith_expr -> term
2107
)
arith_expr -> term
2107
in
arith_expr -> term
2107
>>
arith_expr -> term
2107
is
arith_expr -> term
2107
if
arith_expr -> term
2107
or
arith_expr -> term
2107
!=
arith_expr -> term
2107
>
arith_expr -> term
2107
=
arith_expr -> term
2107
and
arith_expr -> term
2107
<<
arith_expr -> term
2107
<
arith_expr -> term
2107
^
arith_expr -> term
2107
&
arith_expr -> term
2108
[
2090
2108
True
2092
2108
atom_expr
2093
2108
-
2096
2108
~
2094
2108
atom
2098
2108
{
2099
2108
power
2103
2108
STRING
2104
2108
NAME
2105
2108
(
2106
2108
factor
2394
2108
+
2108
2108
NUMBER
2111
2108
False
2113
2108
None
2115
2109
|
2395
2109
>
expr -> xor_expr
2109
if
expr -> xor_expr
2109
is
expr -> xor_expr
2109
and
expr -> xor_expr
2109
)
expr -> xor_expr
2109
=
expr -> xor_expr
2109
not
expr -> xor_expr
2109
or
expr -> xor_expr
2109
>=
expr -> xor_expr
2109
==
expr -> xor_expr
2109
,
expr -> xor_expr
2109
<
expr -> xor_expr
2109
!=
expr -> xor_expr
2109
<=
expr -> xor_expr
2109
in
expr -> xor_expr
2110
=
test -> or_test
2110
)
test -> or_test
2110
if
2396
2110
,
test -> or_test
2111
+
atom -> NUMBER
2111
*
atom -> NUMBER
2111
>
atom -> NUMBER
2111
<<
atom -> NUMBER
2111
-
atom -> NUMBER
2111
**
atom -> NUMBER
2111
if
atom -> NUMBER
2111
or
atom -> NUMBER
2111
is
atom -> NUMBER
2111
=
atom -> NUMBER
2111
[
atom -> NUMBER
2111
(
atom -> NUMBER
2111
not
atom -> NUMBER
2111
&
atom -> NUMBER
2111
)
atom -> NUMBER
2111
^
atom -> NUMBER
2111
in
atom -> NUMBER
2111
==
atom -> NUMBER
2111
//
atom -> NUMBER
2111
!=
atom -> NUMBER
2111
and
atom -> NUMBER
2111
%
atom -> NUMBER
2111
<=
atom -> NUMBER
2111
.
atom -> NUMBER
2111
<
atom -> NUMBER
2111
>>
atom -> NUMBER
2111
,
atom -> NUMBER
2111
/
atom -> NUMBER
2111
@
atom -> NUMBER
2111
>=
atom -> NUMBER
2111
|
atom -> NUMBER
2112
[
2090
2112
factor
2091
2112
True
2092
2112
atom_expr
2093
2112
~
2094
2112
and_expr
2095
2112
-
2096
2112
shift_expr
2097
2112
atom
2098
2112
{
2099
2112
comparison
2100
2112
arith_expr
2102
2112
power
2103
2112
STRING
2104
2112
NAME
2105
2112
(
2106
2112
term
2107
2112
+
2108
2112
xor_expr
2109
2112
NUMBER
2111
2112
not
2112
2112
False
2113
2112
not_test
2397
2112
None
2115
2112
expr
2116
2113
(
atom -> False
2113
*
atom -> False
2113
==
atom -> False
2113
|
atom -> False
2113
,
atom -> False
2113
[
atom -> False
2113
in
atom -> False
2113
&
atom -> False
2113
=
atom -> False
2113
is
atom -> False
2113
not
atom -> False
2113
if
atom -> False
2113
^
atom -> False
2113
+
atom -> False
2113
)
atom -> False
2113
>
atom -> False
2113
<=
atom -> False
2113
<<
atom -> False
2113
<
atom -> False
2113
>=
atom -> False
2113
%
atom -> False
2113
@
atom -> False
2113
and
atom -> False
2113
!=
atom -> False
2113
-
atom -> False
2113
.
atom -> False
2113
//
atom -> False
2113
/
atom -> False
2113
**
atom -> False
2113
>>
atom -> False
2113
or
atom -> False
2114
and
2398
2114
,
and_test -> not_test
2114
if
and_test -> not_test
2114
)
and_test -> not_test
2114
or
and_test -> not_test
2114
=
and_test -> not_test
2115
@
atom -> None
2115
<=
atom -> None
2115
in
atom -> None
2115
and
atom -> None
2115
&
atom -> None
2115
|
atom -> None
2115
>
atom -> None
2115
)
atom -> None
2115
>=
atom -> None
2115
/
atom -> None
2115
<<
atom -> None
2115
-
atom -> None
2115
!=
atom -> None
2115
**
atom -> None
2115
(
atom -> None
2115
*
atom -> None
2115
=
atom -> None
2115
.
atom -> None
2115
>>
atom -> None
2115
==
atom -> None
2115
is
atom -> None
2115
<
atom -> None
2115
if
atom -> None
2115
^
atom -> None
2115
[
atom -> None
2115
%
atom -> None
2115
+
atom -> None
2115
not
atom -> None
2115
,
atom -> None
2115
or
atom -> None
2115
//
atom -> None
2116
>
317
2116
is
318
2116
in
319
2116
<=
320
2116
<
321
2116
>=
322
2116
!=
324
2116
not
325
2116
==
326
2116
=
comparison -> expr
2116
comp_op
2399
2116
or
comparison -> expr
2116
if
comparison -> expr
2116
)
comparison -> expr
2116
and
comparison -> expr
2116
,
comparison -> expr
2117
varargslist
2400
2117
vfpdef
234
2117
:
2401
2117
NAME
233
2118
,
test -> lambdef
2118
=
test -> lambdef
2118
)
test -> lambdef
2119
,
tfpdef -> NAME : test
2119
=
tfpdef -> NAME : test
2119
)
tfpdef -> NAME : test
2120
[
1002
2120
factor
1003
2120
True
1004
2120
atom_expr
1005
2120
~
1006
2120
and_expr
1007
2120
-
1008
2120
shift_expr
1009
2120
atom
1010
2120
{
1011
2120
comparison
1012
2120
arith_expr
1013
2120
power
1014
2120
STRING
1015
2120
NAME
1016
2120
(
1017
2120
and_test
1018
2120
term
1019
2120
+
1020
2120
xor_expr
1021
2120
or_test
1022
2120
NUMBER
1023
2120
not
1024
2120
False
1025
2120
not_test
1026
2120
None
1027
2120
expr
1028
2120
lambda
1029
2120
lambdef
1031
2120
test
2402
2121
)
param -> tfpdef = test
2121
,
param -> tfpdef = test
2122
)
parameters -> param , parameters
2123
DEDENT
2403
2124
.
atom -> [ test_list_comp ]
2124
[
atom -> [ test_list_comp ]
2124
@
atom -> [ test_list_comp ]
2124
<=
atom -> [ test_list_comp ]
2124
<
atom -> [ test_list_comp ]
2124
not
atom -> [ test_list_comp ]
2124
in
atom -> [ test_list_comp ]
2124
and
atom -> [ test_list_comp ]
2124
-
atom -> [ test_list_comp ]
2124
if
atom -> [ test_list_comp ]
2124
!=
atom -> [ test_list_comp ]
2124
is
atom -> [ test_list_comp ]
2124
>>
atom -> [ test_list_comp ]
2124
or
atom -> [ test_list_comp ]
2124
//
atom -> [ test_list_comp ]
2124
/
atom -> [ test_list_comp ]
2124
,
atom -> [ test_list_comp ]
2124
|
atom -> [ test_list_comp ]
2124
>
atom -> [ test_list_comp ]
2124
&
atom -> [ test_list_comp ]
2124
(
atom -> [ test_list_comp ]
2124
%
atom -> [ test_list_comp ]
2124
>=
atom -> [ test_list_comp ]
2124
==
atom -> [ test_list_comp ]
2124
**
atom -> [ test_list_comp ]
2124
:
atom -> [ test_list_comp ]
2124
<<
atom -> [ test_list_comp ]
2124
+
atom -> [ test_list_comp ]
2124
*
atom -> [ test_list_comp ]
2124
^
atom -> [ test_list_comp ]
2125
<<
term -> factor @ term
2125
^
term -> factor @ term
2125
<=
term -> factor @ term
2125
&
term -> factor @ term
2125
==
term -> factor @ term
2125
if
term -> factor @ term
2125
|
term -> factor @ term
2125
!=
term -> factor @ term
2125
or
term -> factor @ term
2125
>
term -> factor @ term
2125
and
term -> factor @ term
2125
>>
term -> factor @ term
2125
is
term -> factor @ term
2125
-
term -> factor @ term
2125
not
term -> factor @ term
2125
+
term -> factor @ term
2125
in
term -> factor @ term
2125
>=
term -> factor @ term
2125
<
term -> factor @ term
2125
,
term -> factor @ term
2125
:
term -> factor @ term
2126
<=
term -> factor % term
2126
is
term -> factor % term
2126
>
term -> factor % term
2126
and
term -> factor % term
2126
in
term -> factor % term
2126
,
term -> factor % term
2126
or
term -> factor % term
2126
<
term -> factor % term
2126
:
term -> factor % term
2126
-
term -> factor % term
2126
!=
term -> factor % term
2126
>>
term -> factor % term
2126
^
term -> factor % term
2126
+
term -> factor % term
2126
if
term -> factor % term
2126
<<
term -> factor % term
2126
>=
term -> factor % term
2126
==
term -> factor % term
2126
not
term -> factor % term
2126
|
term -> factor % term
2126
&
term -> factor % term
2127
>>
term -> factor / term
2127
!=
term -> factor / term
2127
<
term -> factor / term
2127
<=
term -> factor / term
2127
|
term -> factor / term
2127
is
term -> factor / term
2127
>=
term -> factor / term
2127
^
term -> factor / term
2127
&
term -> factor / term
2127
+
term -> factor / term
2127
<<
term -> factor / term
2127
and
term -> factor / term
2127
-
term -> factor / term
2127
in
term -> factor / term
2127
>
term -> factor / term
2127
or
term -> factor / term
2127
not
term -> factor / term
2127
==
term -> factor / term
2127
,
term -> factor / term
2127
:
term -> factor / term
2127
if
term -> factor / term
2128
is
term -> factor * term
2128
+
term -> factor * term
2128
>=
term -> factor * term
2128
^
term -> factor * term
2128
,
term -> factor * term
2128
<=
term -> factor * term
2128
or
term -> factor * term
2128
<
term -> factor * term
2128
|
term -> factor * term
2128
>>
term -> factor * term
2128
in
term -> factor * term
2128
not
term -> factor * term
2128
==
term -> factor * term
2128
:
term -> factor * term
2128
-
term -> factor * term
2128
and
term -> factor * term
2128
!=
term -> factor * term
2128
<<
term -> factor * term
2128
>
term -> factor * term
2128
if
term -> factor * term
2128
&
term -> factor * term
2129
!=
term -> factor // term
2129
or
term -> factor // term
2129
^
term -> factor // term
2129
>
term -> factor // term
2129
is
term -> factor // term
2129
&
term -> factor // term
2129
-
term -> factor // term
2129
:
term -> factor // term
2129
in
term -> factor // term
2129
>>
term -> factor // term
2129
|
term -> factor // term
2129
<
term -> factor // term
2129
>=
term -> factor // term
2129
not
term -> factor // term
2129
if
term -> factor // term
2129
==
term -> factor // term
2129
<=
term -> factor // term
2129
,
term -> factor // term
2129
and
term -> factor // term
2129
<<
term -> factor // term
2129
+
term -> factor // term
2130
:
power -> atom_expr ** factor
2130
!=
power -> atom_expr ** factor
2130
@
power -> atom_expr ** factor
2130
|
power -> atom_expr ** factor
2130
in
power -> atom_expr ** factor
2130
==
power -> atom_expr ** factor
2130
if
power -> atom_expr ** factor
2130
and
power -> atom_expr ** factor
2130
>=
power -> atom_expr ** factor
2130
/
power -> atom_expr ** factor
2130
not
power -> atom_expr ** factor
2130
^
power -> atom_expr ** factor
2130
//
power -> atom_expr ** factor
2130
>
power -> atom_expr ** factor
2130
+
power -> atom_expr ** factor
2130
%
power -> atom_expr ** factor
2130
-
power -> atom_expr ** factor
2130
is
power -> atom_expr ** factor
2130
<=
power -> atom_expr ** factor
2130
<
power -> atom_expr ** factor
2130
,
power -> atom_expr ** factor
2130
*
power -> atom_expr ** factor
2130
<<
power -> atom_expr ** factor
2130
or
power -> atom_expr ** factor
2130
>>
power -> atom_expr ** factor
2130
&
power -> atom_expr ** factor
2131
not
xor_expr -> and_expr ^ xor_expr
2131
<
xor_expr -> and_expr ^ xor_expr
2131
,
xor_expr -> and_expr ^ xor_expr
2131
>=
xor_expr -> and_expr ^ xor_expr
2131
>
xor_expr -> and_expr ^ xor_expr
2131
is
xor_expr -> and_expr ^ xor_expr
2131
!=
xor_expr -> and_expr ^ xor_expr
2131
and
xor_expr -> and_expr ^ xor_expr
2131
:
xor_expr -> and_expr ^ xor_expr
2131
if
xor_expr -> and_expr ^ xor_expr
2131
<=
xor_expr -> and_expr ^ xor_expr
2131
in
xor_expr -> and_expr ^ xor_expr
2131
==
xor_expr -> and_expr ^ xor_expr
2131
|
xor_expr -> and_expr ^ xor_expr
2131
or
xor_expr -> and_expr ^ xor_expr
2132
<
and_expr -> shift_expr & and_expr
2132
if
and_expr -> shift_expr & and_expr
2132
>=
and_expr -> shift_expr & and_expr
2132
|
and_expr -> shift_expr & and_expr
2132
not
and_expr -> shift_expr & and_expr
2132
==
and_expr -> shift_expr & and_expr
2132
>
and_expr -> shift_expr & and_expr
2132
in
and_expr -> shift_expr & and_expr
2132
^
and_expr -> shift_expr & and_expr
2132
or
and_expr -> shift_expr & and_expr
2132
and
and_expr -> shift_expr & and_expr
2132
!=
and_expr -> shift_expr & and_expr
2132
,
and_expr -> shift_expr & and_expr
2132
:
and_expr -> shift_expr & and_expr
2132
is
and_expr -> shift_expr & and_expr
2132
<=
and_expr -> shift_expr & and_expr
2133
+
trailer -> ( )
2133
!=
trailer -> ( )
2133
<<
trailer -> ( )
2133
>=
trailer -> ( )
2133
**
trailer -> ( )
2133
not
trailer -> ( )
2133
if
trailer -> ( )
2133
,
trailer -> ( )
2133
|
trailer -> ( )
2133
[
trailer -> ( )
2133
==
trailer -> ( )
2133
%
trailer -> ( )
2133
*
trailer -> ( )
2133
>>
trailer -> ( )
2133
@
trailer -> ( )
2133
>
trailer -> ( )
2133
/
trailer -> ( )
2133
in
trailer -> ( )
2133
(
trailer -> ( )
2133
is
trailer -> ( )
2133
//
trailer -> ( )
2133
<
trailer -> ( )
2133
:
trailer -> ( )
2133
or
trailer -> ( )
2133
^
trailer -> ( )
2133
and
trailer -> ( )
2133
<=
trailer -> ( )
2133
.
trailer -> ( )
2133
-
trailer -> ( )
2133
&
trailer -> ( )
2134
)
2404
2135
<=
trailer_expr -> trailer trailer_expr
2135
+
trailer_expr -> trailer trailer_expr
2135
^
trailer_expr -> trailer trailer_expr
2135
or
trailer_expr -> trailer trailer_expr
2135
==
trailer_expr -> trailer trailer_expr
2135
%
trailer_expr -> trailer trailer_expr
2135
@
trailer_expr -> trailer trailer_expr
2135
not
trailer_expr -> trailer trailer_expr
2135
<<
trailer_expr -> trailer trailer_expr
2135
-
trailer_expr -> trailer trailer_expr
2135
//
trailer_expr -> trailer trailer_expr
2135
and
trailer_expr -> trailer trailer_expr
2135
|
trailer_expr -> trailer trailer_expr
2135
if
trailer_expr -> trailer trailer_expr
2135
>
trailer_expr -> trailer trailer_expr
2135
!=
trailer_expr -> trailer trailer_expr
2135
,
trailer_expr -> trailer trailer_expr
2135
<
trailer_expr -> trailer trailer_expr
2135
>>
trailer_expr -> trailer trailer_expr
2135
/
trailer_expr -> trailer trailer_expr
2135
:
trailer_expr -> trailer trailer_expr
2135
is
trailer_expr -> trailer trailer_expr
2135
&
trailer_expr -> trailer trailer_expr
2135
in
trailer_expr -> trailer trailer_expr
2135
>=
trailer_expr -> trailer trailer_expr
2135
*
trailer_expr -> trailer trailer_expr
2135
**
trailer_expr -> trailer trailer_expr
2136
.
trailer -> . NAME
2136
not
trailer -> . NAME
2136
if
trailer -> . NAME
2136
**
trailer -> . NAME
2136
:
trailer -> . NAME
2136
|
trailer -> . NAME
2136
-
trailer -> . NAME
2136
(
trailer -> . NAME
2136
%
trailer -> . NAME
2136
//
trailer -> . NAME
2136
==
trailer -> . NAME
2136
>>
trailer -> . NAME
2136
is
trailer -> . NAME
2136
!=
trailer -> . NAME
2136
and
trailer -> . NAME
2136
>=
trailer -> . NAME
2136
,
trailer -> . NAME
2136
>
trailer -> . NAME
2136
in
trailer -> . NAME
2136
<<
trailer -> . NAME
2136
&
trailer -> . NAME
2136
/
trailer -> . NAME
2136
^
trailer -> . NAME
2136
[
trailer -> . NAME
2136
<=
trailer -> . NAME
2136
or
trailer -> . NAME
2136
+
trailer -> . NAME
2136
<
trailer -> . NAME
2136
*
trailer -> . NAME
2136
@
trailer -> . NAME
2137
]
2405
2138
else
2406
2139
==
shift_expr -> arith_expr >> shift_expr
2139
^
shift_expr -> arith_expr >> shift_expr
2139
or
shift_expr -> arith_expr >> shift_expr
2139
if
shift_expr -> arith_expr >> shift_expr
2139
,
shift_expr -> arith_expr >> shift_expr
2139
not
shift_expr -> arith_expr >> shift_expr
2139
|
shift_expr -> arith_expr >> shift_expr
2139
<=
shift_expr -> arith_expr >> shift_expr
2139
is
shift_expr -> arith_expr >> shift_expr
2139
in
shift_expr -> arith_expr >> shift_expr
2139
>=
shift_expr -> arith_expr >> shift_expr
2139
>
shift_expr -> arith_expr >> shift_expr
2139
:
shift_expr -> arith_expr >> shift_expr
2139
&
shift_expr -> arith_expr >> shift_expr
2139
<
shift_expr -> arith_expr >> shift_expr
2139
and
shift_expr -> arith_expr >> shift_expr
2139
!=
shift_expr -> arith_expr >> shift_expr
2140
or
shift_expr -> arith_expr << shift_expr
2140
>
shift_expr -> arith_expr << shift_expr
2140
in
shift_expr -> arith_expr << shift_expr
2140
&
shift_expr -> arith_expr << shift_expr
2140
:
shift_expr -> arith_expr << shift_expr
2140
is
shift_expr -> arith_expr << shift_expr
2140
<
shift_expr -> arith_expr << shift_expr
2140
<=
shift_expr -> arith_expr << shift_expr
2140
not
shift_expr -> arith_expr << shift_expr
2140
^
shift_expr -> arith_expr << shift_expr
2140
if
shift_expr -> arith_expr << shift_expr
2140
,
shift_expr -> arith_expr << shift_expr
2140
and
shift_expr -> arith_expr << shift_expr
2140
|
shift_expr -> arith_expr << shift_expr
2140
!=
shift_expr -> arith_expr << shift_expr
2140
==
shift_expr -> arith_expr << shift_expr
2140
>=
shift_expr -> arith_expr << shift_expr
2141
class
for_stmt -> for expr_list in test_list : suite
2141
lambda
for_stmt -> for expr_list in test_list : suite
2141
assert
for_stmt -> for expr_list in test_list : suite
2141
else
2407
2141
return
for_stmt -> for expr_list in test_list : suite
2141
-
for_stmt -> for expr_list in test_list : suite
2141
while
for_stmt -> for expr_list in test_list : suite
2141
continue
for_stmt -> for expr_list in test_list : suite
2141
not
for_stmt -> for expr_list in test_list : suite
2141
+
for_stmt -> for expr_list in test_list : suite
2141
pass
for_stmt -> for expr_list in test_list : suite
2141
del
for_stmt -> for expr_list in test_list : suite
2141
servmod
for_stmt -> for expr_list in test_list : suite
2141
modopt
for_stmt -> for expr_list in test_list : suite
2141
None
for_stmt -> for expr_list in test_list : suite
2141
if
for_stmt -> for expr_list in test_list : suite
2141
yield
for_stmt -> for expr_list in test_list : suite
2141
{
for_stmt -> for expr_list in test_list : suite
2141
with
for_stmt -> for expr_list in test_list : suite
2141
@
for_stmt -> for expr_list in test_list : suite
2141
raise
for_stmt -> for expr_list in test_list : suite
2141
endsim
for_stmt -> for expr_list in test_list : suite
2141
STRING
for_stmt -> for expr_list in test_list : suite
2141
NEWLINE
for_stmt -> for expr_list in test_list : suite
2141
nonlocal
for_stmt -> for expr_list in test_list : suite
2141
~
for_stmt -> for expr_list in test_list : suite
2141
False
for_stmt -> for expr_list in test_list : suite
2141
def
for_stmt -> for expr_list in test_list : suite
2141
[
for_stmt -> for expr_list in test_list : suite
2141
NAME
for_stmt -> for expr_list in test_list : suite
2141
server
for_stmt -> for expr_list in test_list : suite
2141
conf
for_stmt -> for expr_list in test_list : suite
2141
$
for_stmt -> for expr_list in test_list : suite
2141
(
for_stmt -> for expr_list in test_list : suite
2141
break
for_stmt -> for expr_list in test_list : suite
2141
for
for_stmt -> for expr_list in test_list : suite
2141
try
for_stmt -> for expr_list in test_list : suite
2141
NUMBER
for_stmt -> for expr_list in test_list : suite
2141
begsim
for_stmt -> for expr_list in test_list : suite
2141
True
for_stmt -> for expr_list in test_list : suite
2141
global
for_stmt -> for expr_list in test_list : suite
2141
resetstats
for_stmt -> for expr_list in test_list : suite
2142
>
atom -> ( test_list_comp )
2142
@
atom -> ( test_list_comp )
2142
&
atom -> ( test_list_comp )
2142
[
atom -> ( test_list_comp )
2142
if
atom -> ( test_list_comp )
2142
==
atom -> ( test_list_comp )
2142
>=
atom -> ( test_list_comp )
2142
**
atom -> ( test_list_comp )
2142
not
atom -> ( test_list_comp )
2142
<<
atom -> ( test_list_comp )
2142
>>
atom -> ( test_list_comp )
2142
in
atom -> ( test_list_comp )
2142
or
atom -> ( test_list_comp )
2142
.
atom -> ( test_list_comp )
2142
/
atom -> ( test_list_comp )
2142
^
atom -> ( test_list_comp )
2142
is
atom -> ( test_list_comp )
2142
,
atom -> ( test_list_comp )
2142
and
atom -> ( test_list_comp )
2142
//
atom -> ( test_list_comp )
2142
<
atom -> ( test_list_comp )
2142
*
atom -> ( test_list_comp )
2142
<=
atom -> ( test_list_comp )
2142
(
atom -> ( test_list_comp )
2142
-
atom -> ( test_list_comp )
2142
|
atom -> ( test_list_comp )
2142
!=
atom -> ( test_list_comp )
2142
:
atom -> ( test_list_comp )
2142
+
atom -> ( test_list_comp )
2142
%
atom -> ( test_list_comp )
2143
:
or_test -> and_test or or_test
2143
,
or_test -> and_test or or_test
2143
if
or_test -> and_test or or_test
2144
^
arith_expr -> term - arith_expr
2144
!=
arith_expr -> term - arith_expr
2144
<
arith_expr -> term - arith_expr
2144
in
arith_expr -> term - arith_expr
2144
==
arith_expr -> term - arith_expr
2144
|
arith_expr -> term - arith_expr
2144
is
arith_expr -> term - arith_expr
2144
&
arith_expr -> term - arith_expr
2144
>>
arith_expr -> term - arith_expr
2144
<<
arith_expr -> term - arith_expr
2144
and
arith_expr -> term - arith_expr
2144
,
arith_expr -> term - arith_expr
2144
>
arith_expr -> term - arith_expr
2144
if
arith_expr -> term - arith_expr
2144
not
arith_expr -> term - arith_expr
2144
>=
arith_expr -> term - arith_expr
2144
<=
arith_expr -> term - arith_expr
2144
or
arith_expr -> term - arith_expr
2144
:
arith_expr -> term - arith_expr
2145
>=
arith_expr -> term + arith_expr
2145
>
arith_expr -> term + arith_expr
2145
^
arith_expr -> term + arith_expr
2145
or
arith_expr -> term + arith_expr
2145
==
arith_expr -> term + arith_expr
2145
<=
arith_expr -> term + arith_expr
2145
if
arith_expr -> term + arith_expr
2145
>>
arith_expr -> term + arith_expr
2145
<
arith_expr -> term + arith_expr
2145
not
arith_expr -> term + arith_expr
2145
&
arith_expr -> term + arith_expr
2145
in
arith_expr -> term + arith_expr
2145
and
arith_expr -> term + arith_expr
2145
,
arith_expr -> term + arith_expr
2145
|
arith_expr -> term + arith_expr
2145
!=
arith_expr -> term + arith_expr
2145
:
arith_expr -> term + arith_expr
2145
<<
arith_expr -> term + arith_expr
2145
is
arith_expr -> term + arith_expr
2146
>=
expr -> xor_expr | expr
2146
,
expr -> xor_expr | expr
2146
or
expr -> xor_expr | expr
2146
in
expr -> xor_expr | expr
2146
and
expr -> xor_expr | expr
2146
==
expr -> xor_expr | expr
2146
:
expr -> xor_expr | expr
2146
>
expr -> xor_expr | expr
2146
<=
expr -> xor_expr | expr
2146
is
expr -> xor_expr | expr
2146
<
expr -> xor_expr | expr
2146
if
expr -> xor_expr | expr
2146
not
expr -> xor_expr | expr
2146
!=
expr -> xor_expr | expr
2147
or
comparison -> expr comp_op comparison
2147
:
comparison -> expr comp_op comparison
2147
if
comparison -> expr comp_op comparison
2147
and
comparison -> expr comp_op comparison
2147
,
comparison -> expr comp_op comparison
2148
,
and_test -> not_test and and_test
2148
if
and_test -> not_test and and_test
2148
or
and_test -> not_test and and_test
2148
:
and_test -> not_test and and_test
2149
:
test_list -> test , test_list
2150
[
1111
2150
factor
1112
2150
True
1113
2150
atom_expr
1114
2150
~
1115
2150
and_expr
1116
2150
-
1117
2150
shift_expr
1118
2150
atom
1119
2150
{
1120
2150
comparison
1121
2150
or_test
1122
2150
arith_expr
1123
2150
power
1124
2150
STRING
1125
2150
NAME
1126
2150
(
1128
2150
and_test
1129
2150
term
1130
2150
+
1131
2150
xor_expr
1132
2150
NUMBER
1133
2150
not
1134
2150
False
1135
2150
expr
1136
2150
not_test
1137
2150
None
1139
2150
lambdef
1140
2150
lambda
1141
2150
test
2408
2151
,
lambdef -> lambda : test
2151
:
lambdef -> lambda : test
2152
NEWLINE
2409
2153
DEDENT
2410
2154
,
trailer -> ( arglist )
2154
.
trailer -> ( arglist )
2154
|
trailer -> ( arglist )
2154
^
trailer -> ( arglist )
2154
==
trailer -> ( arglist )
2154
**
trailer -> ( arglist )
2154
>>
trailer -> ( arglist )
2154
not
trailer -> ( arglist )
2154
<<
trailer -> ( arglist )
2154
>=
trailer -> ( arglist )
2154
!=
trailer -> ( arglist )
2154
in
trailer -> ( arglist )
2154
[
trailer -> ( arglist )
2154
(
trailer -> ( arglist )
2154
NEWLINE
trailer -> ( arglist )
2154
>
trailer -> ( arglist )
2154
and
trailer -> ( arglist )
2154
+
trailer -> ( arglist )
2154
%
trailer -> ( arglist )
2154
or
trailer -> ( arglist )
2154
*
trailer -> ( arglist )
2154
is
trailer -> ( arglist )
2154
&
trailer -> ( arglist )
2154
//
trailer -> ( arglist )
2154
=
trailer -> ( arglist )
2154
-
trailer -> ( arglist )
2154
<
trailer -> ( arglist )
2154
<=
trailer -> ( arglist )
2154
if
trailer -> ( arglist )
2154
/
trailer -> ( arglist )
2154
@
trailer -> ( arglist )
2155
<=
trailer -> [ subscriptlist ]
2155
NEWLINE
trailer -> [ subscriptlist ]
2155
<<
trailer -> [ subscriptlist ]
2155
*
trailer -> [ subscriptlist ]
2155
+
trailer -> [ subscriptlist ]
2155
in
trailer -> [ subscriptlist ]
2155
>>
trailer -> [ subscriptlist ]
2155
//
trailer -> [ subscriptlist ]
2155
.
trailer -> [ subscriptlist ]
2155
,
trailer -> [ subscriptlist ]
2155
and
trailer -> [ subscriptlist ]
2155
**
trailer -> [ subscriptlist ]
2155
=
trailer -> [ subscriptlist ]
2155
@
trailer -> [ subscriptlist ]
2155
<
trailer -> [ subscriptlist ]
2155
not
trailer -> [ subscriptlist ]
2155
-
trailer -> [ subscriptlist ]
2155
!=
trailer -> [ subscriptlist ]
2155
%
trailer -> [ subscriptlist ]
2155
[
trailer -> [ subscriptlist ]
2155
/
trailer -> [ subscriptlist ]
2155
or
trailer -> [ subscriptlist ]
2155
&
trailer -> [ subscriptlist ]
2155
>=
trailer -> [ subscriptlist ]
2155
==
trailer -> [ subscriptlist ]
2155
(
trailer -> [ subscriptlist ]
2155
|
trailer -> [ subscriptlist ]
2155
is
trailer -> [ subscriptlist ]
2155
if
trailer -> [ subscriptlist ]
2155
>
trailer -> [ subscriptlist ]
2155
^
trailer -> [ subscriptlist ]
2156
!=
atom -> [ ]
2156
>>
atom -> [ ]
2156
|
atom -> [ ]
2156
NEWLINE
atom -> [ ]
2156
<<
atom -> [ ]
2156
>
atom -> [ ]
2156
.
atom -> [ ]
2156
%
atom -> [ ]
2156
^
atom -> [ ]
2156
=
atom -> [ ]
2156
-
atom -> [ ]
2156
in
atom -> [ ]
2156
or
atom -> [ ]
2156
/
atom -> [ ]
2156
**
atom -> [ ]
2156
//
atom -> [ ]
2156
not
atom -> [ ]
2156
(
atom -> [ ]
2156
+
atom -> [ ]
2156
and
atom -> [ ]
2156
==
atom -> [ ]
2156
[
atom -> [ ]
2156
if
atom -> [ ]
2156
<
atom -> [ ]
2156
<=
atom -> [ ]
2156
>=
atom -> [ ]
2156
is
atom -> [ ]
2156
*
atom -> [ ]
2156
@
atom -> [ ]
2156
&
atom -> [ ]
2157
]
2411
2158
term
2412
2158
[
1721
2158
factor
1722
2158
True
1723
2158
atom_expr
1724
2158
~
1725
2158
-
1727
2158
None
1728
2158
atom
1729
2158
{
1730
2158
power
1733
2158
STRING
1734
2158
NAME
1735
2158
(
1736
2158
NUMBER
1737
2158
+
1739
2158
False
1743
2159
[
1721
2159
factor
1722
2159
True
1723
2159
term
2413
2159
~
1725
2159
-
1727
2159
atom_expr
1724
2159
None
1728
2159
atom
1729
2159
{
1730
2159
power
1733
2159
STRING
1734
2159
NAME
1735
2159
(
1736
2159
NUMBER
1737
2159
+
1739
2159
False
1743
2160
[
1721
2160
factor
1722
2160
True
1723
2160
atom_expr
1724
2160
~
1725
2160
-
1727
2160
None
1728
2160
atom
1729
2160
{
1730
2160
power
1733
2160
STRING
1734
2160
NAME
1735
2160
(
1736
2160
NUMBER
1737
2160
term
2414
2160
+
1739
2160
False
1743
2161
[
1721
2161
factor
1722
2161
True
1723
2161
atom_expr
1724
2161
~
1725
2161
-
1727
2161
None
1728
2161
atom
1729
2161
{
1730
2161
power
1733
2161
STRING
1734
2161
NAME
1735
2161
(
1736
2161
NUMBER
1737
2161
term
2415
2161
+
1739
2161
False
1743
2162
[
1721
2162
factor
1722
2162
True
1723
2162
atom_expr
1724
2162
~
1725
2162
-
1727
2162
None
1728
2162
atom
1729
2162
{
1730
2162
power
1733
2162
STRING
1734
2162
NAME
1735
2162
term
2416
2162
(
1736
2162
NUMBER
1737
2162
+
1739
2162
False
1743
2163
[
1721
2163
True
1723
2163
atom_expr
1724
2163
-
1727
2163
~
1725
2163
None
1728
2163
atom
1729
2163
{
1730
2163
power
1733
2163
STRING
1734
2163
NAME
1735
2163
(
1736
2163
NUMBER
1737
2163
+
1739
2163
False
1743
2163
factor
2417
2164
@
factor -> ~ factor
2164
NEWLINE
factor -> ~ factor
2164
>>
factor -> ~ factor
2164
<=
factor -> ~ factor
2164
and
factor -> ~ factor
2164
+
factor -> ~ factor
2164
*
factor -> ~ factor
2164
!=
factor -> ~ factor
2164
%
factor -> ~ factor
2164
<<
factor -> ~ factor
2164
>=
factor -> ~ factor
2164
=
factor -> ~ factor
2164
&
factor -> ~ factor
2164
is
factor -> ~ factor
2164
==
factor -> ~ factor
2164
//
factor -> ~ factor
2164
<
factor -> ~ factor
2164
/
factor -> ~ factor
2164
not
factor -> ~ factor
2164
-
factor -> ~ factor
2164
or
factor -> ~ factor
2164
|
factor -> ~ factor
2164
>
factor -> ~ factor
2164
^
factor -> ~ factor
2164
if
factor -> ~ factor
2164
in
factor -> ~ factor
2165
[
1721
2165
factor
1722
2165
True
1723
2165
atom_expr
1724
2165
~
1725
2165
and_expr
1726
2165
-
1727
2165
None
1728
2165
atom
1729
2165
{
1730
2165
xor_expr
2418
2165
arith_expr
1732
2165
power
1733
2165
STRING
1734
2165
NAME
1735
2165
(
1736
2165
NUMBER
1737
2165
term
1738
2165
+
1739
2165
shift_expr
1741
2165
False
1743
2166
@
factor -> - factor
2166
=
factor -> - factor
2166
<=
factor -> - factor
2166
in
factor -> - factor
2166
>>
factor -> - factor
2166
|
factor -> - factor
2166
is
factor -> - factor
2166
+
factor -> - factor
2166
%
factor -> - factor
2166
<
factor -> - factor
2166
*
factor -> - factor
2166
<<
factor -> - factor
2166
if
factor -> - factor
2166
-
factor -> - factor
2166
>=
factor -> - factor
2166
not
factor -> - factor
2166
and
factor -> - factor
2166
/
factor -> - factor
2166
or
factor -> - factor
2166
NEWLINE
factor -> - factor
2166
^
factor -> - factor
2166
>
factor -> - factor
2166
!=
factor -> - factor
2166
&
factor -> - factor
2166
==
factor -> - factor
2166
//
factor -> - factor
2167
[
766
2167
factor
767
2167
True
768
2167
atom_expr
769
2167
~
770
2167
and_expr
771
2167
-
772
2167
{
773
2167
shift_expr
774
2167
atom
775
2167
comparison
776
2167
and_test
777
2167
arith_expr
778
2167
power
779
2167
STRING
780
2167
NAME
781
2167
(
782
2167
term
784
2167
+
785
2167
xor_expr
786
2167
)
2419
2167
or_test
788
2167
arglist
2420
2167
NUMBER
789
2167
not
790
2167
False
791
2167
expr
792
2167
*
793
2167
not_test
794
2167
None
795
2167
lambdef
796
2167
lambda
797
2167
test
798
2167
argument
799
2167
**
800
2168
trailer_expr
2421
2168
>>
trailer_expr -> 
2168
(
2167
2168
trailer
2168
2168
.
2170
2168
+
trailer_expr -> 
2168
[
2171
2168
is
trailer_expr -> 
2168
>
trailer_expr -> 
2168
not
trailer_expr -> 
2168
|
trailer_expr -> 
2168
=
trailer_expr -> 
2168
NEWLINE
trailer_expr -> 
2168
&
trailer_expr -> 
2168
/
trailer_expr -> 
2168
@
trailer_expr -> 
2168
!=
trailer_expr -> 
2168
**
trailer_expr -> 
2168
>=
trailer_expr -> 
2168
^
trailer_expr -> 
2168
in
trailer_expr -> 
2168
<<
trailer_expr -> 
2168
and
trailer_expr -> 
2168
or
trailer_expr -> 
2168
if
trailer_expr -> 
2168
//
trailer_expr -> 
2168
%
trailer_expr -> 
2168
<=
trailer_expr -> 
2168
<
trailer_expr -> 
2168
==
trailer_expr -> 
2168
-
trailer_expr -> 
2168
*
trailer_expr -> 
2169
^
atom_expr -> atom trailer_expr
2169
or
atom_expr -> atom trailer_expr
2169
=
atom_expr -> atom trailer_expr
2169
&
atom_expr -> atom trailer_expr
2169
@
atom_expr -> atom trailer_expr
2169
|
atom_expr -> atom trailer_expr
2169
-
atom_expr -> atom trailer_expr
2169
*
atom_expr -> atom trailer_expr
2169
%
atom_expr -> atom trailer_expr
2169
==
atom_expr -> atom trailer_expr
2169
**
atom_expr -> atom trailer_expr
2169
and
atom_expr -> atom trailer_expr
2169
NEWLINE
atom_expr -> atom trailer_expr
2169
is
atom_expr -> atom trailer_expr
2169
in
atom_expr -> atom trailer_expr
2169
<<
atom_expr -> atom trailer_expr
2169
!=
atom_expr -> atom trailer_expr
2169
<=
atom_expr -> atom trailer_expr
2169
/
atom_expr -> atom trailer_expr
2169
//
atom_expr -> atom trailer_expr
2169
<
atom_expr -> atom trailer_expr
2169
>=
atom_expr -> atom trailer_expr
2169
>>
atom_expr -> atom trailer_expr
2169
if
atom_expr -> atom trailer_expr
2169
not
atom_expr -> atom trailer_expr
2169
+
atom_expr -> atom trailer_expr
2169
>
atom_expr -> atom trailer_expr
2170
NAME
2422
2171
[
802
2171
factor
803
2171
True
804
2171
atom_expr
810
2171
~
806
2171
not
807
2171
and_expr
808
2171
-
809
2171
shift_expr
811
2171
atom
812
2171
{
813
2171
comparison
814
2171
or_test
815
2171
(
816
2171
arith_expr
817
2171
power
818
2171
STRING
819
2171
NAME
820
2171
and_test
821
2171
term
822
2171
+
823
2171
xor_expr
824
2171
subscriptlist
2423
2171
test
825
2171
NUMBER
826
2171
False
827
2171
subscript
828
2171
expr
829
2171
not_test
830
2171
None
831
2171
lambdef
832
2171
lambda
833
2171
maybe_test
834
2171
:
maybe_test -> 
2172
in
atom -> { }
2172
<=
atom -> { }
2172
*
atom -> { }
2172
NEWLINE
atom -> { }
2172
>
atom -> { }
2172
+
atom -> { }
2172
@
atom -> { }
2172
>=
atom -> { }
2172
/
atom -> { }
2172
|
atom -> { }
2172
is
atom -> { }
2172
and
atom -> { }
2172
=
atom -> { }
2172
if
atom -> { }
2172
(
atom -> { }
2172
>>
atom -> { }
2172
not
atom -> { }
2172
-
atom -> { }
2172
<<
atom -> { }
2172
**
atom -> { }
2172
or
atom -> { }
2172
<
atom -> { }
2172
!=
atom -> { }
2172
==
atom -> { }
2172
%
atom -> { }
2172
//
atom -> { }
2172
&
atom -> { }
2172
[
atom -> { }
2172
.
atom -> { }
2172
^
atom -> { }
2173
[
1721
2173
factor
1722
2173
True
1723
2173
atom_expr
1724
2173
~
1725
2173
and_expr
1726
2173
-
1727
2173
None
1728
2173
atom
1729
2173
{
1730
2173
and_test
1731
2173
arith_expr
1732
2173
power
1733
2173
STRING
1734
2173
NAME
1735
2173
(
1736
2173
NUMBER
1737
2173
term
1738
2173
+
1739
2173
xor_expr
1740
2173
shift_expr
1741
2173
not
1742
2173
False
1743
2173
comparison
1745
2173
not_test
1746
2173
expr
1749
2173
or_test
2424
2174
[
1721
2174
factor
1722
2174
True
1723
2174
atom_expr
1724
2174
~
1725
2174
-
1727
2174
None
1728
2174
atom
1729
2174
{
1730
2174
arith_expr
1732
2174
power
1733
2174
STRING
1734
2174
NAME
1735
2174
shift_expr
2425
2174
(
1736
2174
NUMBER
1737
2174
term
1738
2174
+
1739
2174
False
1743
2175
[
1721
2175
factor
1722
2175
True
1723
2175
atom_expr
1724
2175
~
1725
2175
-
1727
2175
None
1728
2175
atom
1729
2175
{
1730
2175
arith_expr
1732
2175
power
1733
2175
STRING
1734
2175
NAME
1735
2175
(
1736
2175
NUMBER
1737
2175
term
1738
2175
+
1739
2175
False
1743
2175
shift_expr
2426
2176
)
2427
2177
or
atom -> ( )
2177
>>
atom -> ( )
2177
(
atom -> ( )
2177
<=
atom -> ( )
2177
.
atom -> ( )
2177
is
atom -> ( )
2177
@
atom -> ( )
2177
%
atom -> ( )
2177
<<
atom -> ( )
2177
**
atom -> ( )
2177
^
atom -> ( )
2177
/
atom -> ( )
2177
if
atom -> ( )
2177
not
atom -> ( )
2177
=
atom -> ( )
2177
*
atom -> ( )
2177
!=
atom -> ( )
2177
<
atom -> ( )
2177
NEWLINE
atom -> ( )
2177
&
atom -> ( )
2177
-
atom -> ( )
2177
>
atom -> ( )
2177
//
atom -> ( )
2177
==
atom -> ( )
2177
in
atom -> ( )
2177
+
atom -> ( )
2177
[
atom -> ( )
2177
>=
atom -> ( )
2177
and
atom -> ( )
2177
|
atom -> ( )
2178
[
1721
2178
factor
1722
2178
True
1723
2178
atom_expr
1724
2178
~
1725
2178
-
1727
2178
None
1728
2178
arith_expr
2428
2178
atom
1729
2178
{
1730
2178
power
1733
2178
STRING
1734
2178
NAME
1735
2178
(
1736
2178
NUMBER
1737
2178
term
1738
2178
+
1739
2178
False
1743
2179
[
1721
2179
factor
1722
2179
True
1723
2179
atom_expr
1724
2179
~
1725
2179
-
1727
2179
None
1728
2179
atom
1729
2179
{
1730
2179
arith_expr
2429
2179
power
1733
2179
STRING
1734
2179
NAME
1735
2179
(
1736
2179
NUMBER
1737
2179
term
1738
2179
+
1739
2179
False
1743
2180
-
factor -> + factor
2180
@
factor -> + factor
2180
<<
factor -> + factor
2180
is
factor -> + factor
2180
and
factor -> + factor
2180
<=
factor -> + factor
2180
or
factor -> + factor
2180
<
factor -> + factor
2180
^
factor -> + factor
2180
not
factor -> + factor
2180
//
factor -> + factor
2180
*
factor -> + factor
2180
in
factor -> + factor
2180
&
factor -> + factor
2180
+
factor -> + factor
2180
if
factor -> + factor
2180
>>
factor -> + factor
2180
|
factor -> + factor
2180
=
factor -> + factor
2180
>
factor -> + factor
2180
%
factor -> + factor
2180
NEWLINE
factor -> + factor
2180
>=
factor -> + factor
2180
!=
factor -> + factor
2180
/
factor -> + factor
2180
==
factor -> + factor
2181
[
1721
2181
factor
1722
2181
True
1723
2181
atom_expr
1724
2181
~
1725
2181
and_expr
1726
2181
-
1727
2181
None
1728
2181
atom
1729
2181
{
1730
2181
expr
2430
2181
arith_expr
1732
2181
power
1733
2181
STRING
1734
2181
NAME
1735
2181
(
1736
2181
NUMBER
1737
2181
term
1738
2181
+
1739
2181
xor_expr
1740
2181
shift_expr
1741
2181
False
1743
2182
[
1721
2182
factor
1722
2182
True
1723
2182
atom_expr
1724
2182
~
1725
2182
-
1727
2182
None
1728
2182
atom
1729
2182
{
1730
2182
arith_expr
1732
2182
power
1733
2182
STRING
1734
2182
NAME
1735
2182
(
1736
2182
NUMBER
1737
2182
term
1738
2182
+
1739
2182
and_expr
2431
2182
shift_expr
1741
2182
False
1743
2183
NEWLINE
not_test -> not not_test
2183
and
not_test -> not not_test
2183
=
not_test -> not not_test
2183
or
not_test -> not not_test
2183
if
not_test -> not not_test
2184
[
1721
2184
factor
1722
2184
True
1723
2184
atom_expr
1724
2184
~
1725
2184
and_expr
1726
2184
-
1727
2184
None
1728
2184
atom
1729
2184
{
1730
2184
and_test
1731
2184
arith_expr
1732
2184
power
1733
2184
STRING
1734
2184
NAME
1735
2184
(
1736
2184
NUMBER
1737
2184
term
1738
2184
+
1739
2184
xor_expr
1740
2184
shift_expr
1741
2184
not
1742
2184
False
1743
2184
lambda
1744
2184
comparison
1745
2184
not_test
1746
2184
or_test
1747
2184
lambdef
1748
2184
expr
1749
2184
test
2432
2185
:
2433
2186
[
1721
2186
factor
1722
2186
True
1723
2186
atom_expr
1724
2186
~
1725
2186
and_expr
1726
2186
-
1727
2186
None
1728
2186
atom
1729
2186
{
1730
2186
arith_expr
1732
2186
power
1733
2186
STRING
1734
2186
NAME
1735
2186
(
1736
2186
NUMBER
1737
2186
term
1738
2186
+
1739
2186
xor_expr
1740
2186
shift_expr
1741
2186
not
1742
2186
False
1743
2186
and_test
2434
2186
comparison
1745
2186
not_test
1746
2186
expr
1749
2187
[
738
2187
factor
740
2187
True
741
2187
~
742
2187
and_expr
743
2187
-
744
2187
atom
745
2187
{
746
2187
arith_expr
747
2187
power
748
2187
atom_expr
749
2187
STRING
750
2187
NAME
751
2187
(
752
2187
or_test
2435
2187
term
753
2187
+
754
2187
xor_expr
755
2187
shift_expr
756
2187
NUMBER
757
2187
not
758
2187
False
759
2187
comparison
760
2187
not_test
761
2187
None
762
2187
expr
763
2187
and_test
764
2188
[
1721
2188
factor
1722
2188
True
1723
2188
atom_expr
1724
2188
~
1725
2188
and_expr
1726
2188
-
1727
2188
None
1728
2188
atom
1729
2188
{
1730
2188
arith_expr
1732
2188
power
1733
2188
STRING
1734
2188
NAME
1735
2188
(
1736
2188
NUMBER
1737
2188
term
1738
2188
+
1739
2188
xor_expr
1740
2188
shift_expr
1741
2188
False
1743
2188
expr
1749
2188
comparison
2436
2189
,
lambdef -> lambda varargslist : test
2189
=
lambdef -> lambda varargslist : test
2189
NEWLINE
lambdef -> lambda varargslist : test
2190
[
632
2190
factor
633
2190
True
634
2190
atom_expr
635
2190
~
636
2190
and_expr
637
2190
-
638
2190
None
639
2190
shift_expr
640
2190
atom
641
2190
{
642
2190
comparison
643
2190
and_test
644
2190
arith_expr
645
2190
power
646
2190
STRING
647
2190
NAME
648
2190
(
649
2190
NUMBER
650
2190
term
651
2190
+
652
2190
xor_expr
654
2190
not
656
2190
False
657
2190
lambda
658
2190
test
2437
2190
not_test
659
2190
or_test
661
2190
lambdef
662
2190
expr
663
2191
.
trailer -> ( arglist )
2191
|
trailer -> ( arglist )
2191
^
trailer -> ( arglist )
2191
==
trailer -> ( arglist )
2191
**
trailer -> ( arglist )
2191
>>
trailer -> ( arglist )
2191
not
trailer -> ( arglist )
2191
<<
trailer -> ( arglist )
2191
>=
trailer -> ( arglist )
2191
!=
trailer -> ( arglist )
2191
in
trailer -> ( arglist )
2191
[
trailer -> ( arglist )
2191
(
trailer -> ( arglist )
2191
>
trailer -> ( arglist )
2191
and
trailer -> ( arglist )
2191
+
trailer -> ( arglist )
2191
%
trailer -> ( arglist )
2191
or
trailer -> ( arglist )
2191
*
trailer -> ( arglist )
2191
is
trailer -> ( arglist )
2191
&
trailer -> ( arglist )
2191
//
trailer -> ( arglist )
2191
=
trailer -> ( arglist )
2191
<
trailer -> ( arglist )
2191
if
trailer -> ( arglist )
2191
<=
trailer -> ( arglist )
2191
-
trailer -> ( arglist )
2191
/
trailer -> ( arglist )
2191
@
trailer -> ( arglist )
2192
<=
trailer -> [ subscriptlist ]
2192
<<
trailer -> [ subscriptlist ]
2192
*
trailer -> [ subscriptlist ]
2192
+
trailer -> [ subscriptlist ]
2192
in
trailer -> [ subscriptlist ]
2192
>>
trailer -> [ subscriptlist ]
2192
//
trailer -> [ subscriptlist ]
2192
.
trailer -> [ subscriptlist ]
2192
and
trailer -> [ subscriptlist ]
2192
**
trailer -> [ subscriptlist ]
2192
=
trailer -> [ subscriptlist ]
2192
@
trailer -> [ subscriptlist ]
2192
<
trailer -> [ subscriptlist ]
2192
not
trailer -> [ subscriptlist ]
2192
-
trailer -> [ subscriptlist ]
2192
!=
trailer -> [ subscriptlist ]
2192
%
trailer -> [ subscriptlist ]
2192
[
trailer -> [ subscriptlist ]
2192
/
trailer -> [ subscriptlist ]
2192
or
trailer -> [ subscriptlist ]
2192
&
trailer -> [ subscriptlist ]
2192
>=
trailer -> [ subscriptlist ]
2192
==
trailer -> [ subscriptlist ]
2192
(
trailer -> [ subscriptlist ]
2192
|
trailer -> [ subscriptlist ]
2192
is
trailer -> [ subscriptlist ]
2192
if
trailer -> [ subscriptlist ]
2192
>
trailer -> [ subscriptlist ]
2192
^
trailer -> [ subscriptlist ]
2193
[
665
2193
factor
666
2193
True
667
2193
atom_expr
668
2193
~
669
2193
and_expr
670
2193
-
671
2193
atom
672
2193
{
673
2193
and_test
674
2193
arith_expr
675
2193
power
676
2193
STRING
677
2193
NAME
678
2193
(
679
2193
term
680
2193
+
681
2193
xor_expr
682
2193
shift_expr
683
2193
NUMBER
684
2193
not
685
2193
False
687
2193
comparison
688
2193
not_test
689
2193
None
690
2193
or_test
691
2193
expr
692
2193
lambda
693
2193
test
2438
2193
lambdef
694
2194
=
lambdef -> lambda varargslist : test
2195
as
test -> or_test if or_test else test
2195
,
test -> or_test if or_test else test
2195
:
test -> or_test if or_test else test
2196
.
atom -> [ test_list_comp ]
2196
/
atom -> [ test_list_comp ]
2196
*
atom -> [ test_list_comp ]
2196
,
atom -> [ test_list_comp ]
2196
[
atom -> [ test_list_comp ]
2196
@
atom -> [ test_list_comp ]
2196
|
atom -> [ test_list_comp ]
2196
**
atom -> [ test_list_comp ]
2196
&
atom -> [ test_list_comp ]
2196
<<
atom -> [ test_list_comp ]
2196
-
atom -> [ test_list_comp ]
2196
(
atom -> [ test_list_comp ]
2196
//
atom -> [ test_list_comp ]
2196
^
atom -> [ test_list_comp ]
2196
+
atom -> [ test_list_comp ]
2196
:
atom -> [ test_list_comp ]
2196
>>
atom -> [ test_list_comp ]
2196
%
atom -> [ test_list_comp ]
2197
+
term -> factor * term
2197
^
term -> factor * term
2197
|
term -> factor * term
2197
<<
term -> factor * term
2197
,
term -> factor * term
2197
>>
term -> factor * term
2197
:
term -> factor * term
2197
&
term -> factor * term
2197
-
term -> factor * term
2198
&
term -> factor / term
2198
+
term -> factor / term
2198
,
term -> factor / term
2198
|
term -> factor / term
2198
:
term -> factor / term
2198
>>
term -> factor / term
2198
<<
term -> factor / term
2198
-
term -> factor / term
2198
^
term -> factor / term
2199
,
term -> factor % term
2199
>>
term -> factor % term
2199
|
term -> factor % term
2199
<<
term -> factor % term
2199
^
term -> factor % term
2199
:
term -> factor % term
2199
-
term -> factor % term
2199
+
term -> factor % term
2199
&
term -> factor % term
2200
&
term -> factor @ term
2200
|
term -> factor @ term
2200
-
term -> factor @ term
2200
<<
term -> factor @ term
2200
^
term -> factor @ term
2200
+
term -> factor @ term
2200
,
term -> factor @ term
2200
:
term -> factor @ term
2200
>>
term -> factor @ term
2201
>>
term -> factor // term
2201
|
term -> factor // term
2201
^
term -> factor // term
2201
&
term -> factor // term
2201
,
term -> factor // term
2201
-
term -> factor // term
2201
<<
term -> factor // term
2201
:
term -> factor // term
2201
+
term -> factor // term
2202
,
xor_expr -> and_expr ^ xor_expr
2202
:
xor_expr -> and_expr ^ xor_expr
2202
|
xor_expr -> and_expr ^ xor_expr
2203
&
shift_expr -> arith_expr << shift_expr
2203
:
shift_expr -> arith_expr << shift_expr
2203
^
shift_expr -> arith_expr << shift_expr
2203
,
shift_expr -> arith_expr << shift_expr
2203
|
shift_expr -> arith_expr << shift_expr
2204
,
shift_expr -> arith_expr >> shift_expr
2204
|
shift_expr -> arith_expr >> shift_expr
2204
:
shift_expr -> arith_expr >> shift_expr
2204
&
shift_expr -> arith_expr >> shift_expr
2204
^
shift_expr -> arith_expr >> shift_expr
2205
:
and_expr -> shift_expr & and_expr
2205
^
and_expr -> shift_expr & and_expr
2205
,
and_expr -> shift_expr & and_expr
2205
|
and_expr -> shift_expr & and_expr
2206
^
trailer -> ( )
2206
@
trailer -> ( )
2206
/
trailer -> ( )
2206
[
trailer -> ( )
2206
,
trailer -> ( )
2206
|
trailer -> ( )
2206
(
trailer -> ( )
2206
.
trailer -> ( )
2206
+
trailer -> ( )
2206
-
trailer -> ( )
2206
<<
trailer -> ( )
2206
&
trailer -> ( )
2206
//
trailer -> ( )
2206
:
trailer -> ( )
2206
*
trailer -> ( )
2206
**
trailer -> ( )
2206
%
trailer -> ( )
2206
>>
trailer -> ( )
2207
)
2439
2208
]
2440
2209
:
trailer_expr -> trailer trailer_expr
2209
,
trailer_expr -> trailer trailer_expr
2209
&
trailer_expr -> trailer trailer_expr
2209
|
trailer_expr -> trailer trailer_expr
2209
%
trailer_expr -> trailer trailer_expr
2209
@
trailer_expr -> trailer trailer_expr
2209
+
trailer_expr -> trailer trailer_expr
2209
*
trailer_expr -> trailer trailer_expr
2209
>>
trailer_expr -> trailer trailer_expr
2209
^
trailer_expr -> trailer trailer_expr
2209
**
trailer_expr -> trailer trailer_expr
2209
<<
trailer_expr -> trailer trailer_expr
2209
-
trailer_expr -> trailer trailer_expr
2209
//
trailer_expr -> trailer trailer_expr
2209
/
trailer_expr -> trailer trailer_expr
2210
.
trailer -> . NAME
2210
,
trailer -> . NAME
2210
%
trailer -> . NAME
2210
//
trailer -> . NAME
2210
**
trailer -> . NAME
2210
*
trailer -> . NAME
2210
:
trailer -> . NAME
2210
|
trailer -> . NAME
2210
<<
trailer -> . NAME
2210
-
trailer -> . NAME
2210
>>
trailer -> . NAME
2210
(
trailer -> . NAME
2210
&
trailer -> . NAME
2210
+
trailer -> . NAME
2210
/
trailer -> . NAME
2210
^
trailer -> . NAME
2210
[
trailer -> . NAME
2210
@
trailer -> . NAME
2211
@
atom -> ( test_list_comp )
2211
.
atom -> ( test_list_comp )
2211
&
atom -> ( test_list_comp )
2211
/
atom -> ( test_list_comp )
2211
//
atom -> ( test_list_comp )
2211
^
atom -> ( test_list_comp )
2211
(
atom -> ( test_list_comp )
2211
*
atom -> ( test_list_comp )
2211
-
atom -> ( test_list_comp )
2211
**
atom -> ( test_list_comp )
2211
|
atom -> ( test_list_comp )
2211
[
atom -> ( test_list_comp )
2211
+
atom -> ( test_list_comp )
2211
:
atom -> ( test_list_comp )
2211
<<
atom -> ( test_list_comp )
2211
%
atom -> ( test_list_comp )
2211
,
atom -> ( test_list_comp )
2211
>>
atom -> ( test_list_comp )
2212
^
arith_expr -> term - arith_expr
2212
|
arith_expr -> term - arith_expr
2212
&
arith_expr -> term - arith_expr
2212
<<
arith_expr -> term - arith_expr
2212
>>
arith_expr -> term - arith_expr
2212
,
arith_expr -> term - arith_expr
2212
:
arith_expr -> term - arith_expr
2213
^
arith_expr -> term + arith_expr
2213
&
arith_expr -> term + arith_expr
2213
>>
arith_expr -> term + arith_expr
2213
:
arith_expr -> term + arith_expr
2213
<<
arith_expr -> term + arith_expr
2213
,
arith_expr -> term + arith_expr
2213
|
arith_expr -> term + arith_expr
2214
:
power -> atom_expr ** factor
2214
@
power -> atom_expr ** factor
2214
^
power -> atom_expr ** factor
2214
//
power -> atom_expr ** factor
2214
,
power -> atom_expr ** factor
2214
*
power -> atom_expr ** factor
2214
%
power -> atom_expr ** factor
2214
<<
power -> atom_expr ** factor
2214
|
power -> atom_expr ** factor
2214
+
power -> atom_expr ** factor
2214
-
power -> atom_expr ** factor
2214
>>
power -> atom_expr ** factor
2214
&
power -> atom_expr ** factor
2214
/
power -> atom_expr ** factor
2215
:
expr -> xor_expr | expr
2215
,
expr -> xor_expr | expr
2216
:
2441
2217
:
2442
2218
DEDENT
2443
2219
.
trailer -> ( arglist )
2219
|
trailer -> ( arglist )
2219
^
trailer -> ( arglist )
2219
==
trailer -> ( arglist )
2219
**
trailer -> ( arglist )
2219
else
trailer -> ( arglist )
2219
>>
trailer -> ( arglist )
2219
not
trailer -> ( arglist )
2219
<<
trailer -> ( arglist )
2219
>=
trailer -> ( arglist )
2219
!=
trailer -> ( arglist )
2219
in
trailer -> ( arglist )
2219
[
trailer -> ( arglist )
2219
(
trailer -> ( arglist )
2219
>
trailer -> ( arglist )
2219
and
trailer -> ( arglist )
2219
+
trailer -> ( arglist )
2219
%
trailer -> ( arglist )
2219
or
trailer -> ( arglist )
2219
*
trailer -> ( arglist )
2219
is
trailer -> ( arglist )
2219
&
trailer -> ( arglist )
2219
//
trailer -> ( arglist )
2219
<
trailer -> ( arglist )
2219
<=
trailer -> ( arglist )
2219
-
trailer -> ( arglist )
2219
/
trailer -> ( arglist )
2219
@
trailer -> ( arglist )
2220
<=
trailer -> [ subscriptlist ]
2220
<<
trailer -> [ subscriptlist ]
2220
*
trailer -> [ subscriptlist ]
2220
+
trailer -> [ subscriptlist ]
2220
in
trailer -> [ subscriptlist ]
2220
>>
trailer -> [ subscriptlist ]
2220
//
trailer -> [ subscriptlist ]
2220
.
trailer -> [ subscriptlist ]
2220
else
trailer -> [ subscriptlist ]
2220
and
trailer -> [ subscriptlist ]
2220
**
trailer -> [ subscriptlist ]
2220
@
trailer -> [ subscriptlist ]
2220
<
trailer -> [ subscriptlist ]
2220
not
trailer -> [ subscriptlist ]
2220
-
trailer -> [ subscriptlist ]
2220
!=
trailer -> [ subscriptlist ]
2220
%
trailer -> [ subscriptlist ]
2220
[
trailer -> [ subscriptlist ]
2220
/
trailer -> [ subscriptlist ]
2220
or
trailer -> [ subscriptlist ]
2220
&
trailer -> [ subscriptlist ]
2220
>=
trailer -> [ subscriptlist ]
2220
==
trailer -> [ subscriptlist ]
2220
(
trailer -> [ subscriptlist ]
2220
|
trailer -> [ subscriptlist ]
2220
is
trailer -> [ subscriptlist ]
2220
>
trailer -> [ subscriptlist ]
2220
^
trailer -> [ subscriptlist ]
2221
,
trailer -> ( arglist )
2221
.
trailer -> ( arglist )
2221
|
trailer -> ( arglist )
2221
^
trailer -> ( arglist )
2221
==
trailer -> ( arglist )
2221
**
trailer -> ( arglist )
2221
>>
trailer -> ( arglist )
2221
not
trailer -> ( arglist )
2221
<<
trailer -> ( arglist )
2221
>=
trailer -> ( arglist )
2221
!=
trailer -> ( arglist )
2221
in
trailer -> ( arglist )
2221
[
trailer -> ( arglist )
2221
(
trailer -> ( arglist )
2221
>
trailer -> ( arglist )
2221
and
trailer -> ( arglist )
2221
+
trailer -> ( arglist )
2221
%
trailer -> ( arglist )
2221
or
trailer -> ( arglist )
2221
*
trailer -> ( arglist )
2221
for
trailer -> ( arglist )
2221
is
trailer -> ( arglist )
2221
&
trailer -> ( arglist )
2221
//
trailer -> ( arglist )
2221
=
trailer -> ( arglist )
2221
-
trailer -> ( arglist )
2221
)
trailer -> ( arglist )
2221
<
trailer -> ( arglist )
2221
<=
trailer -> ( arglist )
2221
if
trailer -> ( arglist )
2221
/
trailer -> ( arglist )
2221
@
trailer -> ( arglist )
2222
for
trailer -> [ subscriptlist ]
2222
<=
trailer -> [ subscriptlist ]
2222
<<
trailer -> [ subscriptlist ]
2222
*
trailer -> [ subscriptlist ]
2222
+
trailer -> [ subscriptlist ]
2222
in
trailer -> [ subscriptlist ]
2222
>>
trailer -> [ subscriptlist ]
2222
//
trailer -> [ subscriptlist ]
2222
.
trailer -> [ subscriptlist ]
2222
,
trailer -> [ subscriptlist ]
2222
and
trailer -> [ subscriptlist ]
2222
**
trailer -> [ subscriptlist ]
2222
=
trailer -> [ subscriptlist ]
2222
@
trailer -> [ subscriptlist ]
2222
<
trailer -> [ subscriptlist ]
2222
not
trailer -> [ subscriptlist ]
2222
-
trailer -> [ subscriptlist ]
2222
!=
trailer -> [ subscriptlist ]
2222
%
trailer -> [ subscriptlist ]
2222
)
trailer -> [ subscriptlist ]
2222
[
trailer -> [ subscriptlist ]
2222
/
trailer -> [ subscriptlist ]
2222
or
trailer -> [ subscriptlist ]
2222
&
trailer -> [ subscriptlist ]
2222
>=
trailer -> [ subscriptlist ]
2222
==
trailer -> [ subscriptlist ]
2222
(
trailer -> [ subscriptlist ]
2222
|
trailer -> [ subscriptlist ]
2222
is
trailer -> [ subscriptlist ]
2222
if
trailer -> [ subscriptlist ]
2222
>
trailer -> [ subscriptlist ]
2222
^
trailer -> [ subscriptlist ]
2223
[
766
2223
factor
767
2223
True
768
2223
atom_expr
769
2223
~
770
2223
and_expr
771
2223
-
772
2223
{
773
2223
shift_expr
774
2223
atom
775
2223
comparison
776
2223
and_test
777
2223
arith_expr
778
2223
power
779
2223
STRING
780
2223
NAME
781
2223
(
782
2223
term
784
2223
+
785
2223
xor_expr
786
2223
or_test
788
2223
NUMBER
789
2223
not
790
2223
False
791
2223
expr
792
2223
not_test
794
2223
None
795
2223
lambdef
796
2223
lambda
797
2223
test
2444
2224
,
lambdef -> lambda varargslist : test
2224
=
lambdef -> lambda varargslist : test
2224
)
lambdef -> lambda varargslist : test
2224
for
lambdef -> lambda varargslist : test
2225
[
128
2225
factor
129
2225
True
130
2225
atom_expr
131
2225
~
132
2225
and_expr
133
2225
-
134
2225
{
135
2225
shift_expr
137
2225
atom
138
2225
comparison
140
2225
or_test
2445
2225
arith_expr
141
2225
power
142
2225
STRING
143
2225
NAME
144
2225
(
145
2225
and_test
146
2225
term
147
2225
+
148
2225
xor_expr
149
2225
NUMBER
151
2225
not
152
2225
False
153
2225
expr
154
2225
not_test
155
2225
None
156
2226
,
trailer -> ( arglist )
2226
.
trailer -> ( arglist )
2226
|
trailer -> ( arglist )
2226
^
trailer -> ( arglist )
2226
==
trailer -> ( arglist )
2226
**
trailer -> ( arglist )
2226
>>
trailer -> ( arglist )
2226
not
trailer -> ( arglist )
2226
<<
trailer -> ( arglist )
2226
>=
trailer -> ( arglist )
2226
!=
trailer -> ( arglist )
2226
in
trailer -> ( arglist )
2226
[
trailer -> ( arglist )
2226
(
trailer -> ( arglist )
2226
]
trailer -> ( arglist )
2226
>
trailer -> ( arglist )
2226
and
trailer -> ( arglist )
2226
+
trailer -> ( arglist )
2226
%
trailer -> ( arglist )
2226
or
trailer -> ( arglist )
2226
*
trailer -> ( arglist )
2226
is
trailer -> ( arglist )
2226
&
trailer -> ( arglist )
2226
//
trailer -> ( arglist )
2226
:
trailer -> ( arglist )
2226
<
trailer -> ( arglist )
2226
if
trailer -> ( arglist )
2226
<=
trailer -> ( arglist )
2226
-
trailer -> ( arglist )
2226
/
trailer -> ( arglist )
2226
@
trailer -> ( arglist )
2227
]
trailer -> [ subscriptlist ]
2227
<=
trailer -> [ subscriptlist ]
2227
<<
trailer -> [ subscriptlist ]
2227
:
trailer -> [ subscriptlist ]
2227
*
trailer -> [ subscriptlist ]
2227
+
trailer -> [ subscriptlist ]
2227
in
trailer -> [ subscriptlist ]
2227
>>
trailer -> [ subscriptlist ]
2227
//
trailer -> [ subscriptlist ]
2227
.
trailer -> [ subscriptlist ]
2227
,
trailer -> [ subscriptlist ]
2227
and
trailer -> [ subscriptlist ]
2227
**
trailer -> [ subscriptlist ]
2227
@
trailer -> [ subscriptlist ]
2227
<
trailer -> [ subscriptlist ]
2227
not
trailer -> [ subscriptlist ]
2227
-
trailer -> [ subscriptlist ]
2227
!=
trailer -> [ subscriptlist ]
2227
%
trailer -> [ subscriptlist ]
2227
[
trailer -> [ subscriptlist ]
2227
/
trailer -> [ subscriptlist ]
2227
or
trailer -> [ subscriptlist ]
2227
&
trailer -> [ subscriptlist ]
2227
>=
trailer -> [ subscriptlist ]
2227
==
trailer -> [ subscriptlist ]
2227
(
trailer -> [ subscriptlist ]
2227
|
trailer -> [ subscriptlist ]
2227
is
trailer -> [ subscriptlist ]
2227
if
trailer -> [ subscriptlist ]
2227
>
trailer -> [ subscriptlist ]
2227
^
trailer -> [ subscriptlist ]
2228
[
802
2228
factor
803
2228
True
804
2228
atom_expr
810
2228
~
806
2228
not
807
2228
and_expr
808
2228
-
809
2228
shift_expr
811
2228
atom
812
2228
{
813
2228
comparison
814
2228
or_test
815
2228
(
816
2228
arith_expr
817
2228
power
818
2228
STRING
819
2228
NAME
820
2228
and_test
821
2228
term
822
2228
+
823
2228
xor_expr
824
2228
NUMBER
826
2228
False
827
2228
expr
829
2228
not_test
830
2228
None
831
2228
lambdef
832
2228
test
2446
2228
lambda
833
2229
,
lambdef -> lambda varargslist : test
2229
:
lambdef -> lambda varargslist : test
2229
]
lambdef -> lambda varargslist : test
2230
,
subscript -> maybe_test : maybe_test sliceop
2230
]
subscript -> maybe_test : maybe_test sliceop
2231
[
1052
2231
factor
1053
2231
True
1054
2231
atom_expr
1055
2231
~
1056
2231
not
1057
2231
and_expr
1058
2231
-
1059
2231
shift_expr
1060
2231
atom
1061
2231
{
1062
2231
comparison
1063
2231
(
1064
2231
arith_expr
1065
2231
power
1066
2231
STRING
1067
2231
NAME
1068
2231
and_test
1069
2231
term
1071
2231
+
1072
2231
xor_expr
1073
2231
NUMBER
1074
2231
False
1075
2231
not_test
1076
2231
]
maybe_test -> 
2231
None
1077
2231
expr
1078
2231
test
2447
2231
lambda
1079
2231
or_test
1080
2231
,
maybe_test -> 
2231
lambdef
1081
2231
maybe_test
2448
2232
NEWLINE
test -> or_test if or_test else test
2232
,
test -> or_test if or_test else test
2233
NEWLINE
test -> or_test if or_test else test
2233
from
test -> or_test if or_test else test
2234
NEWLINE
test -> or_test if or_test else test
2235
True
try_stmt -> try : suite except_clause finally : suite
2235
assert
try_stmt -> try : suite except_clause finally : suite
2235
conf
try_stmt -> try : suite except_clause finally : suite
2235
with
try_stmt -> try : suite except_clause finally : suite
2235
return
try_stmt -> try : suite except_clause finally : suite
2235
if
try_stmt -> try : suite except_clause finally : suite
2235
raise
try_stmt -> try : suite except_clause finally : suite
2235
~
try_stmt -> try : suite except_clause finally : suite
2235
not
try_stmt -> try : suite except_clause finally : suite
2235
NEWLINE
try_stmt -> try : suite except_clause finally : suite
2235
@
try_stmt -> try : suite except_clause finally : suite
2235
del
try_stmt -> try : suite except_clause finally : suite
2235
continue
try_stmt -> try : suite except_clause finally : suite
2235
NUMBER
try_stmt -> try : suite except_clause finally : suite
2235
yield
try_stmt -> try : suite except_clause finally : suite
2235
server
try_stmt -> try : suite except_clause finally : suite
2235
try
try_stmt -> try : suite except_clause finally : suite
2235
resetstats
try_stmt -> try : suite except_clause finally : suite
2235
for
try_stmt -> try : suite except_clause finally : suite
2235
begsim
try_stmt -> try : suite except_clause finally : suite
2235
class
try_stmt -> try : suite except_clause finally : suite
2235
-
try_stmt -> try : suite except_clause finally : suite
2235
pass
try_stmt -> try : suite except_clause finally : suite
2235
endsim
try_stmt -> try : suite except_clause finally : suite
2235
None
try_stmt -> try : suite except_clause finally : suite
2235
while
try_stmt -> try : suite except_clause finally : suite
2235
break
try_stmt -> try : suite except_clause finally : suite
2235
STRING
try_stmt -> try : suite except_clause finally : suite
2235
[
try_stmt -> try : suite except_clause finally : suite
2235
nonlocal
try_stmt -> try : suite except_clause finally : suite
2235
(
try_stmt -> try : suite except_clause finally : suite
2235
+
try_stmt -> try : suite except_clause finally : suite
2235
lambda
try_stmt -> try : suite except_clause finally : suite
2235
modopt
try_stmt -> try : suite except_clause finally : suite
2235
global
try_stmt -> try : suite except_clause finally : suite
2235
False
try_stmt -> try : suite except_clause finally : suite
2235
$
try_stmt -> try : suite except_clause finally : suite
2235
NAME
try_stmt -> try : suite except_clause finally : suite
2235
def
try_stmt -> try : suite except_clause finally : suite
2235
servmod
try_stmt -> try : suite except_clause finally : suite
2235
{
try_stmt -> try : suite except_clause finally : suite
2236
NEWLINE
2449
2237
INDENT
2450
2238
modopt
suite -> simple_stmt
2238
~
suite -> simple_stmt
2238
False
suite -> simple_stmt
2238
@
suite -> simple_stmt
2238
begsim
suite -> simple_stmt
2238
NUMBER
suite -> simple_stmt
2238
conf
suite -> simple_stmt
2238
class
suite -> simple_stmt
2238
finally
suite -> simple_stmt
2238
if
suite -> simple_stmt
2238
yield
suite -> simple_stmt
2238
try
suite -> simple_stmt
2238
pass
suite -> simple_stmt
2238
NEWLINE
suite -> simple_stmt
2238
[
suite -> simple_stmt
2238
break
suite -> simple_stmt
2238
True
suite -> simple_stmt
2238
None
suite -> simple_stmt
2238
server
suite -> simple_stmt
2238
assert
suite -> simple_stmt
2238
$
suite -> simple_stmt
2238
servmod
suite -> simple_stmt
2238
raise
suite -> simple_stmt
2238
nonlocal
suite -> simple_stmt
2238
lambda
suite -> simple_stmt
2238
return
suite -> simple_stmt
2238
+
suite -> simple_stmt
2238
-
suite -> simple_stmt
2238
NAME
suite -> simple_stmt
2238
while
suite -> simple_stmt
2238
def
suite -> simple_stmt
2238
with
suite -> simple_stmt
2238
del
suite -> simple_stmt
2238
STRING
suite -> simple_stmt
2238
for
suite -> simple_stmt
2238
resetstats
suite -> simple_stmt
2238
global
suite -> simple_stmt
2238
continue
suite -> simple_stmt
2238
endsim
suite -> simple_stmt
2238
not
suite -> simple_stmt
2238
{
suite -> simple_stmt
2238
(
suite -> simple_stmt
2239
finally
2451
2239
server
try_stmt -> try : suite except_clause else : suite
2239
endsim
try_stmt -> try : suite except_clause else : suite
2239
lambda
try_stmt -> try : suite except_clause else : suite
2239
False
try_stmt -> try : suite except_clause else : suite
2239
del
try_stmt -> try : suite except_clause else : suite
2239
(
try_stmt -> try : suite except_clause else : suite
2239
global
try_stmt -> try : suite except_clause else : suite
2239
continue
try_stmt -> try : suite except_clause else : suite
2239
with
try_stmt -> try : suite except_clause else : suite
2239
nonlocal
try_stmt -> try : suite except_clause else : suite
2239
conf
try_stmt -> try : suite except_clause else : suite
2239
begsim
try_stmt -> try : suite except_clause else : suite
2239
NUMBER
try_stmt -> try : suite except_clause else : suite
2239
[
try_stmt -> try : suite except_clause else : suite
2239
~
try_stmt -> try : suite except_clause else : suite
2239
True
try_stmt -> try : suite except_clause else : suite
2239
class
try_stmt -> try : suite except_clause else : suite
2239
{
try_stmt -> try : suite except_clause else : suite
2239
assert
try_stmt -> try : suite except_clause else : suite
2239
break
try_stmt -> try : suite except_clause else : suite
2239
for
try_stmt -> try : suite except_clause else : suite
2239
not
try_stmt -> try : suite except_clause else : suite
2239
NAME
try_stmt -> try : suite except_clause else : suite
2239
try
try_stmt -> try : suite except_clause else : suite
2239
def
try_stmt -> try : suite except_clause else : suite
2239
while
try_stmt -> try : suite except_clause else : suite
2239
return
try_stmt -> try : suite except_clause else : suite
2239
@
try_stmt -> try : suite except_clause else : suite
2239
None
try_stmt -> try : suite except_clause else : suite
2239
+
try_stmt -> try : suite except_clause else : suite
2239
STRING
try_stmt -> try : suite except_clause else : suite
2239
if
try_stmt -> try : suite except_clause else : suite
2239
yield
try_stmt -> try : suite except_clause else : suite
2239
servmod
try_stmt -> try : suite except_clause else : suite
2239
raise
try_stmt -> try : suite except_clause else : suite
2239
-
try_stmt -> try : suite except_clause else : suite
2239
modopt
try_stmt -> try : suite except_clause else : suite
2239
NEWLINE
try_stmt -> try : suite except_clause else : suite
2239
pass
try_stmt -> try : suite except_clause else : suite
2239
resetstats
try_stmt -> try : suite except_clause else : suite
2239
$
try_stmt -> try : suite except_clause else : suite
2240
.
atom -> [ test_list_comp ]
2240
[
atom -> [ test_list_comp ]
2240
@
atom -> [ test_list_comp ]
2240
<=
atom -> [ test_list_comp ]
2240
<
atom -> [ test_list_comp ]
2240
not
atom -> [ test_list_comp ]
2240
in
atom -> [ test_list_comp ]
2240
and
atom -> [ test_list_comp ]
2240
-
atom -> [ test_list_comp ]
2240
if
atom -> [ test_list_comp ]
2240
!=
atom -> [ test_list_comp ]
2240
is
atom -> [ test_list_comp ]
2240
>>
atom -> [ test_list_comp ]
2240
or
atom -> [ test_list_comp ]
2240
//
atom -> [ test_list_comp ]
2240
/
atom -> [ test_list_comp ]
2240
|
atom -> [ test_list_comp ]
2240
>
atom -> [ test_list_comp ]
2240
&
atom -> [ test_list_comp ]
2240
(
atom -> [ test_list_comp ]
2240
%
atom -> [ test_list_comp ]
2240
>=
atom -> [ test_list_comp ]
2240
==
atom -> [ test_list_comp ]
2240
**
atom -> [ test_list_comp ]
2240
:
atom -> [ test_list_comp ]
2240
<<
atom -> [ test_list_comp ]
2240
as
atom -> [ test_list_comp ]
2240
*
atom -> [ test_list_comp ]
2240
^
atom -> [ test_list_comp ]
2240
+
atom -> [ test_list_comp ]
2241
:
2452
2242
except
938
2242
None
maybe_except_clause -> 
2242
if
maybe_except_clause -> 
2242
while
maybe_except_clause -> 
2242
return
maybe_except_clause -> 
2242
continue
maybe_except_clause -> 
2242
except_clause
2262
2242
server
maybe_except_clause -> 
2242
maybe_except_clause
2453
2242
nonlocal
maybe_except_clause -> 
2242
def
maybe_except_clause -> 
2242
servmod
maybe_except_clause -> 
2242
endsim
maybe_except_clause -> 
2242
else
maybe_except_clause -> 
2242
global
maybe_except_clause -> 
2242
conf
maybe_except_clause -> 
2242
pass
maybe_except_clause -> 
2242
True
maybe_except_clause -> 
2242
NUMBER
maybe_except_clause -> 
2242
NEWLINE
maybe_except_clause -> 
2242
try
maybe_except_clause -> 
2242
False
maybe_except_clause -> 
2242
~
maybe_except_clause -> 
2242
with
maybe_except_clause -> 
2242
not
maybe_except_clause -> 
2242
NAME
maybe_except_clause -> 
2242
@
maybe_except_clause -> 
2242
(
maybe_except_clause -> 
2242
yield
maybe_except_clause -> 
2242
[
maybe_except_clause -> 
2242
finally
maybe_except_clause -> 
2242
-
maybe_except_clause -> 
2242
raise
maybe_except_clause -> 
2242
{
maybe_except_clause -> 
2242
assert
maybe_except_clause -> 
2242
$
maybe_except_clause -> 
2242
class
maybe_except_clause -> 
2242
break
maybe_except_clause -> 
2242
+
maybe_except_clause -> 
2242
STRING
maybe_except_clause -> 
2242
del
maybe_except_clause -> 
2242
begsim
maybe_except_clause -> 
2242
lambda
maybe_except_clause -> 
2242
resetstats
maybe_except_clause -> 
2242
for
maybe_except_clause -> 
2242
modopt
maybe_except_clause -> 
2243
<<
term -> factor @ term
2243
^
term -> factor @ term
2243
<=
term -> factor @ term
2243
&
term -> factor @ term
2243
==
term -> factor @ term
2243
if
term -> factor @ term
2243
|
term -> factor @ term
2243
!=
term -> factor @ term
2243
or
term -> factor @ term
2243
>
term -> factor @ term
2243
and
term -> factor @ term
2243
>>
term -> factor @ term
2243
is
term -> factor @ term
2243
-
term -> factor @ term
2243
not
term -> factor @ term
2243
+
term -> factor @ term
2243
in
term -> factor @ term
2243
>=
term -> factor @ term
2243
as
term -> factor @ term
2243
<
term -> factor @ term
2243
:
term -> factor @ term
2244
<=
term -> factor % term
2244
is
term -> factor % term
2244
>
term -> factor % term
2244
and
term -> factor % term
2244
in
term -> factor % term
2244
or
term -> factor % term
2244
<
term -> factor % term
2244
:
term -> factor % term
2244
-
term -> factor % term
2244
!=
term -> factor % term
2244
>>
term -> factor % term
2244
^
term -> factor % term
2244
+
term -> factor % term
2244
if
term -> factor % term
2244
<<
term -> factor % term
2244
as
term -> factor % term
2244
>=
term -> factor % term
2244
==
term -> factor % term
2244
not
term -> factor % term
2244
|
term -> factor % term
2244
&
term -> factor % term
2245
>>
term -> factor / term
2245
!=
term -> factor / term
2245
<
term -> factor / term
2245
<=
term -> factor / term
2245
|
term -> factor / term
2245
is
term -> factor / term
2245
>=
term -> factor / term
2245
^
term -> factor / term
2245
&
term -> factor / term
2245
+
term -> factor / term
2245
as
term -> factor / term
2245
<<
term -> factor / term
2245
and
term -> factor / term
2245
-
term -> factor / term
2245
in
term -> factor / term
2245
>
term -> factor / term
2245
or
term -> factor / term
2245
not
term -> factor / term
2245
==
term -> factor / term
2245
:
term -> factor / term
2245
if
term -> factor / term
2246
is
term -> factor * term
2246
+
term -> factor * term
2246
>=
term -> factor * term
2246
^
term -> factor * term
2246
<=
term -> factor * term
2246
or
term -> factor * term
2246
<
term -> factor * term
2246
|
term -> factor * term
2246
>>
term -> factor * term
2246
in
term -> factor * term
2246
not
term -> factor * term
2246
==
term -> factor * term
2246
as
term -> factor * term
2246
:
term -> factor * term
2246
-
term -> factor * term
2246
and
term -> factor * term
2246
!=
term -> factor * term
2246
<<
term -> factor * term
2246
>
term -> factor * term
2246
if
term -> factor * term
2246
&
term -> factor * term
2247
!=
term -> factor // term
2247
or
term -> factor // term
2247
^
term -> factor // term
2247
>
term -> factor // term
2247
is
term -> factor // term
2247
&
term -> factor // term
2247
-
term -> factor // term
2247
:
term -> factor // term
2247
in
term -> factor // term
2247
>>
term -> factor // term
2247
|
term -> factor // term
2247
as
term -> factor // term
2247
<
term -> factor // term
2247
>=
term -> factor // term
2247
not
term -> factor // term
2247
if
term -> factor // term
2247
==
term -> factor // term
2247
<=
term -> factor // term
2247
and
term -> factor // term
2247
<<
term -> factor // term
2247
+
term -> factor // term
2248
:
power -> atom_expr ** factor
2248
!=
power -> atom_expr ** factor
2248
@
power -> atom_expr ** factor
2248
|
power -> atom_expr ** factor
2248
in
power -> atom_expr ** factor
2248
==
power -> atom_expr ** factor
2248
if
power -> atom_expr ** factor
2248
and
power -> atom_expr ** factor
2248
>=
power -> atom_expr ** factor
2248
/
power -> atom_expr ** factor
2248
not
power -> atom_expr ** factor
2248
^
power -> atom_expr ** factor
2248
//
power -> atom_expr ** factor
2248
as
power -> atom_expr ** factor
2248
>
power -> atom_expr ** factor
2248
+
power -> atom_expr ** factor
2248
%
power -> atom_expr ** factor
2248
-
power -> atom_expr ** factor
2248
is
power -> atom_expr ** factor
2248
<=
power -> atom_expr ** factor
2248
<
power -> atom_expr ** factor
2248
*
power -> atom_expr ** factor
2248
<<
power -> atom_expr ** factor
2248
or
power -> atom_expr ** factor
2248
>>
power -> atom_expr ** factor
2248
&
power -> atom_expr ** factor
2249
not
xor_expr -> and_expr ^ xor_expr
2249
<
xor_expr -> and_expr ^ xor_expr
2249
>=
xor_expr -> and_expr ^ xor_expr
2249
>
xor_expr -> and_expr ^ xor_expr
2249
is
xor_expr -> and_expr ^ xor_expr
2249
!=
xor_expr -> and_expr ^ xor_expr
2249
and
xor_expr -> and_expr ^ xor_expr
2249
:
xor_expr -> and_expr ^ xor_expr
2249
as
xor_expr -> and_expr ^ xor_expr
2249
if
xor_expr -> and_expr ^ xor_expr
2249
<=
xor_expr -> and_expr ^ xor_expr
2249
in
xor_expr -> and_expr ^ xor_expr
2249
==
xor_expr -> and_expr ^ xor_expr
2249
|
xor_expr -> and_expr ^ xor_expr
2249
or
xor_expr -> and_expr ^ xor_expr
2250
+
trailer -> ( )
2250
!=
trailer -> ( )
2250
<<
trailer -> ( )
2250
>=
trailer -> ( )
2250
**
trailer -> ( )
2250
not
trailer -> ( )
2250
if
trailer -> ( )
2250
|
trailer -> ( )
2250
[
trailer -> ( )
2250
==
trailer -> ( )
2250
%
trailer -> ( )
2250
*
trailer -> ( )
2250
>>
trailer -> ( )
2250
@
trailer -> ( )
2250
>
trailer -> ( )
2250
/
trailer -> ( )
2250
in
trailer -> ( )
2250
(
trailer -> ( )
2250
as
trailer -> ( )
2250
is
trailer -> ( )
2250
//
trailer -> ( )
2250
<
trailer -> ( )
2250
:
trailer -> ( )
2250
or
trailer -> ( )
2250
^
trailer -> ( )
2250
and
trailer -> ( )
2250
<=
trailer -> ( )
2250
.
trailer -> ( )
2250
-
trailer -> ( )
2250
&
trailer -> ( )
2251
)
2454
2252
<=
trailer_expr -> trailer trailer_expr
2252
+
trailer_expr -> trailer trailer_expr
2252
^
trailer_expr -> trailer trailer_expr
2252
or
trailer_expr -> trailer trailer_expr
2252
==
trailer_expr -> trailer trailer_expr
2252
%
trailer_expr -> trailer trailer_expr
2252
@
trailer_expr -> trailer trailer_expr
2252
not
trailer_expr -> trailer trailer_expr
2252
<<
trailer_expr -> trailer trailer_expr
2252
-
trailer_expr -> trailer trailer_expr
2252
//
trailer_expr -> trailer trailer_expr
2252
and
trailer_expr -> trailer trailer_expr
2252
|
trailer_expr -> trailer trailer_expr
2252
if
trailer_expr -> trailer trailer_expr
2252
as
trailer_expr -> trailer trailer_expr
2252
>
trailer_expr -> trailer trailer_expr
2252
!=
trailer_expr -> trailer trailer_expr
2252
<
trailer_expr -> trailer trailer_expr
2252
>>
trailer_expr -> trailer trailer_expr
2252
/
trailer_expr -> trailer trailer_expr
2252
:
trailer_expr -> trailer trailer_expr
2252
is
trailer_expr -> trailer trailer_expr
2252
&
trailer_expr -> trailer trailer_expr
2252
in
trailer_expr -> trailer trailer_expr
2252
>=
trailer_expr -> trailer trailer_expr
2252
*
trailer_expr -> trailer trailer_expr
2252
**
trailer_expr -> trailer trailer_expr
2253
.
trailer -> . NAME
2253
not
trailer -> . NAME
2253
if
trailer -> . NAME
2253
**
trailer -> . NAME
2253
:
trailer -> . NAME
2253
|
trailer -> . NAME
2253
-
trailer -> . NAME
2253
(
trailer -> . NAME
2253
%
trailer -> . NAME
2253
//
trailer -> . NAME
2253
==
trailer -> . NAME
2253
>>
trailer -> . NAME
2253
is
trailer -> . NAME
2253
!=
trailer -> . NAME
2253
and
trailer -> . NAME
2253
as
trailer -> . NAME
2253
>=
trailer -> . NAME
2253
>
trailer -> . NAME
2253
in
trailer -> . NAME
2253
<<
trailer -> . NAME
2253
&
trailer -> . NAME
2253
/
trailer -> . NAME
2253
^
trailer -> . NAME
2253
[
trailer -> . NAME
2253
<=
trailer -> . NAME
2253
or
trailer -> . NAME
2253
+
trailer -> . NAME
2253
<
trailer -> . NAME
2253
*
trailer -> . NAME
2253
@
trailer -> . NAME
2254
]
2455
2255
else
2456
2256
==
shift_expr -> arith_expr >> shift_expr
2256
^
shift_expr -> arith_expr >> shift_expr
2256
or
shift_expr -> arith_expr >> shift_expr
2256
if
shift_expr -> arith_expr >> shift_expr
2256
not
shift_expr -> arith_expr >> shift_expr
2256
as
shift_expr -> arith_expr >> shift_expr
2256
|
shift_expr -> arith_expr >> shift_expr
2256
<=
shift_expr -> arith_expr >> shift_expr
2256
is
shift_expr -> arith_expr >> shift_expr
2256
in
shift_expr -> arith_expr >> shift_expr
2256
>=
shift_expr -> arith_expr >> shift_expr
2256
>
shift_expr -> arith_expr >> shift_expr
2256
:
shift_expr -> arith_expr >> shift_expr
2256
&
shift_expr -> arith_expr >> shift_expr
2256
<
shift_expr -> arith_expr >> shift_expr
2256
and
shift_expr -> arith_expr >> shift_expr
2256
!=
shift_expr -> arith_expr >> shift_expr
2257
or
shift_expr -> arith_expr << shift_expr
2257
>
shift_expr -> arith_expr << shift_expr
2257
in
shift_expr -> arith_expr << shift_expr
2257
&
shift_expr -> arith_expr << shift_expr
2257
:
shift_expr -> arith_expr << shift_expr
2257
is
shift_expr -> arith_expr << shift_expr
2257
<
shift_expr -> arith_expr << shift_expr
2257
<=
shift_expr -> arith_expr << shift_expr
2257
as
shift_expr -> arith_expr << shift_expr
2257
not
shift_expr -> arith_expr << shift_expr
2257
if
shift_expr -> arith_expr << shift_expr
2257
^
shift_expr -> arith_expr << shift_expr
2257
and
shift_expr -> arith_expr << shift_expr
2257
|
shift_expr -> arith_expr << shift_expr
2257
!=
shift_expr -> arith_expr << shift_expr
2257
==
shift_expr -> arith_expr << shift_expr
2257
>=
shift_expr -> arith_expr << shift_expr
2258
<
and_expr -> shift_expr & and_expr
2258
if
and_expr -> shift_expr & and_expr
2258
>=
and_expr -> shift_expr & and_expr
2258
|
and_expr -> shift_expr & and_expr
2258
not
and_expr -> shift_expr & and_expr
2258
==
and_expr -> shift_expr & and_expr
2258
>
and_expr -> shift_expr & and_expr
2258
in
and_expr -> shift_expr & and_expr
2258
^
and_expr -> shift_expr & and_expr
2258
or
and_expr -> shift_expr & and_expr
2258
and
and_expr -> shift_expr & and_expr
2258
!=
and_expr -> shift_expr & and_expr
2258
as
and_expr -> shift_expr & and_expr
2258
:
and_expr -> shift_expr & and_expr
2258
is
and_expr -> shift_expr & and_expr
2258
<=
and_expr -> shift_expr & and_expr
2259
del
simple_stmt -> small_stmt NEWLINE
2259
finally
simple_stmt -> small_stmt NEWLINE
2259
break
simple_stmt -> small_stmt NEWLINE
2259
raise
simple_stmt -> small_stmt NEWLINE
2259
servmod
simple_stmt -> small_stmt NEWLINE
2259
class
simple_stmt -> small_stmt NEWLINE
2259
not
simple_stmt -> small_stmt NEWLINE
2259
-
simple_stmt -> small_stmt NEWLINE
2259
except
simple_stmt -> small_stmt NEWLINE
2259
False
simple_stmt -> small_stmt NEWLINE
2259
(
simple_stmt -> small_stmt NEWLINE
2259
endsim
simple_stmt -> small_stmt NEWLINE
2259
+
simple_stmt -> small_stmt NEWLINE
2259
None
simple_stmt -> small_stmt NEWLINE
2259
resetstats
simple_stmt -> small_stmt NEWLINE
2259
conf
simple_stmt -> small_stmt NEWLINE
2259
server
simple_stmt -> small_stmt NEWLINE
2259
STRING
simple_stmt -> small_stmt NEWLINE
2259
$
simple_stmt -> small_stmt NEWLINE
2259
else
simple_stmt -> small_stmt NEWLINE
2259
if
simple_stmt -> small_stmt NEWLINE
2259
NUMBER
simple_stmt -> small_stmt NEWLINE
2259
global
simple_stmt -> small_stmt NEWLINE
2259
@
simple_stmt -> small_stmt NEWLINE
2259
True
simple_stmt -> small_stmt NEWLINE
2259
lambda
simple_stmt -> small_stmt NEWLINE
2259
pass
simple_stmt -> small_stmt NEWLINE
2259
return
simple_stmt -> small_stmt NEWLINE
2259
def
simple_stmt -> small_stmt NEWLINE
2259
with
simple_stmt -> small_stmt NEWLINE
2259
nonlocal
simple_stmt -> small_stmt NEWLINE
2259
assert
simple_stmt -> small_stmt NEWLINE
2259
NAME
simple_stmt -> small_stmt NEWLINE
2259
try
simple_stmt -> small_stmt NEWLINE
2259
begsim
simple_stmt -> small_stmt NEWLINE
2259
while
simple_stmt -> small_stmt NEWLINE
2259
for
simple_stmt -> small_stmt NEWLINE
2259
[
simple_stmt -> small_stmt NEWLINE
2259
modopt
simple_stmt -> small_stmt NEWLINE
2259
yield
simple_stmt -> small_stmt NEWLINE
2259
NEWLINE
simple_stmt -> small_stmt NEWLINE
2259
continue
simple_stmt -> small_stmt NEWLINE
2259
{
simple_stmt -> small_stmt NEWLINE
2259
~
simple_stmt -> small_stmt NEWLINE
2260
arith_expr
1
2260
try
1533
2260
modopt
1534
2260
compound_stmt
1535
2260
test
5
2260
servmod
1536
2260
while
1537
2260
and_expr
8
2260
power
9
2260
STRING
10
2260
decorated
1538
2260
cli_serv_model
1539
2260
@
13
2260
try_stmt
1540
2260
lambdef
15
2260
stmt_list
2457
2260
(
16
2260
factor
17
2260
[
18
2260
class
1541
2260
small_stmt
1542
2260
{
21
2260
term
22
2260
def
1543
2260
server
1544
2260
while_stmt
1545
2260
-
26
2260
+
27
2260
for
1546
2260
if
1547
2260
lambda
29
2260
decorators
1548
2260
atom_expr
31
2260
not_test
32
2260
if_stmt
1549
2260
yield
34
2260
conf
1550
2260
test_list
36
2260
~
37
2260
True
38
2260
False
39
2260
funcdef
1551
2260
xor_expr
41
2260
with
1552
2260
for_stmt
1553
2260
sim_stmt
45
2260
and_test
46
2260
expr
47
2260
shift_expr
48
2260
comparison
49
2260
with_stmt
1554
2260
simple_stmt
1555
2260
NAME
52
2260
or_test
53
2260
confdef
1556
2260
None
55
2260
classdef
1557
2260
atom
57
2260
NUMBER
58
2260
return
59
2260
break_stmt
60
2260
return_stmt
61
2260
stmt
1558
2260
not
62
2260
break
63
2260
raise
64
2260
expr_stmt
65
2260
stat_stmt
66
2260
decorator
67
2260
assert_stmt
68
2260
begsim
69
2260
global
70
2260
assert
71
2260
nonlocal
72
2260
nonlocal_stmt
73
2260
raise_stmt
74
2260
yield_stmt
75
2260
continue
77
2260
endsim
78
2260
del
80
2260
pass_stmt
81
2260
flow_stmt
82
2260
resetstats
84
2260
del_stmt
85
2260
continue_stmt
86
2260
global_stmt
87
2260
pass
88
2261
server
except_clause -> except : suite maybe_except_clause
2261
class
except_clause -> except : suite maybe_except_clause
2261
global
except_clause -> except : suite maybe_except_clause
2261
endsim
except_clause -> except : suite maybe_except_clause
2261
pass
except_clause -> except : suite maybe_except_clause
2261
yield
except_clause -> except : suite maybe_except_clause
2261
resetstats
except_clause -> except : suite maybe_except_clause
2261
~
except_clause -> except : suite maybe_except_clause
2261
while
except_clause -> except : suite maybe_except_clause
2261
not
except_clause -> except : suite maybe_except_clause
2261
@
except_clause -> except : suite maybe_except_clause
2261
{
except_clause -> except : suite maybe_except_clause
2261
True
except_clause -> except : suite maybe_except_clause
2261
finally
except_clause -> except : suite maybe_except_clause
2261
else
except_clause -> except : suite maybe_except_clause
2261
with
except_clause -> except : suite maybe_except_clause
2261
for
except_clause -> except : suite maybe_except_clause
2261
if
except_clause -> except : suite maybe_except_clause
2261
NAME
except_clause -> except : suite maybe_except_clause
2261
False
except_clause -> except : suite maybe_except_clause
2261
nonlocal
except_clause -> except : suite maybe_except_clause
2261
return
except_clause -> except : suite maybe_except_clause
2261
None
except_clause -> except : suite maybe_except_clause
2261
NEWLINE
except_clause -> except : suite maybe_except_clause
2261
+
except_clause -> except : suite maybe_except_clause
2261
begsim
except_clause -> except : suite maybe_except_clause
2261
def
except_clause -> except : suite maybe_except_clause
2261
assert
except_clause -> except : suite maybe_except_clause
2261
modopt
except_clause -> except : suite maybe_except_clause
2261
try
except_clause -> except : suite maybe_except_clause
2261
break
except_clause -> except : suite maybe_except_clause
2261
STRING
except_clause -> except : suite maybe_except_clause
2261
NUMBER
except_clause -> except : suite maybe_except_clause
2261
raise
except_clause -> except : suite maybe_except_clause
2261
-
except_clause -> except : suite maybe_except_clause
2261
continue
except_clause -> except : suite maybe_except_clause
2261
servmod
except_clause -> except : suite maybe_except_clause
2261
(
except_clause -> except : suite maybe_except_clause
2261
del
except_clause -> except : suite maybe_except_clause
2261
[
except_clause -> except : suite maybe_except_clause
2261
conf
except_clause -> except : suite maybe_except_clause
2261
$
except_clause -> except : suite maybe_except_clause
2261
lambda
except_clause -> except : suite maybe_except_clause
2262
NEWLINE
maybe_except_clause -> except_clause
2262
continue
maybe_except_clause -> except_clause
2262
def
maybe_except_clause -> except_clause
2262
lambda
maybe_except_clause -> except_clause
2262
servmod
maybe_except_clause -> except_clause
2262
(
maybe_except_clause -> except_clause
2262
for
maybe_except_clause -> except_clause
2262
True
maybe_except_clause -> except_clause
2262
yield
maybe_except_clause -> except_clause
2262
$
maybe_except_clause -> except_clause
2262
not
maybe_except_clause -> except_clause
2262
while
maybe_except_clause -> except_clause
2262
+
maybe_except_clause -> except_clause
2262
with
maybe_except_clause -> except_clause
2262
endsim
maybe_except_clause -> except_clause
2262
server
maybe_except_clause -> except_clause
2262
break
maybe_except_clause -> except_clause
2262
-
maybe_except_clause -> except_clause
2262
NUMBER
maybe_except_clause -> except_clause
2262
class
maybe_except_clause -> except_clause
2262
return
maybe_except_clause -> except_clause
2262
modopt
maybe_except_clause -> except_clause
2262
None
maybe_except_clause -> except_clause
2262
global
maybe_except_clause -> except_clause
2262
NAME
maybe_except_clause -> except_clause
2262
finally
maybe_except_clause -> except_clause
2262
STRING
maybe_except_clause -> except_clause
2262
try
maybe_except_clause -> except_clause
2262
pass
maybe_except_clause -> except_clause
2262
[
maybe_except_clause -> except_clause
2262
@
maybe_except_clause -> except_clause
2262
raise
maybe_except_clause -> except_clause
2262
del
maybe_except_clause -> except_clause
2262
conf
maybe_except_clause -> except_clause
2262
~
maybe_except_clause -> except_clause
2262
False
maybe_except_clause -> except_clause
2262
{
maybe_except_clause -> except_clause
2262
begsim
maybe_except_clause -> except_clause
2262
else
maybe_except_clause -> except_clause
2262
resetstats
maybe_except_clause -> except_clause
2262
if
maybe_except_clause -> except_clause
2262
assert
maybe_except_clause -> except_clause
2262
nonlocal
maybe_except_clause -> except_clause
2263
>
atom -> ( test_list_comp )
2263
@
atom -> ( test_list_comp )
2263
&
atom -> ( test_list_comp )
2263
[
atom -> ( test_list_comp )
2263
if
atom -> ( test_list_comp )
2263
==
atom -> ( test_list_comp )
2263
>=
atom -> ( test_list_comp )
2263
**
atom -> ( test_list_comp )
2263
not
atom -> ( test_list_comp )
2263
<<
atom -> ( test_list_comp )
2263
>>
atom -> ( test_list_comp )
2263
as
atom -> ( test_list_comp )
2263
in
atom -> ( test_list_comp )
2263
or
atom -> ( test_list_comp )
2263
.
atom -> ( test_list_comp )
2263
/
atom -> ( test_list_comp )
2263
^
atom -> ( test_list_comp )
2263
is
atom -> ( test_list_comp )
2263
and
atom -> ( test_list_comp )
2263
//
atom -> ( test_list_comp )
2263
<
atom -> ( test_list_comp )
2263
*
atom -> ( test_list_comp )
2263
<=
atom -> ( test_list_comp )
2263
(
atom -> ( test_list_comp )
2263
-
atom -> ( test_list_comp )
2263
|
atom -> ( test_list_comp )
2263
!=
atom -> ( test_list_comp )
2263
:
atom -> ( test_list_comp )
2263
+
atom -> ( test_list_comp )
2263
%
atom -> ( test_list_comp )
2264
:
or_test -> and_test or or_test
2264
as
or_test -> and_test or or_test
2264
if
or_test -> and_test or or_test
2265
^
arith_expr -> term - arith_expr
2265
!=
arith_expr -> term - arith_expr
2265
<
arith_expr -> term - arith_expr
2265
in
arith_expr -> term - arith_expr
2265
==
arith_expr -> term - arith_expr
2265
|
arith_expr -> term - arith_expr
2265
is
arith_expr -> term - arith_expr
2265
as
arith_expr -> term - arith_expr
2265
&
arith_expr -> term - arith_expr
2265
>>
arith_expr -> term - arith_expr
2265
<<
arith_expr -> term - arith_expr
2265
and
arith_expr -> term - arith_expr
2265
>
arith_expr -> term - arith_expr
2265
if
arith_expr -> term - arith_expr
2265
not
arith_expr -> term - arith_expr
2265
>=
arith_expr -> term - arith_expr
2265
<=
arith_expr -> term - arith_expr
2265
or
arith_expr -> term - arith_expr
2265
:
arith_expr -> term - arith_expr
2266
>=
arith_expr -> term + arith_expr
2266
>
arith_expr -> term + arith_expr
2266
^
arith_expr -> term + arith_expr
2266
or
arith_expr -> term + arith_expr
2266
as
arith_expr -> term + arith_expr
2266
==
arith_expr -> term + arith_expr
2266
<=
arith_expr -> term + arith_expr
2266
if
arith_expr -> term + arith_expr
2266
>>
arith_expr -> term + arith_expr
2266
<
arith_expr -> term + arith_expr
2266
not
arith_expr -> term + arith_expr
2266
&
arith_expr -> term + arith_expr
2266
in
arith_expr -> term + arith_expr
2266
and
arith_expr -> term + arith_expr
2266
|
arith_expr -> term + arith_expr
2266
!=
arith_expr -> term + arith_expr
2266
:
arith_expr -> term + arith_expr
2266
<<
arith_expr -> term + arith_expr
2266
is
arith_expr -> term + arith_expr
2267
>=
expr -> xor_expr | expr
2267
or
expr -> xor_expr | expr
2267
in
expr -> xor_expr | expr
2267
and
expr -> xor_expr | expr
2267
as
expr -> xor_expr | expr
2267
==
expr -> xor_expr | expr
2267
:
expr -> xor_expr | expr
2267
>
expr -> xor_expr | expr
2267
<=
expr -> xor_expr | expr
2267
is
expr -> xor_expr | expr
2267
<
expr -> xor_expr | expr
2267
if
expr -> xor_expr | expr
2267
not
expr -> xor_expr | expr
2267
!=
expr -> xor_expr | expr
2268
as
comparison -> expr comp_op comparison
2268
or
comparison -> expr comp_op comparison
2268
:
comparison -> expr comp_op comparison
2268
if
comparison -> expr comp_op comparison
2268
and
comparison -> expr comp_op comparison
2269
if
and_test -> not_test and and_test
2269
or
and_test -> not_test and and_test
2269
:
and_test -> not_test and and_test
2269
as
and_test -> not_test and and_test
2270
as
lambdef -> lambda : test
2270
:
lambdef -> lambda : test
2271
[
1502
2271
factor
1504
2271
True
1505
2271
atom_expr
1506
2271
~
1507
2271
and_expr
1508
2271
-
1509
2271
atom
1510
2271
{
1511
2271
or_test
1512
2271
arith_expr
1513
2271
power
1514
2271
STRING
1515
2271
NAME
1516
2271
shift_expr
1517
2271
(
1519
2271
and_test
1520
2271
term
1521
2271
+
1522
2271
xor_expr
1523
2271
NUMBER
1524
2271
not
1525
2271
False
1526
2271
expr
1527
2271
not_test
1528
2271
comparison
1529
2271
None
1530
2271
lambdef
1531
2271
lambda
1532
2271
test
2458
2272
except_clause
2459
2272
except
2460
2273
NEWLINE
2461
2274
NEWLINE
2462
2275
suite
2463
2275
arith_expr
1
2275
small_stmt
2464
2275
factor
17
2275
True
38
2275
atom_expr
31
2275
term
22
2275
-
26
2275
None
55
2275
atom
57
2275
test
5
2275
comparison
49
2275
and_expr
8
2275
power
9
2275
STRING
10
2275
NAME
52
2275
shift_expr
48
2275
lambdef
15
2275
NUMBER
58
2275
simple_stmt
2465
2275
(
16
2275
expr
47
2275
[
18
2275
NEWLINE
2466
2275
not_test
32
2275
{
21
2275
and_test
46
2275
+
27
2275
lambda
29
2275
xor_expr
41
2275
yield
34
2275
not
62
2275
test_list
36
2275
~
37
2275
or_test
53
2275
False
39
2275
sim_stmt
45
2275
nonlocal
72
2275
nonlocal_stmt
73
2275
return
59
2275
break_stmt
60
2275
return_stmt
61
2275
raise_stmt
74
2275
break
63
2275
yield_stmt
75
2275
raise
64
2275
continue
77
2275
expr_stmt
65
2275
endsim
78
2275
del
80
2275
pass_stmt
81
2275
flow_stmt
82
2275
stat_stmt
66
2275
assert_stmt
68
2275
resetstats
84
2275
del_stmt
85
2275
continue_stmt
86
2275
begsim
69
2275
global_stmt
87
2275
pass
88
2275
global
70
2275
assert
71
2276
[
766
2276
arglist
2467
2276
factor
767
2276
True
768
2276
atom_expr
769
2276
~
770
2276
and_expr
771
2276
-
772
2276
)
2468
2276
{
773
2276
shift_expr
774
2276
atom
775
2276
comparison
776
2276
and_test
777
2276
arith_expr
778
2276
power
779
2276
STRING
780
2276
NAME
781
2276
(
782
2276
term
784
2276
+
785
2276
xor_expr
786
2276
or_test
788
2276
NUMBER
789
2276
not
790
2276
False
791
2276
expr
792
2276
*
793
2276
not_test
794
2276
None
795
2276
lambdef
796
2276
lambda
797
2276
test
798
2276
argument
799
2276
**
800
2277
arith_expr
1
2277
small_stmt
1542
2277
factor
17
2277
True
38
2277
atom_expr
31
2277
term
22
2277
-
26
2277
None
55
2277
atom
57
2277
test
5
2277
comparison
49
2277
and_expr
8
2277
power
9
2277
STRING
10
2277
NAME
52
2277
shift_expr
48
2277
lambdef
15
2277
NUMBER
58
2277
simple_stmt
2469
2277
(
16
2277
expr
47
2277
[
18
2277
NEWLINE
2470
2277
not_test
32
2277
{
21
2277
and_test
46
2277
suite
2471
2277
+
27
2277
lambda
29
2277
xor_expr
41
2277
yield
34
2277
not
62
2277
test_list
36
2277
~
37
2277
or_test
53
2277
False
39
2277
sim_stmt
45
2277
nonlocal
72
2277
nonlocal_stmt
73
2277
return
59
2277
break_stmt
60
2277
return_stmt
61
2277
raise_stmt
74
2277
break
63
2277
yield_stmt
75
2277
raise
64
2277
continue
77
2277
expr_stmt
65
2277
endsim
78
2277
del
80
2277
pass_stmt
81
2277
flow_stmt
82
2277
stat_stmt
66
2277
assert_stmt
68
2277
resetstats
84
2277
del_stmt
85
2277
continue_stmt
86
2277
begsim
69
2277
global_stmt
87
2277
pass
88
2277
global
70
2277
assert
71
2278
parameters
2472
2278
)
2473
2278
NAME
1099
2278
**
1100
2278
tfpdef
1101
2278
*
1102
2278
param
1103
2279
NEWLINE
2474
2280
[
1111
2280
factor
1112
2280
True
1113
2280
atom_expr
1114
2280
~
1115
2280
and_expr
1116
2280
-
1117
2280
shift_expr
1118
2280
atom
1119
2280
{
1120
2280
comparison
1121
2280
or_test
1122
2280
arith_expr
1123
2280
power
1124
2280
STRING
1125
2280
NAME
1126
2280
test_list
2475
2280
(
1128
2280
and_test
1129
2280
term
1130
2280
+
1131
2280
xor_expr
1132
2280
NUMBER
1133
2280
not
1134
2280
False
1135
2280
expr
1136
2280
not_test
1137
2280
test
1138
2280
None
1139
2280
lambdef
1140
2280
lambda
1141
2281
arith_expr
1
2281
small_stmt
2476
2281
factor
17
2281
True
38
2281
atom_expr
31
2281
term
22
2281
-
26
2281
None
55
2281
atom
57
2281
test
5
2281
comparison
49
2281
and_expr
8
2281
power
9
2281
STRING
10
2281
NAME
52
2281
shift_expr
48
2281
lambdef
15
2281
NUMBER
58
2281
simple_stmt
2477
2281
(
16
2281
expr
47
2281
suite
2478
2281
[
18
2281
NEWLINE
2479
2281
not_test
32
2281
{
21
2281
and_test
46
2281
+
27
2281
lambda
29
2281
xor_expr
41
2281
yield
34
2281
not
62
2281
test_list
36
2281
~
37
2281
or_test
53
2281
False
39
2281
sim_stmt
45
2281
nonlocal
72
2281
nonlocal_stmt
73
2281
return
59
2281
break_stmt
60
2281
return_stmt
61
2281
raise_stmt
74
2281
break
63
2281
yield_stmt
75
2281
raise
64
2281
continue
77
2281
expr_stmt
65
2281
endsim
78
2281
del
80
2281
pass_stmt
81
2281
flow_stmt
82
2281
stat_stmt
66
2281
assert_stmt
68
2281
resetstats
84
2281
del_stmt
85
2281
continue_stmt
86
2281
begsim
69
2281
global_stmt
87
2281
pass
88
2281
global
70
2281
assert
71
2282
NAME
2480
2283
NEWLINE
2481
2284
arith_expr
1
2284
small_stmt
1542
2284
factor
17
2284
True
38
2284
atom_expr
31
2284
term
22
2284
-
26
2284
None
55
2284
atom
57
2284
test
5
2284
comparison
49
2284
and_expr
8
2284
power
9
2284
STRING
10
2284
NAME
52
2284
shift_expr
48
2284
lambdef
15
2284
NUMBER
58
2284
simple_stmt
2469
2284
suite
2482
2284
(
16
2284
expr
47
2284
[
18
2284
NEWLINE
2470
2284
not_test
32
2284
{
21
2284
and_test
46
2284
+
27
2284
lambda
29
2284
xor_expr
41
2284
yield
34
2284
not
62
2284
test_list
36
2284
~
37
2284
or_test
53
2284
False
39
2284
sim_stmt
45
2284
nonlocal
72
2284
nonlocal_stmt
73
2284
return
59
2284
break_stmt
60
2284
return_stmt
61
2284
raise_stmt
74
2284
break
63
2284
yield_stmt
75
2284
raise
64
2284
continue
77
2284
expr_stmt
65
2284
endsim
78
2284
del
80
2284
pass_stmt
81
2284
flow_stmt
82
2284
stat_stmt
66
2284
assert_stmt
68
2284
resetstats
84
2284
del_stmt
85
2284
continue_stmt
86
2284
begsim
69
2284
global_stmt
87
2284
pass
88
2284
global
70
2284
assert
71
2285
servmod
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
del
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
-
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
conf
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
yield
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
None
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
server
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
resetstats
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
continue
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
while
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
begsim
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
for
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
endsim
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
with
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
NEWLINE
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
lambda
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
NUMBER
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
[
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
pass
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
raise
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
if
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
assert
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
modopt
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
try
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
$
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
+
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
True
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
class
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
not
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
nonlocal
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
(
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
~
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
break
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
NAME
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
@
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
def
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
False
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
STRING
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
return
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
global
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2285
{
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2286
NEWLINE
2483
2287
yield
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
continue
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
conf
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
NUMBER
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
nonlocal
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
del
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
try
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
None
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
assert
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
while
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
$
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
pass
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
servmod
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
with
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
break
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
lambda
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
begsim
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
{
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
[
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
-
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
+
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
global
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
server
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
if
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
def
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
True
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
class
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
for
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
~
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
modopt
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
(
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
STRING
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
NAME
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
NEWLINE
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
return
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
not
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
@
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
resetstats
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
False
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
raise
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2287
endsim
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2288
None
while_stmt -> while test : suite else : suite
2288
NEWLINE
while_stmt -> while test : suite else : suite
2288
try
while_stmt -> while test : suite else : suite
2288
resetstats
while_stmt -> while test : suite else : suite
2288
return
while_stmt -> while test : suite else : suite
2288
$
while_stmt -> while test : suite else : suite
2288
-
while_stmt -> while test : suite else : suite
2288
{
while_stmt -> while test : suite else : suite
2288
(
while_stmt -> while test : suite else : suite
2288
conf
while_stmt -> while test : suite else : suite
2288
nonlocal
while_stmt -> while test : suite else : suite
2288
+
while_stmt -> while test : suite else : suite
2288
while
while_stmt -> while test : suite else : suite
2288
endsim
while_stmt -> while test : suite else : suite
2288
NUMBER
while_stmt -> while test : suite else : suite
2288
True
while_stmt -> while test : suite else : suite
2288
NAME
while_stmt -> while test : suite else : suite
2288
yield
while_stmt -> while test : suite else : suite
2288
servmod
while_stmt -> while test : suite else : suite
2288
@
while_stmt -> while test : suite else : suite
2288
server
while_stmt -> while test : suite else : suite
2288
raise
while_stmt -> while test : suite else : suite
2288
continue
while_stmt -> while test : suite else : suite
2288
break
while_stmt -> while test : suite else : suite
2288
begsim
while_stmt -> while test : suite else : suite
2288
STRING
while_stmt -> while test : suite else : suite
2288
modopt
while_stmt -> while test : suite else : suite
2288
for
while_stmt -> while test : suite else : suite
2288
not
while_stmt -> while test : suite else : suite
2288
def
while_stmt -> while test : suite else : suite
2288
assert
while_stmt -> while test : suite else : suite
2288
if
while_stmt -> while test : suite else : suite
2288
del
while_stmt -> while test : suite else : suite
2288
class
while_stmt -> while test : suite else : suite
2288
~
while_stmt -> while test : suite else : suite
2288
pass
while_stmt -> while test : suite else : suite
2288
with
while_stmt -> while test : suite else : suite
2288
lambda
while_stmt -> while test : suite else : suite
2288
global
while_stmt -> while test : suite else : suite
2288
[
while_stmt -> while test : suite else : suite
2288
False
while_stmt -> while test : suite else : suite
2289
+
suite -> NEWLINE INDENT stmt_list DEDENT
2289
False
suite -> NEWLINE INDENT stmt_list DEDENT
2289
[
suite -> NEWLINE INDENT stmt_list DEDENT
2289
pass
suite -> NEWLINE INDENT stmt_list DEDENT
2289
continue
suite -> NEWLINE INDENT stmt_list DEDENT
2289
break
suite -> NEWLINE INDENT stmt_list DEDENT
2289
lambda
suite -> NEWLINE INDENT stmt_list DEDENT
2289
NUMBER
suite -> NEWLINE INDENT stmt_list DEDENT
2289
True
suite -> NEWLINE INDENT stmt_list DEDENT
2289
conf
suite -> NEWLINE INDENT stmt_list DEDENT
2289
endsim
suite -> NEWLINE INDENT stmt_list DEDENT
2289
server
suite -> NEWLINE INDENT stmt_list DEDENT
2289
raise
suite -> NEWLINE INDENT stmt_list DEDENT
2289
del
suite -> NEWLINE INDENT stmt_list DEDENT
2289
class
suite -> NEWLINE INDENT stmt_list DEDENT
2289
global
suite -> NEWLINE INDENT stmt_list DEDENT
2289
NEWLINE
suite -> NEWLINE INDENT stmt_list DEDENT
2289
def
suite -> NEWLINE INDENT stmt_list DEDENT
2289
@
suite -> NEWLINE INDENT stmt_list DEDENT
2289
if
suite -> NEWLINE INDENT stmt_list DEDENT
2289
else
suite -> NEWLINE INDENT stmt_list DEDENT
2289
$
suite -> NEWLINE INDENT stmt_list DEDENT
2289
nonlocal
suite -> NEWLINE INDENT stmt_list DEDENT
2289
-
suite -> NEWLINE INDENT stmt_list DEDENT
2289
NAME
suite -> NEWLINE INDENT stmt_list DEDENT
2289
yield
suite -> NEWLINE INDENT stmt_list DEDENT
2289
~
suite -> NEWLINE INDENT stmt_list DEDENT
2289
modopt
suite -> NEWLINE INDENT stmt_list DEDENT
2289
{
suite -> NEWLINE INDENT stmt_list DEDENT
2289
servmod
suite -> NEWLINE INDENT stmt_list DEDENT
2289
begsim
suite -> NEWLINE INDENT stmt_list DEDENT
2289
not
suite -> NEWLINE INDENT stmt_list DEDENT
2289
assert
suite -> NEWLINE INDENT stmt_list DEDENT
2289
with
suite -> NEWLINE INDENT stmt_list DEDENT
2289
None
suite -> NEWLINE INDENT stmt_list DEDENT
2289
resetstats
suite -> NEWLINE INDENT stmt_list DEDENT
2289
try
suite -> NEWLINE INDENT stmt_list DEDENT
2289
while
suite -> NEWLINE INDENT stmt_list DEDENT
2289
return
suite -> NEWLINE INDENT stmt_list DEDENT
2289
for
suite -> NEWLINE INDENT stmt_list DEDENT
2289
STRING
suite -> NEWLINE INDENT stmt_list DEDENT
2289
(
suite -> NEWLINE INDENT stmt_list DEDENT
2290
,
trailer -> ( arglist )
2290
.
trailer -> ( arglist )
2290
|
trailer -> ( arglist )
2290
^
trailer -> ( arglist )
2290
==
trailer -> ( arglist )
2290
**
trailer -> ( arglist )
2290
>>
trailer -> ( arglist )
2290
not
trailer -> ( arglist )
2290
<<
trailer -> ( arglist )
2290
>=
trailer -> ( arglist )
2290
!=
trailer -> ( arglist )
2290
in
trailer -> ( arglist )
2290
[
trailer -> ( arglist )
2290
(
trailer -> ( arglist )
2290
>
trailer -> ( arglist )
2290
and
trailer -> ( arglist )
2290
+
trailer -> ( arglist )
2290
%
trailer -> ( arglist )
2290
or
trailer -> ( arglist )
2290
*
trailer -> ( arglist )
2290
is
trailer -> ( arglist )
2290
&
trailer -> ( arglist )
2290
//
trailer -> ( arglist )
2290
)
trailer -> ( arglist )
2290
<
trailer -> ( arglist )
2290
if
trailer -> ( arglist )
2290
<=
trailer -> ( arglist )
2290
-
trailer -> ( arglist )
2290
/
trailer -> ( arglist )
2290
@
trailer -> ( arglist )
2291
<=
trailer -> [ subscriptlist ]
2291
<<
trailer -> [ subscriptlist ]
2291
*
trailer -> [ subscriptlist ]
2291
+
trailer -> [ subscriptlist ]
2291
in
trailer -> [ subscriptlist ]
2291
>>
trailer -> [ subscriptlist ]
2291
//
trailer -> [ subscriptlist ]
2291
.
trailer -> [ subscriptlist ]
2291
,
trailer -> [ subscriptlist ]
2291
and
trailer -> [ subscriptlist ]
2291
**
trailer -> [ subscriptlist ]
2291
@
trailer -> [ subscriptlist ]
2291
<
trailer -> [ subscriptlist ]
2291
not
trailer -> [ subscriptlist ]
2291
-
trailer -> [ subscriptlist ]
2291
!=
trailer -> [ subscriptlist ]
2291
%
trailer -> [ subscriptlist ]
2291
)
trailer -> [ subscriptlist ]
2291
[
trailer -> [ subscriptlist ]
2291
/
trailer -> [ subscriptlist ]
2291
or
trailer -> [ subscriptlist ]
2291
&
trailer -> [ subscriptlist ]
2291
>=
trailer -> [ subscriptlist ]
2291
==
trailer -> [ subscriptlist ]
2291
(
trailer -> [ subscriptlist ]
2291
|
trailer -> [ subscriptlist ]
2291
is
trailer -> [ subscriptlist ]
2291
if
trailer -> [ subscriptlist ]
2291
>
trailer -> [ subscriptlist ]
2291
^
trailer -> [ subscriptlist ]
2292
[
1002
2292
factor
1003
2292
True
1004
2292
atom_expr
1005
2292
~
1006
2292
and_expr
1007
2292
-
1008
2292
shift_expr
1009
2292
atom
1010
2292
{
1011
2292
comparison
1012
2292
arith_expr
1013
2292
power
1014
2292
STRING
1015
2292
NAME
1016
2292
(
1017
2292
and_test
1018
2292
term
1019
2292
+
1020
2292
xor_expr
1021
2292
or_test
1022
2292
NUMBER
1023
2292
not
1024
2292
False
1025
2292
not_test
1026
2292
None
1027
2292
expr
1028
2292
test
2484
2292
lambda
1029
2292
lambdef
1031
2293
,
lambdef -> lambda varargslist : test
2293
)
lambdef -> lambda varargslist : test
2294
!=
atom -> [ ]
2294
>>
atom -> [ ]
2294
|
atom -> [ ]
2294
<<
atom -> [ ]
2294
>
atom -> [ ]
2294
.
atom -> [ ]
2294
%
atom -> [ ]
2294
^
atom -> [ ]
2294
-
atom -> [ ]
2294
in
atom -> [ ]
2294
or
atom -> [ ]
2294
/
atom -> [ ]
2294
**
atom -> [ ]
2294
//
atom -> [ ]
2294
for
atom -> [ ]
2294
not
atom -> [ ]
2294
(
atom -> [ ]
2294
)
atom -> [ ]
2294
+
atom -> [ ]
2294
and
atom -> [ ]
2294
==
atom -> [ ]
2294
[
atom -> [ ]
2294
if
atom -> [ ]
2294
<
atom -> [ ]
2294
<=
atom -> [ ]
2294
>=
atom -> [ ]
2294
is
atom -> [ ]
2294
*
atom -> [ ]
2294
@
atom -> [ ]
2294
&
atom -> [ ]
2295
]
2485
2296
term
2486
2296
[
2004
2296
factor
2005
2296
True
2006
2296
atom_expr
2007
2296
~
2008
2296
-
2010
2296
{
2011
2296
atom
2012
2296
power
2015
2296
STRING
2016
2296
NAME
2017
2296
(
2018
2296
+
2021
2296
NUMBER
2024
2296
False
2026
2296
None
2030
2297
[
2004
2297
factor
2005
2297
True
2006
2297
term
2487
2297
~
2008
2297
-
2010
2297
atom_expr
2007
2297
{
2011
2297
atom
2012
2297
power
2015
2297
STRING
2016
2297
NAME
2017
2297
(
2018
2297
+
2021
2297
NUMBER
2024
2297
False
2026
2297
None
2030
2298
[
2004
2298
factor
2005
2298
True
2006
2298
atom_expr
2007
2298
~
2008
2298
-
2010
2298
{
2011
2298
atom
2012
2298
power
2015
2298
STRING
2016
2298
NAME
2017
2298
(
2018
2298
term
2488
2298
+
2021
2298
NUMBER
2024
2298
False
2026
2298
None
2030
2299
[
2004
2299
factor
2005
2299
True
2006
2299
atom_expr
2007
2299
~
2008
2299
-
2010
2299
{
2011
2299
atom
2012
2299
power
2015
2299
STRING
2016
2299
NAME
2017
2299
(
2018
2299
term
2489
2299
+
2021
2299
NUMBER
2024
2299
False
2026
2299
None
2030
2300
[
2004
2300
factor
2005
2300
True
2006
2300
atom_expr
2007
2300
~
2008
2300
-
2010
2300
{
2011
2300
atom
2012
2300
power
2015
2300
STRING
2016
2300
NAME
2017
2300
term
2490
2300
(
2018
2300
+
2021
2300
NUMBER
2024
2300
False
2026
2300
None
2030
2301
[
2004
2301
True
2006
2301
atom_expr
2007
2301
-
2010
2301
~
2008
2301
{
2011
2301
atom
2012
2301
power
2015
2301
STRING
2016
2301
NAME
2017
2301
(
2018
2301
+
2021
2301
NUMBER
2024
2301
False
2026
2301
factor
2491
2301
None
2030
2302
@
factor -> ~ factor
2302
>>
factor -> ~ factor
2302
)
factor -> ~ factor
2302
<=
factor -> ~ factor
2302
and
factor -> ~ factor
2302
+
factor -> ~ factor
2302
*
factor -> ~ factor
2302
!=
factor -> ~ factor
2302
for
factor -> ~ factor
2302
%
factor -> ~ factor
2302
<<
factor -> ~ factor
2302
>=
factor -> ~ factor
2302
&
factor -> ~ factor
2302
is
factor -> ~ factor
2302
==
factor -> ~ factor
2302
//
factor -> ~ factor
2302
<
factor -> ~ factor
2302
/
factor -> ~ factor
2302
not
factor -> ~ factor
2302
-
factor -> ~ factor
2302
or
factor -> ~ factor
2302
|
factor -> ~ factor
2302
>
factor -> ~ factor
2302
^
factor -> ~ factor
2302
if
factor -> ~ factor
2302
in
factor -> ~ factor
2303
[
2004
2303
factor
2005
2303
True
2006
2303
atom_expr
2007
2303
~
2008
2303
and_expr
2009
2303
-
2010
2303
{
2011
2303
atom
2012
2303
xor_expr
2492
2303
arith_expr
2014
2303
power
2015
2303
STRING
2016
2303
NAME
2017
2303
(
2018
2303
term
2020
2303
+
2021
2303
shift_expr
2023
2303
NUMBER
2024
2303
False
2026
2303
None
2030
2304
@
factor -> - factor
2304
<=
factor -> - factor
2304
in
factor -> - factor
2304
>>
factor -> - factor
2304
|
factor -> - factor
2304
is
factor -> - factor
2304
+
factor -> - factor
2304
%
factor -> - factor
2304
<
factor -> - factor
2304
*
factor -> - factor
2304
<<
factor -> - factor
2304
if
factor -> - factor
2304
for
factor -> - factor
2304
-
factor -> - factor
2304
>=
factor -> - factor
2304
not
factor -> - factor
2304
and
factor -> - factor
2304
/
factor -> - factor
2304
or
factor -> - factor
2304
^
factor -> - factor
2304
)
factor -> - factor
2304
>
factor -> - factor
2304
!=
factor -> - factor
2304
&
factor -> - factor
2304
==
factor -> - factor
2304
//
factor -> - factor
2305
in
atom -> { }
2305
<=
atom -> { }
2305
*
atom -> { }
2305
>
atom -> { }
2305
+
atom -> { }
2305
@
atom -> { }
2305
>=
atom -> { }
2305
/
atom -> { }
2305
|
atom -> { }
2305
is
atom -> { }
2305
and
atom -> { }
2305
if
atom -> { }
2305
(
atom -> { }
2305
>>
atom -> { }
2305
not
atom -> { }
2305
-
atom -> { }
2305
<<
atom -> { }
2305
**
atom -> { }
2305
or
atom -> { }
2305
<
atom -> { }
2305
!=
atom -> { }
2305
==
atom -> { }
2305
for
atom -> { }
2305
//
atom -> { }
2305
%
atom -> { }
2305
)
atom -> { }
2305
&
atom -> { }
2305
[
atom -> { }
2305
.
atom -> { }
2305
^
atom -> { }
2306
NAME
2493
2307
[
766
2307
factor
767
2307
True
768
2307
atom_expr
769
2307
~
770
2307
and_expr
771
2307
-
772
2307
{
773
2307
shift_expr
774
2307
atom
775
2307
comparison
776
2307
and_test
777
2307
arith_expr
778
2307
power
779
2307
STRING
780
2307
NAME
781
2307
(
782
2307
term
784
2307
+
785
2307
xor_expr
786
2307
)
2494
2307
or_test
788
2307
arglist
2495
2307
NUMBER
789
2307
not
790
2307
False
791
2307
expr
792
2307
*
793
2307
not_test
794
2307
None
795
2307
lambdef
796
2307
lambda
797
2307
test
798
2307
argument
799
2307
**
800
2308
trailer_expr
2496
2308
>>
trailer_expr -> 
2308
.
2306
2308
(
2307
2308
)
trailer_expr -> 
2308
trailer
2308
2308
+
trailer_expr -> 
2308
is
trailer_expr -> 
2308
>
trailer_expr -> 
2308
not
trailer_expr -> 
2308
|
trailer_expr -> 
2308
[
2310
2308
&
trailer_expr -> 
2308
/
trailer_expr -> 
2308
@
trailer_expr -> 
2308
!=
trailer_expr -> 
2308
**
trailer_expr -> 
2308
>=
trailer_expr -> 
2308
^
trailer_expr -> 
2308
in
trailer_expr -> 
2308
<<
trailer_expr -> 
2308
and
trailer_expr -> 
2308
or
trailer_expr -> 
2308
if
trailer_expr -> 
2308
//
trailer_expr -> 
2308
%
trailer_expr -> 
2308
<=
trailer_expr -> 
2308
<
trailer_expr -> 
2308
==
trailer_expr -> 
2308
for
trailer_expr -> 
2308
-
trailer_expr -> 
2308
*
trailer_expr -> 
2309
^
atom_expr -> atom trailer_expr
2309
or
atom_expr -> atom trailer_expr
2309
&
atom_expr -> atom trailer_expr
2309
@
atom_expr -> atom trailer_expr
2309
|
atom_expr -> atom trailer_expr
2309
-
atom_expr -> atom trailer_expr
2309
*
atom_expr -> atom trailer_expr
2309
%
atom_expr -> atom trailer_expr
2309
==
atom_expr -> atom trailer_expr
2309
**
atom_expr -> atom trailer_expr
2309
and
atom_expr -> atom trailer_expr
2309
is
atom_expr -> atom trailer_expr
2309
in
atom_expr -> atom trailer_expr
2309
<<
atom_expr -> atom trailer_expr
2309
!=
atom_expr -> atom trailer_expr
2309
<=
atom_expr -> atom trailer_expr
2309
/
atom_expr -> atom trailer_expr
2309
)
atom_expr -> atom trailer_expr
2309
//
atom_expr -> atom trailer_expr
2309
<
atom_expr -> atom trailer_expr
2309
>=
atom_expr -> atom trailer_expr
2309
>>
atom_expr -> atom trailer_expr
2309
if
atom_expr -> atom trailer_expr
2309
not
atom_expr -> atom trailer_expr
2309
for
atom_expr -> atom trailer_expr
2309
+
atom_expr -> atom trailer_expr
2309
>
atom_expr -> atom trailer_expr
2310
[
802
2310
factor
803
2310
True
804
2310
atom_expr
810
2310
~
806
2310
not
807
2310
and_expr
808
2310
-
809
2310
shift_expr
811
2310
atom
812
2310
{
813
2310
comparison
814
2310
or_test
815
2310
(
816
2310
arith_expr
817
2310
power
818
2310
STRING
819
2310
NAME
820
2310
and_test
821
2310
term
822
2310
+
823
2310
xor_expr
824
2310
subscriptlist
2497
2310
test
825
2310
NUMBER
826
2310
False
827
2310
subscript
828
2310
expr
829
2310
not_test
830
2310
None
831
2310
lambdef
832
2310
lambda
833
2310
maybe_test
834
2310
:
maybe_test -> 
2311
[
2004
2311
factor
2005
2311
True
2006
2311
atom_expr
2007
2311
~
2008
2311
and_expr
2009
2311
-
2010
2311
{
2011
2311
atom
2012
2311
arith_expr
2014
2311
power
2015
2311
STRING
2016
2311
NAME
2017
2311
(
2018
2311
and_test
2019
2311
term
2020
2311
+
2021
2311
xor_expr
2022
2311
shift_expr
2023
2311
lambda
2498
2311
or_test
2499
2311
NUMBER
2024
2311
not
2025
2311
False
2026
2311
expr
2027
2311
comparison
2028
2311
not_test
2029
2311
None
2030
2311
lambdef_nocond
2500
2311
test_nocond
2501
2312
)
comp_iter -> comp_for
2313
)
comp_for -> for expr_list in or_test comp_iter
2314
)
comp_iter -> comp_if
2315
[
2004
2315
factor
2005
2315
True
2006
2315
atom_expr
2007
2315
~
2008
2315
-
2010
2315
{
2011
2315
atom
2012
2315
arith_expr
2014
2315
power
2015
2315
STRING
2016
2315
NAME
2017
2315
shift_expr
2502
2315
(
2018
2315
term
2020
2315
+
2021
2315
NUMBER
2024
2315
False
2026
2315
None
2030
2316
[
2004
2316
factor
2005
2316
True
2006
2316
atom_expr
2007
2316
~
2008
2316
-
2010
2316
{
2011
2316
atom
2012
2316
arith_expr
2014
2316
power
2015
2316
STRING
2016
2316
NAME
2017
2316
shift_expr
2503
2316
(
2018
2316
term
2020
2316
+
2021
2316
NUMBER
2024
2316
False
2026
2316
None
2030
2317
)
2504
2318
or
atom -> ( )
2318
>>
atom -> ( )
2318
(
atom -> ( )
2318
<=
atom -> ( )
2318
.
atom -> ( )
2318
is
atom -> ( )
2318
@
atom -> ( )
2318
%
atom -> ( )
2318
<<
atom -> ( )
2318
**
atom -> ( )
2318
^
atom -> ( )
2318
/
atom -> ( )
2318
)
atom -> ( )
2318
if
atom -> ( )
2318
not
atom -> ( )
2318
*
atom -> ( )
2318
!=
atom -> ( )
2318
for
atom -> ( )
2318
<
atom -> ( )
2318
&
atom -> ( )
2318
-
atom -> ( )
2318
>
atom -> ( )
2318
//
atom -> ( )
2318
==
atom -> ( )
2318
in
atom -> ( )
2318
+
atom -> ( )
2318
[
atom -> ( )
2318
>=
atom -> ( )
2318
and
atom -> ( )
2318
|
atom -> ( )
2319
[
2004
2319
factor
2005
2319
True
2006
2319
atom_expr
2007
2319
~
2008
2319
and_expr
2009
2319
-
2010
2319
{
2011
2319
atom
2012
2319
arith_expr
2014
2319
power
2015
2319
STRING
2016
2319
NAME
2017
2319
(
2018
2319
and_test
2019
2319
term
2020
2319
+
2021
2319
xor_expr
2022
2319
shift_expr
2023
2319
NUMBER
2024
2319
not
2025
2319
False
2026
2319
expr
2027
2319
comparison
2028
2319
not_test
2029
2319
None
2030
2319
or_test
2505
2320
[
2004
2320
factor
2005
2320
True
2006
2320
atom_expr
2007
2320
~
2008
2320
-
2010
2320
{
2011
2320
arith_expr
2506
2320
atom
2012
2320
power
2015
2320
STRING
2016
2320
NAME
2017
2320
(
2018
2320
term
2020
2320
+
2021
2320
NUMBER
2024
2320
False
2026
2320
None
2030
2321
[
2004
2321
factor
2005
2321
True
2006
2321
atom_expr
2007
2321
~
2008
2321
-
2010
2321
{
2011
2321
atom
2012
2321
arith_expr
2507
2321
power
2015
2321
STRING
2016
2321
NAME
2017
2321
(
2018
2321
term
2020
2321
+
2021
2321
NUMBER
2024
2321
False
2026
2321
None
2030
2322
-
factor -> + factor
2322
@
factor -> + factor
2322
<<
factor -> + factor
2322
is
factor -> + factor
2322
and
factor -> + factor
2322
<=
factor -> + factor
2322
or
factor -> + factor
2322
<
factor -> + factor
2322
^
factor -> + factor
2322
not
factor -> + factor
2322
//
factor -> + factor
2322
for
factor -> + factor
2322
*
factor -> + factor
2322
in
factor -> + factor
2322
&
factor -> + factor
2322
+
factor -> + factor
2322
if
factor -> + factor
2322
>>
factor -> + factor
2322
)
factor -> + factor
2322
|
factor -> + factor
2322
%
factor -> + factor
2322
>
factor -> + factor
2322
>=
factor -> + factor
2322
!=
factor -> + factor
2322
/
factor -> + factor
2322
==
factor -> + factor
2323
[
2004
2323
factor
2005
2323
True
2006
2323
atom_expr
2007
2323
~
2008
2323
and_expr
2009
2323
-
2010
2323
{
2011
2323
atom
2012
2323
expr
2508
2323
arith_expr
2014
2323
power
2015
2323
STRING
2016
2323
NAME
2017
2323
(
2018
2323
term
2020
2323
+
2021
2323
xor_expr
2022
2323
shift_expr
2023
2323
NUMBER
2024
2323
False
2026
2323
None
2030
2324
[
2004
2324
factor
2005
2324
True
2006
2324
atom_expr
2007
2324
~
2008
2324
-
2010
2324
{
2011
2324
atom
2012
2324
arith_expr
2014
2324
power
2015
2324
STRING
2016
2324
NAME
2017
2324
(
2018
2324
term
2020
2324
+
2021
2324
and_expr
2509
2324
shift_expr
2023
2324
NUMBER
2024
2324
False
2026
2324
None
2030
2325
and
not_test -> not not_test
2325
or
not_test -> not not_test
2325
for
not_test -> not not_test
2325
)
not_test -> not not_test
2325
if
not_test -> not not_test
2326
[
2004
2326
factor
2005
2326
True
2006
2326
atom_expr
2007
2326
~
2008
2326
and_expr
2009
2326
-
2010
2326
{
2011
2326
atom
2012
2326
arith_expr
2014
2326
power
2015
2326
STRING
2016
2326
NAME
2017
2326
(
2018
2326
term
2020
2326
+
2021
2326
xor_expr
2022
2326
shift_expr
2023
2326
NUMBER
2024
2326
False
2026
2326
expr
2027
2326
None
2030
2326
comparison
2510
2327
[
2004
2327
factor
2005
2327
True
2006
2327
atom_expr
2007
2327
~
2008
2327
and_expr
2009
2327
-
2010
2327
{
2011
2327
atom
2012
2327
arith_expr
2014
2327
power
2015
2327
STRING
2016
2327
NAME
2017
2327
(
2018
2327
term
2020
2327
+
2021
2327
xor_expr
2022
2327
shift_expr
2023
2327
NUMBER
2024
2327
not
2025
2327
False
2026
2327
expr
2027
2327
and_test
2511
2327
comparison
2028
2327
not_test
2029
2327
None
2030
2328
!=
atom -> [ ]
2328
>>
atom -> [ ]
2328
|
atom -> [ ]
2328
<<
atom -> [ ]
2328
>
atom -> [ ]
2328
.
atom -> [ ]
2328
%
atom -> [ ]
2328
^
atom -> [ ]
2328
-
atom -> [ ]
2328
in
atom -> [ ]
2328
or
atom -> [ ]
2328
/
atom -> [ ]
2328
**
atom -> [ ]
2328
//
atom -> [ ]
2328
for
atom -> [ ]
2328
not
atom -> [ ]
2328
(
atom -> [ ]
2328
+
atom -> [ ]
2328
and
atom -> [ ]
2328
]
atom -> [ ]
2328
==
atom -> [ ]
2328
[
atom -> [ ]
2328
if
atom -> [ ]
2328
<
atom -> [ ]
2328
<=
atom -> [ ]
2328
>=
atom -> [ ]
2328
is
atom -> [ ]
2328
*
atom -> [ ]
2328
@
atom -> [ ]
2328
&
atom -> [ ]
2329
]
2512
2330
term
2513
2330
[
2031
2330
factor
2032
2330
True
2033
2330
atom_expr
2034
2330
~
2035
2330
-
2038
2330
{
2039
2330
atom
2040
2330
(
2041
2330
power
2043
2330
STRING
2044
2330
NAME
2045
2330
+
2048
2330
NUMBER
2051
2330
False
2052
2330
None
2056
2331
[
2031
2331
factor
2032
2331
True
2033
2331
atom_expr
2034
2331
~
2035
2331
-
2038
2331
{
2039
2331
atom
2040
2331
term
2514
2331
(
2041
2331
power
2043
2331
STRING
2044
2331
NAME
2045
2331
+
2048
2331
NUMBER
2051
2331
False
2052
2331
None
2056
2332
[
2031
2332
factor
2032
2332
True
2033
2332
term
2515
2332
~
2035
2332
-
2038
2332
atom_expr
2034
2332
{
2039
2332
atom
2040
2332
(
2041
2332
power
2043
2332
STRING
2044
2332
NAME
2045
2332
+
2048
2332
NUMBER
2051
2332
False
2052
2332
None
2056
2333
[
2031
2333
factor
2032
2333
True
2033
2333
atom_expr
2034
2333
~
2035
2333
-
2038
2333
{
2039
2333
atom
2040
2333
(
2041
2333
power
2043
2333
STRING
2044
2333
NAME
2045
2333
term
2516
2333
+
2048
2333
NUMBER
2051
2333
False
2052
2333
None
2056
2334
[
2031
2334
factor
2032
2334
True
2033
2334
atom_expr
2034
2334
~
2035
2334
-
2038
2334
{
2039
2334
atom
2040
2334
(
2041
2334
power
2043
2334
STRING
2044
2334
NAME
2045
2334
term
2517
2334
+
2048
2334
NUMBER
2051
2334
False
2052
2334
None
2056
2335
[
2031
2335
True
2033
2335
atom_expr
2034
2335
-
2038
2335
~
2035
2335
{
2039
2335
atom
2040
2335
(
2041
2335
power
2043
2335
STRING
2044
2335
NAME
2045
2335
+
2048
2335
NUMBER
2051
2335
False
2052
2335
factor
2518
2335
None
2056
2336
@
factor -> ~ factor
2336
>>
factor -> ~ factor
2336
<=
factor -> ~ factor
2336
and
factor -> ~ factor
2336
+
factor -> ~ factor
2336
*
factor -> ~ factor
2336
!=
factor -> ~ factor
2336
for
factor -> ~ factor
2336
%
factor -> ~ factor
2336
<<
factor -> ~ factor
2336
>=
factor -> ~ factor
2336
&
factor -> ~ factor
2336
]
factor -> ~ factor
2336
is
factor -> ~ factor
2336
==
factor -> ~ factor
2336
//
factor -> ~ factor
2336
<
factor -> ~ factor
2336
/
factor -> ~ factor
2336
not
factor -> ~ factor
2336
-
factor -> ~ factor
2336
or
factor -> ~ factor
2336
|
factor -> ~ factor
2336
>
factor -> ~ factor
2336
^
factor -> ~ factor
2336
if
factor -> ~ factor
2336
in
factor -> ~ factor
2337
]
not_test -> not not_test
2337
and
not_test -> not not_test
2337
or
not_test -> not not_test
2337
for
not_test -> not not_test
2337
if
not_test -> not not_test
2338
[
2031
2338
factor
2032
2338
True
2033
2338
atom_expr
2034
2338
~
2035
2338
and_expr
2037
2338
-
2038
2338
{
2039
2338
atom
2040
2338
xor_expr
2519
2338
(
2041
2338
arith_expr
2042
2338
power
2043
2338
STRING
2044
2338
NAME
2045
2338
term
2047
2338
+
2048
2338
shift_expr
2050
2338
NUMBER
2051
2338
False
2052
2338
None
2056
2339
@
factor -> - factor
2339
<=
factor -> - factor
2339
in
factor -> - factor
2339
>>
factor -> - factor
2339
|
factor -> - factor
2339
is
factor -> - factor
2339
+
factor -> - factor
2339
%
factor -> - factor
2339
<
factor -> - factor
2339
*
factor -> - factor
2339
<<
factor -> - factor
2339
if
factor -> - factor
2339
for
factor -> - factor
2339
-
factor -> - factor
2339
>=
factor -> - factor
2339
not
factor -> - factor
2339
and
factor -> - factor
2339
/
factor -> - factor
2339
or
factor -> - factor
2339
^
factor -> - factor
2339
>
factor -> - factor
2339
!=
factor -> - factor
2339
&
factor -> - factor
2339
==
factor -> - factor
2339
//
factor -> - factor
2339
]
factor -> - factor
2340
in
atom -> { }
2340
<=
atom -> { }
2340
*
atom -> { }
2340
>
atom -> { }
2340
+
atom -> { }
2340
@
atom -> { }
2340
>=
atom -> { }
2340
/
atom -> { }
2340
|
atom -> { }
2340
is
atom -> { }
2340
and
atom -> { }
2340
if
atom -> { }
2340
(
atom -> { }
2340
>>
atom -> { }
2340
]
atom -> { }
2340
not
atom -> { }
2340
-
atom -> { }
2340
<<
atom -> { }
2340
**
atom -> { }
2340
or
atom -> { }
2340
<
atom -> { }
2340
!=
atom -> { }
2340
==
atom -> { }
2340
for
atom -> { }
2340
//
atom -> { }
2340
%
atom -> { }
2340
&
atom -> { }
2340
[
atom -> { }
2340
.
atom -> { }
2340
^
atom -> { }
2341
[
766
2341
factor
767
2341
True
768
2341
atom_expr
769
2341
~
770
2341
and_expr
771
2341
-
772
2341
{
773
2341
shift_expr
774
2341
atom
775
2341
comparison
776
2341
and_test
777
2341
arith_expr
778
2341
power
779
2341
STRING
780
2341
NAME
781
2341
(
782
2341
term
784
2341
+
785
2341
xor_expr
786
2341
)
2520
2341
or_test
788
2341
arglist
2521
2341
NUMBER
789
2341
not
790
2341
False
791
2341
expr
792
2341
*
793
2341
not_test
794
2341
None
795
2341
lambdef
796
2341
lambda
797
2341
test
798
2341
argument
799
2341
**
800
2342
trailer_expr
2522
2342
>>
trailer_expr -> 
2342
(
2341
2342
trailer
2342
2342
.
2344
2342
+
trailer_expr -> 
2342
[
2345
2342
is
trailer_expr -> 
2342
>
trailer_expr -> 
2342
not
trailer_expr -> 
2342
|
trailer_expr -> 
2342
&
trailer_expr -> 
2342
/
trailer_expr -> 
2342
@
trailer_expr -> 
2342
!=
trailer_expr -> 
2342
**
trailer_expr -> 
2342
>=
trailer_expr -> 
2342
^
trailer_expr -> 
2342
in
trailer_expr -> 
2342
]
trailer_expr -> 
2342
<<
trailer_expr -> 
2342
and
trailer_expr -> 
2342
or
trailer_expr -> 
2342
if
trailer_expr -> 
2342
//
trailer_expr -> 
2342
%
trailer_expr -> 
2342
<=
trailer_expr -> 
2342
<
trailer_expr -> 
2342
==
trailer_expr -> 
2342
for
trailer_expr -> 
2342
-
trailer_expr -> 
2342
*
trailer_expr -> 
2343
^
atom_expr -> atom trailer_expr
2343
or
atom_expr -> atom trailer_expr
2343
&
atom_expr -> atom trailer_expr
2343
@
atom_expr -> atom trailer_expr
2343
|
atom_expr -> atom trailer_expr
2343
-
atom_expr -> atom trailer_expr
2343
*
atom_expr -> atom trailer_expr
2343
%
atom_expr -> atom trailer_expr
2343
==
atom_expr -> atom trailer_expr
2343
**
atom_expr -> atom trailer_expr
2343
and
atom_expr -> atom trailer_expr
2343
is
atom_expr -> atom trailer_expr
2343
in
atom_expr -> atom trailer_expr
2343
<<
atom_expr -> atom trailer_expr
2343
!=
atom_expr -> atom trailer_expr
2343
<=
atom_expr -> atom trailer_expr
2343
/
atom_expr -> atom trailer_expr
2343
//
atom_expr -> atom trailer_expr
2343
<
atom_expr -> atom trailer_expr
2343
>=
atom_expr -> atom trailer_expr
2343
>>
atom_expr -> atom trailer_expr
2343
if
atom_expr -> atom trailer_expr
2343
not
atom_expr -> atom trailer_expr
2343
for
atom_expr -> atom trailer_expr
2343
+
atom_expr -> atom trailer_expr
2343
]
atom_expr -> atom trailer_expr
2343
>
atom_expr -> atom trailer_expr
2344
NAME
2523
2345
[
802
2345
factor
803
2345
True
804
2345
atom_expr
810
2345
~
806
2345
not
807
2345
and_expr
808
2345
-
809
2345
shift_expr
811
2345
atom
812
2345
{
813
2345
comparison
814
2345
or_test
815
2345
(
816
2345
arith_expr
817
2345
power
818
2345
STRING
819
2345
NAME
820
2345
and_test
821
2345
term
822
2345
+
823
2345
xor_expr
824
2345
subscriptlist
2524
2345
test
825
2345
NUMBER
826
2345
False
827
2345
subscript
828
2345
expr
829
2345
not_test
830
2345
None
831
2345
lambdef
832
2345
lambda
833
2345
maybe_test
834
2345
:
maybe_test -> 
2346
)
2525
2347
or
atom -> ( )
2347
>>
atom -> ( )
2347
(
atom -> ( )
2347
<=
atom -> ( )
2347
.
atom -> ( )
2347
is
atom -> ( )
2347
@
atom -> ( )
2347
%
atom -> ( )
2347
<<
atom -> ( )
2347
**
atom -> ( )
2347
^
atom -> ( )
2347
/
atom -> ( )
2347
if
atom -> ( )
2347
not
atom -> ( )
2347
*
atom -> ( )
2347
!=
atom -> ( )
2347
for
atom -> ( )
2347
<
atom -> ( )
2347
&
atom -> ( )
2347
-
atom -> ( )
2347
>
atom -> ( )
2347
//
atom -> ( )
2347
==
atom -> ( )
2347
]
atom -> ( )
2347
in
atom -> ( )
2347
+
atom -> ( )
2347
[
atom -> ( )
2347
>=
atom -> ( )
2347
and
atom -> ( )
2347
|
atom -> ( )
2348
[
2031
2348
factor
2032
2348
True
2033
2348
atom_expr
2034
2348
~
2035
2348
-
2038
2348
{
2039
2348
atom
2040
2348
(
2041
2348
arith_expr
2042
2348
power
2043
2348
STRING
2044
2348
NAME
2045
2348
shift_expr
2526
2348
term
2047
2348
+
2048
2348
NUMBER
2051
2348
False
2052
2348
None
2056
2349
[
2031
2349
factor
2032
2349
True
2033
2349
atom_expr
2034
2349
~
2035
2349
-
2038
2349
{
2039
2349
atom
2040
2349
(
2041
2349
arith_expr
2042
2349
power
2043
2349
STRING
2044
2349
NAME
2045
2349
term
2047
2349
+
2048
2349
NUMBER
2051
2349
False
2052
2349
shift_expr
2527
2349
None
2056
2350
[
2031
2350
factor
2032
2350
True
2033
2350
atom_expr
2034
2350
~
2035
2350
not
2036
2350
and_expr
2037
2350
-
2038
2350
{
2039
2350
atom
2040
2350
(
2041
2350
arith_expr
2042
2350
power
2043
2350
STRING
2044
2350
NAME
2045
2350
or_test
2528
2350
and_test
2046
2350
term
2047
2350
+
2048
2350
xor_expr
2049
2350
shift_expr
2050
2350
NUMBER
2051
2350
False
2052
2350
expr
2053
2350
comparison
2054
2350
not_test
2055
2350
None
2056
2351
[
2031
2351
factor
2032
2351
True
2033
2351
atom_expr
2034
2351
~
2035
2351
-
2038
2351
{
2039
2351
arith_expr
2529
2351
atom
2040
2351
(
2041
2351
power
2043
2351
STRING
2044
2351
NAME
2045
2351
term
2047
2351
+
2048
2351
NUMBER
2051
2351
False
2052
2351
None
2056
2352
[
2031
2352
factor
2032
2352
True
2033
2352
atom_expr
2034
2352
~
2035
2352
-
2038
2352
{
2039
2352
atom
2040
2352
arith_expr
2530
2352
(
2041
2352
power
2043
2352
STRING
2044
2352
NAME
2045
2352
term
2047
2352
+
2048
2352
NUMBER
2051
2352
False
2052
2352
None
2056
2353
-
factor -> + factor
2353
@
factor -> + factor
2353
<<
factor -> + factor
2353
is
factor -> + factor
2353
and
factor -> + factor
2353
<=
factor -> + factor
2353
or
factor -> + factor
2353
<
factor -> + factor
2353
^
factor -> + factor
2353
not
factor -> + factor
2353
//
factor -> + factor
2353
for
factor -> + factor
2353
*
factor -> + factor
2353
in
factor -> + factor
2353
&
factor -> + factor
2353
+
factor -> + factor
2353
if
factor -> + factor
2353
>>
factor -> + factor
2353
|
factor -> + factor
2353
%
factor -> + factor
2353
>
factor -> + factor
2353
>=
factor -> + factor
2353
!=
factor -> + factor
2353
]
factor -> + factor
2353
/
factor -> + factor
2353
==
factor -> + factor
2354
[
2031
2354
factor
2032
2354
True
2033
2354
atom_expr
2034
2354
~
2035
2354
and_expr
2037
2354
-
2038
2354
{
2039
2354
atom
2040
2354
expr
2531
2354
(
2041
2354
arith_expr
2042
2354
power
2043
2354
STRING
2044
2354
NAME
2045
2354
term
2047
2354
+
2048
2354
xor_expr
2049
2354
shift_expr
2050
2354
NUMBER
2051
2354
False
2052
2354
None
2056
2355
[
2031
2355
factor
2032
2355
True
2033
2355
atom_expr
2034
2355
~
2035
2355
-
2038
2355
{
2039
2355
atom
2040
2355
(
2041
2355
arith_expr
2042
2355
power
2043
2355
STRING
2044
2355
NAME
2045
2355
and_expr
2532
2355
term
2047
2355
+
2048
2355
shift_expr
2050
2355
NUMBER
2051
2355
False
2052
2355
None
2056
2356
[
2031
2356
factor
2032
2356
True
2033
2356
atom_expr
2034
2356
~
2035
2356
and_expr
2037
2356
-
2038
2356
{
2039
2356
atom
2040
2356
(
2041
2356
arith_expr
2042
2356
power
2043
2356
STRING
2044
2356
NAME
2045
2356
term
2047
2356
+
2048
2356
xor_expr
2049
2356
shift_expr
2050
2356
NUMBER
2051
2356
False
2052
2356
expr
2053
2356
None
2056
2356
comparison
2533
2357
[
2031
2357
factor
2032
2357
True
2033
2357
atom_expr
2034
2357
~
2035
2357
not
2036
2357
and_expr
2037
2357
-
2038
2357
{
2039
2357
atom
2040
2357
(
2041
2357
arith_expr
2042
2357
power
2043
2357
STRING
2044
2357
NAME
2045
2357
term
2047
2357
+
2048
2357
xor_expr
2049
2357
shift_expr
2050
2357
NUMBER
2051
2357
False
2052
2357
expr
2053
2357
and_test
2534
2357
comparison
2054
2357
not_test
2055
2357
None
2056
2358
]
comp_iter -> comp_if
2359
]
comp_for -> for expr_list in or_test comp_iter
2360
]
comp_iter -> comp_for
2361
[
2031
2361
factor
2032
2361
True
2033
2361
atom_expr
2034
2361
~
2035
2361
not
2036
2361
and_expr
2037
2361
-
2038
2361
{
2039
2361
atom
2040
2361
(
2041
2361
arith_expr
2042
2361
power
2043
2361
STRING
2044
2361
NAME
2045
2361
and_test
2046
2361
term
2047
2361
+
2048
2361
xor_expr
2049
2361
test_nocond
2535
2361
shift_expr
2050
2361
lambda
2536
2361
NUMBER
2051
2361
False
2052
2361
expr
2053
2361
or_test
2537
2361
comparison
2054
2361
not_test
2055
2361
None
2056
2361
lambdef_nocond
2538
2362
,
trailer -> ( arglist )
2362
.
trailer -> ( arglist )
2362
|
trailer -> ( arglist )
2362
^
trailer -> ( arglist )
2362
==
trailer -> ( arglist )
2362
**
trailer -> ( arglist )
2362
>>
trailer -> ( arglist )
2362
not
trailer -> ( arglist )
2362
<<
trailer -> ( arglist )
2362
>=
trailer -> ( arglist )
2362
!=
trailer -> ( arglist )
2362
in
trailer -> ( arglist )
2362
[
trailer -> ( arglist )
2362
(
trailer -> ( arglist )
2362
]
trailer -> ( arglist )
2362
>
trailer -> ( arglist )
2362
and
trailer -> ( arglist )
2362
+
trailer -> ( arglist )
2362
%
trailer -> ( arglist )
2362
or
trailer -> ( arglist )
2362
*
trailer -> ( arglist )
2362
is
trailer -> ( arglist )
2362
&
trailer -> ( arglist )
2362
//
trailer -> ( arglist )
2362
<
trailer -> ( arglist )
2362
if
trailer -> ( arglist )
2362
<=
trailer -> ( arglist )
2362
-
trailer -> ( arglist )
2362
/
trailer -> ( arglist )
2362
@
trailer -> ( arglist )
2363
]
trailer -> [ subscriptlist ]
2363
<=
trailer -> [ subscriptlist ]
2363
<<
trailer -> [ subscriptlist ]
2363
*
trailer -> [ subscriptlist ]
2363
+
trailer -> [ subscriptlist ]
2363
in
trailer -> [ subscriptlist ]
2363
>>
trailer -> [ subscriptlist ]
2363
//
trailer -> [ subscriptlist ]
2363
.
trailer -> [ subscriptlist ]
2363
,
trailer -> [ subscriptlist ]
2363
and
trailer -> [ subscriptlist ]
2363
**
trailer -> [ subscriptlist ]
2363
@
trailer -> [ subscriptlist ]
2363
<
trailer -> [ subscriptlist ]
2363
not
trailer -> [ subscriptlist ]
2363
-
trailer -> [ subscriptlist ]
2363
!=
trailer -> [ subscriptlist ]
2363
%
trailer -> [ subscriptlist ]
2363
[
trailer -> [ subscriptlist ]
2363
/
trailer -> [ subscriptlist ]
2363
or
trailer -> [ subscriptlist ]
2363
&
trailer -> [ subscriptlist ]
2363
>=
trailer -> [ subscriptlist ]
2363
==
trailer -> [ subscriptlist ]
2363
(
trailer -> [ subscriptlist ]
2363
|
trailer -> [ subscriptlist ]
2363
is
trailer -> [ subscriptlist ]
2363
if
trailer -> [ subscriptlist ]
2363
>
trailer -> [ subscriptlist ]
2363
^
trailer -> [ subscriptlist ]
2364
,
lambdef -> lambda varargslist : test
2364
]
lambdef -> lambda varargslist : test
2365
[
1052
2365
factor
1053
2365
True
1054
2365
atom_expr
1055
2365
~
1056
2365
not
1057
2365
and_expr
1058
2365
-
1059
2365
shift_expr
1060
2365
atom
1061
2365
{
1062
2365
comparison
1063
2365
(
1064
2365
arith_expr
1065
2365
power
1066
2365
STRING
1067
2365
NAME
1068
2365
and_test
1069
2365
term
1071
2365
+
1072
2365
xor_expr
1073
2365
NUMBER
1074
2365
False
1075
2365
not_test
1076
2365
None
1077
2365
expr
1078
2365
test
2539
2365
lambda
1079
2365
or_test
1080
2365
lambdef
1081
2366
-
classdef -> class NAME ( arglist ) : suite
2366
~
classdef -> class NAME ( arglist ) : suite
2366
class
classdef -> class NAME ( arglist ) : suite
2366
endsim
classdef -> class NAME ( arglist ) : suite
2366
NAME
classdef -> class NAME ( arglist ) : suite
2366
{
classdef -> class NAME ( arglist ) : suite
2366
begsim
classdef -> class NAME ( arglist ) : suite
2366
+
classdef -> class NAME ( arglist ) : suite
2366
None
classdef -> class NAME ( arglist ) : suite
2366
not
classdef -> class NAME ( arglist ) : suite
2366
return
classdef -> class NAME ( arglist ) : suite
2366
pass
classdef -> class NAME ( arglist ) : suite
2366
resetstats
classdef -> class NAME ( arglist ) : suite
2366
global
classdef -> class NAME ( arglist ) : suite
2366
[
classdef -> class NAME ( arglist ) : suite
2366
NEWLINE
classdef -> class NAME ( arglist ) : suite
2366
@
classdef -> class NAME ( arglist ) : suite
2366
modopt
classdef -> class NAME ( arglist ) : suite
2366
with
classdef -> class NAME ( arglist ) : suite
2366
server
classdef -> class NAME ( arglist ) : suite
2366
assert
classdef -> class NAME ( arglist ) : suite
2366
conf
classdef -> class NAME ( arglist ) : suite
2366
lambda
classdef -> class NAME ( arglist ) : suite
2366
while
classdef -> class NAME ( arglist ) : suite
2366
$
classdef -> class NAME ( arglist ) : suite
2366
continue
classdef -> class NAME ( arglist ) : suite
2366
False
classdef -> class NAME ( arglist ) : suite
2366
break
classdef -> class NAME ( arglist ) : suite
2366
del
classdef -> class NAME ( arglist ) : suite
2366
NUMBER
classdef -> class NAME ( arglist ) : suite
2366
try
classdef -> class NAME ( arglist ) : suite
2366
yield
classdef -> class NAME ( arglist ) : suite
2366
if
classdef -> class NAME ( arglist ) : suite
2366
nonlocal
classdef -> class NAME ( arglist ) : suite
2366
for
classdef -> class NAME ( arglist ) : suite
2366
raise
classdef -> class NAME ( arglist ) : suite
2366
STRING
classdef -> class NAME ( arglist ) : suite
2366
(
classdef -> class NAME ( arglist ) : suite
2366
servmod
classdef -> class NAME ( arglist ) : suite
2366
def
classdef -> class NAME ( arglist ) : suite
2366
True
classdef -> class NAME ( arglist ) : suite
2367
+
suite -> NEWLINE INDENT stmt_list DEDENT
2367
False
suite -> NEWLINE INDENT stmt_list DEDENT
2367
[
suite -> NEWLINE INDENT stmt_list DEDENT
2367
pass
suite -> NEWLINE INDENT stmt_list DEDENT
2367
continue
suite -> NEWLINE INDENT stmt_list DEDENT
2367
break
suite -> NEWLINE INDENT stmt_list DEDENT
2367
lambda
suite -> NEWLINE INDENT stmt_list DEDENT
2367
NUMBER
suite -> NEWLINE INDENT stmt_list DEDENT
2367
True
suite -> NEWLINE INDENT stmt_list DEDENT
2367
conf
suite -> NEWLINE INDENT stmt_list DEDENT
2367
endsim
suite -> NEWLINE INDENT stmt_list DEDENT
2367
server
suite -> NEWLINE INDENT stmt_list DEDENT
2367
raise
suite -> NEWLINE INDENT stmt_list DEDENT
2367
del
suite -> NEWLINE INDENT stmt_list DEDENT
2367
class
suite -> NEWLINE INDENT stmt_list DEDENT
2367
global
suite -> NEWLINE INDENT stmt_list DEDENT
2367
NEWLINE
suite -> NEWLINE INDENT stmt_list DEDENT
2367
def
suite -> NEWLINE INDENT stmt_list DEDENT
2367
@
suite -> NEWLINE INDENT stmt_list DEDENT
2367
if
suite -> NEWLINE INDENT stmt_list DEDENT
2367
$
suite -> NEWLINE INDENT stmt_list DEDENT
2367
nonlocal
suite -> NEWLINE INDENT stmt_list DEDENT
2367
-
suite -> NEWLINE INDENT stmt_list DEDENT
2367
NAME
suite -> NEWLINE INDENT stmt_list DEDENT
2367
yield
suite -> NEWLINE INDENT stmt_list DEDENT
2367
~
suite -> NEWLINE INDENT stmt_list DEDENT
2367
modopt
suite -> NEWLINE INDENT stmt_list DEDENT
2367
{
suite -> NEWLINE INDENT stmt_list DEDENT
2367
servmod
suite -> NEWLINE INDENT stmt_list DEDENT
2367
begsim
suite -> NEWLINE INDENT stmt_list DEDENT
2367
not
suite -> NEWLINE INDENT stmt_list DEDENT
2367
assert
suite -> NEWLINE INDENT stmt_list DEDENT
2367
with
suite -> NEWLINE INDENT stmt_list DEDENT
2367
None
suite -> NEWLINE INDENT stmt_list DEDENT
2367
resetstats
suite -> NEWLINE INDENT stmt_list DEDENT
2367
try
suite -> NEWLINE INDENT stmt_list DEDENT
2367
while
suite -> NEWLINE INDENT stmt_list DEDENT
2367
return
suite -> NEWLINE INDENT stmt_list DEDENT
2367
for
suite -> NEWLINE INDENT stmt_list DEDENT
2367
STRING
suite -> NEWLINE INDENT stmt_list DEDENT
2367
(
suite -> NEWLINE INDENT stmt_list DEDENT
2368
resetstats
funcdef -> def NAME ( parameters ) : suite
2368
return
funcdef -> def NAME ( parameters ) : suite
2368
servmod
funcdef -> def NAME ( parameters ) : suite
2368
begsim
funcdef -> def NAME ( parameters ) : suite
2368
STRING
funcdef -> def NAME ( parameters ) : suite
2368
with
funcdef -> def NAME ( parameters ) : suite
2368
continue
funcdef -> def NAME ( parameters ) : suite
2368
endsim
funcdef -> def NAME ( parameters ) : suite
2368
def
funcdef -> def NAME ( parameters ) : suite
2368
NAME
funcdef -> def NAME ( parameters ) : suite
2368
raise
funcdef -> def NAME ( parameters ) : suite
2368
pass
funcdef -> def NAME ( parameters ) : suite
2368
try
funcdef -> def NAME ( parameters ) : suite
2368
-
funcdef -> def NAME ( parameters ) : suite
2368
{
funcdef -> def NAME ( parameters ) : suite
2368
modopt
funcdef -> def NAME ( parameters ) : suite
2368
server
funcdef -> def NAME ( parameters ) : suite
2368
conf
funcdef -> def NAME ( parameters ) : suite
2368
nonlocal
funcdef -> def NAME ( parameters ) : suite
2368
assert
funcdef -> def NAME ( parameters ) : suite
2368
global
funcdef -> def NAME ( parameters ) : suite
2368
(
funcdef -> def NAME ( parameters ) : suite
2368
[
funcdef -> def NAME ( parameters ) : suite
2368
del
funcdef -> def NAME ( parameters ) : suite
2368
for
funcdef -> def NAME ( parameters ) : suite
2368
lambda
funcdef -> def NAME ( parameters ) : suite
2368
+
funcdef -> def NAME ( parameters ) : suite
2368
True
funcdef -> def NAME ( parameters ) : suite
2368
break
funcdef -> def NAME ( parameters ) : suite
2368
not
funcdef -> def NAME ( parameters ) : suite
2368
while
funcdef -> def NAME ( parameters ) : suite
2368
class
funcdef -> def NAME ( parameters ) : suite
2368
NEWLINE
funcdef -> def NAME ( parameters ) : suite
2368
NUMBER
funcdef -> def NAME ( parameters ) : suite
2368
$
funcdef -> def NAME ( parameters ) : suite
2368
@
funcdef -> def NAME ( parameters ) : suite
2368
~
funcdef -> def NAME ( parameters ) : suite
2368
yield
funcdef -> def NAME ( parameters ) : suite
2368
if
funcdef -> def NAME ( parameters ) : suite
2368
None
funcdef -> def NAME ( parameters ) : suite
2368
False
funcdef -> def NAME ( parameters ) : suite
2369
!=
atom -> [ ]
2369
>>
atom -> [ ]
2369
|
atom -> [ ]
2369
<<
atom -> [ ]
2369
>
atom -> [ ]
2369
.
atom -> [ ]
2369
%
atom -> [ ]
2369
^
atom -> [ ]
2369
=
atom -> [ ]
2369
-
atom -> [ ]
2369
,
atom -> [ ]
2369
in
atom -> [ ]
2369
or
atom -> [ ]
2369
/
atom -> [ ]
2369
**
atom -> [ ]
2369
//
atom -> [ ]
2369
not
atom -> [ ]
2369
(
atom -> [ ]
2369
)
atom -> [ ]
2369
+
atom -> [ ]
2369
and
atom -> [ ]
2369
==
atom -> [ ]
2369
[
atom -> [ ]
2369
if
atom -> [ ]
2369
<
atom -> [ ]
2369
<=
atom -> [ ]
2369
>=
atom -> [ ]
2369
is
atom -> [ ]
2369
*
atom -> [ ]
2369
@
atom -> [ ]
2369
&
atom -> [ ]
2370
]
2540
2371
term
2541
2371
[
2090
2371
factor
2091
2371
True
2092
2371
atom_expr
2093
2371
~
2094
2371
-
2096
2371
atom
2098
2371
{
2099
2371
power
2103
2371
STRING
2104
2371
NAME
2105
2371
(
2106
2371
+
2108
2371
NUMBER
2111
2371
False
2113
2371
None
2115
2372
[
2090
2372
factor
2091
2372
True
2092
2372
term
2542
2372
~
2094
2372
-
2096
2372
atom_expr
2093
2372
atom
2098
2372
{
2099
2372
power
2103
2372
STRING
2104
2372
NAME
2105
2372
(
2106
2372
+
2108
2372
NUMBER
2111
2372
False
2113
2372
None
2115
2373
[
2090
2373
factor
2091
2373
True
2092
2373
atom_expr
2093
2373
~
2094
2373
-
2096
2373
atom
2098
2373
{
2099
2373
power
2103
2373
STRING
2104
2373
NAME
2105
2373
(
2106
2373
term
2543
2373
+
2108
2373
NUMBER
2111
2373
False
2113
2373
None
2115
2374
[
2090
2374
factor
2091
2374
True
2092
2374
atom_expr
2093
2374
~
2094
2374
-
2096
2374
atom
2098
2374
{
2099
2374
power
2103
2374
STRING
2104
2374
NAME
2105
2374
(
2106
2374
term
2544
2374
+
2108
2374
NUMBER
2111
2374
False
2113
2374
None
2115
2375
[
2090
2375
factor
2091
2375
True
2092
2375
atom_expr
2093
2375
~
2094
2375
-
2096
2375
atom
2098
2375
{
2099
2375
power
2103
2375
STRING
2104
2375
NAME
2105
2375
term
2545
2375
(
2106
2375
+
2108
2375
NUMBER
2111
2375
False
2113
2375
None
2115
2376
[
2090
2376
True
2092
2376
atom_expr
2093
2376
-
2096
2376
~
2094
2376
atom
2098
2376
{
2099
2376
power
2103
2376
STRING
2104
2376
NAME
2105
2376
(
2106
2376
+
2108
2376
NUMBER
2111
2376
False
2113
2376
factor
2546
2376
None
2115
2377
@
factor -> ~ factor
2377
>>
factor -> ~ factor
2377
)
factor -> ~ factor
2377
<=
factor -> ~ factor
2377
and
factor -> ~ factor
2377
+
factor -> ~ factor
2377
*
factor -> ~ factor
2377
!=
factor -> ~ factor
2377
%
factor -> ~ factor
2377
<<
factor -> ~ factor
2377
>=
factor -> ~ factor
2377
=
factor -> ~ factor
2377
,
factor -> ~ factor
2377
&
factor -> ~ factor
2377
is
factor -> ~ factor
2377
==
factor -> ~ factor
2377
//
factor -> ~ factor
2377
<
factor -> ~ factor
2377
/
factor -> ~ factor
2377
not
factor -> ~ factor
2377
-
factor -> ~ factor
2377
or
factor -> ~ factor
2377
|
factor -> ~ factor
2377
>
factor -> ~ factor
2377
^
factor -> ~ factor
2377
if
factor -> ~ factor
2377
in
factor -> ~ factor
2378
[
2090
2378
factor
2091
2378
True
2092
2378
atom_expr
2093
2378
~
2094
2378
and_expr
2095
2378
-
2096
2378
shift_expr
2097
2378
atom
2098
2378
{
2099
2378
xor_expr
2547
2378
arith_expr
2102
2378
power
2103
2378
STRING
2104
2378
NAME
2105
2378
(
2106
2378
term
2107
2378
+
2108
2378
NUMBER
2111
2378
False
2113
2378
None
2115
2379
@
factor -> - factor
2379
=
factor -> - factor
2379
<=
factor -> - factor
2379
in
factor -> - factor
2379
>>
factor -> - factor
2379
|
factor -> - factor
2379
is
factor -> - factor
2379
+
factor -> - factor
2379
%
factor -> - factor
2379
<
factor -> - factor
2379
*
factor -> - factor
2379
<<
factor -> - factor
2379
if
factor -> - factor
2379
-
factor -> - factor
2379
>=
factor -> - factor
2379
not
factor -> - factor
2379
and
factor -> - factor
2379
/
factor -> - factor
2379
or
factor -> - factor
2379
^
factor -> - factor
2379
)
factor -> - factor
2379
>
factor -> - factor
2379
!=
factor -> - factor
2379
&
factor -> - factor
2379
==
factor -> - factor
2379
//
factor -> - factor
2379
,
factor -> - factor
2380
[
2090
2380
factor
2091
2380
True
2092
2380
atom_expr
2093
2380
~
2094
2380
-
2096
2380
shift_expr
2097
2380
atom
2098
2380
{
2099
2380
arith_expr
2102
2380
power
2103
2380
STRING
2104
2380
NAME
2105
2380
(
2106
2380
term
2107
2380
+
2108
2380
and_expr
2548
2380
NUMBER
2111
2380
False
2113
2380
None
2115
2381
NAME
2549
2382
[
766
2382
factor
767
2382
True
768
2382
atom_expr
769
2382
~
770
2382
and_expr
771
2382
-
772
2382
{
773
2382
shift_expr
774
2382
atom
775
2382
comparison
776
2382
and_test
777
2382
arith_expr
778
2382
power
779
2382
STRING
780
2382
NAME
781
2382
(
782
2382
term
784
2382
+
785
2382
xor_expr
786
2382
)
2550
2382
or_test
788
2382
arglist
2551
2382
NUMBER
789
2382
not
790
2382
False
791
2382
expr
792
2382
*
793
2382
not_test
794
2382
None
795
2382
lambdef
796
2382
lambda
797
2382
test
798
2382
argument
799
2382
**
800
2383
trailer_expr
2552
2383
>>
trailer_expr -> 
2383
.
2381
2383
(
2382
2383
)
trailer_expr -> 
2383
trailer
2383
2383
+
trailer_expr -> 
2383
[
2385
2383
is
trailer_expr -> 
2383
>
trailer_expr -> 
2383
not
trailer_expr -> 
2383
|
trailer_expr -> 
2383
=
trailer_expr -> 
2383
&
trailer_expr -> 
2383
/
trailer_expr -> 
2383
@
trailer_expr -> 
2383
!=
trailer_expr -> 
2383
**
trailer_expr -> 
2383
>=
trailer_expr -> 
2383
^
trailer_expr -> 
2383
in
trailer_expr -> 
2383
<<
trailer_expr -> 
2383
and
trailer_expr -> 
2383
or
trailer_expr -> 
2383
if
trailer_expr -> 
2383
//
trailer_expr -> 
2383
%
trailer_expr -> 
2383
,
trailer_expr -> 
2383
<=
trailer_expr -> 
2383
<
trailer_expr -> 
2383
==
trailer_expr -> 
2383
-
trailer_expr -> 
2383
*
trailer_expr -> 
2384
^
atom_expr -> atom trailer_expr
2384
or
atom_expr -> atom trailer_expr
2384
=
atom_expr -> atom trailer_expr
2384
&
atom_expr -> atom trailer_expr
2384
@
atom_expr -> atom trailer_expr
2384
|
atom_expr -> atom trailer_expr
2384
-
atom_expr -> atom trailer_expr
2384
*
atom_expr -> atom trailer_expr
2384
%
atom_expr -> atom trailer_expr
2384
==
atom_expr -> atom trailer_expr
2384
**
atom_expr -> atom trailer_expr
2384
and
atom_expr -> atom trailer_expr
2384
is
atom_expr -> atom trailer_expr
2384
in
atom_expr -> atom trailer_expr
2384
<<
atom_expr -> atom trailer_expr
2384
!=
atom_expr -> atom trailer_expr
2384
<=
atom_expr -> atom trailer_expr
2384
/
atom_expr -> atom trailer_expr
2384
)
atom_expr -> atom trailer_expr
2384
//
atom_expr -> atom trailer_expr
2384
<
atom_expr -> atom trailer_expr
2384
>=
atom_expr -> atom trailer_expr
2384
>>
atom_expr -> atom trailer_expr
2384
if
atom_expr -> atom trailer_expr
2384
not
atom_expr -> atom trailer_expr
2384
+
atom_expr -> atom trailer_expr
2384
>
atom_expr -> atom trailer_expr
2384
,
atom_expr -> atom trailer_expr
2385
[
802
2385
factor
803
2385
True
804
2385
atom_expr
810
2385
~
806
2385
not
807
2385
and_expr
808
2385
-
809
2385
shift_expr
811
2385
atom
812
2385
{
813
2385
comparison
814
2385
or_test
815
2385
(
816
2385
arith_expr
817
2385
power
818
2385
STRING
819
2385
NAME
820
2385
and_test
821
2385
subscriptlist
2553
2385
term
822
2385
+
823
2385
xor_expr
824
2385
test
825
2385
NUMBER
826
2385
False
827
2385
subscript
828
2385
expr
829
2385
not_test
830
2385
None
831
2385
lambdef
832
2385
lambda
833
2385
maybe_test
834
2385
:
maybe_test -> 
2386
in
atom -> { }
2386
<=
atom -> { }
2386
*
atom -> { }
2386
>
atom -> { }
2386
+
atom -> { }
2386
@
atom -> { }
2386
,
atom -> { }
2386
>=
atom -> { }
2386
/
atom -> { }
2386
|
atom -> { }
2386
is
atom -> { }
2386
and
atom -> { }
2386
=
atom -> { }
2386
if
atom -> { }
2386
(
atom -> { }
2386
>>
atom -> { }
2386
not
atom -> { }
2386
-
atom -> { }
2386
<<
atom -> { }
2386
**
atom -> { }
2386
or
atom -> { }
2386
<
atom -> { }
2386
!=
atom -> { }
2386
==
atom -> { }
2386
%
atom -> { }
2386
//
atom -> { }
2386
)
atom -> { }
2386
&
atom -> { }
2386
[
atom -> { }
2386
.
atom -> { }
2386
^
atom -> { }
2387
[
2090
2387
factor
2091
2387
True
2092
2387
atom_expr
2093
2387
~
2094
2387
and_expr
2095
2387
-
2096
2387
shift_expr
2097
2387
atom
2098
2387
{
2099
2387
comparison
2100
2387
and_test
2101
2387
arith_expr
2102
2387
power
2103
2387
STRING
2104
2387
NAME
2105
2387
(
2106
2387
term
2107
2387
+
2108
2387
xor_expr
2109
2387
NUMBER
2111
2387
not
2112
2387
False
2113
2387
not_test
2114
2387
None
2115
2387
expr
2116
2387
or_test
2554
2388
[
2090
2388
factor
2091
2388
True
2092
2388
atom_expr
2093
2388
~
2094
2388
-
2096
2388
atom
2098
2388
{
2099
2388
arith_expr
2102
2388
power
2103
2388
STRING
2104
2388
NAME
2105
2388
shift_expr
2555
2388
(
2106
2388
term
2107
2388
+
2108
2388
NUMBER
2111
2388
False
2113
2388
None
2115
2389
[
2090
2389
factor
2091
2389
True
2092
2389
atom_expr
2093
2389
~
2094
2389
-
2096
2389
atom
2098
2389
{
2099
2389
arith_expr
2102
2389
power
2103
2389
STRING
2104
2389
NAME
2105
2389
shift_expr
2556
2389
(
2106
2389
term
2107
2389
+
2108
2389
NUMBER
2111
2389
False
2113
2389
None
2115
2390
)
2557
2391
or
atom -> ( )
2391
>>
atom -> ( )
2391
(
atom -> ( )
2391
<=
atom -> ( )
2391
.
atom -> ( )
2391
is
atom -> ( )
2391
@
atom -> ( )
2391
,
atom -> ( )
2391
%
atom -> ( )
2391
<<
atom -> ( )
2391
**
atom -> ( )
2391
^
atom -> ( )
2391
/
atom -> ( )
2391
)
atom -> ( )
2391
if
atom -> ( )
2391
not
atom -> ( )
2391
=
atom -> ( )
2391
*
atom -> ( )
2391
!=
atom -> ( )
2391
<
atom -> ( )
2391
&
atom -> ( )
2391
-
atom -> ( )
2391
>
atom -> ( )
2391
//
atom -> ( )
2391
==
atom -> ( )
2391
in
atom -> ( )
2391
+
atom -> ( )
2391
[
atom -> ( )
2391
>=
atom -> ( )
2391
and
atom -> ( )
2391
|
atom -> ( )
2392
[
2090
2392
factor
2091
2392
True
2092
2392
atom_expr
2093
2392
~
2094
2392
-
2096
2392
arith_expr
2558
2392
atom
2098
2392
{
2099
2392
power
2103
2392
STRING
2104
2392
NAME
2105
2392
(
2106
2392
term
2107
2392
+
2108
2392
NUMBER
2111
2392
False
2113
2392
None
2115
2393
[
2090
2393
factor
2091
2393
True
2092
2393
atom_expr
2093
2393
~
2094
2393
-
2096
2393
atom
2098
2393
{
2099
2393
arith_expr
2559
2393
power
2103
2393
STRING
2104
2393
NAME
2105
2393
(
2106
2393
term
2107
2393
+
2108
2393
NUMBER
2111
2393
False
2113
2393
None
2115
2394
-
factor -> + factor
2394
@
factor -> + factor
2394
<<
factor -> + factor
2394
is
factor -> + factor
2394
and
factor -> + factor
2394
<=
factor -> + factor
2394
or
factor -> + factor
2394
<
factor -> + factor
2394
^
factor -> + factor
2394
not
factor -> + factor
2394
//
factor -> + factor
2394
,
factor -> + factor
2394
*
factor -> + factor
2394
in
factor -> + factor
2394
&
factor -> + factor
2394
+
factor -> + factor
2394
if
factor -> + factor
2394
>>
factor -> + factor
2394
)
factor -> + factor
2394
|
factor -> + factor
2394
=
factor -> + factor
2394
>
factor -> + factor
2394
%
factor -> + factor
2394
>=
factor -> + factor
2394
!=
factor -> + factor
2394
/
factor -> + factor
2394
==
factor -> + factor
2395
[
2090
2395
factor
2091
2395
True
2092
2395
atom_expr
2093
2395
~
2094
2395
and_expr
2095
2395
-
2096
2395
shift_expr
2097
2395
atom
2098
2395
{
2099
2395
expr
2560
2395
arith_expr
2102
2395
power
2103
2395
STRING
2104
2395
NAME
2105
2395
(
2106
2395
term
2107
2395
+
2108
2395
xor_expr
2109
2395
NUMBER
2111
2395
False
2113
2395
None
2115
2396
[
738
2396
factor
740
2396
True
741
2396
~
742
2396
and_expr
743
2396
-
744
2396
atom
745
2396
{
746
2396
arith_expr
747
2396
power
748
2396
atom_expr
749
2396
STRING
750
2396
NAME
751
2396
(
752
2396
or_test
2561
2396
term
753
2396
+
754
2396
xor_expr
755
2396
shift_expr
756
2396
NUMBER
757
2396
not
758
2396
False
759
2396
comparison
760
2396
not_test
761
2396
None
762
2396
expr
763
2396
and_test
764
2397
,
not_test -> not not_test
2397
=
not_test -> not not_test
2397
and
not_test -> not not_test
2397
or
not_test -> not not_test
2397
)
not_test -> not not_test
2397
if
not_test -> not not_test
2398
[
2090
2398
factor
2091
2398
True
2092
2398
atom_expr
2093
2398
~
2094
2398
and_expr
2095
2398
-
2096
2398
shift_expr
2097
2398
atom
2098
2398
{
2099
2398
comparison
2100
2398
arith_expr
2102
2398
power
2103
2398
STRING
2104
2398
NAME
2105
2398
(
2106
2398
term
2107
2398
+
2108
2398
xor_expr
2109
2398
NUMBER
2111
2398
not
2112
2398
False
2113
2398
and_test
2562
2398
not_test
2114
2398
None
2115
2398
expr
2116
2399
[
2090
2399
factor
2091
2399
True
2092
2399
atom_expr
2093
2399
~
2094
2399
and_expr
2095
2399
-
2096
2399
shift_expr
2097
2399
atom
2098
2399
{
2099
2399
arith_expr
2102
2399
power
2103
2399
STRING
2104
2399
NAME
2105
2399
(
2106
2399
term
2107
2399
+
2108
2399
xor_expr
2109
2399
NUMBER
2111
2399
False
2113
2399
None
2115
2399
expr
2116
2399
comparison
2563
2400
:
2564
2401
[
2090
2401
factor
2091
2401
True
2092
2401
atom_expr
2093
2401
~
2094
2401
and_expr
2095
2401
-
2096
2401
shift_expr
2097
2401
atom
2098
2401
{
2099
2401
comparison
2100
2401
and_test
2101
2401
arith_expr
2102
2401
power
2103
2401
STRING
2104
2401
NAME
2105
2401
(
2106
2401
term
2107
2401
+
2108
2401
xor_expr
2109
2401
or_test
2110
2401
NUMBER
2111
2401
not
2112
2401
False
2113
2401
not_test
2114
2401
None
2115
2401
expr
2116
2401
lambda
2117
2401
lambdef
2118
2401
test
2565
2402
,
tfpdef -> NAME : test
2402
)
tfpdef -> NAME : test
2403
@
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
+
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
server
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
STRING
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
-
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
~
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
servmod
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
{
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
break
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
True
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
raise
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
NUMBER
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
modopt
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
return
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
with
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
NAME
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
NEWLINE
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
False
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
$
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
nonlocal
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
begsim
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
if
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
lambda
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
endsim
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
continue
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
try
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
not
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
global
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
yield
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
assert
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
pass
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
resetstats
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
[
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
for
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
while
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
class
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
conf
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
(
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
None
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
def
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2403
del
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2404
,
trailer -> ( arglist )
2404
.
trailer -> ( arglist )
2404
|
trailer -> ( arglist )
2404
^
trailer -> ( arglist )
2404
==
trailer -> ( arglist )
2404
**
trailer -> ( arglist )
2404
>>
trailer -> ( arglist )
2404
not
trailer -> ( arglist )
2404
<<
trailer -> ( arglist )
2404
>=
trailer -> ( arglist )
2404
!=
trailer -> ( arglist )
2404
in
trailer -> ( arglist )
2404
[
trailer -> ( arglist )
2404
(
trailer -> ( arglist )
2404
>
trailer -> ( arglist )
2404
and
trailer -> ( arglist )
2404
+
trailer -> ( arglist )
2404
%
trailer -> ( arglist )
2404
or
trailer -> ( arglist )
2404
*
trailer -> ( arglist )
2404
is
trailer -> ( arglist )
2404
&
trailer -> ( arglist )
2404
//
trailer -> ( arglist )
2404
:
trailer -> ( arglist )
2404
<
trailer -> ( arglist )
2404
if
trailer -> ( arglist )
2404
<=
trailer -> ( arglist )
2404
-
trailer -> ( arglist )
2404
/
trailer -> ( arglist )
2404
@
trailer -> ( arglist )
2405
<=
trailer -> [ subscriptlist ]
2405
<<
trailer -> [ subscriptlist ]
2405
:
trailer -> [ subscriptlist ]
2405
*
trailer -> [ subscriptlist ]
2405
+
trailer -> [ subscriptlist ]
2405
in
trailer -> [ subscriptlist ]
2405
>>
trailer -> [ subscriptlist ]
2405
//
trailer -> [ subscriptlist ]
2405
.
trailer -> [ subscriptlist ]
2405
,
trailer -> [ subscriptlist ]
2405
and
trailer -> [ subscriptlist ]
2405
**
trailer -> [ subscriptlist ]
2405
@
trailer -> [ subscriptlist ]
2405
<
trailer -> [ subscriptlist ]
2405
not
trailer -> [ subscriptlist ]
2405
-
trailer -> [ subscriptlist ]
2405
!=
trailer -> [ subscriptlist ]
2405
%
trailer -> [ subscriptlist ]
2405
[
trailer -> [ subscriptlist ]
2405
/
trailer -> [ subscriptlist ]
2405
or
trailer -> [ subscriptlist ]
2405
&
trailer -> [ subscriptlist ]
2405
>=
trailer -> [ subscriptlist ]
2405
==
trailer -> [ subscriptlist ]
2405
(
trailer -> [ subscriptlist ]
2405
|
trailer -> [ subscriptlist ]
2405
is
trailer -> [ subscriptlist ]
2405
if
trailer -> [ subscriptlist ]
2405
>
trailer -> [ subscriptlist ]
2405
^
trailer -> [ subscriptlist ]
2406
[
1111
2406
factor
1112
2406
True
1113
2406
atom_expr
1114
2406
~
1115
2406
and_expr
1116
2406
-
1117
2406
shift_expr
1118
2406
atom
1119
2406
{
1120
2406
comparison
1121
2406
or_test
1122
2406
arith_expr
1123
2406
power
1124
2406
STRING
1125
2406
NAME
1126
2406
(
1128
2406
and_test
1129
2406
term
1130
2406
+
1131
2406
xor_expr
1132
2406
NUMBER
1133
2406
not
1134
2406
False
1135
2406
expr
1136
2406
not_test
1137
2406
None
1139
2406
lambdef
1140
2406
test
2566
2406
lambda
1141
2407
:
2567
2408
,
lambdef -> lambda varargslist : test
2408
:
lambdef -> lambda varargslist : test
2409
INDENT
2568
2410
class
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
try
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
modopt
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
nonlocal
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
@
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
-
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
continue
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
for
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
True
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
pass
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
raise
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
endsim
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
STRING
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
resetstats
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
None
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
del
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
(
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
False
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
if
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
NUMBER
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
def
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
not
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
while
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
[
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
~
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
break
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
return
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
with
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
global
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
lambda
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
NAME
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
NEWLINE
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
begsim
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
conf
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
{
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
server
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
assert
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
servmod
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
yield
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
$
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2410
+
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2411
.
atom -> [ test_list_comp ]
2411
[
atom -> [ test_list_comp ]
2411
@
atom -> [ test_list_comp ]
2411
<=
atom -> [ test_list_comp ]
2411
<
atom -> [ test_list_comp ]
2411
not
atom -> [ test_list_comp ]
2411
in
atom -> [ test_list_comp ]
2411
and
atom -> [ test_list_comp ]
2411
-
atom -> [ test_list_comp ]
2411
if
atom -> [ test_list_comp ]
2411
!=
atom -> [ test_list_comp ]
2411
is
atom -> [ test_list_comp ]
2411
>>
atom -> [ test_list_comp ]
2411
=
atom -> [ test_list_comp ]
2411
or
atom -> [ test_list_comp ]
2411
//
atom -> [ test_list_comp ]
2411
/
atom -> [ test_list_comp ]
2411
|
atom -> [ test_list_comp ]
2411
>
atom -> [ test_list_comp ]
2411
NEWLINE
atom -> [ test_list_comp ]
2411
&
atom -> [ test_list_comp ]
2411
(
atom -> [ test_list_comp ]
2411
%
atom -> [ test_list_comp ]
2411
>=
atom -> [ test_list_comp ]
2411
==
atom -> [ test_list_comp ]
2411
**
atom -> [ test_list_comp ]
2411
<<
atom -> [ test_list_comp ]
2411
^
atom -> [ test_list_comp ]
2411
+
atom -> [ test_list_comp ]
2411
*
atom -> [ test_list_comp ]
2412
<<
term -> factor @ term
2412
^
term -> factor @ term
2412
<=
term -> factor @ term
2412
==
term -> factor @ term
2412
if
term -> factor @ term
2412
|
term -> factor @ term
2412
NEWLINE
term -> factor @ term
2412
!=
term -> factor @ term
2412
or
term -> factor @ term
2412
>
term -> factor @ term
2412
and
term -> factor @ term
2412
>>
term -> factor @ term
2412
is
term -> factor @ term
2412
-
term -> factor @ term
2412
not
term -> factor @ term
2412
=
term -> factor @ term
2412
+
term -> factor @ term
2412
in
term -> factor @ term
2412
>=
term -> factor @ term
2412
<
term -> factor @ term
2412
&
term -> factor @ term
2413
<=
term -> factor % term
2413
is
term -> factor % term
2413
>
term -> factor % term
2413
and
term -> factor % term
2413
in
term -> factor % term
2413
or
term -> factor % term
2413
<
term -> factor % term
2413
-
term -> factor % term
2413
NEWLINE
term -> factor % term
2413
!=
term -> factor % term
2413
>>
term -> factor % term
2413
^
term -> factor % term
2413
+
term -> factor % term
2413
if
term -> factor % term
2413
<<
term -> factor % term
2413
>=
term -> factor % term
2413
==
term -> factor % term
2413
not
term -> factor % term
2413
|
term -> factor % term
2413
=
term -> factor % term
2413
&
term -> factor % term
2414
>>
term -> factor / term
2414
!=
term -> factor / term
2414
<
term -> factor / term
2414
<=
term -> factor / term
2414
|
term -> factor / term
2414
is
term -> factor / term
2414
=
term -> factor / term
2414
>=
term -> factor / term
2414
^
term -> factor / term
2414
&
term -> factor / term
2414
+
term -> factor / term
2414
NEWLINE
term -> factor / term
2414
<<
term -> factor / term
2414
and
term -> factor / term
2414
-
term -> factor / term
2414
in
term -> factor / term
2414
>
term -> factor / term
2414
or
term -> factor / term
2414
not
term -> factor / term
2414
==
term -> factor / term
2414
if
term -> factor / term
2415
is
term -> factor * term
2415
+
term -> factor * term
2415
>=
term -> factor * term
2415
^
term -> factor * term
2415
=
term -> factor * term
2415
NEWLINE
term -> factor * term
2415
<=
term -> factor * term
2415
or
term -> factor * term
2415
<
term -> factor * term
2415
|
term -> factor * term
2415
>>
term -> factor * term
2415
in
term -> factor * term
2415
not
term -> factor * term
2415
==
term -> factor * term
2415
-
term -> factor * term
2415
and
term -> factor * term
2415
!=
term -> factor * term
2415
<<
term -> factor * term
2415
>
term -> factor * term
2415
if
term -> factor * term
2415
&
term -> factor * term
2416
!=
term -> factor // term
2416
or
term -> factor // term
2416
^
term -> factor // term
2416
>
term -> factor // term
2416
is
term -> factor // term
2416
&
term -> factor // term
2416
-
term -> factor // term
2416
in
term -> factor // term
2416
>>
term -> factor // term
2416
|
term -> factor // term
2416
<
term -> factor // term
2416
>=
term -> factor // term
2416
not
term -> factor // term
2416
if
term -> factor // term
2416
=
term -> factor // term
2416
==
term -> factor // term
2416
NEWLINE
term -> factor // term
2416
<=
term -> factor // term
2416
and
term -> factor // term
2416
<<
term -> factor // term
2416
+
term -> factor // term
2417
!=
power -> atom_expr ** factor
2417
@
power -> atom_expr ** factor
2417
|
power -> atom_expr ** factor
2417
in
power -> atom_expr ** factor
2417
==
power -> atom_expr ** factor
2417
if
power -> atom_expr ** factor
2417
NEWLINE
power -> atom_expr ** factor
2417
and
power -> atom_expr ** factor
2417
=
power -> atom_expr ** factor
2417
>=
power -> atom_expr ** factor
2417
/
power -> atom_expr ** factor
2417
not
power -> atom_expr ** factor
2417
^
power -> atom_expr ** factor
2417
//
power -> atom_expr ** factor
2417
>
power -> atom_expr ** factor
2417
+
power -> atom_expr ** factor
2417
%
power -> atom_expr ** factor
2417
-
power -> atom_expr ** factor
2417
is
power -> atom_expr ** factor
2417
<=
power -> atom_expr ** factor
2417
<
power -> atom_expr ** factor
2417
*
power -> atom_expr ** factor
2417
<<
power -> atom_expr ** factor
2417
or
power -> atom_expr ** factor
2417
>>
power -> atom_expr ** factor
2417
&
power -> atom_expr ** factor
2418
not
xor_expr -> and_expr ^ xor_expr
2418
<
xor_expr -> and_expr ^ xor_expr
2418
=
xor_expr -> and_expr ^ xor_expr
2418
>=
xor_expr -> and_expr ^ xor_expr
2418
>
xor_expr -> and_expr ^ xor_expr
2418
is
xor_expr -> and_expr ^ xor_expr
2418
!=
xor_expr -> and_expr ^ xor_expr
2418
and
xor_expr -> and_expr ^ xor_expr
2418
if
xor_expr -> and_expr ^ xor_expr
2418
<=
xor_expr -> and_expr ^ xor_expr
2418
in
xor_expr -> and_expr ^ xor_expr
2418
==
xor_expr -> and_expr ^ xor_expr
2418
|
xor_expr -> and_expr ^ xor_expr
2418
or
xor_expr -> and_expr ^ xor_expr
2418
NEWLINE
xor_expr -> and_expr ^ xor_expr
2419
+
trailer -> ( )
2419
!=
trailer -> ( )
2419
<<
trailer -> ( )
2419
>=
trailer -> ( )
2419
**
trailer -> ( )
2419
not
trailer -> ( )
2419
=
trailer -> ( )
2419
if
trailer -> ( )
2419
|
trailer -> ( )
2419
[
trailer -> ( )
2419
==
trailer -> ( )
2419
%
trailer -> ( )
2419
*
trailer -> ( )
2419
>>
trailer -> ( )
2419
@
trailer -> ( )
2419
>
trailer -> ( )
2419
/
trailer -> ( )
2419
in
trailer -> ( )
2419
(
trailer -> ( )
2419
is
trailer -> ( )
2419
//
trailer -> ( )
2419
<
trailer -> ( )
2419
NEWLINE
trailer -> ( )
2419
or
trailer -> ( )
2419
^
trailer -> ( )
2419
and
trailer -> ( )
2419
<=
trailer -> ( )
2419
.
trailer -> ( )
2419
-
trailer -> ( )
2419
&
trailer -> ( )
2420
)
2569
2421
<=
trailer_expr -> trailer trailer_expr
2421
+
trailer_expr -> trailer trailer_expr
2421
^
trailer_expr -> trailer trailer_expr
2421
or
trailer_expr -> trailer trailer_expr
2421
==
trailer_expr -> trailer trailer_expr
2421
%
trailer_expr -> trailer trailer_expr
2421
@
trailer_expr -> trailer trailer_expr
2421
=
trailer_expr -> trailer trailer_expr
2421
not
trailer_expr -> trailer trailer_expr
2421
<<
trailer_expr -> trailer trailer_expr
2421
-
trailer_expr -> trailer trailer_expr
2421
//
trailer_expr -> trailer trailer_expr
2421
and
trailer_expr -> trailer trailer_expr
2421
|
trailer_expr -> trailer trailer_expr
2421
if
trailer_expr -> trailer trailer_expr
2421
>
trailer_expr -> trailer trailer_expr
2421
!=
trailer_expr -> trailer trailer_expr
2421
<
trailer_expr -> trailer trailer_expr
2421
>>
trailer_expr -> trailer trailer_expr
2421
/
trailer_expr -> trailer trailer_expr
2421
is
trailer_expr -> trailer trailer_expr
2421
NEWLINE
trailer_expr -> trailer trailer_expr
2421
&
trailer_expr -> trailer trailer_expr
2421
in
trailer_expr -> trailer trailer_expr
2421
>=
trailer_expr -> trailer trailer_expr
2421
*
trailer_expr -> trailer trailer_expr
2421
**
trailer_expr -> trailer trailer_expr
2422
=
trailer -> . NAME
2422
.
trailer -> . NAME
2422
not
trailer -> . NAME
2422
if
trailer -> . NAME
2422
NEWLINE
trailer -> . NAME
2422
**
trailer -> . NAME
2422
|
trailer -> . NAME
2422
-
trailer -> . NAME
2422
(
trailer -> . NAME
2422
%
trailer -> . NAME
2422
//
trailer -> . NAME
2422
==
trailer -> . NAME
2422
>>
trailer -> . NAME
2422
is
trailer -> . NAME
2422
!=
trailer -> . NAME
2422
and
trailer -> . NAME
2422
>=
trailer -> . NAME
2422
>
trailer -> . NAME
2422
in
trailer -> . NAME
2422
<<
trailer -> . NAME
2422
&
trailer -> . NAME
2422
/
trailer -> . NAME
2422
^
trailer -> . NAME
2422
[
trailer -> . NAME
2422
<=
trailer -> . NAME
2422
or
trailer -> . NAME
2422
+
trailer -> . NAME
2422
<
trailer -> . NAME
2422
*
trailer -> . NAME
2422
@
trailer -> . NAME
2423
]
2570
2424
if
or_test -> and_test or or_test
2424
NEWLINE
or_test -> and_test or or_test
2424
=
or_test -> and_test or or_test
2425
==
shift_expr -> arith_expr >> shift_expr
2425
^
shift_expr -> arith_expr >> shift_expr
2425
or
shift_expr -> arith_expr >> shift_expr
2425
if
shift_expr -> arith_expr >> shift_expr
2425
not
shift_expr -> arith_expr >> shift_expr
2425
|
shift_expr -> arith_expr >> shift_expr
2425
<=
shift_expr -> arith_expr >> shift_expr
2425
=
shift_expr -> arith_expr >> shift_expr
2425
in
shift_expr -> arith_expr >> shift_expr
2425
is
shift_expr -> arith_expr >> shift_expr
2425
>=
shift_expr -> arith_expr >> shift_expr
2425
NEWLINE
shift_expr -> arith_expr >> shift_expr
2425
>
shift_expr -> arith_expr >> shift_expr
2425
&
shift_expr -> arith_expr >> shift_expr
2425
<
shift_expr -> arith_expr >> shift_expr
2425
and
shift_expr -> arith_expr >> shift_expr
2425
!=
shift_expr -> arith_expr >> shift_expr
2426
or
shift_expr -> arith_expr << shift_expr
2426
>
shift_expr -> arith_expr << shift_expr
2426
in
shift_expr -> arith_expr << shift_expr
2426
NEWLINE
shift_expr -> arith_expr << shift_expr
2426
&
shift_expr -> arith_expr << shift_expr
2426
is
shift_expr -> arith_expr << shift_expr
2426
=
shift_expr -> arith_expr << shift_expr
2426
<
shift_expr -> arith_expr << shift_expr
2426
<=
shift_expr -> arith_expr << shift_expr
2426
not
shift_expr -> arith_expr << shift_expr
2426
^
shift_expr -> arith_expr << shift_expr
2426
if
shift_expr -> arith_expr << shift_expr
2426
and
shift_expr -> arith_expr << shift_expr
2426
|
shift_expr -> arith_expr << shift_expr
2426
!=
shift_expr -> arith_expr << shift_expr
2426
==
shift_expr -> arith_expr << shift_expr
2426
>=
shift_expr -> arith_expr << shift_expr
2427
>
atom -> ( test_list_comp )
2427
@
atom -> ( test_list_comp )
2427
&
atom -> ( test_list_comp )
2427
=
atom -> ( test_list_comp )
2427
[
atom -> ( test_list_comp )
2427
if
atom -> ( test_list_comp )
2427
==
atom -> ( test_list_comp )
2427
>=
atom -> ( test_list_comp )
2427
NEWLINE
atom -> ( test_list_comp )
2427
**
atom -> ( test_list_comp )
2427
not
atom -> ( test_list_comp )
2427
<<
atom -> ( test_list_comp )
2427
>>
atom -> ( test_list_comp )
2427
in
atom -> ( test_list_comp )
2427
or
atom -> ( test_list_comp )
2427
.
atom -> ( test_list_comp )
2427
/
atom -> ( test_list_comp )
2427
^
atom -> ( test_list_comp )
2427
is
atom -> ( test_list_comp )
2427
and
atom -> ( test_list_comp )
2427
//
atom -> ( test_list_comp )
2427
<
atom -> ( test_list_comp )
2427
*
atom -> ( test_list_comp )
2427
<=
atom -> ( test_list_comp )
2427
(
atom -> ( test_list_comp )
2427
-
atom -> ( test_list_comp )
2427
|
atom -> ( test_list_comp )
2427
!=
atom -> ( test_list_comp )
2427
+
atom -> ( test_list_comp )
2427
%
atom -> ( test_list_comp )
2428
^
arith_expr -> term - arith_expr
2428
!=
arith_expr -> term - arith_expr
2428
<
arith_expr -> term - arith_expr
2428
in
arith_expr -> term - arith_expr
2428
==
arith_expr -> term - arith_expr
2428
|
arith_expr -> term - arith_expr
2428
is
arith_expr -> term - arith_expr
2428
&
arith_expr -> term - arith_expr
2428
>>
arith_expr -> term - arith_expr
2428
<<
arith_expr -> term - arith_expr
2428
=
arith_expr -> term - arith_expr
2428
and
arith_expr -> term - arith_expr
2428
>
arith_expr -> term - arith_expr
2428
if
arith_expr -> term - arith_expr
2428
NEWLINE
arith_expr -> term - arith_expr
2428
not
arith_expr -> term - arith_expr
2428
>=
arith_expr -> term - arith_expr
2428
<=
arith_expr -> term - arith_expr
2428
or
arith_expr -> term - arith_expr
2429
>=
arith_expr -> term + arith_expr
2429
>
arith_expr -> term + arith_expr
2429
^
arith_expr -> term + arith_expr
2429
or
arith_expr -> term + arith_expr
2429
==
arith_expr -> term + arith_expr
2429
<=
arith_expr -> term + arith_expr
2429
if
arith_expr -> term + arith_expr
2429
>>
arith_expr -> term + arith_expr
2429
<
arith_expr -> term + arith_expr
2429
not
arith_expr -> term + arith_expr
2429
&
arith_expr -> term + arith_expr
2429
in
arith_expr -> term + arith_expr
2429
and
arith_expr -> term + arith_expr
2429
|
arith_expr -> term + arith_expr
2429
!=
arith_expr -> term + arith_expr
2429
NEWLINE
arith_expr -> term + arith_expr
2429
=
arith_expr -> term + arith_expr
2429
<<
arith_expr -> term + arith_expr
2429
is
arith_expr -> term + arith_expr
2430
>=
expr -> xor_expr | expr
2430
=
expr -> xor_expr | expr
2430
or
expr -> xor_expr | expr
2430
in
expr -> xor_expr | expr
2430
NEWLINE
expr -> xor_expr | expr
2430
and
expr -> xor_expr | expr
2430
==
expr -> xor_expr | expr
2430
>
expr -> xor_expr | expr
2430
<=
expr -> xor_expr | expr
2430
is
expr -> xor_expr | expr
2430
<
expr -> xor_expr | expr
2430
if
expr -> xor_expr | expr
2430
not
expr -> xor_expr | expr
2430
!=
expr -> xor_expr | expr
2431
<
and_expr -> shift_expr & and_expr
2431
if
and_expr -> shift_expr & and_expr
2431
>=
and_expr -> shift_expr & and_expr
2431
=
and_expr -> shift_expr & and_expr
2431
NEWLINE
and_expr -> shift_expr & and_expr
2431
not
and_expr -> shift_expr & and_expr
2431
==
and_expr -> shift_expr & and_expr
2431
>
and_expr -> shift_expr & and_expr
2431
in
and_expr -> shift_expr & and_expr
2431
^
and_expr -> shift_expr & and_expr
2431
or
and_expr -> shift_expr & and_expr
2431
and
and_expr -> shift_expr & and_expr
2431
!=
and_expr -> shift_expr & and_expr
2431
|
and_expr -> shift_expr & and_expr
2431
is
and_expr -> shift_expr & and_expr
2431
<=
and_expr -> shift_expr & and_expr
2432
NEWLINE
lambdef -> lambda : test
2432
=
lambdef -> lambda : test
2433
[
1721
2433
factor
1722
2433
True
1723
2433
atom_expr
1724
2433
~
1725
2433
and_expr
1726
2433
-
1727
2433
None
1728
2433
atom
1729
2433
{
1730
2433
and_test
1731
2433
arith_expr
1732
2433
power
1733
2433
STRING
1734
2433
NAME
1735
2433
(
1736
2433
NUMBER
1737
2433
term
1738
2433
+
1739
2433
xor_expr
1740
2433
shift_expr
1741
2433
not
1742
2433
False
1743
2433
lambda
1744
2433
comparison
1745
2433
not_test
1746
2433
or_test
1747
2433
lambdef
1748
2433
expr
1749
2433
test
2571
2434
NEWLINE
and_test -> not_test and and_test
2434
if
and_test -> not_test and and_test
2434
=
and_test -> not_test and and_test
2434
or
and_test -> not_test and and_test
2435
else
2572
2436
or
comparison -> expr comp_op comparison
2436
and
comparison -> expr comp_op comparison
2436
if
comparison -> expr comp_op comparison
2436
NEWLINE
comparison -> expr comp_op comparison
2436
=
comparison -> expr comp_op comparison
2437
NEWLINE
test -> or_test if or_test else test
2437
,
test -> or_test if or_test else test
2437
=
test -> or_test if or_test else test
2438
=
test -> or_test if or_test else test
2439
,
trailer -> ( arglist )
2439
&
trailer -> ( arglist )
2439
//
trailer -> ( arglist )
2439
.
trailer -> ( arglist )
2439
<<
trailer -> ( arglist )
2439
|
trailer -> ( arglist )
2439
%
trailer -> ( arglist )
2439
:
trailer -> ( arglist )
2439
[
trailer -> ( arglist )
2439
(
trailer -> ( arglist )
2439
^
trailer -> ( arglist )
2439
*
trailer -> ( arglist )
2439
**
trailer -> ( arglist )
2439
-
trailer -> ( arglist )
2439
/
trailer -> ( arglist )
2439
@
trailer -> ( arglist )
2439
+
trailer -> ( arglist )
2439
>>
trailer -> ( arglist )
2440
<<
trailer -> [ subscriptlist ]
2440
:
trailer -> [ subscriptlist ]
2440
%
trailer -> [ subscriptlist ]
2440
@
trailer -> [ subscriptlist ]
2440
**
trailer -> [ subscriptlist ]
2440
|
trailer -> [ subscriptlist ]
2440
&
trailer -> [ subscriptlist ]
2440
*
trailer -> [ subscriptlist ]
2440
+
trailer -> [ subscriptlist ]
2440
(
trailer -> [ subscriptlist ]
2440
-
trailer -> [ subscriptlist ]
2440
>>
trailer -> [ subscriptlist ]
2440
^
trailer -> [ subscriptlist ]
2440
[
trailer -> [ subscriptlist ]
2440
//
trailer -> [ subscriptlist ]
2440
/
trailer -> [ subscriptlist ]
2440
.
trailer -> [ subscriptlist ]
2440
,
trailer -> [ subscriptlist ]
2441
arith_expr
1
2441
small_stmt
20
2441
factor
17
2441
True
38
2441
atom_expr
31
2441
term
22
2441
-
26
2441
None
55
2441
atom
57
2441
test
5
2441
comparison
49
2441
and_expr
8
2441
power
9
2441
STRING
10
2441
NAME
52
2441
shift_expr
48
2441
lambdef
15
2441
NUMBER
58
2441
simple_stmt
1094
2441
(
16
2441
expr
47
2441
[
18
2441
NEWLINE
1095
2441
not_test
32
2441
{
21
2441
and_test
46
2441
+
27
2441
lambda
29
2441
xor_expr
41
2441
suite
2573
2441
yield
34
2441
not
62
2441
test_list
36
2441
~
37
2441
or_test
53
2441
False
39
2441
sim_stmt
45
2441
nonlocal
72
2441
nonlocal_stmt
73
2441
return
59
2441
break_stmt
60
2441
return_stmt
61
2441
raise_stmt
74
2441
break
63
2441
yield_stmt
75
2441
raise
64
2441
continue
77
2441
expr_stmt
65
2441
endsim
78
2441
del
80
2441
pass_stmt
81
2441
flow_stmt
82
2441
stat_stmt
66
2441
assert_stmt
68
2441
resetstats
84
2441
del_stmt
85
2441
continue_stmt
86
2441
begsim
69
2441
global_stmt
87
2441
pass
88
2441
global
70
2441
assert
71
2442
arith_expr
1
2442
small_stmt
1308
2442
factor
17
2442
True
38
2442
atom_expr
31
2442
term
22
2442
-
26
2442
None
55
2442
atom
57
2442
test
5
2442
comparison
49
2442
suite
2574
2442
and_expr
8
2442
power
9
2442
STRING
10
2442
NAME
52
2442
shift_expr
48
2442
lambdef
15
2442
NUMBER
58
2442
simple_stmt
1309
2442
(
16
2442
expr
47
2442
[
18
2442
NEWLINE
1311
2442
not_test
32
2442
{
21
2442
and_test
46
2442
+
27
2442
lambda
29
2442
xor_expr
41
2442
yield
34
2442
not
62
2442
test_list
36
2442
~
37
2442
or_test
53
2442
False
39
2442
sim_stmt
45
2442
nonlocal
72
2442
nonlocal_stmt
73
2442
return
59
2442
break_stmt
60
2442
return_stmt
61
2442
raise_stmt
74
2442
break
63
2442
yield_stmt
75
2442
raise
64
2442
continue
77
2442
expr_stmt
65
2442
endsim
78
2442
del
80
2442
pass_stmt
81
2442
flow_stmt
82
2442
stat_stmt
66
2442
assert_stmt
68
2442
resetstats
84
2442
del_stmt
85
2442
continue_stmt
86
2442
begsim
69
2442
global_stmt
87
2442
pass
88
2442
global
70
2442
assert
71
2443
+
suite -> NEWLINE INDENT stmt_list DEDENT
2443
False
suite -> NEWLINE INDENT stmt_list DEDENT
2443
[
suite -> NEWLINE INDENT stmt_list DEDENT
2443
pass
suite -> NEWLINE INDENT stmt_list DEDENT
2443
continue
suite -> NEWLINE INDENT stmt_list DEDENT
2443
break
suite -> NEWLINE INDENT stmt_list DEDENT
2443
lambda
suite -> NEWLINE INDENT stmt_list DEDENT
2443
NUMBER
suite -> NEWLINE INDENT stmt_list DEDENT
2443
True
suite -> NEWLINE INDENT stmt_list DEDENT
2443
elif
suite -> NEWLINE INDENT stmt_list DEDENT
2443
conf
suite -> NEWLINE INDENT stmt_list DEDENT
2443
endsim
suite -> NEWLINE INDENT stmt_list DEDENT
2443
server
suite -> NEWLINE INDENT stmt_list DEDENT
2443
raise
suite -> NEWLINE INDENT stmt_list DEDENT
2443
del
suite -> NEWLINE INDENT stmt_list DEDENT
2443
class
suite -> NEWLINE INDENT stmt_list DEDENT
2443
global
suite -> NEWLINE INDENT stmt_list DEDENT
2443
NEWLINE
suite -> NEWLINE INDENT stmt_list DEDENT
2443
def
suite -> NEWLINE INDENT stmt_list DEDENT
2443
@
suite -> NEWLINE INDENT stmt_list DEDENT
2443
if
suite -> NEWLINE INDENT stmt_list DEDENT
2443
else
suite -> NEWLINE INDENT stmt_list DEDENT
2443
$
suite -> NEWLINE INDENT stmt_list DEDENT
2443
nonlocal
suite -> NEWLINE INDENT stmt_list DEDENT
2443
-
suite -> NEWLINE INDENT stmt_list DEDENT
2443
NAME
suite -> NEWLINE INDENT stmt_list DEDENT
2443
yield
suite -> NEWLINE INDENT stmt_list DEDENT
2443
~
suite -> NEWLINE INDENT stmt_list DEDENT
2443
modopt
suite -> NEWLINE INDENT stmt_list DEDENT
2443
{
suite -> NEWLINE INDENT stmt_list DEDENT
2443
servmod
suite -> NEWLINE INDENT stmt_list DEDENT
2443
begsim
suite -> NEWLINE INDENT stmt_list DEDENT
2443
not
suite -> NEWLINE INDENT stmt_list DEDENT
2443
assert
suite -> NEWLINE INDENT stmt_list DEDENT
2443
with
suite -> NEWLINE INDENT stmt_list DEDENT
2443
None
suite -> NEWLINE INDENT stmt_list DEDENT
2443
resetstats
suite -> NEWLINE INDENT stmt_list DEDENT
2443
try
suite -> NEWLINE INDENT stmt_list DEDENT
2443
while
suite -> NEWLINE INDENT stmt_list DEDENT
2443
return
suite -> NEWLINE INDENT stmt_list DEDENT
2443
for
suite -> NEWLINE INDENT stmt_list DEDENT
2443
STRING
suite -> NEWLINE INDENT stmt_list DEDENT
2443
(
suite -> NEWLINE INDENT stmt_list DEDENT
2444
for
test -> or_test if or_test else test
2444
,
test -> or_test if or_test else test
2444
)
test -> or_test if or_test else test
2444
=
test -> or_test if or_test else test
2445
comp_iter
2575
2445
,
comp_iter -> 
2445
comp_for
2576
2445
)
comp_iter -> 
2445
if
2577
2445
comp_if
2578
2445
for
1380
2446
,
test -> or_test if or_test else test
2446
]
test -> or_test if or_test else test
2446
:
test -> or_test if or_test else test
2447
,
maybe_test -> test
2447
]
maybe_test -> test
2448
,
sliceop -> : maybe_test
2448
]
sliceop -> : maybe_test
2449
del
simple_stmt -> small_stmt NEWLINE
2449
finally
simple_stmt -> small_stmt NEWLINE
2449
break
simple_stmt -> small_stmt NEWLINE
2449
raise
simple_stmt -> small_stmt NEWLINE
2449
servmod
simple_stmt -> small_stmt NEWLINE
2449
class
simple_stmt -> small_stmt NEWLINE
2449
not
simple_stmt -> small_stmt NEWLINE
2449
-
simple_stmt -> small_stmt NEWLINE
2449
False
simple_stmt -> small_stmt NEWLINE
2449
(
simple_stmt -> small_stmt NEWLINE
2449
endsim
simple_stmt -> small_stmt NEWLINE
2449
+
simple_stmt -> small_stmt NEWLINE
2449
None
simple_stmt -> small_stmt NEWLINE
2449
resetstats
simple_stmt -> small_stmt NEWLINE
2449
conf
simple_stmt -> small_stmt NEWLINE
2449
server
simple_stmt -> small_stmt NEWLINE
2449
STRING
simple_stmt -> small_stmt NEWLINE
2449
$
simple_stmt -> small_stmt NEWLINE
2449
if
simple_stmt -> small_stmt NEWLINE
2449
NUMBER
simple_stmt -> small_stmt NEWLINE
2449
global
simple_stmt -> small_stmt NEWLINE
2449
@
simple_stmt -> small_stmt NEWLINE
2449
True
simple_stmt -> small_stmt NEWLINE
2449
lambda
simple_stmt -> small_stmt NEWLINE
2449
pass
simple_stmt -> small_stmt NEWLINE
2449
return
simple_stmt -> small_stmt NEWLINE
2449
def
simple_stmt -> small_stmt NEWLINE
2449
with
simple_stmt -> small_stmt NEWLINE
2449
nonlocal
simple_stmt -> small_stmt NEWLINE
2449
assert
simple_stmt -> small_stmt NEWLINE
2449
NAME
simple_stmt -> small_stmt NEWLINE
2449
try
simple_stmt -> small_stmt NEWLINE
2449
begsim
simple_stmt -> small_stmt NEWLINE
2449
while
simple_stmt -> small_stmt NEWLINE
2449
for
simple_stmt -> small_stmt NEWLINE
2449
[
simple_stmt -> small_stmt NEWLINE
2449
modopt
simple_stmt -> small_stmt NEWLINE
2449
yield
simple_stmt -> small_stmt NEWLINE
2449
NEWLINE
simple_stmt -> small_stmt NEWLINE
2449
continue
simple_stmt -> small_stmt NEWLINE
2449
{
simple_stmt -> small_stmt NEWLINE
2449
~
simple_stmt -> small_stmt NEWLINE
2450
arith_expr
1
2450
try
1533
2450
modopt
1534
2450
compound_stmt
1535
2450
test
5
2450
servmod
1536
2450
while
1537
2450
and_expr
8
2450
power
9
2450
STRING
10
2450
decorated
1538
2450
cli_serv_model
1539
2450
@
13
2450
try_stmt
1540
2450
lambdef
15
2450
stmt_list
2579
2450
(
16
2450
factor
17
2450
[
18
2450
class
1541
2450
small_stmt
1542
2450
{
21
2450
term
22
2450
def
1543
2450
server
1544
2450
while_stmt
1545
2450
-
26
2450
+
27
2450
for
1546
2450
if
1547
2450
lambda
29
2450
decorators
1548
2450
atom_expr
31
2450
not_test
32
2450
if_stmt
1549
2450
yield
34
2450
conf
1550
2450
test_list
36
2450
~
37
2450
True
38
2450
False
39
2450
funcdef
1551
2450
xor_expr
41
2450
with
1552
2450
for_stmt
1553
2450
sim_stmt
45
2450
and_test
46
2450
expr
47
2450
shift_expr
48
2450
comparison
49
2450
with_stmt
1554
2450
simple_stmt
1555
2450
NAME
52
2450
or_test
53
2450
confdef
1556
2450
None
55
2450
classdef
1557
2450
atom
57
2450
NUMBER
58
2450
return
59
2450
break_stmt
60
2450
return_stmt
61
2450
stmt
1558
2450
not
62
2450
break
63
2450
raise
64
2450
expr_stmt
65
2450
stat_stmt
66
2450
decorator
67
2450
assert_stmt
68
2450
begsim
69
2450
global
70
2450
assert
71
2450
nonlocal
72
2450
nonlocal_stmt
73
2450
raise_stmt
74
2450
yield_stmt
75
2450
continue
77
2450
endsim
78
2450
del
80
2450
pass_stmt
81
2450
flow_stmt
82
2450
resetstats
84
2450
del_stmt
85
2450
continue_stmt
86
2450
global_stmt
87
2450
pass
88
2451
:
2580
2452
arith_expr
1
2452
small_stmt
1938
2452
factor
17
2452
True
38
2452
atom_expr
31
2452
term
22
2452
-
26
2452
None
55
2452
atom
57
2452
test
5
2452
comparison
49
2452
suite
2581
2452
and_expr
8
2452
power
9
2452
STRING
10
2452
NAME
52
2452
shift_expr
48
2452
NEWLINE
1939
2452
lambdef
15
2452
NUMBER
58
2452
simple_stmt
1940
2452
(
16
2452
expr
47
2452
[
18
2452
not_test
32
2452
{
21
2452
and_test
46
2452
+
27
2452
lambda
29
2452
xor_expr
41
2452
yield
34
2452
not
62
2452
test_list
36
2452
~
37
2452
or_test
53
2452
False
39
2452
sim_stmt
45
2452
nonlocal
72
2452
nonlocal_stmt
73
2452
return
59
2452
break_stmt
60
2452
return_stmt
61
2452
raise_stmt
74
2452
break
63
2452
yield_stmt
75
2452
raise
64
2452
continue
77
2452
expr_stmt
65
2452
endsim
78
2452
del
80
2452
pass_stmt
81
2452
flow_stmt
82
2452
stat_stmt
66
2452
assert_stmt
68
2452
resetstats
84
2452
del_stmt
85
2452
continue_stmt
86
2452
begsim
69
2452
global_stmt
87
2452
pass
88
2452
global
70
2452
assert
71
2453
else
except_clause -> except test : suite maybe_except_clause
2453
NAME
except_clause -> except test : suite maybe_except_clause
2453
begsim
except_clause -> except test : suite maybe_except_clause
2453
@
except_clause -> except test : suite maybe_except_clause
2453
lambda
except_clause -> except test : suite maybe_except_clause
2453
-
except_clause -> except test : suite maybe_except_clause
2453
global
except_clause -> except test : suite maybe_except_clause
2453
resetstats
except_clause -> except test : suite maybe_except_clause
2453
NEWLINE
except_clause -> except test : suite maybe_except_clause
2453
+
except_clause -> except test : suite maybe_except_clause
2453
server
except_clause -> except test : suite maybe_except_clause
2453
if
except_clause -> except test : suite maybe_except_clause
2453
not
except_clause -> except test : suite maybe_except_clause
2453
try
except_clause -> except test : suite maybe_except_clause
2453
for
except_clause -> except test : suite maybe_except_clause
2453
True
except_clause -> except test : suite maybe_except_clause
2453
return
except_clause -> except test : suite maybe_except_clause
2453
yield
except_clause -> except test : suite maybe_except_clause
2453
while
except_clause -> except test : suite maybe_except_clause
2453
servmod
except_clause -> except test : suite maybe_except_clause
2453
$
except_clause -> except test : suite maybe_except_clause
2453
{
except_clause -> except test : suite maybe_except_clause
2453
STRING
except_clause -> except test : suite maybe_except_clause
2453
modopt
except_clause -> except test : suite maybe_except_clause
2453
with
except_clause -> except test : suite maybe_except_clause
2453
finally
except_clause -> except test : suite maybe_except_clause
2453
pass
except_clause -> except test : suite maybe_except_clause
2453
break
except_clause -> except test : suite maybe_except_clause
2453
nonlocal
except_clause -> except test : suite maybe_except_clause
2453
endsim
except_clause -> except test : suite maybe_except_clause
2453
raise
except_clause -> except test : suite maybe_except_clause
2453
conf
except_clause -> except test : suite maybe_except_clause
2453
class
except_clause -> except test : suite maybe_except_clause
2453
[
except_clause -> except test : suite maybe_except_clause
2453
assert
except_clause -> except test : suite maybe_except_clause
2453
None
except_clause -> except test : suite maybe_except_clause
2453
~
except_clause -> except test : suite maybe_except_clause
2453
False
except_clause -> except test : suite maybe_except_clause
2453
NUMBER
except_clause -> except test : suite maybe_except_clause
2453
continue
except_clause -> except test : suite maybe_except_clause
2453
del
except_clause -> except test : suite maybe_except_clause
2453
(
except_clause -> except test : suite maybe_except_clause
2453
def
except_clause -> except test : suite maybe_except_clause
2454
.
trailer -> ( arglist )
2454
|
trailer -> ( arglist )
2454
^
trailer -> ( arglist )
2454
==
trailer -> ( arglist )
2454
**
trailer -> ( arglist )
2454
>>
trailer -> ( arglist )
2454
not
trailer -> ( arglist )
2454
<<
trailer -> ( arglist )
2454
>=
trailer -> ( arglist )
2454
!=
trailer -> ( arglist )
2454
in
trailer -> ( arglist )
2454
[
trailer -> ( arglist )
2454
(
trailer -> ( arglist )
2454
>
trailer -> ( arglist )
2454
and
trailer -> ( arglist )
2454
+
trailer -> ( arglist )
2454
%
trailer -> ( arglist )
2454
or
trailer -> ( arglist )
2454
*
trailer -> ( arglist )
2454
is
trailer -> ( arglist )
2454
&
trailer -> ( arglist )
2454
//
trailer -> ( arglist )
2454
:
trailer -> ( arglist )
2454
<
trailer -> ( arglist )
2454
if
trailer -> ( arglist )
2454
as
trailer -> ( arglist )
2454
<=
trailer -> ( arglist )
2454
-
trailer -> ( arglist )
2454
/
trailer -> ( arglist )
2454
@
trailer -> ( arglist )
2455
<=
trailer -> [ subscriptlist ]
2455
<<
trailer -> [ subscriptlist ]
2455
:
trailer -> [ subscriptlist ]
2455
*
trailer -> [ subscriptlist ]
2455
+
trailer -> [ subscriptlist ]
2455
in
trailer -> [ subscriptlist ]
2455
>>
trailer -> [ subscriptlist ]
2455
//
trailer -> [ subscriptlist ]
2455
.
trailer -> [ subscriptlist ]
2455
and
trailer -> [ subscriptlist ]
2455
**
trailer -> [ subscriptlist ]
2455
@
trailer -> [ subscriptlist ]
2455
<
trailer -> [ subscriptlist ]
2455
not
trailer -> [ subscriptlist ]
2455
-
trailer -> [ subscriptlist ]
2455
!=
trailer -> [ subscriptlist ]
2455
%
trailer -> [ subscriptlist ]
2455
as
trailer -> [ subscriptlist ]
2455
[
trailer -> [ subscriptlist ]
2455
/
trailer -> [ subscriptlist ]
2455
or
trailer -> [ subscriptlist ]
2455
&
trailer -> [ subscriptlist ]
2455
>=
trailer -> [ subscriptlist ]
2455
==
trailer -> [ subscriptlist ]
2455
(
trailer -> [ subscriptlist ]
2455
|
trailer -> [ subscriptlist ]
2455
is
trailer -> [ subscriptlist ]
2455
if
trailer -> [ subscriptlist ]
2455
>
trailer -> [ subscriptlist ]
2455
^
trailer -> [ subscriptlist ]
2456
[
1502
2456
factor
1504
2456
True
1505
2456
atom_expr
1506
2456
~
1507
2456
and_expr
1508
2456
-
1509
2456
atom
1510
2456
{
1511
2456
or_test
1512
2456
arith_expr
1513
2456
power
1514
2456
STRING
1515
2456
NAME
1516
2456
shift_expr
1517
2456
(
1519
2456
and_test
1520
2456
term
1521
2456
+
1522
2456
xor_expr
1523
2456
NUMBER
1524
2456
not
1525
2456
False
1526
2456
expr
1527
2456
not_test
1528
2456
comparison
1529
2456
None
1530
2456
lambdef
1531
2456
test
2582
2456
lambda
1532
2457
DEDENT
2583
2458
as
lambdef -> lambda varargslist : test
2458
:
lambdef -> lambda varargslist : test
2459
finally
2584
2459
else
2585
2459
while
try_stmt -> try : suite except_clause
2459
conf
try_stmt -> try : suite except_clause
2459
raise
try_stmt -> try : suite except_clause
2459
NAME
try_stmt -> try : suite except_clause
2459
try
try_stmt -> try : suite except_clause
2459
modopt
try_stmt -> try : suite except_clause
2459
for
try_stmt -> try : suite except_clause
2459
(
try_stmt -> try : suite except_clause
2459
lambda
try_stmt -> try : suite except_clause
2459
True
try_stmt -> try : suite except_clause
2459
[
try_stmt -> try : suite except_clause
2459
continue
try_stmt -> try : suite except_clause
2459
{
try_stmt -> try : suite except_clause
2459
server
try_stmt -> try : suite except_clause
2459
DEDENT
try_stmt -> try : suite except_clause
2459
None
try_stmt -> try : suite except_clause
2459
servmod
try_stmt -> try : suite except_clause
2459
break
try_stmt -> try : suite except_clause
2459
endsim
try_stmt -> try : suite except_clause
2459
assert
try_stmt -> try : suite except_clause
2459
yield
try_stmt -> try : suite except_clause
2459
not
try_stmt -> try : suite except_clause
2459
global
try_stmt -> try : suite except_clause
2459
begsim
try_stmt -> try : suite except_clause
2459
False
try_stmt -> try : suite except_clause
2459
if
try_stmt -> try : suite except_clause
2459
resetstats
try_stmt -> try : suite except_clause
2459
NUMBER
try_stmt -> try : suite except_clause
2459
+
try_stmt -> try : suite except_clause
2459
class
try_stmt -> try : suite except_clause
2459
nonlocal
try_stmt -> try : suite except_clause
2459
pass
try_stmt -> try : suite except_clause
2459
return
try_stmt -> try : suite except_clause
2459
with
try_stmt -> try : suite except_clause
2459
@
try_stmt -> try : suite except_clause
2459
-
try_stmt -> try : suite except_clause
2459
del
try_stmt -> try : suite except_clause
2459
STRING
try_stmt -> try : suite except_clause
2459
~
try_stmt -> try : suite except_clause
2459
def
try_stmt -> try : suite except_clause
2460
[
1502
2460
test
2586
2460
factor
1504
2460
True
1505
2460
atom_expr
1506
2460
~
1507
2460
and_expr
1508
2460
-
1509
2460
atom
1510
2460
{
1511
2460
or_test
1512
2460
arith_expr
1513
2460
power
1514
2460
STRING
1515
2460
NAME
1516
2460
shift_expr
1517
2460
:
2587
2460
(
1519
2460
and_test
1520
2460
term
1521
2460
+
1522
2460
xor_expr
1523
2460
NUMBER
1524
2460
not
1525
2460
False
1526
2460
expr
1527
2460
not_test
1528
2460
comparison
1529
2460
None
1530
2460
lambdef
1531
2460
lambda
1532
2461
INDENT
2588
2462
INDENT
2589
2463
else
2590
2463
while
while_stmt -> while test : suite
2463
[
while_stmt -> while test : suite
2463
def
while_stmt -> while test : suite
2463
None
while_stmt -> while test : suite
2463
resetstats
while_stmt -> while test : suite
2463
True
while_stmt -> while test : suite
2463
server
while_stmt -> while test : suite
2463
raise
while_stmt -> while test : suite
2463
if
while_stmt -> while test : suite
2463
False
while_stmt -> while test : suite
2463
return
while_stmt -> while test : suite
2463
del
while_stmt -> while test : suite
2463
global
while_stmt -> while test : suite
2463
endsim
while_stmt -> while test : suite
2463
pass
while_stmt -> while test : suite
2463
STRING
while_stmt -> while test : suite
2463
+
while_stmt -> while test : suite
2463
conf
while_stmt -> while test : suite
2463
DEDENT
while_stmt -> while test : suite
2463
try
while_stmt -> while test : suite
2463
break
while_stmt -> while test : suite
2463
servmod
while_stmt -> while test : suite
2463
with
while_stmt -> while test : suite
2463
lambda
while_stmt -> while test : suite
2463
NUMBER
while_stmt -> while test : suite
2463
modopt
while_stmt -> while test : suite
2463
~
while_stmt -> while test : suite
2463
-
while_stmt -> while test : suite
2463
assert
while_stmt -> while test : suite
2463
NAME
while_stmt -> while test : suite
2463
(
while_stmt -> while test : suite
2463
yield
while_stmt -> while test : suite
2463
continue
while_stmt -> while test : suite
2463
not
while_stmt -> while test : suite
2463
begsim
while_stmt -> while test : suite
2463
{
while_stmt -> while test : suite
2463
class
while_stmt -> while test : suite
2463
nonlocal
while_stmt -> while test : suite
2463
@
while_stmt -> while test : suite
2463
for
while_stmt -> while test : suite
2464
NEWLINE
2591
2465
modopt
suite -> simple_stmt
2465
~
suite -> simple_stmt
2465
False
suite -> simple_stmt
2465
@
suite -> simple_stmt
2465
begsim
suite -> simple_stmt
2465
NUMBER
suite -> simple_stmt
2465
conf
suite -> simple_stmt
2465
class
suite -> simple_stmt
2465
if
suite -> simple_stmt
2465
yield
suite -> simple_stmt
2465
try
suite -> simple_stmt
2465
else
suite -> simple_stmt
2465
pass
suite -> simple_stmt
2465
[
suite -> simple_stmt
2465
break
suite -> simple_stmt
2465
True
suite -> simple_stmt
2465
DEDENT
suite -> simple_stmt
2465
None
suite -> simple_stmt
2465
server
suite -> simple_stmt
2465
assert
suite -> simple_stmt
2465
servmod
suite -> simple_stmt
2465
raise
suite -> simple_stmt
2465
nonlocal
suite -> simple_stmt
2465
lambda
suite -> simple_stmt
2465
return
suite -> simple_stmt
2465
+
suite -> simple_stmt
2465
-
suite -> simple_stmt
2465
NAME
suite -> simple_stmt
2465
while
suite -> simple_stmt
2465
def
suite -> simple_stmt
2465
with
suite -> simple_stmt
2465
del
suite -> simple_stmt
2465
STRING
suite -> simple_stmt
2465
for
suite -> simple_stmt
2465
resetstats
suite -> simple_stmt
2465
global
suite -> simple_stmt
2465
continue
suite -> simple_stmt
2465
endsim
suite -> simple_stmt
2465
not
suite -> simple_stmt
2465
{
suite -> simple_stmt
2465
(
suite -> simple_stmt
2466
INDENT
2592
2467
)
2593
2468
:
2594
2469
modopt
suite -> simple_stmt
2469
~
suite -> simple_stmt
2469
False
suite -> simple_stmt
2469
@
suite -> simple_stmt
2469
begsim
suite -> simple_stmt
2469
NUMBER
suite -> simple_stmt
2469
conf
suite -> simple_stmt
2469
class
suite -> simple_stmt
2469
if
suite -> simple_stmt
2469
yield
suite -> simple_stmt
2469
try
suite -> simple_stmt
2469
pass
suite -> simple_stmt
2469
[
suite -> simple_stmt
2469
break
suite -> simple_stmt
2469
True
suite -> simple_stmt
2469
DEDENT
suite -> simple_stmt
2469
None
suite -> simple_stmt
2469
server
suite -> simple_stmt
2469
assert
suite -> simple_stmt
2469
servmod
suite -> simple_stmt
2469
raise
suite -> simple_stmt
2469
nonlocal
suite -> simple_stmt
2469
lambda
suite -> simple_stmt
2469
return
suite -> simple_stmt
2469
+
suite -> simple_stmt
2469
-
suite -> simple_stmt
2469
NAME
suite -> simple_stmt
2469
while
suite -> simple_stmt
2469
def
suite -> simple_stmt
2469
with
suite -> simple_stmt
2469
del
suite -> simple_stmt
2469
STRING
suite -> simple_stmt
2469
for
suite -> simple_stmt
2469
resetstats
suite -> simple_stmt
2469
global
suite -> simple_stmt
2469
continue
suite -> simple_stmt
2469
endsim
suite -> simple_stmt
2469
not
suite -> simple_stmt
2469
{
suite -> simple_stmt
2469
(
suite -> simple_stmt
2470
INDENT
2595
2471
(
classdef -> class NAME : suite
2471
server
classdef -> class NAME : suite
2471
False
classdef -> class NAME : suite
2471
DEDENT
classdef -> class NAME : suite
2471
raise
classdef -> class NAME : suite
2471
conf
classdef -> class NAME : suite
2471
del
classdef -> class NAME : suite
2471
modopt
classdef -> class NAME : suite
2471
global
classdef -> class NAME : suite
2471
pass
classdef -> class NAME : suite
2471
return
classdef -> class NAME : suite
2471
@
classdef -> class NAME : suite
2471
not
classdef -> class NAME : suite
2471
for
classdef -> class NAME : suite
2471
assert
classdef -> class NAME : suite
2471
servmod
classdef -> class NAME : suite
2471
yield
classdef -> class NAME : suite
2471
with
classdef -> class NAME : suite
2471
NAME
classdef -> class NAME : suite
2471
def
classdef -> class NAME : suite
2471
-
classdef -> class NAME : suite
2471
STRING
classdef -> class NAME : suite
2471
begsim
classdef -> class NAME : suite
2471
class
classdef -> class NAME : suite
2471
True
classdef -> class NAME : suite
2471
endsim
classdef -> class NAME : suite
2471
None
classdef -> class NAME : suite
2471
~
classdef -> class NAME : suite
2471
+
classdef -> class NAME : suite
2471
NUMBER
classdef -> class NAME : suite
2471
continue
classdef -> class NAME : suite
2471
nonlocal
classdef -> class NAME : suite
2471
resetstats
classdef -> class NAME : suite
2471
[
classdef -> class NAME : suite
2471
while
classdef -> class NAME : suite
2471
if
classdef -> class NAME : suite
2471
lambda
classdef -> class NAME : suite
2471
try
classdef -> class NAME : suite
2471
{
classdef -> class NAME : suite
2471
break
classdef -> class NAME : suite
2472
)
2596
2473
:
2597
2474
INDENT
2598
2475
:
2599
2476
NEWLINE
2600
2477
modopt
suite -> simple_stmt
2477
~
suite -> simple_stmt
2477
False
suite -> simple_stmt
2477
@
suite -> simple_stmt
2477
begsim
suite -> simple_stmt
2477
NUMBER
suite -> simple_stmt
2477
elif
suite -> simple_stmt
2477
conf
suite -> simple_stmt
2477
class
suite -> simple_stmt
2477
if
suite -> simple_stmt
2477
yield
suite -> simple_stmt
2477
try
suite -> simple_stmt
2477
else
suite -> simple_stmt
2477
pass
suite -> simple_stmt
2477
[
suite -> simple_stmt
2477
break
suite -> simple_stmt
2477
True
suite -> simple_stmt
2477
DEDENT
suite -> simple_stmt
2477
None
suite -> simple_stmt
2477
server
suite -> simple_stmt
2477
assert
suite -> simple_stmt
2477
servmod
suite -> simple_stmt
2477
raise
suite -> simple_stmt
2477
nonlocal
suite -> simple_stmt
2477
lambda
suite -> simple_stmt
2477
return
suite -> simple_stmt
2477
+
suite -> simple_stmt
2477
-
suite -> simple_stmt
2477
NAME
suite -> simple_stmt
2477
while
suite -> simple_stmt
2477
def
suite -> simple_stmt
2477
with
suite -> simple_stmt
2477
del
suite -> simple_stmt
2477
STRING
suite -> simple_stmt
2477
for
suite -> simple_stmt
2477
resetstats
suite -> simple_stmt
2477
global
suite -> simple_stmt
2477
continue
suite -> simple_stmt
2477
endsim
suite -> simple_stmt
2477
not
suite -> simple_stmt
2477
{
suite -> simple_stmt
2477
(
suite -> simple_stmt
2478
elif_clause
2601
2478
elif
2602
2478
del
elif_clause -> 
2478
class
elif_clause -> 
2478
resetstats
elif_clause -> 
2478
+
elif_clause -> 
2478
DEDENT
elif_clause -> 
2478
break
elif_clause -> 
2478
if
elif_clause -> 
2478
[
elif_clause -> 
2478
endsim
elif_clause -> 
2478
for
elif_clause -> 
2478
begsim
elif_clause -> 
2478
try
elif_clause -> 
2478
lambda
elif_clause -> 
2478
@
elif_clause -> 
2478
with
elif_clause -> 
2478
-
elif_clause -> 
2478
(
elif_clause -> 
2478
True
elif_clause -> 
2478
STRING
elif_clause -> 
2478
NUMBER
elif_clause -> 
2478
def
elif_clause -> 
2478
global
elif_clause -> 
2478
nonlocal
elif_clause -> 
2478
{
elif_clause -> 
2478
continue
elif_clause -> 
2478
modopt
elif_clause -> 
2478
pass
elif_clause -> 
2478
None
elif_clause -> 
2478
return
elif_clause -> 
2478
~
elif_clause -> 
2478
servmod
elif_clause -> 
2478
else
elif_clause -> 
2478
not
elif_clause -> 
2478
conf
elif_clause -> 
2478
raise
elif_clause -> 
2478
yield
elif_clause -> 
2478
False
elif_clause -> 
2478
server
elif_clause -> 
2478
assert
elif_clause -> 
2478
while
elif_clause -> 
2478
NAME
elif_clause -> 
2479
INDENT
2603
2480
)
2604
2481
INDENT
2605
2482
global
with_stmt -> with with_items : suite
2482
try
with_stmt -> with with_items : suite
2482
server
with_stmt -> with with_items : suite
2482
begsim
with_stmt -> with with_items : suite
2482
+
with_stmt -> with with_items : suite
2482
endsim
with_stmt -> with with_items : suite
2482
NUMBER
with_stmt -> with with_items : suite
2482
assert
with_stmt -> with with_items : suite
2482
return
with_stmt -> with with_items : suite
2482
raise
with_stmt -> with with_items : suite
2482
None
with_stmt -> with with_items : suite
2482
NAME
with_stmt -> with with_items : suite
2482
yield
with_stmt -> with with_items : suite
2482
nonlocal
with_stmt -> with with_items : suite
2482
modopt
with_stmt -> with with_items : suite
2482
if
with_stmt -> with with_items : suite
2482
for
with_stmt -> with with_items : suite
2482
break
with_stmt -> with with_items : suite
2482
-
with_stmt -> with with_items : suite
2482
{
with_stmt -> with with_items : suite
2482
DEDENT
with_stmt -> with with_items : suite
2482
conf
with_stmt -> with with_items : suite
2482
(
with_stmt -> with with_items : suite
2482
def
with_stmt -> with with_items : suite
2482
True
with_stmt -> with with_items : suite
2482
@
with_stmt -> with with_items : suite
2482
STRING
with_stmt -> with with_items : suite
2482
continue
with_stmt -> with with_items : suite
2482
~
with_stmt -> with with_items : suite
2482
class
with_stmt -> with with_items : suite
2482
lambda
with_stmt -> with with_items : suite
2482
False
with_stmt -> with with_items : suite
2482
while
with_stmt -> with with_items : suite
2482
with
with_stmt -> with with_items : suite
2482
resetstats
with_stmt -> with with_items : suite
2482
[
with_stmt -> with with_items : suite
2482
servmod
with_stmt -> with with_items : suite
2482
pass
with_stmt -> with with_items : suite
2482
del
with_stmt -> with with_items : suite
2482
not
with_stmt -> with with_items : suite
2483
confbody
2606
2483
NAME
1971
2483
DEDENT
confbody -> NAME test NEWLINE
2484
,
test -> or_test if or_test else test
2484
)
test -> or_test if or_test else test
2485
.
atom -> [ test_list_comp ]
2485
[
atom -> [ test_list_comp ]
2485
@
atom -> [ test_list_comp ]
2485
<=
atom -> [ test_list_comp ]
2485
<
atom -> [ test_list_comp ]
2485
not
atom -> [ test_list_comp ]
2485
for
atom -> [ test_list_comp ]
2485
in
atom -> [ test_list_comp ]
2485
and
atom -> [ test_list_comp ]
2485
-
atom -> [ test_list_comp ]
2485
if
atom -> [ test_list_comp ]
2485
!=
atom -> [ test_list_comp ]
2485
is
atom -> [ test_list_comp ]
2485
>>
atom -> [ test_list_comp ]
2485
or
atom -> [ test_list_comp ]
2485
//
atom -> [ test_list_comp ]
2485
/
atom -> [ test_list_comp ]
2485
|
atom -> [ test_list_comp ]
2485
>
atom -> [ test_list_comp ]
2485
&
atom -> [ test_list_comp ]
2485
(
atom -> [ test_list_comp ]
2485
%
atom -> [ test_list_comp ]
2485
>=
atom -> [ test_list_comp ]
2485
)
atom -> [ test_list_comp ]
2485
==
atom -> [ test_list_comp ]
2485
**
atom -> [ test_list_comp ]
2485
<<
atom -> [ test_list_comp ]
2485
^
atom -> [ test_list_comp ]
2485
+
atom -> [ test_list_comp ]
2485
*
atom -> [ test_list_comp ]
2486
for
term -> factor @ term
2486
<<
term -> factor @ term
2486
^
term -> factor @ term
2486
<=
term -> factor @ term
2486
==
term -> factor @ term
2486
if
term -> factor @ term
2486
|
term -> factor @ term
2486
!=
term -> factor @ term
2486
or
term -> factor @ term
2486
>
term -> factor @ term
2486
and
term -> factor @ term
2486
>>
term -> factor @ term
2486
is
term -> factor @ term
2486
-
term -> factor @ term
2486
not
term -> factor @ term
2486
+
term -> factor @ term
2486
in
term -> factor @ term
2486
>=
term -> factor @ term
2486
<
term -> factor @ term
2486
&
term -> factor @ term
2486
)
term -> factor @ term
2487
<=
term -> factor % term
2487
is
term -> factor % term
2487
>
term -> factor % term
2487
and
term -> factor % term
2487
in
term -> factor % term
2487
or
term -> factor % term
2487
<
term -> factor % term
2487
-
term -> factor % term
2487
!=
term -> factor % term
2487
>>
term -> factor % term
2487
^
term -> factor % term
2487
+
term -> factor % term
2487
if
term -> factor % term
2487
<<
term -> factor % term
2487
>=
term -> factor % term
2487
==
term -> factor % term
2487
not
term -> factor % term
2487
|
term -> factor % term
2487
)
term -> factor % term
2487
&
term -> factor % term
2487
for
term -> factor % term
2488
>>
term -> factor / term
2488
!=
term -> factor / term
2488
<
term -> factor / term
2488
<=
term -> factor / term
2488
|
term -> factor / term
2488
is
term -> factor / term
2488
>=
term -> factor / term
2488
^
term -> factor / term
2488
&
term -> factor / term
2488
+
term -> factor / term
2488
for
term -> factor / term
2488
<<
term -> factor / term
2488
and
term -> factor / term
2488
-
term -> factor / term
2488
in
term -> factor / term
2488
>
term -> factor / term
2488
or
term -> factor / term
2488
not
term -> factor / term
2488
==
term -> factor / term
2488
if
term -> factor / term
2488
)
term -> factor / term
2489
is
term -> factor * term
2489
+
term -> factor * term
2489
>=
term -> factor * term
2489
^
term -> factor * term
2489
<=
term -> factor * term
2489
or
term -> factor * term
2489
)
term -> factor * term
2489
for
term -> factor * term
2489
<
term -> factor * term
2489
|
term -> factor * term
2489
>>
term -> factor * term
2489
in
term -> factor * term
2489
not
term -> factor * term
2489
==
term -> factor * term
2489
-
term -> factor * term
2489
and
term -> factor * term
2489
!=
term -> factor * term
2489
<<
term -> factor * term
2489
>
term -> factor * term
2489
if
term -> factor * term
2489
&
term -> factor * term
2490
for
term -> factor // term
2490
!=
term -> factor // term
2490
or
term -> factor // term
2490
^
term -> factor // term
2490
>
term -> factor // term
2490
is
term -> factor // term
2490
&
term -> factor // term
2490
-
term -> factor // term
2490
in
term -> factor // term
2490
>>
term -> factor // term
2490
|
term -> factor // term
2490
<
term -> factor // term
2490
>=
term -> factor // term
2490
not
term -> factor // term
2490
if
term -> factor // term
2490
==
term -> factor // term
2490
)
term -> factor // term
2490
<=
term -> factor // term
2490
and
term -> factor // term
2490
<<
term -> factor // term
2490
+
term -> factor // term
2491
!=
power -> atom_expr ** factor
2491
@
power -> atom_expr ** factor
2491
for
power -> atom_expr ** factor
2491
|
power -> atom_expr ** factor
2491
in
power -> atom_expr ** factor
2491
==
power -> atom_expr ** factor
2491
if
power -> atom_expr ** factor
2491
and
power -> atom_expr ** factor
2491
>=
power -> atom_expr ** factor
2491
/
power -> atom_expr ** factor
2491
not
power -> atom_expr ** factor
2491
^
power -> atom_expr ** factor
2491
//
power -> atom_expr ** factor
2491
>
power -> atom_expr ** factor
2491
+
power -> atom_expr ** factor
2491
%
power -> atom_expr ** factor
2491
)
power -> atom_expr ** factor
2491
-
power -> atom_expr ** factor
2491
is
power -> atom_expr ** factor
2491
<=
power -> atom_expr ** factor
2491
<
power -> atom_expr ** factor
2491
*
power -> atom_expr ** factor
2491
<<
power -> atom_expr ** factor
2491
or
power -> atom_expr ** factor
2491
>>
power -> atom_expr ** factor
2491
&
power -> atom_expr ** factor
2492
not
xor_expr -> and_expr ^ xor_expr
2492
<
xor_expr -> and_expr ^ xor_expr
2492
>=
xor_expr -> and_expr ^ xor_expr
2492
>
xor_expr -> and_expr ^ xor_expr
2492
)
xor_expr -> and_expr ^ xor_expr
2492
!=
xor_expr -> and_expr ^ xor_expr
2492
is
xor_expr -> and_expr ^ xor_expr
2492
and
xor_expr -> and_expr ^ xor_expr
2492
if
xor_expr -> and_expr ^ xor_expr
2492
<=
xor_expr -> and_expr ^ xor_expr
2492
in
xor_expr -> and_expr ^ xor_expr
2492
==
xor_expr -> and_expr ^ xor_expr
2492
for
xor_expr -> and_expr ^ xor_expr
2492
|
xor_expr -> and_expr ^ xor_expr
2492
or
xor_expr -> and_expr ^ xor_expr
2493
.
trailer -> . NAME
2493
not
trailer -> . NAME
2493
if
trailer -> . NAME
2493
**
trailer -> . NAME
2493
|
trailer -> . NAME
2493
-
trailer -> . NAME
2493
(
trailer -> . NAME
2493
%
trailer -> . NAME
2493
//
trailer -> . NAME
2493
==
trailer -> . NAME
2493
>>
trailer -> . NAME
2493
is
trailer -> . NAME
2493
!=
trailer -> . NAME
2493
)
trailer -> . NAME
2493
and
trailer -> . NAME
2493
>=
trailer -> . NAME
2493
>
trailer -> . NAME
2493
in
trailer -> . NAME
2493
<<
trailer -> . NAME
2493
&
trailer -> . NAME
2493
/
trailer -> . NAME
2493
^
trailer -> . NAME
2493
[
trailer -> . NAME
2493
<=
trailer -> . NAME
2493
or
trailer -> . NAME
2493
+
trailer -> . NAME
2493
for
trailer -> . NAME
2493
<
trailer -> . NAME
2493
*
trailer -> . NAME
2493
@
trailer -> . NAME
2494
)
trailer -> ( )
2494
+
trailer -> ( )
2494
!=
trailer -> ( )
2494
<<
trailer -> ( )
2494
>=
trailer -> ( )
2494
**
trailer -> ( )
2494
not
trailer -> ( )
2494
if
trailer -> ( )
2494
|
trailer -> ( )
2494
[
trailer -> ( )
2494
==
trailer -> ( )
2494
%
trailer -> ( )
2494
*
trailer -> ( )
2494
>>
trailer -> ( )
2494
for
trailer -> ( )
2494
@
trailer -> ( )
2494
>
trailer -> ( )
2494
/
trailer -> ( )
2494
in
trailer -> ( )
2494
(
trailer -> ( )
2494
is
trailer -> ( )
2494
//
trailer -> ( )
2494
<
trailer -> ( )
2494
or
trailer -> ( )
2494
^
trailer -> ( )
2494
and
trailer -> ( )
2494
<=
trailer -> ( )
2494
.
trailer -> ( )
2494
-
trailer -> ( )
2494
&
trailer -> ( )
2495
)
2607
2496
<=
trailer_expr -> trailer trailer_expr
2496
+
trailer_expr -> trailer trailer_expr
2496
^
trailer_expr -> trailer trailer_expr
2496
for
trailer_expr -> trailer trailer_expr
2496
or
trailer_expr -> trailer trailer_expr
2496
==
trailer_expr -> trailer trailer_expr
2496
%
trailer_expr -> trailer trailer_expr
2496
@
trailer_expr -> trailer trailer_expr
2496
not
trailer_expr -> trailer trailer_expr
2496
<<
trailer_expr -> trailer trailer_expr
2496
-
trailer_expr -> trailer trailer_expr
2496
//
trailer_expr -> trailer trailer_expr
2496
and
trailer_expr -> trailer trailer_expr
2496
|
trailer_expr -> trailer trailer_expr
2496
if
trailer_expr -> trailer trailer_expr
2496
>
trailer_expr -> trailer trailer_expr
2496
!=
trailer_expr -> trailer trailer_expr
2496
<
trailer_expr -> trailer trailer_expr
2496
>>
trailer_expr -> trailer trailer_expr
2496
/
trailer_expr -> trailer trailer_expr
2496
is
trailer_expr -> trailer trailer_expr
2496
&
trailer_expr -> trailer trailer_expr
2496
in
trailer_expr -> trailer trailer_expr
2496
>=
trailer_expr -> trailer trailer_expr
2496
*
trailer_expr -> trailer trailer_expr
2496
)
trailer_expr -> trailer trailer_expr
2496
**
trailer_expr -> trailer trailer_expr
2497
]
2608
2498
:
2609
2498
vfpdef
234
2498
varargslist
2610
2498
NAME
233
2499
if
test_nocond -> or_test
2499
)
test_nocond -> or_test
2499
for
test_nocond -> or_test
2500
)
test_nocond -> lambdef_nocond
2500
if
test_nocond -> lambdef_nocond
2500
for
test_nocond -> lambdef_nocond
2501
if
2311
2501
comp_iter
2611
2501
for
517
2501
)
comp_iter -> 
2501
comp_for
2312
2501
comp_if
2314
2502
==
shift_expr -> arith_expr >> shift_expr
2502
^
shift_expr -> arith_expr >> shift_expr
2502
or
shift_expr -> arith_expr >> shift_expr
2502
if
shift_expr -> arith_expr >> shift_expr
2502
for
shift_expr -> arith_expr >> shift_expr
2502
not
shift_expr -> arith_expr >> shift_expr
2502
<
shift_expr -> arith_expr >> shift_expr
2502
|
shift_expr -> arith_expr >> shift_expr
2502
<=
shift_expr -> arith_expr >> shift_expr
2502
is
shift_expr -> arith_expr >> shift_expr
2502
in
shift_expr -> arith_expr >> shift_expr
2502
>=
shift_expr -> arith_expr >> shift_expr
2502
)
shift_expr -> arith_expr >> shift_expr
2502
&
shift_expr -> arith_expr >> shift_expr
2502
>
shift_expr -> arith_expr >> shift_expr
2502
and
shift_expr -> arith_expr >> shift_expr
2502
!=
shift_expr -> arith_expr >> shift_expr
2503
for
shift_expr -> arith_expr << shift_expr
2503
or
shift_expr -> arith_expr << shift_expr
2503
>
shift_expr -> arith_expr << shift_expr
2503
in
shift_expr -> arith_expr << shift_expr
2503
&
shift_expr -> arith_expr << shift_expr
2503
is
shift_expr -> arith_expr << shift_expr
2503
<
shift_expr -> arith_expr << shift_expr
2503
)
shift_expr -> arith_expr << shift_expr
2503
<=
shift_expr -> arith_expr << shift_expr
2503
not
shift_expr -> arith_expr << shift_expr
2503
if
shift_expr -> arith_expr << shift_expr
2503
^
shift_expr -> arith_expr << shift_expr
2503
and
shift_expr -> arith_expr << shift_expr
2503
|
shift_expr -> arith_expr << shift_expr
2503
!=
shift_expr -> arith_expr << shift_expr
2503
==
shift_expr -> arith_expr << shift_expr
2503
>=
shift_expr -> arith_expr << shift_expr
2504
>
atom -> ( test_list_comp )
2504
@
atom -> ( test_list_comp )
2504
&
atom -> ( test_list_comp )
2504
[
atom -> ( test_list_comp )
2504
)
atom -> ( test_list_comp )
2504
if
atom -> ( test_list_comp )
2504
==
atom -> ( test_list_comp )
2504
>=
atom -> ( test_list_comp )
2504
**
atom -> ( test_list_comp )
2504
not
atom -> ( test_list_comp )
2504
<<
atom -> ( test_list_comp )
2504
>>
atom -> ( test_list_comp )
2504
in
atom -> ( test_list_comp )
2504
or
atom -> ( test_list_comp )
2504
.
atom -> ( test_list_comp )
2504
/
atom -> ( test_list_comp )
2504
^
atom -> ( test_list_comp )
2504
is
atom -> ( test_list_comp )
2504
and
atom -> ( test_list_comp )
2504
//
atom -> ( test_list_comp )
2504
<
atom -> ( test_list_comp )
2504
*
atom -> ( test_list_comp )
2504
<=
atom -> ( test_list_comp )
2504
(
atom -> ( test_list_comp )
2504
for
atom -> ( test_list_comp )
2504
-
atom -> ( test_list_comp )
2504
!=
atom -> ( test_list_comp )
2504
|
atom -> ( test_list_comp )
2504
+
atom -> ( test_list_comp )
2504
%
atom -> ( test_list_comp )
2505
for
or_test -> and_test or or_test
2505
if
or_test -> and_test or or_test
2505
)
or_test -> and_test or or_test
2506
^
arith_expr -> term - arith_expr
2506
!=
arith_expr -> term - arith_expr
2506
<
arith_expr -> term - arith_expr
2506
in
arith_expr -> term - arith_expr
2506
==
arith_expr -> term - arith_expr
2506
|
arith_expr -> term - arith_expr
2506
is
arith_expr -> term - arith_expr
2506
&
arith_expr -> term - arith_expr
2506
>>
arith_expr -> term - arith_expr
2506
<<
arith_expr -> term - arith_expr
2506
and
arith_expr -> term - arith_expr
2506
>
arith_expr -> term - arith_expr
2506
if
arith_expr -> term - arith_expr
2506
for
arith_expr -> term - arith_expr
2506
not
arith_expr -> term - arith_expr
2506
)
arith_expr -> term - arith_expr
2506
>=
arith_expr -> term - arith_expr
2506
<=
arith_expr -> term - arith_expr
2506
or
arith_expr -> term - arith_expr
2507
>=
arith_expr -> term + arith_expr
2507
>
arith_expr -> term + arith_expr
2507
^
arith_expr -> term + arith_expr
2507
or
arith_expr -> term + arith_expr
2507
==
arith_expr -> term + arith_expr
2507
<=
arith_expr -> term + arith_expr
2507
if
arith_expr -> term + arith_expr
2507
>>
arith_expr -> term + arith_expr
2507
<
arith_expr -> term + arith_expr
2507
not
arith_expr -> term + arith_expr
2507
&
arith_expr -> term + arith_expr
2507
in
arith_expr -> term + arith_expr
2507
and
arith_expr -> term + arith_expr
2507
|
arith_expr -> term + arith_expr
2507
!=
arith_expr -> term + arith_expr
2507
)
arith_expr -> term + arith_expr
2507
<<
arith_expr -> term + arith_expr
2507
for
arith_expr -> term + arith_expr
2507
is
arith_expr -> term + arith_expr
2508
>=
expr -> xor_expr | expr
2508
for
expr -> xor_expr | expr
2508
or
expr -> xor_expr | expr
2508
in
expr -> xor_expr | expr
2508
and
expr -> xor_expr | expr
2508
==
expr -> xor_expr | expr
2508
>
expr -> xor_expr | expr
2508
<=
expr -> xor_expr | expr
2508
is
expr -> xor_expr | expr
2508
)
expr -> xor_expr | expr
2508
<
expr -> xor_expr | expr
2508
if
expr -> xor_expr | expr
2508
not
expr -> xor_expr | expr
2508
!=
expr -> xor_expr | expr
2509
<
and_expr -> shift_expr & and_expr
2509
if
and_expr -> shift_expr & and_expr
2509
>=
and_expr -> shift_expr & and_expr
2509
not
and_expr -> shift_expr & and_expr
2509
==
and_expr -> shift_expr & and_expr
2509
>
and_expr -> shift_expr & and_expr
2509
in
and_expr -> shift_expr & and_expr
2509
^
and_expr -> shift_expr & and_expr
2509
or
and_expr -> shift_expr & and_expr
2509
and
and_expr -> shift_expr & and_expr
2509
!=
and_expr -> shift_expr & and_expr
2509
for
and_expr -> shift_expr & and_expr
2509
<=
and_expr -> shift_expr & and_expr
2509
|
and_expr -> shift_expr & and_expr
2509
is
and_expr -> shift_expr & and_expr
2509
)
and_expr -> shift_expr & and_expr
2510
for
comparison -> expr comp_op comparison
2510
)
comparison -> expr comp_op comparison
2510
or
comparison -> expr comp_op comparison
2510
if
comparison -> expr comp_op comparison
2510
and
comparison -> expr comp_op comparison
2511
if
and_test -> not_test and and_test
2511
for
and_test -> not_test and and_test
2511
or
and_test -> not_test and and_test
2511
)
and_test -> not_test and and_test
2512
.
atom -> [ test_list_comp ]
2512
[
atom -> [ test_list_comp ]
2512
@
atom -> [ test_list_comp ]
2512
<=
atom -> [ test_list_comp ]
2512
<
atom -> [ test_list_comp ]
2512
not
atom -> [ test_list_comp ]
2512
]
atom -> [ test_list_comp ]
2512
for
atom -> [ test_list_comp ]
2512
in
atom -> [ test_list_comp ]
2512
and
atom -> [ test_list_comp ]
2512
-
atom -> [ test_list_comp ]
2512
if
atom -> [ test_list_comp ]
2512
!=
atom -> [ test_list_comp ]
2512
is
atom -> [ test_list_comp ]
2512
>>
atom -> [ test_list_comp ]
2512
or
atom -> [ test_list_comp ]
2512
//
atom -> [ test_list_comp ]
2512
/
atom -> [ test_list_comp ]
2512
|
atom -> [ test_list_comp ]
2512
>
atom -> [ test_list_comp ]
2512
&
atom -> [ test_list_comp ]
2512
(
atom -> [ test_list_comp ]
2512
%
atom -> [ test_list_comp ]
2512
>=
atom -> [ test_list_comp ]
2512
==
atom -> [ test_list_comp ]
2512
**
atom -> [ test_list_comp ]
2512
<<
atom -> [ test_list_comp ]
2512
^
atom -> [ test_list_comp ]
2512
+
atom -> [ test_list_comp ]
2512
*
atom -> [ test_list_comp ]
2513
for
term -> factor @ term
2513
]
term -> factor @ term
2513
<<
term -> factor @ term
2513
^
term -> factor @ term
2513
<=
term -> factor @ term
2513
==
term -> factor @ term
2513
if
term -> factor @ term
2513
|
term -> factor @ term
2513
!=
term -> factor @ term
2513
or
term -> factor @ term
2513
>
term -> factor @ term
2513
and
term -> factor @ term
2513
>>
term -> factor @ term
2513
is
term -> factor @ term
2513
-
term -> factor @ term
2513
not
term -> factor @ term
2513
+
term -> factor @ term
2513
in
term -> factor @ term
2513
>=
term -> factor @ term
2513
<
term -> factor @ term
2513
&
term -> factor @ term
2514
for
term -> factor // term
2514
!=
term -> factor // term
2514
or
term -> factor // term
2514
^
term -> factor // term
2514
>
term -> factor // term
2514
is
term -> factor // term
2514
&
term -> factor // term
2514
-
term -> factor // term
2514
in
term -> factor // term
2514
>>
term -> factor // term
2514
|
term -> factor // term
2514
<
term -> factor // term
2514
>=
term -> factor // term
2514
not
term -> factor // term
2514
if
term -> factor // term
2514
==
term -> factor // term
2514
]
term -> factor // term
2514
<=
term -> factor // term
2514
and
term -> factor // term
2514
<<
term -> factor // term
2514
+
term -> factor // term
2515
<=
term -> factor % term
2515
is
term -> factor % term
2515
>
term -> factor % term
2515
and
term -> factor % term
2515
in
term -> factor % term
2515
or
term -> factor % term
2515
<
term -> factor % term
2515
-
term -> factor % term
2515
]
term -> factor % term
2515
!=
term -> factor % term
2515
>>
term -> factor % term
2515
^
term -> factor % term
2515
+
term -> factor % term
2515
if
term -> factor % term
2515
<<
term -> factor % term
2515
>=
term -> factor % term
2515
==
term -> factor % term
2515
not
term -> factor % term
2515
|
term -> factor % term
2515
&
term -> factor % term
2515
for
term -> factor % term
2516
>>
term -> factor / term
2516
!=
term -> factor / term
2516
<
term -> factor / term
2516
<=
term -> factor / term
2516
|
term -> factor / term
2516
is
term -> factor / term
2516
>=
term -> factor / term
2516
^
term -> factor / term
2516
&
term -> factor / term
2516
]
term -> factor / term
2516
+
term -> factor / term
2516
for
term -> factor / term
2516
<<
term -> factor / term
2516
and
term -> factor / term
2516
-
term -> factor / term
2516
in
term -> factor / term
2516
>
term -> factor / term
2516
or
term -> factor / term
2516
not
term -> factor / term
2516
==
term -> factor / term
2516
if
term -> factor / term
2517
is
term -> factor * term
2517
+
term -> factor * term
2517
>=
term -> factor * term
2517
^
term -> factor * term
2517
<=
term -> factor * term
2517
or
term -> factor * term
2517
for
term -> factor * term
2517
]
term -> factor * term
2517
<
term -> factor * term
2517
|
term -> factor * term
2517
>>
term -> factor * term
2517
in
term -> factor * term
2517
not
term -> factor * term
2517
==
term -> factor * term
2517
-
term -> factor * term
2517
and
term -> factor * term
2517
!=
term -> factor * term
2517
<<
term -> factor * term
2517
>
term -> factor * term
2517
if
term -> factor * term
2517
&
term -> factor * term
2518
!=
power -> atom_expr ** factor
2518
@
power -> atom_expr ** factor
2518
for
power -> atom_expr ** factor
2518
|
power -> atom_expr ** factor
2518
in
power -> atom_expr ** factor
2518
==
power -> atom_expr ** factor
2518
if
power -> atom_expr ** factor
2518
and
power -> atom_expr ** factor
2518
>=
power -> atom_expr ** factor
2518
/
power -> atom_expr ** factor
2518
not
power -> atom_expr ** factor
2518
^
power -> atom_expr ** factor
2518
]
power -> atom_expr ** factor
2518
//
power -> atom_expr ** factor
2518
>
power -> atom_expr ** factor
2518
+
power -> atom_expr ** factor
2518
%
power -> atom_expr ** factor
2518
-
power -> atom_expr ** factor
2518
is
power -> atom_expr ** factor
2518
<=
power -> atom_expr ** factor
2518
<
power -> atom_expr ** factor
2518
*
power -> atom_expr ** factor
2518
<<
power -> atom_expr ** factor
2518
or
power -> atom_expr ** factor
2518
>>
power -> atom_expr ** factor
2518
&
power -> atom_expr ** factor
2519
not
xor_expr -> and_expr ^ xor_expr
2519
<
xor_expr -> and_expr ^ xor_expr
2519
>=
xor_expr -> and_expr ^ xor_expr
2519
>
xor_expr -> and_expr ^ xor_expr
2519
is
xor_expr -> and_expr ^ xor_expr
2519
]
xor_expr -> and_expr ^ xor_expr
2519
!=
xor_expr -> and_expr ^ xor_expr
2519
and
xor_expr -> and_expr ^ xor_expr
2519
if
xor_expr -> and_expr ^ xor_expr
2519
<=
xor_expr -> and_expr ^ xor_expr
2519
in
xor_expr -> and_expr ^ xor_expr
2519
==
xor_expr -> and_expr ^ xor_expr
2519
for
xor_expr -> and_expr ^ xor_expr
2519
|
xor_expr -> and_expr ^ xor_expr
2519
or
xor_expr -> and_expr ^ xor_expr
2520
+
trailer -> ( )
2520
!=
trailer -> ( )
2520
<<
trailer -> ( )
2520
>=
trailer -> ( )
2520
**
trailer -> ( )
2520
not
trailer -> ( )
2520
if
trailer -> ( )
2520
|
trailer -> ( )
2520
[
trailer -> ( )
2520
==
trailer -> ( )
2520
%
trailer -> ( )
2520
*
trailer -> ( )
2520
>>
trailer -> ( )
2520
for
trailer -> ( )
2520
@
trailer -> ( )
2520
>
trailer -> ( )
2520
/
trailer -> ( )
2520
in
trailer -> ( )
2520
(
trailer -> ( )
2520
]
trailer -> ( )
2520
is
trailer -> ( )
2520
//
trailer -> ( )
2520
<
trailer -> ( )
2520
or
trailer -> ( )
2520
^
trailer -> ( )
2520
and
trailer -> ( )
2520
<=
trailer -> ( )
2520
.
trailer -> ( )
2520
-
trailer -> ( )
2520
&
trailer -> ( )
2521
)
2612
2522
<=
trailer_expr -> trailer trailer_expr
2522
+
trailer_expr -> trailer trailer_expr
2522
^
trailer_expr -> trailer trailer_expr
2522
for
trailer_expr -> trailer trailer_expr
2522
or
trailer_expr -> trailer trailer_expr
2522
==
trailer_expr -> trailer trailer_expr
2522
%
trailer_expr -> trailer trailer_expr
2522
@
trailer_expr -> trailer trailer_expr
2522
]
trailer_expr -> trailer trailer_expr
2522
not
trailer_expr -> trailer trailer_expr
2522
<<
trailer_expr -> trailer trailer_expr
2522
-
trailer_expr -> trailer trailer_expr
2522
//
trailer_expr -> trailer trailer_expr
2522
and
trailer_expr -> trailer trailer_expr
2522
|
trailer_expr -> trailer trailer_expr
2522
if
trailer_expr -> trailer trailer_expr
2522
>
trailer_expr -> trailer trailer_expr
2522
!=
trailer_expr -> trailer trailer_expr
2522
<
trailer_expr -> trailer trailer_expr
2522
>>
trailer_expr -> trailer trailer_expr
2522
/
trailer_expr -> trailer trailer_expr
2522
is
trailer_expr -> trailer trailer_expr
2522
&
trailer_expr -> trailer trailer_expr
2522
in
trailer_expr -> trailer trailer_expr
2522
>=
trailer_expr -> trailer trailer_expr
2522
*
trailer_expr -> trailer trailer_expr
2522
**
trailer_expr -> trailer trailer_expr
2523
.
trailer -> . NAME
2523
not
trailer -> . NAME
2523
if
trailer -> . NAME
2523
**
trailer -> . NAME
2523
|
trailer -> . NAME
2523
-
trailer -> . NAME
2523
(
trailer -> . NAME
2523
%
trailer -> . NAME
2523
//
trailer -> . NAME
2523
==
trailer -> . NAME
2523
>>
trailer -> . NAME
2523
is
trailer -> . NAME
2523
!=
trailer -> . NAME
2523
and
trailer -> . NAME
2523
>=
trailer -> . NAME
2523
>
trailer -> . NAME
2523
in
trailer -> . NAME
2523
<<
trailer -> . NAME
2523
&
trailer -> . NAME
2523
/
trailer -> . NAME
2523
^
trailer -> . NAME
2523
[
trailer -> . NAME
2523
<=
trailer -> . NAME
2523
]
trailer -> . NAME
2523
or
trailer -> . NAME
2523
+
trailer -> . NAME
2523
for
trailer -> . NAME
2523
<
trailer -> . NAME
2523
*
trailer -> . NAME
2523
@
trailer -> . NAME
2524
]
2613
2525
>
atom -> ( test_list_comp )
2525
@
atom -> ( test_list_comp )
2525
&
atom -> ( test_list_comp )
2525
[
atom -> ( test_list_comp )
2525
if
atom -> ( test_list_comp )
2525
==
atom -> ( test_list_comp )
2525
>=
atom -> ( test_list_comp )
2525
**
atom -> ( test_list_comp )
2525
not
atom -> ( test_list_comp )
2525
<<
atom -> ( test_list_comp )
2525
>>
atom -> ( test_list_comp )
2525
in
atom -> ( test_list_comp )
2525
or
atom -> ( test_list_comp )
2525
]
atom -> ( test_list_comp )
2525
/
atom -> ( test_list_comp )
2525
.
atom -> ( test_list_comp )
2525
^
atom -> ( test_list_comp )
2525
is
atom -> ( test_list_comp )
2525
and
atom -> ( test_list_comp )
2525
//
atom -> ( test_list_comp )
2525
<
atom -> ( test_list_comp )
2525
*
atom -> ( test_list_comp )
2525
<=
atom -> ( test_list_comp )
2525
(
atom -> ( test_list_comp )
2525
for
atom -> ( test_list_comp )
2525
-
atom -> ( test_list_comp )
2525
!=
atom -> ( test_list_comp )
2525
|
atom -> ( test_list_comp )
2525
+
atom -> ( test_list_comp )
2525
%
atom -> ( test_list_comp )
2526
==
shift_expr -> arith_expr >> shift_expr
2526
^
shift_expr -> arith_expr >> shift_expr
2526
or
shift_expr -> arith_expr >> shift_expr
2526
if
shift_expr -> arith_expr >> shift_expr
2526
for
shift_expr -> arith_expr >> shift_expr
2526
not
shift_expr -> arith_expr >> shift_expr
2526
|
shift_expr -> arith_expr >> shift_expr
2526
<=
shift_expr -> arith_expr >> shift_expr
2526
]
shift_expr -> arith_expr >> shift_expr
2526
in
shift_expr -> arith_expr >> shift_expr
2526
is
shift_expr -> arith_expr >> shift_expr
2526
>=
shift_expr -> arith_expr >> shift_expr
2526
>
shift_expr -> arith_expr >> shift_expr
2526
&
shift_expr -> arith_expr >> shift_expr
2526
<
shift_expr -> arith_expr >> shift_expr
2526
and
shift_expr -> arith_expr >> shift_expr
2526
!=
shift_expr -> arith_expr >> shift_expr
2527
for
shift_expr -> arith_expr << shift_expr
2527
or
shift_expr -> arith_expr << shift_expr
2527
]
shift_expr -> arith_expr << shift_expr
2527
in
shift_expr -> arith_expr << shift_expr
2527
>
shift_expr -> arith_expr << shift_expr
2527
&
shift_expr -> arith_expr << shift_expr
2527
is
shift_expr -> arith_expr << shift_expr
2527
<
shift_expr -> arith_expr << shift_expr
2527
<=
shift_expr -> arith_expr << shift_expr
2527
not
shift_expr -> arith_expr << shift_expr
2527
^
shift_expr -> arith_expr << shift_expr
2527
if
shift_expr -> arith_expr << shift_expr
2527
and
shift_expr -> arith_expr << shift_expr
2527
|
shift_expr -> arith_expr << shift_expr
2527
!=
shift_expr -> arith_expr << shift_expr
2527
==
shift_expr -> arith_expr << shift_expr
2527
>=
shift_expr -> arith_expr << shift_expr
2528
for
or_test -> and_test or or_test
2528
if
or_test -> and_test or or_test
2528
]
or_test -> and_test or or_test
2529
^
arith_expr -> term - arith_expr
2529
!=
arith_expr -> term - arith_expr
2529
<
arith_expr -> term - arith_expr
2529
in
arith_expr -> term - arith_expr
2529
==
arith_expr -> term - arith_expr
2529
|
arith_expr -> term - arith_expr
2529
is
arith_expr -> term - arith_expr
2529
&
arith_expr -> term - arith_expr
2529
>>
arith_expr -> term - arith_expr
2529
]
arith_expr -> term - arith_expr
2529
<<
arith_expr -> term - arith_expr
2529
and
arith_expr -> term - arith_expr
2529
>
arith_expr -> term - arith_expr
2529
if
arith_expr -> term - arith_expr
2529
for
arith_expr -> term - arith_expr
2529
not
arith_expr -> term - arith_expr
2529
>=
arith_expr -> term - arith_expr
2529
<=
arith_expr -> term - arith_expr
2529
or
arith_expr -> term - arith_expr
2530
>=
arith_expr -> term + arith_expr
2530
>
arith_expr -> term + arith_expr
2530
^
arith_expr -> term + arith_expr
2530
or
arith_expr -> term + arith_expr
2530
==
arith_expr -> term + arith_expr
2530
<=
arith_expr -> term + arith_expr
2530
if
arith_expr -> term + arith_expr
2530
]
arith_expr -> term + arith_expr
2530
>>
arith_expr -> term + arith_expr
2530
<
arith_expr -> term + arith_expr
2530
not
arith_expr -> term + arith_expr
2530
&
arith_expr -> term + arith_expr
2530
in
arith_expr -> term + arith_expr
2530
and
arith_expr -> term + arith_expr
2530
|
arith_expr -> term + arith_expr
2530
!=
arith_expr -> term + arith_expr
2530
<<
arith_expr -> term + arith_expr
2530
for
arith_expr -> term + arith_expr
2530
is
arith_expr -> term + arith_expr
2531
>=
expr -> xor_expr | expr
2531
for
expr -> xor_expr | expr
2531
or
expr -> xor_expr | expr
2531
in
expr -> xor_expr | expr
2531
]
expr -> xor_expr | expr
2531
and
expr -> xor_expr | expr
2531
==
expr -> xor_expr | expr
2531
>
expr -> xor_expr | expr
2531
<=
expr -> xor_expr | expr
2531
is
expr -> xor_expr | expr
2531
<
expr -> xor_expr | expr
2531
if
expr -> xor_expr | expr
2531
not
expr -> xor_expr | expr
2531
!=
expr -> xor_expr | expr
2532
<
and_expr -> shift_expr & and_expr
2532
if
and_expr -> shift_expr & and_expr
2532
>=
and_expr -> shift_expr & and_expr
2532
not
and_expr -> shift_expr & and_expr
2532
==
and_expr -> shift_expr & and_expr
2532
>
and_expr -> shift_expr & and_expr
2532
]
and_expr -> shift_expr & and_expr
2532
in
and_expr -> shift_expr & and_expr
2532
^
and_expr -> shift_expr & and_expr
2532
or
and_expr -> shift_expr & and_expr
2532
and
and_expr -> shift_expr & and_expr
2532
!=
and_expr -> shift_expr & and_expr
2532
for
and_expr -> shift_expr & and_expr
2532
|
and_expr -> shift_expr & and_expr
2532
is
and_expr -> shift_expr & and_expr
2532
<=
and_expr -> shift_expr & and_expr
2533
for
comparison -> expr comp_op comparison
2533
or
comparison -> expr comp_op comparison
2533
if
comparison -> expr comp_op comparison
2533
and
comparison -> expr comp_op comparison
2533
]
comparison -> expr comp_op comparison
2534
if
and_test -> not_test and and_test
2534
for
and_test -> not_test and and_test
2534
or
and_test -> not_test and and_test
2534
]
and_test -> not_test and and_test
2535
comp_if
2358
2535
for
547
2535
comp_for
2360
2535
comp_iter
2614
2535
]
comp_iter -> 
2535
if
2361
2536
:
2615
2536
vfpdef
234
2536
varargslist
2616
2536
NAME
233
2537
if
test_nocond -> or_test
2537
for
test_nocond -> or_test
2537
]
test_nocond -> or_test
2538
]
test_nocond -> lambdef_nocond
2538
if
test_nocond -> lambdef_nocond
2538
for
test_nocond -> lambdef_nocond
2539
,
test -> or_test if or_test else test
2539
]
test -> or_test if or_test else test
2540
.
atom -> [ test_list_comp ]
2540
[
atom -> [ test_list_comp ]
2540
@
atom -> [ test_list_comp ]
2540
<=
atom -> [ test_list_comp ]
2540
<
atom -> [ test_list_comp ]
2540
not
atom -> [ test_list_comp ]
2540
in
atom -> [ test_list_comp ]
2540
and
atom -> [ test_list_comp ]
2540
-
atom -> [ test_list_comp ]
2540
if
atom -> [ test_list_comp ]
2540
!=
atom -> [ test_list_comp ]
2540
is
atom -> [ test_list_comp ]
2540
>>
atom -> [ test_list_comp ]
2540
=
atom -> [ test_list_comp ]
2540
or
atom -> [ test_list_comp ]
2540
//
atom -> [ test_list_comp ]
2540
/
atom -> [ test_list_comp ]
2540
,
atom -> [ test_list_comp ]
2540
|
atom -> [ test_list_comp ]
2540
>
atom -> [ test_list_comp ]
2540
&
atom -> [ test_list_comp ]
2540
(
atom -> [ test_list_comp ]
2540
%
atom -> [ test_list_comp ]
2540
>=
atom -> [ test_list_comp ]
2540
)
atom -> [ test_list_comp ]
2540
==
atom -> [ test_list_comp ]
2540
**
atom -> [ test_list_comp ]
2540
<<
atom -> [ test_list_comp ]
2540
^
atom -> [ test_list_comp ]
2540
+
atom -> [ test_list_comp ]
2540
*
atom -> [ test_list_comp ]
2541
<<
term -> factor @ term
2541
^
term -> factor @ term
2541
<=
term -> factor @ term
2541
==
term -> factor @ term
2541
if
term -> factor @ term
2541
|
term -> factor @ term
2541
!=
term -> factor @ term
2541
or
term -> factor @ term
2541
>
term -> factor @ term
2541
and
term -> factor @ term
2541
>>
term -> factor @ term
2541
is
term -> factor @ term
2541
-
term -> factor @ term
2541
not
term -> factor @ term
2541
=
term -> factor @ term
2541
+
term -> factor @ term
2541
in
term -> factor @ term
2541
>=
term -> factor @ term
2541
<
term -> factor @ term
2541
,
term -> factor @ term
2541
&
term -> factor @ term
2541
)
term -> factor @ term
2542
<=
term -> factor % term
2542
is
term -> factor % term
2542
>
term -> factor % term
2542
and
term -> factor % term
2542
in
term -> factor % term
2542
,
term -> factor % term
2542
or
term -> factor % term
2542
<
term -> factor % term
2542
-
term -> factor % term
2542
!=
term -> factor % term
2542
>>
term -> factor % term
2542
^
term -> factor % term
2542
+
term -> factor % term
2542
if
term -> factor % term
2542
<<
term -> factor % term
2542
>=
term -> factor % term
2542
==
term -> factor % term
2542
not
term -> factor % term
2542
|
term -> factor % term
2542
=
term -> factor % term
2542
)
term -> factor % term
2542
&
term -> factor % term
2543
>>
term -> factor / term
2543
!=
term -> factor / term
2543
<
term -> factor / term
2543
<=
term -> factor / term
2543
|
term -> factor / term
2543
is
term -> factor / term
2543
=
term -> factor / term
2543
>=
term -> factor / term
2543
^
term -> factor / term
2543
&
term -> factor / term
2543
+
term -> factor / term
2543
<<
term -> factor / term
2543
and
term -> factor / term
2543
-
term -> factor / term
2543
in
term -> factor / term
2543
>
term -> factor / term
2543
or
term -> factor / term
2543
not
term -> factor / term
2543
==
term -> factor / term
2543
,
term -> factor / term
2543
if
term -> factor / term
2543
)
term -> factor / term
2544
is
term -> factor * term
2544
+
term -> factor * term
2544
>=
term -> factor * term
2544
^
term -> factor * term
2544
=
term -> factor * term
2544
,
term -> factor * term
2544
<=
term -> factor * term
2544
or
term -> factor * term
2544
)
term -> factor * term
2544
<
term -> factor * term
2544
|
term -> factor * term
2544
>>
term -> factor * term
2544
in
term -> factor * term
2544
not
term -> factor * term
2544
==
term -> factor * term
2544
-
term -> factor * term
2544
and
term -> factor * term
2544
!=
term -> factor * term
2544
<<
term -> factor * term
2544
>
term -> factor * term
2544
if
term -> factor * term
2544
&
term -> factor * term
2545
!=
term -> factor // term
2545
or
term -> factor // term
2545
^
term -> factor // term
2545
>
term -> factor // term
2545
is
term -> factor // term
2545
&
term -> factor // term
2545
-
term -> factor // term
2545
in
term -> factor // term
2545
>>
term -> factor // term
2545
|
term -> factor // term
2545
<
term -> factor // term
2545
>=
term -> factor // term
2545
not
term -> factor // term
2545
if
term -> factor // term
2545
=
term -> factor // term
2545
==
term -> factor // term
2545
)
term -> factor // term
2545
<=
term -> factor // term
2545
,
term -> factor // term
2545
and
term -> factor // term
2545
<<
term -> factor // term
2545
+
term -> factor // term
2546
!=
power -> atom_expr ** factor
2546
@
power -> atom_expr ** factor
2546
|
power -> atom_expr ** factor
2546
in
power -> atom_expr ** factor
2546
==
power -> atom_expr ** factor
2546
if
power -> atom_expr ** factor
2546
and
power -> atom_expr ** factor
2546
=
power -> atom_expr ** factor
2546
>=
power -> atom_expr ** factor
2546
/
power -> atom_expr ** factor
2546
not
power -> atom_expr ** factor
2546
^
power -> atom_expr ** factor
2546
//
power -> atom_expr ** factor
2546
>
power -> atom_expr ** factor
2546
+
power -> atom_expr ** factor
2546
%
power -> atom_expr ** factor
2546
)
power -> atom_expr ** factor
2546
-
power -> atom_expr ** factor
2546
is
power -> atom_expr ** factor
2546
<=
power -> atom_expr ** factor
2546
<
power -> atom_expr ** factor
2546
,
power -> atom_expr ** factor
2546
*
power -> atom_expr ** factor
2546
<<
power -> atom_expr ** factor
2546
or
power -> atom_expr ** factor
2546
>>
power -> atom_expr ** factor
2546
&
power -> atom_expr ** factor
2547
not
xor_expr -> and_expr ^ xor_expr
2547
<
xor_expr -> and_expr ^ xor_expr
2547
,
xor_expr -> and_expr ^ xor_expr
2547
=
xor_expr -> and_expr ^ xor_expr
2547
>=
xor_expr -> and_expr ^ xor_expr
2547
>
xor_expr -> and_expr ^ xor_expr
2547
)
xor_expr -> and_expr ^ xor_expr
2547
!=
xor_expr -> and_expr ^ xor_expr
2547
is
xor_expr -> and_expr ^ xor_expr
2547
and
xor_expr -> and_expr ^ xor_expr
2547
if
xor_expr -> and_expr ^ xor_expr
2547
<=
xor_expr -> and_expr ^ xor_expr
2547
in
xor_expr -> and_expr ^ xor_expr
2547
==
xor_expr -> and_expr ^ xor_expr
2547
|
xor_expr -> and_expr ^ xor_expr
2547
or
xor_expr -> and_expr ^ xor_expr
2548
<
and_expr -> shift_expr & and_expr
2548
if
and_expr -> shift_expr & and_expr
2548
>=
and_expr -> shift_expr & and_expr
2548
=
and_expr -> shift_expr & and_expr
2548
not
and_expr -> shift_expr & and_expr
2548
==
and_expr -> shift_expr & and_expr
2548
>
and_expr -> shift_expr & and_expr
2548
in
and_expr -> shift_expr & and_expr
2548
^
and_expr -> shift_expr & and_expr
2548
or
and_expr -> shift_expr & and_expr
2548
and
and_expr -> shift_expr & and_expr
2548
!=
and_expr -> shift_expr & and_expr
2548
,
and_expr -> shift_expr & and_expr
2548
<=
and_expr -> shift_expr & and_expr
2548
|
and_expr -> shift_expr & and_expr
2548
is
and_expr -> shift_expr & and_expr
2548
)
and_expr -> shift_expr & and_expr
2549
=
trailer -> . NAME
2549
.
trailer -> . NAME
2549
not
trailer -> . NAME
2549
if
trailer -> . NAME
2549
**
trailer -> . NAME
2549
|
trailer -> . NAME
2549
-
trailer -> . NAME
2549
(
trailer -> . NAME
2549
%
trailer -> . NAME
2549
//
trailer -> . NAME
2549
==
trailer -> . NAME
2549
>>
trailer -> . NAME
2549
is
trailer -> . NAME
2549
!=
trailer -> . NAME
2549
)
trailer -> . NAME
2549
and
trailer -> . NAME
2549
>=
trailer -> . NAME
2549
,
trailer -> . NAME
2549
>
trailer -> . NAME
2549
in
trailer -> . NAME
2549
<<
trailer -> . NAME
2549
&
trailer -> . NAME
2549
/
trailer -> . NAME
2549
^
trailer -> . NAME
2549
[
trailer -> . NAME
2549
<=
trailer -> . NAME
2549
or
trailer -> . NAME
2549
+
trailer -> . NAME
2549
<
trailer -> . NAME
2549
*
trailer -> . NAME
2549
@
trailer -> . NAME
2550
)
trailer -> ( )
2550
+
trailer -> ( )
2550
!=
trailer -> ( )
2550
<<
trailer -> ( )
2550
>=
trailer -> ( )
2550
**
trailer -> ( )
2550
not
trailer -> ( )
2550
=
trailer -> ( )
2550
if
trailer -> ( )
2550
,
trailer -> ( )
2550
|
trailer -> ( )
2550
[
trailer -> ( )
2550
==
trailer -> ( )
2550
%
trailer -> ( )
2550
*
trailer -> ( )
2550
>>
trailer -> ( )
2550
@
trailer -> ( )
2550
>
trailer -> ( )
2550
/
trailer -> ( )
2550
in
trailer -> ( )
2550
(
trailer -> ( )
2550
is
trailer -> ( )
2550
//
trailer -> ( )
2550
<
trailer -> ( )
2550
or
trailer -> ( )
2550
^
trailer -> ( )
2550
and
trailer -> ( )
2550
<=
trailer -> ( )
2550
.
trailer -> ( )
2550
-
trailer -> ( )
2550
&
trailer -> ( )
2551
)
2617
2552
<=
trailer_expr -> trailer trailer_expr
2552
+
trailer_expr -> trailer trailer_expr
2552
^
trailer_expr -> trailer trailer_expr
2552
or
trailer_expr -> trailer trailer_expr
2552
==
trailer_expr -> trailer trailer_expr
2552
%
trailer_expr -> trailer trailer_expr
2552
@
trailer_expr -> trailer trailer_expr
2552
=
trailer_expr -> trailer trailer_expr
2552
not
trailer_expr -> trailer trailer_expr
2552
<<
trailer_expr -> trailer trailer_expr
2552
-
trailer_expr -> trailer trailer_expr
2552
//
trailer_expr -> trailer trailer_expr
2552
and
trailer_expr -> trailer trailer_expr
2552
|
trailer_expr -> trailer trailer_expr
2552
if
trailer_expr -> trailer trailer_expr
2552
>
trailer_expr -> trailer trailer_expr
2552
!=
trailer_expr -> trailer trailer_expr
2552
,
trailer_expr -> trailer trailer_expr
2552
<
trailer_expr -> trailer trailer_expr
2552
>>
trailer_expr -> trailer trailer_expr
2552
/
trailer_expr -> trailer trailer_expr
2552
is
trailer_expr -> trailer trailer_expr
2552
&
trailer_expr -> trailer trailer_expr
2552
in
trailer_expr -> trailer trailer_expr
2552
>=
trailer_expr -> trailer trailer_expr
2552
*
trailer_expr -> trailer trailer_expr
2552
)
trailer_expr -> trailer trailer_expr
2552
**
trailer_expr -> trailer trailer_expr
2553
]
2618
2554
if
or_test -> and_test or or_test
2554
)
or_test -> and_test or or_test
2554
,
or_test -> and_test or or_test
2554
=
or_test -> and_test or or_test
2555
==
shift_expr -> arith_expr >> shift_expr
2555
^
shift_expr -> arith_expr >> shift_expr
2555
or
shift_expr -> arith_expr >> shift_expr
2555
if
shift_expr -> arith_expr >> shift_expr
2555
,
shift_expr -> arith_expr >> shift_expr
2555
not
shift_expr -> arith_expr >> shift_expr
2555
<
shift_expr -> arith_expr >> shift_expr
2555
|
shift_expr -> arith_expr >> shift_expr
2555
<=
shift_expr -> arith_expr >> shift_expr
2555
=
shift_expr -> arith_expr >> shift_expr
2555
in
shift_expr -> arith_expr >> shift_expr
2555
is
shift_expr -> arith_expr >> shift_expr
2555
>=
shift_expr -> arith_expr >> shift_expr
2555
)
shift_expr -> arith_expr >> shift_expr
2555
&
shift_expr -> arith_expr >> shift_expr
2555
>
shift_expr -> arith_expr >> shift_expr
2555
and
shift_expr -> arith_expr >> shift_expr
2555
!=
shift_expr -> arith_expr >> shift_expr
2556
or
shift_expr -> arith_expr << shift_expr
2556
>
shift_expr -> arith_expr << shift_expr
2556
in
shift_expr -> arith_expr << shift_expr
2556
&
shift_expr -> arith_expr << shift_expr
2556
is
shift_expr -> arith_expr << shift_expr
2556
=
shift_expr -> arith_expr << shift_expr
2556
<
shift_expr -> arith_expr << shift_expr
2556
)
shift_expr -> arith_expr << shift_expr
2556
<=
shift_expr -> arith_expr << shift_expr
2556
not
shift_expr -> arith_expr << shift_expr
2556
if
shift_expr -> arith_expr << shift_expr
2556
,
shift_expr -> arith_expr << shift_expr
2556
and
shift_expr -> arith_expr << shift_expr
2556
^
shift_expr -> arith_expr << shift_expr
2556
|
shift_expr -> arith_expr << shift_expr
2556
!=
shift_expr -> arith_expr << shift_expr
2556
==
shift_expr -> arith_expr << shift_expr
2556
>=
shift_expr -> arith_expr << shift_expr
2557
>
atom -> ( test_list_comp )
2557
@
atom -> ( test_list_comp )
2557
&
atom -> ( test_list_comp )
2557
=
atom -> ( test_list_comp )
2557
[
atom -> ( test_list_comp )
2557
)
atom -> ( test_list_comp )
2557
if
atom -> ( test_list_comp )
2557
==
atom -> ( test_list_comp )
2557
>=
atom -> ( test_list_comp )
2557
**
atom -> ( test_list_comp )
2557
not
atom -> ( test_list_comp )
2557
<<
atom -> ( test_list_comp )
2557
>>
atom -> ( test_list_comp )
2557
in
atom -> ( test_list_comp )
2557
or
atom -> ( test_list_comp )
2557
.
atom -> ( test_list_comp )
2557
/
atom -> ( test_list_comp )
2557
^
atom -> ( test_list_comp )
2557
is
atom -> ( test_list_comp )
2557
,
atom -> ( test_list_comp )
2557
and
atom -> ( test_list_comp )
2557
//
atom -> ( test_list_comp )
2557
<
atom -> ( test_list_comp )
2557
*
atom -> ( test_list_comp )
2557
<=
atom -> ( test_list_comp )
2557
(
atom -> ( test_list_comp )
2557
-
atom -> ( test_list_comp )
2557
|
atom -> ( test_list_comp )
2557
!=
atom -> ( test_list_comp )
2557
+
atom -> ( test_list_comp )
2557
%
atom -> ( test_list_comp )
2558
^
arith_expr -> term - arith_expr
2558
!=
arith_expr -> term - arith_expr
2558
<
arith_expr -> term - arith_expr
2558
in
arith_expr -> term - arith_expr
2558
==
arith_expr -> term - arith_expr
2558
|
arith_expr -> term - arith_expr
2558
is
arith_expr -> term - arith_expr
2558
&
arith_expr -> term - arith_expr
2558
>>
arith_expr -> term - arith_expr
2558
<<
arith_expr -> term - arith_expr
2558
=
arith_expr -> term - arith_expr
2558
and
arith_expr -> term - arith_expr
2558
,
arith_expr -> term - arith_expr
2558
>
arith_expr -> term - arith_expr
2558
if
arith_expr -> term - arith_expr
2558
not
arith_expr -> term - arith_expr
2558
)
arith_expr -> term - arith_expr
2558
>=
arith_expr -> term - arith_expr
2558
<=
arith_expr -> term - arith_expr
2558
or
arith_expr -> term - arith_expr
2559
>=
arith_expr -> term + arith_expr
2559
>
arith_expr -> term + arith_expr
2559
^
arith_expr -> term + arith_expr
2559
or
arith_expr -> term + arith_expr
2559
==
arith_expr -> term + arith_expr
2559
<=
arith_expr -> term + arith_expr
2559
if
arith_expr -> term + arith_expr
2559
>>
arith_expr -> term + arith_expr
2559
<
arith_expr -> term + arith_expr
2559
not
arith_expr -> term + arith_expr
2559
&
arith_expr -> term + arith_expr
2559
in
arith_expr -> term + arith_expr
2559
and
arith_expr -> term + arith_expr
2559
,
arith_expr -> term + arith_expr
2559
|
arith_expr -> term + arith_expr
2559
!=
arith_expr -> term + arith_expr
2559
)
arith_expr -> term + arith_expr
2559
=
arith_expr -> term + arith_expr
2559
<<
arith_expr -> term + arith_expr
2559
is
arith_expr -> term + arith_expr
2560
>=
expr -> xor_expr | expr
2560
=
expr -> xor_expr | expr
2560
,
expr -> xor_expr | expr
2560
or
expr -> xor_expr | expr
2560
in
expr -> xor_expr | expr
2560
and
expr -> xor_expr | expr
2560
==
expr -> xor_expr | expr
2560
>
expr -> xor_expr | expr
2560
<=
expr -> xor_expr | expr
2560
is
expr -> xor_expr | expr
2560
)
expr -> xor_expr | expr
2560
<
expr -> xor_expr | expr
2560
if
expr -> xor_expr | expr
2560
not
expr -> xor_expr | expr
2560
!=
expr -> xor_expr | expr
2561
else
2619
2562
or
and_test -> not_test and and_test
2562
)
and_test -> not_test and and_test
2562
if
and_test -> not_test and and_test
2562
=
and_test -> not_test and and_test
2562
,
and_test -> not_test and and_test
2563
)
comparison -> expr comp_op comparison
2563
or
comparison -> expr comp_op comparison
2563
if
comparison -> expr comp_op comparison
2563
and
comparison -> expr comp_op comparison
2563
=
comparison -> expr comp_op comparison
2563
,
comparison -> expr comp_op comparison
2564
[
2090
2564
factor
2091
2564
True
2092
2564
atom_expr
2093
2564
~
2094
2564
and_expr
2095
2564
-
2096
2564
shift_expr
2097
2564
atom
2098
2564
{
2099
2564
comparison
2100
2564
and_test
2101
2564
arith_expr
2102
2564
power
2103
2564
STRING
2104
2564
NAME
2105
2564
(
2106
2564
term
2107
2564
+
2108
2564
xor_expr
2109
2564
or_test
2110
2564
NUMBER
2111
2564
not
2112
2564
False
2113
2564
not_test
2114
2564
None
2115
2564
test
2620
2564
expr
2116
2564
lambda
2117
2564
lambdef
2118
2565
,
lambdef -> lambda : test
2565
=
lambdef -> lambda : test
2565
)
lambdef -> lambda : test
2566
,
test -> or_test if or_test else test
2566
:
test -> or_test if or_test else test
2567
arith_expr
1
2567
small_stmt
20
2567
factor
17
2567
True
38
2567
atom_expr
31
2567
term
22
2567
-
26
2567
None
55
2567
atom
57
2567
test
5
2567
comparison
49
2567
and_expr
8
2567
power
9
2567
STRING
10
2567
NAME
52
2567
shift_expr
48
2567
lambdef
15
2567
NUMBER
58
2567
simple_stmt
1094
2567
(
16
2567
expr
47
2567
[
18
2567
NEWLINE
1095
2567
not_test
32
2567
{
21
2567
and_test
46
2567
+
27
2567
lambda
29
2567
xor_expr
41
2567
yield
34
2567
not
62
2567
test_list
36
2567
~
37
2567
or_test
53
2567
False
39
2567
suite
2621
2567
sim_stmt
45
2567
nonlocal
72
2567
nonlocal_stmt
73
2567
return
59
2567
break_stmt
60
2567
return_stmt
61
2567
raise_stmt
74
2567
break
63
2567
yield_stmt
75
2567
raise
64
2567
continue
77
2567
expr_stmt
65
2567
endsim
78
2567
del
80
2567
pass_stmt
81
2567
flow_stmt
82
2567
stat_stmt
66
2567
assert_stmt
68
2567
resetstats
84
2567
del_stmt
85
2567
continue_stmt
86
2567
begsim
69
2567
global_stmt
87
2567
pass
88
2567
global
70
2567
assert
71
2568
confbody
2622
2568
NAME
1971
2569
.
trailer -> ( arglist )
2569
|
trailer -> ( arglist )
2569
^
trailer -> ( arglist )
2569
==
trailer -> ( arglist )
2569
**
trailer -> ( arglist )
2569
>>
trailer -> ( arglist )
2569
not
trailer -> ( arglist )
2569
<<
trailer -> ( arglist )
2569
>=
trailer -> ( arglist )
2569
!=
trailer -> ( arglist )
2569
in
trailer -> ( arglist )
2569
[
trailer -> ( arglist )
2569
(
trailer -> ( arglist )
2569
NEWLINE
trailer -> ( arglist )
2569
>
trailer -> ( arglist )
2569
and
trailer -> ( arglist )
2569
+
trailer -> ( arglist )
2569
%
trailer -> ( arglist )
2569
or
trailer -> ( arglist )
2569
*
trailer -> ( arglist )
2569
is
trailer -> ( arglist )
2569
&
trailer -> ( arglist )
2569
//
trailer -> ( arglist )
2569
=
trailer -> ( arglist )
2569
<
trailer -> ( arglist )
2569
if
trailer -> ( arglist )
2569
<=
trailer -> ( arglist )
2569
-
trailer -> ( arglist )
2569
/
trailer -> ( arglist )
2569
@
trailer -> ( arglist )
2570
<=
trailer -> [ subscriptlist ]
2570
NEWLINE
trailer -> [ subscriptlist ]
2570
<<
trailer -> [ subscriptlist ]
2570
*
trailer -> [ subscriptlist ]
2570
+
trailer -> [ subscriptlist ]
2570
in
trailer -> [ subscriptlist ]
2570
>>
trailer -> [ subscriptlist ]
2570
//
trailer -> [ subscriptlist ]
2570
.
trailer -> [ subscriptlist ]
2570
and
trailer -> [ subscriptlist ]
2570
**
trailer -> [ subscriptlist ]
2570
=
trailer -> [ subscriptlist ]
2570
@
trailer -> [ subscriptlist ]
2570
<
trailer -> [ subscriptlist ]
2570
not
trailer -> [ subscriptlist ]
2570
-
trailer -> [ subscriptlist ]
2570
!=
trailer -> [ subscriptlist ]
2570
%
trailer -> [ subscriptlist ]
2570
[
trailer -> [ subscriptlist ]
2570
/
trailer -> [ subscriptlist ]
2570
or
trailer -> [ subscriptlist ]
2570
&
trailer -> [ subscriptlist ]
2570
>=
trailer -> [ subscriptlist ]
2570
==
trailer -> [ subscriptlist ]
2570
(
trailer -> [ subscriptlist ]
2570
|
trailer -> [ subscriptlist ]
2570
is
trailer -> [ subscriptlist ]
2570
if
trailer -> [ subscriptlist ]
2570
>
trailer -> [ subscriptlist ]
2570
^
trailer -> [ subscriptlist ]
2571
=
lambdef -> lambda varargslist : test
2571
NEWLINE
lambdef -> lambda varargslist : test
2572
[
1721
2572
factor
1722
2572
True
1723
2572
atom_expr
1724
2572
~
1725
2572
and_expr
1726
2572
-
1727
2572
None
1728
2572
atom
1729
2572
{
1730
2572
and_test
1731
2572
arith_expr
1732
2572
power
1733
2572
STRING
1734
2572
NAME
1735
2572
(
1736
2572
NUMBER
1737
2572
term
1738
2572
+
1739
2572
xor_expr
1740
2572
shift_expr
1741
2572
not
1742
2572
False
1743
2572
lambda
1744
2572
comparison
1745
2572
test
2623
2572
not_test
1746
2572
or_test
1747
2572
lambdef
1748
2572
expr
1749
2573
pass
if_stmt -> if test : suite elif_clause else : suite
2573
if
if_stmt -> if test : suite elif_clause else : suite
2573
endsim
if_stmt -> if test : suite elif_clause else : suite
2573
modopt
if_stmt -> if test : suite elif_clause else : suite
2573
~
if_stmt -> if test : suite elif_clause else : suite
2573
conf
if_stmt -> if test : suite elif_clause else : suite
2573
resetstats
if_stmt -> if test : suite elif_clause else : suite
2573
return
if_stmt -> if test : suite elif_clause else : suite
2573
assert
if_stmt -> if test : suite elif_clause else : suite
2573
-
if_stmt -> if test : suite elif_clause else : suite
2573
raise
if_stmt -> if test : suite elif_clause else : suite
2573
while
if_stmt -> if test : suite elif_clause else : suite
2573
NEWLINE
if_stmt -> if test : suite elif_clause else : suite
2573
$
if_stmt -> if test : suite elif_clause else : suite
2573
for
if_stmt -> if test : suite elif_clause else : suite
2573
global
if_stmt -> if test : suite elif_clause else : suite
2573
None
if_stmt -> if test : suite elif_clause else : suite
2573
servmod
if_stmt -> if test : suite elif_clause else : suite
2573
continue
if_stmt -> if test : suite elif_clause else : suite
2573
True
if_stmt -> if test : suite elif_clause else : suite
2573
STRING
if_stmt -> if test : suite elif_clause else : suite
2573
try
if_stmt -> if test : suite elif_clause else : suite
2573
lambda
if_stmt -> if test : suite elif_clause else : suite
2573
@
if_stmt -> if test : suite elif_clause else : suite
2573
with
if_stmt -> if test : suite elif_clause else : suite
2573
not
if_stmt -> if test : suite elif_clause else : suite
2573
del
if_stmt -> if test : suite elif_clause else : suite
2573
server
if_stmt -> if test : suite elif_clause else : suite
2573
{
if_stmt -> if test : suite elif_clause else : suite
2573
NAME
if_stmt -> if test : suite elif_clause else : suite
2573
break
if_stmt -> if test : suite elif_clause else : suite
2573
nonlocal
if_stmt -> if test : suite elif_clause else : suite
2573
[
if_stmt -> if test : suite elif_clause else : suite
2573
yield
if_stmt -> if test : suite elif_clause else : suite
2573
(
if_stmt -> if test : suite elif_clause else : suite
2573
False
if_stmt -> if test : suite elif_clause else : suite
2573
class
if_stmt -> if test : suite elif_clause else : suite
2573
begsim
if_stmt -> if test : suite elif_clause else : suite
2573
def
if_stmt -> if test : suite elif_clause else : suite
2573
+
if_stmt -> if test : suite elif_clause else : suite
2573
NUMBER
if_stmt -> if test : suite elif_clause else : suite
2574
elif
1817
2574
elif_clause
2624
2574
pass
elif_clause -> 
2574
None
elif_clause -> 
2574
return
elif_clause -> 
2574
del
elif_clause -> 
2574
NEWLINE
elif_clause -> 
2574
class
elif_clause -> 
2574
resetstats
elif_clause -> 
2574
$
elif_clause -> 
2574
+
elif_clause -> 
2574
break
elif_clause -> 
2574
if
elif_clause -> 
2574
[
elif_clause -> 
2574
~
elif_clause -> 
2574
endsim
elif_clause -> 
2574
servmod
elif_clause -> 
2574
else
elif_clause -> 
2574
for
elif_clause -> 
2574
begsim
elif_clause -> 
2574
not
elif_clause -> 
2574
try
elif_clause -> 
2574
lambda
elif_clause -> 
2574
@
elif_clause -> 
2574
conf
elif_clause -> 
2574
with
elif_clause -> 
2574
-
elif_clause -> 
2574
(
elif_clause -> 
2574
True
elif_clause -> 
2574
STRING
elif_clause -> 
2574
NUMBER
elif_clause -> 
2574
def
elif_clause -> 
2574
global
elif_clause -> 
2574
raise
elif_clause -> 
2574
yield
elif_clause -> 
2574
nonlocal
elif_clause -> 
2574
{
elif_clause -> 
2574
False
elif_clause -> 
2574
server
elif_clause -> 
2574
assert
elif_clause -> 
2574
continue
elif_clause -> 
2574
modopt
elif_clause -> 
2574
while
elif_clause -> 
2574
NAME
elif_clause -> 
2575
)
comp_for -> for expr_list in or_test comp_iter
2575
,
comp_for -> for expr_list in or_test comp_iter
2576
)
comp_iter -> comp_for
2576
,
comp_iter -> comp_for
2577
[
128
2577
factor
129
2577
True
130
2577
atom_expr
131
2577
~
132
2577
and_expr
133
2577
-
134
2577
{
135
2577
shift_expr
137
2577
atom
138
2577
comparison
140
2577
arith_expr
141
2577
power
142
2577
STRING
143
2577
NAME
144
2577
(
145
2577
and_test
146
2577
term
147
2577
+
148
2577
xor_expr
149
2577
lambda
2625
2577
or_test
2626
2577
NUMBER
151
2577
not
152
2577
False
153
2577
expr
154
2577
not_test
155
2577
None
156
2577
lambdef_nocond
2627
2577
test_nocond
2628
2578
)
comp_iter -> comp_if
2578
,
comp_iter -> comp_if
2579
DEDENT
2629
2580
arith_expr
1
2580
small_stmt
20
2580
factor
17
2580
True
38
2580
atom_expr
31
2580
term
22
2580
-
26
2580
None
55
2580
suite
2630
2580
atom
57
2580
test
5
2580
comparison
49
2580
and_expr
8
2580
power
9
2580
STRING
10
2580
NAME
52
2580
shift_expr
48
2580
lambdef
15
2580
NUMBER
58
2580
simple_stmt
1094
2580
(
16
2580
expr
47
2580
[
18
2580
NEWLINE
1095
2580
not_test
32
2580
{
21
2580
and_test
46
2580
+
27
2580
lambda
29
2580
xor_expr
41
2580
yield
34
2580
not
62
2580
test_list
36
2580
~
37
2580
or_test
53
2580
False
39
2580
sim_stmt
45
2580
nonlocal
72
2580
nonlocal_stmt
73
2580
return
59
2580
break_stmt
60
2580
return_stmt
61
2580
raise_stmt
74
2580
break
63
2580
yield_stmt
75
2580
raise
64
2580
continue
77
2580
expr_stmt
65
2580
endsim
78
2580
del
80
2580
pass_stmt
81
2580
flow_stmt
82
2580
stat_stmt
66
2580
assert_stmt
68
2580
resetstats
84
2580
del_stmt
85
2580
continue_stmt
86
2580
begsim
69
2580
global_stmt
87
2580
pass
88
2580
global
70
2580
assert
71
2581
maybe_except_clause
2631
2581
except
938
2581
None
maybe_except_clause -> 
2581
if
maybe_except_clause -> 
2581
while
maybe_except_clause -> 
2581
return
maybe_except_clause -> 
2581
continue
maybe_except_clause -> 
2581
except_clause
2262
2581
server
maybe_except_clause -> 
2581
nonlocal
maybe_except_clause -> 
2581
def
maybe_except_clause -> 
2581
servmod
maybe_except_clause -> 
2581
endsim
maybe_except_clause -> 
2581
else
maybe_except_clause -> 
2581
global
maybe_except_clause -> 
2581
conf
maybe_except_clause -> 
2581
pass
maybe_except_clause -> 
2581
True
maybe_except_clause -> 
2581
NUMBER
maybe_except_clause -> 
2581
NEWLINE
maybe_except_clause -> 
2581
try
maybe_except_clause -> 
2581
False
maybe_except_clause -> 
2581
~
maybe_except_clause -> 
2581
with
maybe_except_clause -> 
2581
not
maybe_except_clause -> 
2581
NAME
maybe_except_clause -> 
2581
@
maybe_except_clause -> 
2581
(
maybe_except_clause -> 
2581
yield
maybe_except_clause -> 
2581
[
maybe_except_clause -> 
2581
finally
maybe_except_clause -> 
2581
-
maybe_except_clause -> 
2581
raise
maybe_except_clause -> 
2581
{
maybe_except_clause -> 
2581
assert
maybe_except_clause -> 
2581
$
maybe_except_clause -> 
2581
class
maybe_except_clause -> 
2581
break
maybe_except_clause -> 
2581
+
maybe_except_clause -> 
2581
STRING
maybe_except_clause -> 
2581
del
maybe_except_clause -> 
2581
begsim
maybe_except_clause -> 
2581
lambda
maybe_except_clause -> 
2581
resetstats
maybe_except_clause -> 
2581
for
maybe_except_clause -> 
2581
modopt
maybe_except_clause -> 
2582
as
test -> or_test if or_test else test
2582
:
test -> or_test if or_test else test
2583
+
suite -> NEWLINE INDENT stmt_list DEDENT
2583
False
suite -> NEWLINE INDENT stmt_list DEDENT
2583
[
suite -> NEWLINE INDENT stmt_list DEDENT
2583
pass
suite -> NEWLINE INDENT stmt_list DEDENT
2583
continue
suite -> NEWLINE INDENT stmt_list DEDENT
2583
break
suite -> NEWLINE INDENT stmt_list DEDENT
2583
lambda
suite -> NEWLINE INDENT stmt_list DEDENT
2583
NUMBER
suite -> NEWLINE INDENT stmt_list DEDENT
2583
finally
suite -> NEWLINE INDENT stmt_list DEDENT
2583
True
suite -> NEWLINE INDENT stmt_list DEDENT
2583
conf
suite -> NEWLINE INDENT stmt_list DEDENT
2583
endsim
suite -> NEWLINE INDENT stmt_list DEDENT
2583
server
suite -> NEWLINE INDENT stmt_list DEDENT
2583
raise
suite -> NEWLINE INDENT stmt_list DEDENT
2583
del
suite -> NEWLINE INDENT stmt_list DEDENT
2583
class
suite -> NEWLINE INDENT stmt_list DEDENT
2583
global
suite -> NEWLINE INDENT stmt_list DEDENT
2583
NEWLINE
suite -> NEWLINE INDENT stmt_list DEDENT
2583
def
suite -> NEWLINE INDENT stmt_list DEDENT
2583
@
suite -> NEWLINE INDENT stmt_list DEDENT
2583
if
suite -> NEWLINE INDENT stmt_list DEDENT
2583
else
suite -> NEWLINE INDENT stmt_list DEDENT
2583
$
suite -> NEWLINE INDENT stmt_list DEDENT
2583
nonlocal
suite -> NEWLINE INDENT stmt_list DEDENT
2583
-
suite -> NEWLINE INDENT stmt_list DEDENT
2583
NAME
suite -> NEWLINE INDENT stmt_list DEDENT
2583
yield
suite -> NEWLINE INDENT stmt_list DEDENT
2583
~
suite -> NEWLINE INDENT stmt_list DEDENT
2583
except
suite -> NEWLINE INDENT stmt_list DEDENT
2583
modopt
suite -> NEWLINE INDENT stmt_list DEDENT
2583
{
suite -> NEWLINE INDENT stmt_list DEDENT
2583
servmod
suite -> NEWLINE INDENT stmt_list DEDENT
2583
begsim
suite -> NEWLINE INDENT stmt_list DEDENT
2583
not
suite -> NEWLINE INDENT stmt_list DEDENT
2583
assert
suite -> NEWLINE INDENT stmt_list DEDENT
2583
with
suite -> NEWLINE INDENT stmt_list DEDENT
2583
None
suite -> NEWLINE INDENT stmt_list DEDENT
2583
resetstats
suite -> NEWLINE INDENT stmt_list DEDENT
2583
try
suite -> NEWLINE INDENT stmt_list DEDENT
2583
while
suite -> NEWLINE INDENT stmt_list DEDENT
2583
return
suite -> NEWLINE INDENT stmt_list DEDENT
2583
for
suite -> NEWLINE INDENT stmt_list DEDENT
2583
STRING
suite -> NEWLINE INDENT stmt_list DEDENT
2583
(
suite -> NEWLINE INDENT stmt_list DEDENT
2584
:
2632
2585
:
2633
2586
as
2634
2586
:
2635
2587
arith_expr
1
2587
small_stmt
2636
2587
factor
17
2587
True
38
2587
atom_expr
31
2587
term
22
2587
-
26
2587
None
55
2587
atom
57
2587
test
5
2587
comparison
49
2587
and_expr
8
2587
power
9
2587
STRING
10
2587
NAME
52
2587
shift_expr
48
2587
NEWLINE
2637
2587
lambdef
15
2587
NUMBER
58
2587
simple_stmt
2638
2587
(
16
2587
expr
47
2587
[
18
2587
not_test
32
2587
{
21
2587
and_test
46
2587
+
27
2587
lambda
29
2587
xor_expr
41
2587
yield
34
2587
suite
2639
2587
not
62
2587
test_list
36
2587
~
37
2587
or_test
53
2587
False
39
2587
sim_stmt
45
2587
nonlocal
72
2587
nonlocal_stmt
73
2587
return
59
2587
break_stmt
60
2587
return_stmt
61
2587
raise_stmt
74
2587
break
63
2587
yield_stmt
75
2587
raise
64
2587
continue
77
2587
expr_stmt
65
2587
endsim
78
2587
del
80
2587
pass_stmt
81
2587
flow_stmt
82
2587
stat_stmt
66
2587
assert_stmt
68
2587
resetstats
84
2587
del_stmt
85
2587
continue_stmt
86
2587
begsim
69
2587
global_stmt
87
2587
pass
88
2587
global
70
2587
assert
71
2588
confbody
2640
2588
NAME
1971
2589
confbody
2641
2589
NAME
1971
2590
:
2642
2591
del
simple_stmt -> small_stmt NEWLINE
2591
break
simple_stmt -> small_stmt NEWLINE
2591
raise
simple_stmt -> small_stmt NEWLINE
2591
servmod
simple_stmt -> small_stmt NEWLINE
2591
class
simple_stmt -> small_stmt NEWLINE
2591
not
simple_stmt -> small_stmt NEWLINE
2591
-
simple_stmt -> small_stmt NEWLINE
2591
False
simple_stmt -> small_stmt NEWLINE
2591
(
simple_stmt -> small_stmt NEWLINE
2591
endsim
simple_stmt -> small_stmt NEWLINE
2591
+
simple_stmt -> small_stmt NEWLINE
2591
None
simple_stmt -> small_stmt NEWLINE
2591
resetstats
simple_stmt -> small_stmt NEWLINE
2591
conf
simple_stmt -> small_stmt NEWLINE
2591
server
simple_stmt -> small_stmt NEWLINE
2591
STRING
simple_stmt -> small_stmt NEWLINE
2591
else
simple_stmt -> small_stmt NEWLINE
2591
if
simple_stmt -> small_stmt NEWLINE
2591
NUMBER
simple_stmt -> small_stmt NEWLINE
2591
global
simple_stmt -> small_stmt NEWLINE
2591
@
simple_stmt -> small_stmt NEWLINE
2591
True
simple_stmt -> small_stmt NEWLINE
2591
lambda
simple_stmt -> small_stmt NEWLINE
2591
pass
simple_stmt -> small_stmt NEWLINE
2591
return
simple_stmt -> small_stmt NEWLINE
2591
def
simple_stmt -> small_stmt NEWLINE
2591
with
simple_stmt -> small_stmt NEWLINE
2591
nonlocal
simple_stmt -> small_stmt NEWLINE
2591
assert
simple_stmt -> small_stmt NEWLINE
2591
NAME
simple_stmt -> small_stmt NEWLINE
2591
try
simple_stmt -> small_stmt NEWLINE
2591
begsim
simple_stmt -> small_stmt NEWLINE
2591
while
simple_stmt -> small_stmt NEWLINE
2591
for
simple_stmt -> small_stmt NEWLINE
2591
[
simple_stmt -> small_stmt NEWLINE
2591
modopt
simple_stmt -> small_stmt NEWLINE
2591
yield
simple_stmt -> small_stmt NEWLINE
2591
DEDENT
simple_stmt -> small_stmt NEWLINE
2591
continue
simple_stmt -> small_stmt NEWLINE
2591
{
simple_stmt -> small_stmt NEWLINE
2591
~
simple_stmt -> small_stmt NEWLINE
2592
arith_expr
1
2592
try
1533
2592
modopt
1534
2592
compound_stmt
1535
2592
test
5
2592
servmod
1536
2592
while
1537
2592
and_expr
8
2592
power
9
2592
STRING
10
2592
decorated
1538
2592
cli_serv_model
1539
2592
@
13
2592
try_stmt
1540
2592
lambdef
15
2592
stmt_list
2643
2592
(
16
2592
factor
17
2592
[
18
2592
class
1541
2592
small_stmt
1542
2592
{
21
2592
term
22
2592
def
1543
2592
server
1544
2592
while_stmt
1545
2592
-
26
2592
+
27
2592
for
1546
2592
if
1547
2592
lambda
29
2592
decorators
1548
2592
atom_expr
31
2592
not_test
32
2592
if_stmt
1549
2592
yield
34
2592
conf
1550
2592
test_list
36
2592
~
37
2592
True
38
2592
False
39
2592
funcdef
1551
2592
xor_expr
41
2592
with
1552
2592
for_stmt
1553
2592
sim_stmt
45
2592
and_test
46
2592
expr
47
2592
shift_expr
48
2592
comparison
49
2592
with_stmt
1554
2592
simple_stmt
1555
2592
NAME
52
2592
or_test
53
2592
confdef
1556
2592
None
55
2592
classdef
1557
2592
atom
57
2592
NUMBER
58
2592
return
59
2592
break_stmt
60
2592
return_stmt
61
2592
stmt
1558
2592
not
62
2592
break
63
2592
raise
64
2592
expr_stmt
65
2592
stat_stmt
66
2592
decorator
67
2592
assert_stmt
68
2592
begsim
69
2592
global
70
2592
assert
71
2592
nonlocal
72
2592
nonlocal_stmt
73
2592
raise_stmt
74
2592
yield_stmt
75
2592
continue
77
2592
endsim
78
2592
del
80
2592
pass_stmt
81
2592
flow_stmt
82
2592
resetstats
84
2592
del_stmt
85
2592
continue_stmt
86
2592
global_stmt
87
2592
pass
88
2593
:
2644
2594
arith_expr
1
2594
small_stmt
1542
2594
factor
17
2594
True
38
2594
atom_expr
31
2594
term
22
2594
-
26
2594
None
55
2594
atom
57
2594
test
5
2594
comparison
49
2594
and_expr
8
2594
power
9
2594
STRING
10
2594
NAME
52
2594
shift_expr
48
2594
lambdef
15
2594
NUMBER
58
2594
simple_stmt
2469
2594
(
16
2594
expr
47
2594
[
18
2594
NEWLINE
2470
2594
not_test
32
2594
{
21
2594
suite
2645
2594
and_test
46
2594
+
27
2594
lambda
29
2594
xor_expr
41
2594
yield
34
2594
not
62
2594
test_list
36
2594
~
37
2594
or_test
53
2594
False
39
2594
sim_stmt
45
2594
nonlocal
72
2594
nonlocal_stmt
73
2594
return
59
2594
break_stmt
60
2594
return_stmt
61
2594
raise_stmt
74
2594
break
63
2594
yield_stmt
75
2594
raise
64
2594
continue
77
2594
expr_stmt
65
2594
endsim
78
2594
del
80
2594
pass_stmt
81
2594
flow_stmt
82
2594
stat_stmt
66
2594
assert_stmt
68
2594
resetstats
84
2594
del_stmt
85
2594
continue_stmt
86
2594
begsim
69
2594
global_stmt
87
2594
pass
88
2594
global
70
2594
assert
71
2595
arith_expr
1
2595
try
1533
2595
modopt
1534
2595
compound_stmt
1535
2595
test
5
2595
servmod
1536
2595
while
1537
2595
and_expr
8
2595
power
9
2595
STRING
10
2595
decorated
1538
2595
cli_serv_model
1539
2595
@
13
2595
try_stmt
1540
2595
lambdef
15
2595
stmt_list
2646
2595
(
16
2595
factor
17
2595
[
18
2595
class
1541
2595
small_stmt
1542
2595
{
21
2595
term
22
2595
def
1543
2595
server
1544
2595
while_stmt
1545
2595
-
26
2595
+
27
2595
for
1546
2595
if
1547
2595
lambda
29
2595
decorators
1548
2595
atom_expr
31
2595
not_test
32
2595
if_stmt
1549
2595
yield
34
2595
conf
1550
2595
test_list
36
2595
~
37
2595
True
38
2595
False
39
2595
funcdef
1551
2595
xor_expr
41
2595
with
1552
2595
for_stmt
1553
2595
sim_stmt
45
2595
and_test
46
2595
expr
47
2595
shift_expr
48
2595
comparison
49
2595
with_stmt
1554
2595
simple_stmt
1555
2595
NAME
52
2595
or_test
53
2595
confdef
1556
2595
None
55
2595
classdef
1557
2595
atom
57
2595
NUMBER
58
2595
return
59
2595
break_stmt
60
2595
return_stmt
61
2595
stmt
1558
2595
not
62
2595
break
63
2595
raise
64
2595
expr_stmt
65
2595
stat_stmt
66
2595
decorator
67
2595
assert_stmt
68
2595
begsim
69
2595
global
70
2595
assert
71
2595
nonlocal
72
2595
nonlocal_stmt
73
2595
raise_stmt
74
2595
yield_stmt
75
2595
continue
77
2595
endsim
78
2595
del
80
2595
pass_stmt
81
2595
flow_stmt
82
2595
resetstats
84
2595
del_stmt
85
2595
continue_stmt
86
2595
global_stmt
87
2595
pass
88
2596
:
2647
2597
arith_expr
1
2597
small_stmt
1542
2597
factor
17
2597
True
38
2597
atom_expr
31
2597
term
22
2597
-
26
2597
None
55
2597
atom
57
2597
test
5
2597
comparison
49
2597
and_expr
8
2597
power
9
2597
STRING
10
2597
NAME
52
2597
suite
2648
2597
shift_expr
48
2597
lambdef
15
2597
NUMBER
58
2597
simple_stmt
2469
2597
(
16
2597
expr
47
2597
[
18
2597
NEWLINE
2470
2597
not_test
32
2597
{
21
2597
and_test
46
2597
+
27
2597
lambda
29
2597
xor_expr
41
2597
yield
34
2597
not
62
2597
test_list
36
2597
~
37
2597
or_test
53
2597
False
39
2597
sim_stmt
45
2597
nonlocal
72
2597
nonlocal_stmt
73
2597
return
59
2597
break_stmt
60
2597
return_stmt
61
2597
raise_stmt
74
2597
break
63
2597
yield_stmt
75
2597
raise
64
2597
continue
77
2597
expr_stmt
65
2597
endsim
78
2597
del
80
2597
pass_stmt
81
2597
flow_stmt
82
2597
stat_stmt
66
2597
assert_stmt
68
2597
resetstats
84
2597
del_stmt
85
2597
continue_stmt
86
2597
begsim
69
2597
global_stmt
87
2597
pass
88
2597
global
70
2597
assert
71
2598
confbody
2649
2598
NAME
1971
2599
arith_expr
1
2599
small_stmt
2464
2599
factor
17
2599
True
38
2599
atom_expr
31
2599
term
22
2599
-
26
2599
None
55
2599
atom
57
2599
test
5
2599
comparison
49
2599
and_expr
8
2599
power
9
2599
STRING
10
2599
NAME
52
2599
shift_expr
48
2599
lambdef
15
2599
suite
2650
2599
NUMBER
58
2599
simple_stmt
2465
2599
(
16
2599
expr
47
2599
[
18
2599
NEWLINE
2466
2599
not_test
32
2599
{
21
2599
and_test
46
2599
+
27
2599
lambda
29
2599
xor_expr
41
2599
yield
34
2599
not
62
2599
test_list
36
2599
~
37
2599
or_test
53
2599
False
39
2599
sim_stmt
45
2599
nonlocal
72
2599
nonlocal_stmt
73
2599
return
59
2599
break_stmt
60
2599
return_stmt
61
2599
raise_stmt
74
2599
break
63
2599
yield_stmt
75
2599
raise
64
2599
continue
77
2599
expr_stmt
65
2599
endsim
78
2599
del
80
2599
pass_stmt
81
2599
flow_stmt
82
2599
stat_stmt
66
2599
assert_stmt
68
2599
resetstats
84
2599
del_stmt
85
2599
continue_stmt
86
2599
begsim
69
2599
global_stmt
87
2599
pass
88
2599
global
70
2599
assert
71
2600
del
simple_stmt -> small_stmt NEWLINE
2600
elif
simple_stmt -> small_stmt NEWLINE
2600
break
simple_stmt -> small_stmt NEWLINE
2600
raise
simple_stmt -> small_stmt NEWLINE
2600
servmod
simple_stmt -> small_stmt NEWLINE
2600
class
simple_stmt -> small_stmt NEWLINE
2600
not
simple_stmt -> small_stmt NEWLINE
2600
-
simple_stmt -> small_stmt NEWLINE
2600
False
simple_stmt -> small_stmt NEWLINE
2600
(
simple_stmt -> small_stmt NEWLINE
2600
endsim
simple_stmt -> small_stmt NEWLINE
2600
+
simple_stmt -> small_stmt NEWLINE
2600
None
simple_stmt -> small_stmt NEWLINE
2600
resetstats
simple_stmt -> small_stmt NEWLINE
2600
conf
simple_stmt -> small_stmt NEWLINE
2600
server
simple_stmt -> small_stmt NEWLINE
2600
STRING
simple_stmt -> small_stmt NEWLINE
2600
else
simple_stmt -> small_stmt NEWLINE
2600
if
simple_stmt -> small_stmt NEWLINE
2600
NUMBER
simple_stmt -> small_stmt NEWLINE
2600
global
simple_stmt -> small_stmt NEWLINE
2600
@
simple_stmt -> small_stmt NEWLINE
2600
True
simple_stmt -> small_stmt NEWLINE
2600
lambda
simple_stmt -> small_stmt NEWLINE
2600
pass
simple_stmt -> small_stmt NEWLINE
2600
return
simple_stmt -> small_stmt NEWLINE
2600
def
simple_stmt -> small_stmt NEWLINE
2600
with
simple_stmt -> small_stmt NEWLINE
2600
nonlocal
simple_stmt -> small_stmt NEWLINE
2600
assert
simple_stmt -> small_stmt NEWLINE
2600
NAME
simple_stmt -> small_stmt NEWLINE
2600
try
simple_stmt -> small_stmt NEWLINE
2600
begsim
simple_stmt -> small_stmt NEWLINE
2600
while
simple_stmt -> small_stmt NEWLINE
2600
for
simple_stmt -> small_stmt NEWLINE
2600
[
simple_stmt -> small_stmt NEWLINE
2600
modopt
simple_stmt -> small_stmt NEWLINE
2600
yield
simple_stmt -> small_stmt NEWLINE
2600
DEDENT
simple_stmt -> small_stmt NEWLINE
2600
continue
simple_stmt -> small_stmt NEWLINE
2600
{
simple_stmt -> small_stmt NEWLINE
2600
~
simple_stmt -> small_stmt NEWLINE
2601
del
if_stmt -> if test : suite elif_clause
2601
def
if_stmt -> if test : suite elif_clause
2601
else
2651
2601
for
if_stmt -> if test : suite elif_clause
2601
(
if_stmt -> if test : suite elif_clause
2601
None
if_stmt -> if test : suite elif_clause
2601
servmod
if_stmt -> if test : suite elif_clause
2601
conf
if_stmt -> if test : suite elif_clause
2601
yield
if_stmt -> if test : suite elif_clause
2601
True
if_stmt -> if test : suite elif_clause
2601
endsim
if_stmt -> if test : suite elif_clause
2601
with
if_stmt -> if test : suite elif_clause
2601
NUMBER
if_stmt -> if test : suite elif_clause
2601
server
if_stmt -> if test : suite elif_clause
2601
break
if_stmt -> if test : suite elif_clause
2601
raise
if_stmt -> if test : suite elif_clause
2601
assert
if_stmt -> if test : suite elif_clause
2601
+
if_stmt -> if test : suite elif_clause
2601
{
if_stmt -> if test : suite elif_clause
2601
DEDENT
if_stmt -> if test : suite elif_clause
2601
global
if_stmt -> if test : suite elif_clause
2601
[
if_stmt -> if test : suite elif_clause
2601
STRING
if_stmt -> if test : suite elif_clause
2601
~
if_stmt -> if test : suite elif_clause
2601
if
if_stmt -> if test : suite elif_clause
2601
return
if_stmt -> if test : suite elif_clause
2601
-
if_stmt -> if test : suite elif_clause
2601
lambda
if_stmt -> if test : suite elif_clause
2601
@
if_stmt -> if test : suite elif_clause
2601
nonlocal
if_stmt -> if test : suite elif_clause
2601
begsim
if_stmt -> if test : suite elif_clause
2601
False
if_stmt -> if test : suite elif_clause
2601
NAME
if_stmt -> if test : suite elif_clause
2601
not
if_stmt -> if test : suite elif_clause
2601
continue
if_stmt -> if test : suite elif_clause
2601
modopt
if_stmt -> if test : suite elif_clause
2601
resetstats
if_stmt -> if test : suite elif_clause
2601
pass
if_stmt -> if test : suite elif_clause
2601
while
if_stmt -> if test : suite elif_clause
2601
try
if_stmt -> if test : suite elif_clause
2601
class
if_stmt -> if test : suite elif_clause
2602
[
95
2602
factor
96
2602
True
97
2602
atom_expr
98
2602
~
99
2602
and_expr
100
2602
-
101
2602
atom
102
2602
{
103
2602
or_test
104
2602
arith_expr
105
2602
power
106
2602
STRING
107
2602
NAME
108
2602
(
109
2602
test
2652
2602
and_test
110
2602
term
111
2602
+
112
2602
xor_expr
113
2602
shift_expr
115
2602
NUMBER
116
2602
not
117
2602
False
118
2602
expr
119
2602
not_test
120
2602
comparison
121
2602
None
122
2602
lambdef
123
2602
lambda
124
2603
arith_expr
1
2603
try
1533
2603
modopt
1534
2603
compound_stmt
1535
2603
test
5
2603
servmod
1536
2603
while
1537
2603
and_expr
8
2603
power
9
2603
STRING
10
2603
decorated
1538
2603
cli_serv_model
1539
2603
@
13
2603
try_stmt
1540
2603
lambdef
15
2603
stmt_list
2653
2603
(
16
2603
factor
17
2603
[
18
2603
class
1541
2603
small_stmt
1542
2603
{
21
2603
term
22
2603
def
1543
2603
server
1544
2603
while_stmt
1545
2603
-
26
2603
+
27
2603
for
1546
2603
if
1547
2603
lambda
29
2603
decorators
1548
2603
atom_expr
31
2603
not_test
32
2603
if_stmt
1549
2603
yield
34
2603
conf
1550
2603
test_list
36
2603
~
37
2603
True
38
2603
False
39
2603
funcdef
1551
2603
xor_expr
41
2603
with
1552
2603
for_stmt
1553
2603
sim_stmt
45
2603
and_test
46
2603
expr
47
2603
shift_expr
48
2603
comparison
49
2603
with_stmt
1554
2603
simple_stmt
1555
2603
NAME
52
2603
or_test
53
2603
confdef
1556
2603
None
55
2603
classdef
1557
2603
atom
57
2603
NUMBER
58
2603
return
59
2603
break_stmt
60
2603
return_stmt
61
2603
stmt
1558
2603
not
62
2603
break
63
2603
raise
64
2603
expr_stmt
65
2603
stat_stmt
66
2603
decorator
67
2603
assert_stmt
68
2603
begsim
69
2603
global
70
2603
assert
71
2603
nonlocal
72
2603
nonlocal_stmt
73
2603
raise_stmt
74
2603
yield_stmt
75
2603
continue
77
2603
endsim
78
2603
del
80
2603
pass_stmt
81
2603
flow_stmt
82
2603
resetstats
84
2603
del_stmt
85
2603
continue_stmt
86
2603
global_stmt
87
2603
pass
88
2604
:
2654
2605
confbody
2655
2605
NAME
1971
2606
DEDENT
confbody -> NAME test NEWLINE confbody
2607
.
trailer -> ( arglist )
2607
|
trailer -> ( arglist )
2607
^
trailer -> ( arglist )
2607
==
trailer -> ( arglist )
2607
**
trailer -> ( arglist )
2607
>>
trailer -> ( arglist )
2607
not
trailer -> ( arglist )
2607
<<
trailer -> ( arglist )
2607
>=
trailer -> ( arglist )
2607
!=
trailer -> ( arglist )
2607
in
trailer -> ( arglist )
2607
[
trailer -> ( arglist )
2607
(
trailer -> ( arglist )
2607
>
trailer -> ( arglist )
2607
and
trailer -> ( arglist )
2607
+
trailer -> ( arglist )
2607
%
trailer -> ( arglist )
2607
or
trailer -> ( arglist )
2607
*
trailer -> ( arglist )
2607
for
trailer -> ( arglist )
2607
is
trailer -> ( arglist )
2607
&
trailer -> ( arglist )
2607
//
trailer -> ( arglist )
2607
)
trailer -> ( arglist )
2607
<
trailer -> ( arglist )
2607
if
trailer -> ( arglist )
2607
<=
trailer -> ( arglist )
2607
-
trailer -> ( arglist )
2607
/
trailer -> ( arglist )
2607
@
trailer -> ( arglist )
2608
for
trailer -> [ subscriptlist ]
2608
<=
trailer -> [ subscriptlist ]
2608
<<
trailer -> [ subscriptlist ]
2608
*
trailer -> [ subscriptlist ]
2608
+
trailer -> [ subscriptlist ]
2608
in
trailer -> [ subscriptlist ]
2608
>>
trailer -> [ subscriptlist ]
2608
//
trailer -> [ subscriptlist ]
2608
.
trailer -> [ subscriptlist ]
2608
and
trailer -> [ subscriptlist ]
2608
**
trailer -> [ subscriptlist ]
2608
@
trailer -> [ subscriptlist ]
2608
<
trailer -> [ subscriptlist ]
2608
not
trailer -> [ subscriptlist ]
2608
-
trailer -> [ subscriptlist ]
2608
!=
trailer -> [ subscriptlist ]
2608
%
trailer -> [ subscriptlist ]
2608
)
trailer -> [ subscriptlist ]
2608
[
trailer -> [ subscriptlist ]
2608
/
trailer -> [ subscriptlist ]
2608
or
trailer -> [ subscriptlist ]
2608
&
trailer -> [ subscriptlist ]
2608
>=
trailer -> [ subscriptlist ]
2608
==
trailer -> [ subscriptlist ]
2608
(
trailer -> [ subscriptlist ]
2608
|
trailer -> [ subscriptlist ]
2608
is
trailer -> [ subscriptlist ]
2608
if
trailer -> [ subscriptlist ]
2608
>
trailer -> [ subscriptlist ]
2608
^
trailer -> [ subscriptlist ]
2609
[
2004
2609
factor
2005
2609
True
2006
2609
atom_expr
2007
2609
~
2008
2609
and_expr
2009
2609
-
2010
2609
{
2011
2609
atom
2012
2609
arith_expr
2014
2609
power
2015
2609
STRING
2016
2609
NAME
2017
2609
(
2018
2609
and_test
2019
2609
term
2020
2609
+
2021
2609
xor_expr
2022
2609
shift_expr
2023
2609
lambda
2498
2609
or_test
2499
2609
NUMBER
2024
2609
not
2025
2609
False
2026
2609
expr
2027
2609
comparison
2028
2609
not_test
2029
2609
None
2030
2609
lambdef_nocond
2500
2609
test_nocond
2656
2610
:
2657
2611
)
comp_if -> if test_nocond comp_iter
2612
.
trailer -> ( arglist )
2612
|
trailer -> ( arglist )
2612
^
trailer -> ( arglist )
2612
==
trailer -> ( arglist )
2612
**
trailer -> ( arglist )
2612
>>
trailer -> ( arglist )
2612
not
trailer -> ( arglist )
2612
<<
trailer -> ( arglist )
2612
>=
trailer -> ( arglist )
2612
!=
trailer -> ( arglist )
2612
in
trailer -> ( arglist )
2612
[
trailer -> ( arglist )
2612
(
trailer -> ( arglist )
2612
]
trailer -> ( arglist )
2612
>
trailer -> ( arglist )
2612
and
trailer -> ( arglist )
2612
+
trailer -> ( arglist )
2612
%
trailer -> ( arglist )
2612
or
trailer -> ( arglist )
2612
*
trailer -> ( arglist )
2612
for
trailer -> ( arglist )
2612
is
trailer -> ( arglist )
2612
&
trailer -> ( arglist )
2612
//
trailer -> ( arglist )
2612
<
trailer -> ( arglist )
2612
if
trailer -> ( arglist )
2612
<=
trailer -> ( arglist )
2612
-
trailer -> ( arglist )
2612
/
trailer -> ( arglist )
2612
@
trailer -> ( arglist )
2613
for
trailer -> [ subscriptlist ]
2613
]
trailer -> [ subscriptlist ]
2613
<=
trailer -> [ subscriptlist ]
2613
<<
trailer -> [ subscriptlist ]
2613
*
trailer -> [ subscriptlist ]
2613
+
trailer -> [ subscriptlist ]
2613
in
trailer -> [ subscriptlist ]
2613
>>
trailer -> [ subscriptlist ]
2613
//
trailer -> [ subscriptlist ]
2613
.
trailer -> [ subscriptlist ]
2613
and
trailer -> [ subscriptlist ]
2613
**
trailer -> [ subscriptlist ]
2613
@
trailer -> [ subscriptlist ]
2613
<
trailer -> [ subscriptlist ]
2613
not
trailer -> [ subscriptlist ]
2613
-
trailer -> [ subscriptlist ]
2613
!=
trailer -> [ subscriptlist ]
2613
%
trailer -> [ subscriptlist ]
2613
[
trailer -> [ subscriptlist ]
2613
/
trailer -> [ subscriptlist ]
2613
or
trailer -> [ subscriptlist ]
2613
&
trailer -> [ subscriptlist ]
2613
>=
trailer -> [ subscriptlist ]
2613
==
trailer -> [ subscriptlist ]
2613
(
trailer -> [ subscriptlist ]
2613
|
trailer -> [ subscriptlist ]
2613
is
trailer -> [ subscriptlist ]
2613
if
trailer -> [ subscriptlist ]
2613
>
trailer -> [ subscriptlist ]
2613
^
trailer -> [ subscriptlist ]
2614
]
comp_if -> if test_nocond comp_iter
2615
[
2031
2615
factor
2032
2615
True
2033
2615
test_nocond
2658
2615
~
2035
2615
not
2036
2615
and_expr
2037
2615
-
2038
2615
atom_expr
2034
2615
atom
2040
2615
{
2039
2615
(
2041
2615
arith_expr
2042
2615
power
2043
2615
STRING
2044
2615
NAME
2045
2615
and_test
2046
2615
term
2047
2615
+
2048
2615
xor_expr
2049
2615
shift_expr
2050
2615
lambda
2536
2615
NUMBER
2051
2615
False
2052
2615
expr
2053
2615
or_test
2537
2615
comparison
2054
2615
not_test
2055
2615
None
2056
2615
lambdef_nocond
2538
2616
:
2659
2617
,
trailer -> ( arglist )
2617
.
trailer -> ( arglist )
2617
|
trailer -> ( arglist )
2617
^
trailer -> ( arglist )
2617
==
trailer -> ( arglist )
2617
**
trailer -> ( arglist )
2617
>>
trailer -> ( arglist )
2617
not
trailer -> ( arglist )
2617
<<
trailer -> ( arglist )
2617
>=
trailer -> ( arglist )
2617
!=
trailer -> ( arglist )
2617
in
trailer -> ( arglist )
2617
[
trailer -> ( arglist )
2617
(
trailer -> ( arglist )
2617
>
trailer -> ( arglist )
2617
and
trailer -> ( arglist )
2617
+
trailer -> ( arglist )
2617
%
trailer -> ( arglist )
2617
or
trailer -> ( arglist )
2617
*
trailer -> ( arglist )
2617
is
trailer -> ( arglist )
2617
&
trailer -> ( arglist )
2617
//
trailer -> ( arglist )
2617
=
trailer -> ( arglist )
2617
-
trailer -> ( arglist )
2617
)
trailer -> ( arglist )
2617
<
trailer -> ( arglist )
2617
<=
trailer -> ( arglist )
2617
if
trailer -> ( arglist )
2617
/
trailer -> ( arglist )
2617
@
trailer -> ( arglist )
2618
<=
trailer -> [ subscriptlist ]
2618
<<
trailer -> [ subscriptlist ]
2618
*
trailer -> [ subscriptlist ]
2618
+
trailer -> [ subscriptlist ]
2618
in
trailer -> [ subscriptlist ]
2618
>>
trailer -> [ subscriptlist ]
2618
//
trailer -> [ subscriptlist ]
2618
.
trailer -> [ subscriptlist ]
2618
,
trailer -> [ subscriptlist ]
2618
and
trailer -> [ subscriptlist ]
2618
**
trailer -> [ subscriptlist ]
2618
=
trailer -> [ subscriptlist ]
2618
@
trailer -> [ subscriptlist ]
2618
<
trailer -> [ subscriptlist ]
2618
not
trailer -> [ subscriptlist ]
2618
-
trailer -> [ subscriptlist ]
2618
!=
trailer -> [ subscriptlist ]
2618
%
trailer -> [ subscriptlist ]
2618
)
trailer -> [ subscriptlist ]
2618
[
trailer -> [ subscriptlist ]
2618
/
trailer -> [ subscriptlist ]
2618
or
trailer -> [ subscriptlist ]
2618
&
trailer -> [ subscriptlist ]
2618
>=
trailer -> [ subscriptlist ]
2618
==
trailer -> [ subscriptlist ]
2618
(
trailer -> [ subscriptlist ]
2618
|
trailer -> [ subscriptlist ]
2618
is
trailer -> [ subscriptlist ]
2618
if
trailer -> [ subscriptlist ]
2618
>
trailer -> [ subscriptlist ]
2618
^
trailer -> [ subscriptlist ]
2619
[
2090
2619
factor
2091
2619
True
2092
2619
atom_expr
2093
2619
~
2094
2619
and_expr
2095
2619
-
2096
2619
shift_expr
2097
2619
atom
2098
2619
{
2099
2619
comparison
2100
2619
and_test
2101
2619
arith_expr
2102
2619
power
2103
2619
STRING
2104
2619
NAME
2105
2619
(
2106
2619
term
2107
2619
+
2108
2619
xor_expr
2109
2619
or_test
2110
2619
NUMBER
2111
2619
not
2112
2619
False
2113
2619
not_test
2114
2619
None
2115
2619
expr
2116
2619
lambda
2117
2619
test
2660
2619
lambdef
2118
2620
,
lambdef -> lambda varargslist : test
2620
=
lambdef -> lambda varargslist : test
2620
)
lambdef -> lambda varargslist : test
2621
global
for_stmt -> for expr_list in test_list : suite else : suite
2621
raise
for_stmt -> for expr_list in test_list : suite else : suite
2621
$
for_stmt -> for expr_list in test_list : suite else : suite
2621
NAME
for_stmt -> for expr_list in test_list : suite else : suite
2621
if
for_stmt -> for expr_list in test_list : suite else : suite
2621
(
for_stmt -> for expr_list in test_list : suite else : suite
2621
del
for_stmt -> for expr_list in test_list : suite else : suite
2621
while
for_stmt -> for expr_list in test_list : suite else : suite
2621
for
for_stmt -> for expr_list in test_list : suite else : suite
2621
modopt
for_stmt -> for expr_list in test_list : suite else : suite
2621
True
for_stmt -> for expr_list in test_list : suite else : suite
2621
not
for_stmt -> for expr_list in test_list : suite else : suite
2621
with
for_stmt -> for expr_list in test_list : suite else : suite
2621
+
for_stmt -> for expr_list in test_list : suite else : suite
2621
yield
for_stmt -> for expr_list in test_list : suite else : suite
2621
assert
for_stmt -> for expr_list in test_list : suite else : suite
2621
@
for_stmt -> for expr_list in test_list : suite else : suite
2621
STRING
for_stmt -> for expr_list in test_list : suite else : suite
2621
def
for_stmt -> for expr_list in test_list : suite else : suite
2621
break
for_stmt -> for expr_list in test_list : suite else : suite
2621
continue
for_stmt -> for expr_list in test_list : suite else : suite
2621
server
for_stmt -> for expr_list in test_list : suite else : suite
2621
pass
for_stmt -> for expr_list in test_list : suite else : suite
2621
False
for_stmt -> for expr_list in test_list : suite else : suite
2621
nonlocal
for_stmt -> for expr_list in test_list : suite else : suite
2621
NEWLINE
for_stmt -> for expr_list in test_list : suite else : suite
2621
None
for_stmt -> for expr_list in test_list : suite else : suite
2621
lambda
for_stmt -> for expr_list in test_list : suite else : suite
2621
class
for_stmt -> for expr_list in test_list : suite else : suite
2621
resetstats
for_stmt -> for expr_list in test_list : suite else : suite
2621
[
for_stmt -> for expr_list in test_list : suite else : suite
2621
begsim
for_stmt -> for expr_list in test_list : suite else : suite
2621
try
for_stmt -> for expr_list in test_list : suite else : suite
2621
{
for_stmt -> for expr_list in test_list : suite else : suite
2621
NUMBER
for_stmt -> for expr_list in test_list : suite else : suite
2621
servmod
for_stmt -> for expr_list in test_list : suite else : suite
2621
conf
for_stmt -> for expr_list in test_list : suite else : suite
2621
return
for_stmt -> for expr_list in test_list : suite else : suite
2621
endsim
for_stmt -> for expr_list in test_list : suite else : suite
2621
-
for_stmt -> for expr_list in test_list : suite else : suite
2621
~
for_stmt -> for expr_list in test_list : suite else : suite
2622
DEDENT
2661
2623
NEWLINE
test -> or_test if or_test else test
2623
=
test -> or_test if or_test else test
2624
endsim
elif_clause -> elif test : suite elif_clause
2624
None
elif_clause -> elif test : suite elif_clause
2624
else
elif_clause -> elif test : suite elif_clause
2624
modopt
elif_clause -> elif test : suite elif_clause
2624
with
elif_clause -> elif test : suite elif_clause
2624
@
elif_clause -> elif test : suite elif_clause
2624
nonlocal
elif_clause -> elif test : suite elif_clause
2624
NEWLINE
elif_clause -> elif test : suite elif_clause
2624
for
elif_clause -> elif test : suite elif_clause
2624
def
elif_clause -> elif test : suite elif_clause
2624
True
elif_clause -> elif test : suite elif_clause
2624
NAME
elif_clause -> elif test : suite elif_clause
2624
resetstats
elif_clause -> elif test : suite elif_clause
2624
conf
elif_clause -> elif test : suite elif_clause
2624
break
elif_clause -> elif test : suite elif_clause
2624
lambda
elif_clause -> elif test : suite elif_clause
2624
global
elif_clause -> elif test : suite elif_clause
2624
(
elif_clause -> elif test : suite elif_clause
2624
$
elif_clause -> elif test : suite elif_clause
2624
if
elif_clause -> elif test : suite elif_clause
2624
servmod
elif_clause -> elif test : suite elif_clause
2624
try
elif_clause -> elif test : suite elif_clause
2624
yield
elif_clause -> elif test : suite elif_clause
2624
False
elif_clause -> elif test : suite elif_clause
2624
while
elif_clause -> elif test : suite elif_clause
2624
+
elif_clause -> elif test : suite elif_clause
2624
assert
elif_clause -> elif test : suite elif_clause
2624
not
elif_clause -> elif test : suite elif_clause
2624
NUMBER
elif_clause -> elif test : suite elif_clause
2624
STRING
elif_clause -> elif test : suite elif_clause
2624
continue
elif_clause -> elif test : suite elif_clause
2624
class
elif_clause -> elif test : suite elif_clause
2624
return
elif_clause -> elif test : suite elif_clause
2624
[
elif_clause -> elif test : suite elif_clause
2624
~
elif_clause -> elif test : suite elif_clause
2624
server
elif_clause -> elif test : suite elif_clause
2624
del
elif_clause -> elif test : suite elif_clause
2624
-
elif_clause -> elif test : suite elif_clause
2624
{
elif_clause -> elif test : suite elif_clause
2624
pass
elif_clause -> elif test : suite elif_clause
2624
begsim
elif_clause -> elif test : suite elif_clause
2624
raise
elif_clause -> elif test : suite elif_clause
2625
:
2662
2625
vfpdef
234
2625
varargslist
2663
2625
NAME
233
2626
if
test_nocond -> or_test
2626
)
test_nocond -> or_test
2626
for
test_nocond -> or_test
2626
,
test_nocond -> or_test
2627
,
test_nocond -> lambdef_nocond
2627
)
test_nocond -> lambdef_nocond
2627
if
test_nocond -> lambdef_nocond
2627
for
test_nocond -> lambdef_nocond
2628
,
comp_iter -> 
2628
)
comp_iter -> 
2628
if
2577
2628
comp_for
2576
2628
comp_iter
2664
2628
comp_if
2578
2628
for
1380
2629
+
suite -> NEWLINE INDENT stmt_list DEDENT
2629
False
suite -> NEWLINE INDENT stmt_list DEDENT
2629
[
suite -> NEWLINE INDENT stmt_list DEDENT
2629
pass
suite -> NEWLINE INDENT stmt_list DEDENT
2629
continue
suite -> NEWLINE INDENT stmt_list DEDENT
2629
break
suite -> NEWLINE INDENT stmt_list DEDENT
2629
lambda
suite -> NEWLINE INDENT stmt_list DEDENT
2629
NUMBER
suite -> NEWLINE INDENT stmt_list DEDENT
2629
finally
suite -> NEWLINE INDENT stmt_list DEDENT
2629
True
suite -> NEWLINE INDENT stmt_list DEDENT
2629
conf
suite -> NEWLINE INDENT stmt_list DEDENT
2629
endsim
suite -> NEWLINE INDENT stmt_list DEDENT
2629
server
suite -> NEWLINE INDENT stmt_list DEDENT
2629
raise
suite -> NEWLINE INDENT stmt_list DEDENT
2629
del
suite -> NEWLINE INDENT stmt_list DEDENT
2629
class
suite -> NEWLINE INDENT stmt_list DEDENT
2629
global
suite -> NEWLINE INDENT stmt_list DEDENT
2629
NEWLINE
suite -> NEWLINE INDENT stmt_list DEDENT
2629
def
suite -> NEWLINE INDENT stmt_list DEDENT
2629
@
suite -> NEWLINE INDENT stmt_list DEDENT
2629
if
suite -> NEWLINE INDENT stmt_list DEDENT
2629
$
suite -> NEWLINE INDENT stmt_list DEDENT
2629
nonlocal
suite -> NEWLINE INDENT stmt_list DEDENT
2629
-
suite -> NEWLINE INDENT stmt_list DEDENT
2629
NAME
suite -> NEWLINE INDENT stmt_list DEDENT
2629
yield
suite -> NEWLINE INDENT stmt_list DEDENT
2629
~
suite -> NEWLINE INDENT stmt_list DEDENT
2629
modopt
suite -> NEWLINE INDENT stmt_list DEDENT
2629
{
suite -> NEWLINE INDENT stmt_list DEDENT
2629
servmod
suite -> NEWLINE INDENT stmt_list DEDENT
2629
begsim
suite -> NEWLINE INDENT stmt_list DEDENT
2629
not
suite -> NEWLINE INDENT stmt_list DEDENT
2629
assert
suite -> NEWLINE INDENT stmt_list DEDENT
2629
with
suite -> NEWLINE INDENT stmt_list DEDENT
2629
None
suite -> NEWLINE INDENT stmt_list DEDENT
2629
resetstats
suite -> NEWLINE INDENT stmt_list DEDENT
2629
try
suite -> NEWLINE INDENT stmt_list DEDENT
2629
while
suite -> NEWLINE INDENT stmt_list DEDENT
2629
return
suite -> NEWLINE INDENT stmt_list DEDENT
2629
for
suite -> NEWLINE INDENT stmt_list DEDENT
2629
STRING
suite -> NEWLINE INDENT stmt_list DEDENT
2629
(
suite -> NEWLINE INDENT stmt_list DEDENT
2630
yield
try_stmt -> try : suite except_clause else : suite finally : suite
2630
conf
try_stmt -> try : suite except_clause else : suite finally : suite
2630
modopt
try_stmt -> try : suite except_clause else : suite finally : suite
2630
~
try_stmt -> try : suite except_clause else : suite finally : suite
2630
class
try_stmt -> try : suite except_clause else : suite finally : suite
2630
begsim
try_stmt -> try : suite except_clause else : suite finally : suite
2630
try
try_stmt -> try : suite except_clause else : suite finally : suite
2630
def
try_stmt -> try : suite except_clause else : suite finally : suite
2630
NAME
try_stmt -> try : suite except_clause else : suite finally : suite
2630
return
try_stmt -> try : suite except_clause else : suite finally : suite
2630
pass
try_stmt -> try : suite except_clause else : suite finally : suite
2630
for
try_stmt -> try : suite except_clause else : suite finally : suite
2630
+
try_stmt -> try : suite except_clause else : suite finally : suite
2630
del
try_stmt -> try : suite except_clause else : suite finally : suite
2630
STRING
try_stmt -> try : suite except_clause else : suite finally : suite
2630
nonlocal
try_stmt -> try : suite except_clause else : suite finally : suite
2630
if
try_stmt -> try : suite except_clause else : suite finally : suite
2630
@
try_stmt -> try : suite except_clause else : suite finally : suite
2630
with
try_stmt -> try : suite except_clause else : suite finally : suite
2630
server
try_stmt -> try : suite except_clause else : suite finally : suite
2630
-
try_stmt -> try : suite except_clause else : suite finally : suite
2630
{
try_stmt -> try : suite except_clause else : suite finally : suite
2630
continue
try_stmt -> try : suite except_clause else : suite finally : suite
2630
not
try_stmt -> try : suite except_clause else : suite finally : suite
2630
True
try_stmt -> try : suite except_clause else : suite finally : suite
2630
raise
try_stmt -> try : suite except_clause else : suite finally : suite
2630
global
try_stmt -> try : suite except_clause else : suite finally : suite
2630
endsim
try_stmt -> try : suite except_clause else : suite finally : suite
2630
lambda
try_stmt -> try : suite except_clause else : suite finally : suite
2630
False
try_stmt -> try : suite except_clause else : suite finally : suite
2630
servmod
try_stmt -> try : suite except_clause else : suite finally : suite
2630
break
try_stmt -> try : suite except_clause else : suite finally : suite
2630
$
try_stmt -> try : suite except_clause else : suite finally : suite
2630
(
try_stmt -> try : suite except_clause else : suite finally : suite
2630
NUMBER
try_stmt -> try : suite except_clause else : suite finally : suite
2630
[
try_stmt -> try : suite except_clause else : suite finally : suite
2630
resetstats
try_stmt -> try : suite except_clause else : suite finally : suite
2630
None
try_stmt -> try : suite except_clause else : suite finally : suite
2630
NEWLINE
try_stmt -> try : suite except_clause else : suite finally : suite
2630
while
try_stmt -> try : suite except_clause else : suite finally : suite
2630
assert
try_stmt -> try : suite except_clause else : suite finally : suite
2631
finally
except_clause -> except test as NAME : suite maybe_except_clause
2631
[
except_clause -> except test as NAME : suite maybe_except_clause
2631
continue
except_clause -> except test as NAME : suite maybe_except_clause
2631
False
except_clause -> except test as NAME : suite maybe_except_clause
2631
return
except_clause -> except test as NAME : suite maybe_except_clause
2631
NUMBER
except_clause -> except test as NAME : suite maybe_except_clause
2631
del
except_clause -> except test as NAME : suite maybe_except_clause
2631
modopt
except_clause -> except test as NAME : suite maybe_except_clause
2631
@
except_clause -> except test as NAME : suite maybe_except_clause
2631
servmod
except_clause -> except test as NAME : suite maybe_except_clause
2631
raise
except_clause -> except test as NAME : suite maybe_except_clause
2631
-
except_clause -> except test as NAME : suite maybe_except_clause
2631
None
except_clause -> except test as NAME : suite maybe_except_clause
2631
endsim
except_clause -> except test as NAME : suite maybe_except_clause
2631
try
except_clause -> except test as NAME : suite maybe_except_clause
2631
server
except_clause -> except test as NAME : suite maybe_except_clause
2631
$
except_clause -> except test as NAME : suite maybe_except_clause
2631
else
except_clause -> except test as NAME : suite maybe_except_clause
2631
+
except_clause -> except test as NAME : suite maybe_except_clause
2631
NAME
except_clause -> except test as NAME : suite maybe_except_clause
2631
{
except_clause -> except test as NAME : suite maybe_except_clause
2631
for
except_clause -> except test as NAME : suite maybe_except_clause
2631
assert
except_clause -> except test as NAME : suite maybe_except_clause
2631
~
except_clause -> except test as NAME : suite maybe_except_clause
2631
with
except_clause -> except test as NAME : suite maybe_except_clause
2631
yield
except_clause -> except test as NAME : suite maybe_except_clause
2631
lambda
except_clause -> except test as NAME : suite maybe_except_clause
2631
not
except_clause -> except test as NAME : suite maybe_except_clause
2631
(
except_clause -> except test as NAME : suite maybe_except_clause
2631
while
except_clause -> except test as NAME : suite maybe_except_clause
2631
True
except_clause -> except test as NAME : suite maybe_except_clause
2631
if
except_clause -> except test as NAME : suite maybe_except_clause
2631
STRING
except_clause -> except test as NAME : suite maybe_except_clause
2631
class
except_clause -> except test as NAME : suite maybe_except_clause
2631
def
except_clause -> except test as NAME : suite maybe_except_clause
2631
nonlocal
except_clause -> except test as NAME : suite maybe_except_clause
2631
conf
except_clause -> except test as NAME : suite maybe_except_clause
2631
break
except_clause -> except test as NAME : suite maybe_except_clause
2631
resetstats
except_clause -> except test as NAME : suite maybe_except_clause
2631
global
except_clause -> except test as NAME : suite maybe_except_clause
2631
pass
except_clause -> except test as NAME : suite maybe_except_clause
2631
begsim
except_clause -> except test as NAME : suite maybe_except_clause
2631
NEWLINE
except_clause -> except test as NAME : suite maybe_except_clause
2632
arith_expr
1
2632
small_stmt
1542
2632
factor
17
2632
True
38
2632
atom_expr
31
2632
term
22
2632
-
26
2632
None
55
2632
atom
57
2632
test
5
2632
comparison
49
2632
and_expr
8
2632
power
9
2632
STRING
10
2632
NAME
52
2632
shift_expr
48
2632
lambdef
15
2632
NUMBER
58
2632
simple_stmt
2469
2632
(
16
2632
expr
47
2632
[
18
2632
NEWLINE
2470
2632
not_test
32
2632
{
21
2632
and_test
46
2632
+
27
2632
lambda
29
2632
xor_expr
41
2632
suite
2665
2632
yield
34
2632
not
62
2632
test_list
36
2632
~
37
2632
or_test
53
2632
False
39
2632
sim_stmt
45
2632
nonlocal
72
2632
nonlocal_stmt
73
2632
return
59
2632
break_stmt
60
2632
return_stmt
61
2632
raise_stmt
74
2632
break
63
2632
yield_stmt
75
2632
raise
64
2632
continue
77
2632
expr_stmt
65
2632
endsim
78
2632
del
80
2632
pass_stmt
81
2632
flow_stmt
82
2632
stat_stmt
66
2632
assert_stmt
68
2632
resetstats
84
2632
del_stmt
85
2632
continue_stmt
86
2632
begsim
69
2632
global_stmt
87
2632
pass
88
2632
global
70
2632
assert
71
2633
arith_expr
1
2633
small_stmt
2666
2633
factor
17
2633
True
38
2633
atom_expr
31
2633
term
22
2633
-
26
2633
None
55
2633
atom
57
2633
test
5
2633
comparison
49
2633
and_expr
8
2633
power
9
2633
STRING
10
2633
NAME
52
2633
shift_expr
48
2633
NEWLINE
2667
2633
lambdef
15
2633
NUMBER
58
2633
simple_stmt
2668
2633
(
16
2633
expr
47
2633
[
18
2633
not_test
32
2633
{
21
2633
suite
2669
2633
and_test
46
2633
+
27
2633
lambda
29
2633
xor_expr
41
2633
yield
34
2633
not
62
2633
test_list
36
2633
~
37
2633
or_test
53
2633
False
39
2633
sim_stmt
45
2633
nonlocal
72
2633
nonlocal_stmt
73
2633
return
59
2633
break_stmt
60
2633
return_stmt
61
2633
raise_stmt
74
2633
break
63
2633
yield_stmt
75
2633
raise
64
2633
continue
77
2633
expr_stmt
65
2633
endsim
78
2633
del
80
2633
pass_stmt
81
2633
flow_stmt
82
2633
stat_stmt
66
2633
assert_stmt
68
2633
resetstats
84
2633
del_stmt
85
2633
continue_stmt
86
2633
begsim
69
2633
global_stmt
87
2633
pass
88
2633
global
70
2633
assert
71
2634
NAME
2670
2635
arith_expr
1
2635
small_stmt
2636
2635
factor
17
2635
True
38
2635
atom_expr
31
2635
term
22
2635
-
26
2635
None
55
2635
atom
57
2635
test
5
2635
comparison
49
2635
and_expr
8
2635
power
9
2635
STRING
10
2635
NAME
52
2635
shift_expr
48
2635
NEWLINE
2637
2635
lambdef
15
2635
NUMBER
58
2635
simple_stmt
2638
2635
(
16
2635
expr
47
2635
[
18
2635
not_test
32
2635
{
21
2635
suite
2671
2635
and_test
46
2635
+
27
2635
lambda
29
2635
xor_expr
41
2635
yield
34
2635
not
62
2635
test_list
36
2635
~
37
2635
or_test
53
2635
False
39
2635
sim_stmt
45
2635
nonlocal
72
2635
nonlocal_stmt
73
2635
return
59
2635
break_stmt
60
2635
return_stmt
61
2635
raise_stmt
74
2635
break
63
2635
yield_stmt
75
2635
raise
64
2635
continue
77
2635
expr_stmt
65
2635
endsim
78
2635
del
80
2635
pass_stmt
81
2635
flow_stmt
82
2635
stat_stmt
66
2635
assert_stmt
68
2635
resetstats
84
2635
del_stmt
85
2635
continue_stmt
86
2635
begsim
69
2635
global_stmt
87
2635
pass
88
2635
global
70
2635
assert
71
2636
NEWLINE
2672
2637
INDENT
2673
2638
modopt
suite -> simple_stmt
2638
~
suite -> simple_stmt
2638
False
suite -> simple_stmt
2638
@
suite -> simple_stmt
2638
except
suite -> simple_stmt
2638
begsim
suite -> simple_stmt
2638
NUMBER
suite -> simple_stmt
2638
conf
suite -> simple_stmt
2638
class
suite -> simple_stmt
2638
finally
suite -> simple_stmt
2638
if
suite -> simple_stmt
2638
yield
suite -> simple_stmt
2638
try
suite -> simple_stmt
2638
pass
suite -> simple_stmt
2638
else
suite -> simple_stmt
2638
[
suite -> simple_stmt
2638
break
suite -> simple_stmt
2638
True
suite -> simple_stmt
2638
DEDENT
suite -> simple_stmt
2638
None
suite -> simple_stmt
2638
server
suite -> simple_stmt
2638
assert
suite -> simple_stmt
2638
servmod
suite -> simple_stmt
2638
raise
suite -> simple_stmt
2638
nonlocal
suite -> simple_stmt
2638
lambda
suite -> simple_stmt
2638
return
suite -> simple_stmt
2638
+
suite -> simple_stmt
2638
-
suite -> simple_stmt
2638
NAME
suite -> simple_stmt
2638
while
suite -> simple_stmt
2638
def
suite -> simple_stmt
2638
with
suite -> simple_stmt
2638
del
suite -> simple_stmt
2638
STRING
suite -> simple_stmt
2638
for
suite -> simple_stmt
2638
resetstats
suite -> simple_stmt
2638
global
suite -> simple_stmt
2638
continue
suite -> simple_stmt
2638
endsim
suite -> simple_stmt
2638
not
suite -> simple_stmt
2638
{
suite -> simple_stmt
2638
(
suite -> simple_stmt
2639
except
2460
2639
None
maybe_except_clause -> 
2639
if
maybe_except_clause -> 
2639
while
maybe_except_clause -> 
2639
maybe_except_clause
2674
2639
continue
maybe_except_clause -> 
2639
return
maybe_except_clause -> 
2639
except_clause
2675
2639
server
maybe_except_clause -> 
2639
nonlocal
maybe_except_clause -> 
2639
def
maybe_except_clause -> 
2639
servmod
maybe_except_clause -> 
2639
endsim
maybe_except_clause -> 
2639
else
maybe_except_clause -> 
2639
global
maybe_except_clause -> 
2639
conf
maybe_except_clause -> 
2639
pass
maybe_except_clause -> 
2639
True
maybe_except_clause -> 
2639
NUMBER
maybe_except_clause -> 
2639
try
maybe_except_clause -> 
2639
False
maybe_except_clause -> 
2639
~
maybe_except_clause -> 
2639
with
maybe_except_clause -> 
2639
not
maybe_except_clause -> 
2639
NAME
maybe_except_clause -> 
2639
@
maybe_except_clause -> 
2639
(
maybe_except_clause -> 
2639
yield
maybe_except_clause -> 
2639
[
maybe_except_clause -> 
2639
finally
maybe_except_clause -> 
2639
-
maybe_except_clause -> 
2639
raise
maybe_except_clause -> 
2639
{
maybe_except_clause -> 
2639
assert
maybe_except_clause -> 
2639
class
maybe_except_clause -> 
2639
break
maybe_except_clause -> 
2639
+
maybe_except_clause -> 
2639
STRING
maybe_except_clause -> 
2639
del
maybe_except_clause -> 
2639
begsim
maybe_except_clause -> 
2639
lambda
maybe_except_clause -> 
2639
resetstats
maybe_except_clause -> 
2639
DEDENT
maybe_except_clause -> 
2639
for
maybe_except_clause -> 
2639
modopt
maybe_except_clause -> 
2640
DEDENT
2676
2641
DEDENT
2677
2642
arith_expr
1
2642
small_stmt
1542
2642
factor
17
2642
True
38
2642
atom_expr
31
2642
term
22
2642
-
26
2642
None
55
2642
atom
57
2642
test
5
2642
comparison
49
2642
and_expr
8
2642
power
9
2642
STRING
10
2642
NAME
52
2642
shift_expr
48
2642
lambdef
15
2642
NUMBER
58
2642
simple_stmt
2469
2642
(
16
2642
expr
47
2642
[
18
2642
NEWLINE
2470
2642
not_test
32
2642
{
21
2642
and_test
46
2642
+
27
2642
lambda
29
2642
xor_expr
41
2642
yield
34
2642
not
62
2642
test_list
36
2642
~
37
2642
or_test
53
2642
False
39
2642
sim_stmt
45
2642
suite
2678
2642
nonlocal
72
2642
nonlocal_stmt
73
2642
return
59
2642
break_stmt
60
2642
return_stmt
61
2642
raise_stmt
74
2642
break
63
2642
yield_stmt
75
2642
raise
64
2642
continue
77
2642
expr_stmt
65
2642
endsim
78
2642
del
80
2642
pass_stmt
81
2642
flow_stmt
82
2642
stat_stmt
66
2642
assert_stmt
68
2642
resetstats
84
2642
del_stmt
85
2642
continue_stmt
86
2642
begsim
69
2642
global_stmt
87
2642
pass
88
2642
global
70
2642
assert
71
2643
DEDENT
2679
2644
arith_expr
1
2644
suite
2680
2644
small_stmt
1542
2644
factor
17
2644
atom_expr
31
2644
term
22
2644
-
26
2644
True
38
2644
None
55
2644
atom
57
2644
test
5
2644
comparison
49
2644
and_expr
8
2644
power
9
2644
STRING
10
2644
NAME
52
2644
shift_expr
48
2644
lambdef
15
2644
NUMBER
58
2644
simple_stmt
2469
2644
(
16
2644
expr
47
2644
[
18
2644
NEWLINE
2470
2644
not_test
32
2644
{
21
2644
and_test
46
2644
+
27
2644
lambda
29
2644
xor_expr
41
2644
yield
34
2644
not
62
2644
test_list
36
2644
~
37
2644
or_test
53
2644
False
39
2644
sim_stmt
45
2644
nonlocal
72
2644
nonlocal_stmt
73
2644
return
59
2644
break_stmt
60
2644
return_stmt
61
2644
raise_stmt
74
2644
break
63
2644
yield_stmt
75
2644
raise
64
2644
continue
77
2644
expr_stmt
65
2644
endsim
78
2644
del
80
2644
pass_stmt
81
2644
flow_stmt
82
2644
stat_stmt
66
2644
assert_stmt
68
2644
resetstats
84
2644
del_stmt
85
2644
continue_stmt
86
2644
begsim
69
2644
global_stmt
87
2644
pass
88
2644
global
70
2644
assert
71
2645
endsim
classdef -> class NAME ( ) : suite
2645
conf
classdef -> class NAME ( ) : suite
2645
servmod
classdef -> class NAME ( ) : suite
2645
+
classdef -> class NAME ( ) : suite
2645
@
classdef -> class NAME ( ) : suite
2645
NAME
classdef -> class NAME ( ) : suite
2645
~
classdef -> class NAME ( ) : suite
2645
[
classdef -> class NAME ( ) : suite
2645
break
classdef -> class NAME ( ) : suite
2645
modopt
classdef -> class NAME ( ) : suite
2645
for
classdef -> class NAME ( ) : suite
2645
begsim
classdef -> class NAME ( ) : suite
2645
if
classdef -> class NAME ( ) : suite
2645
assert
classdef -> class NAME ( ) : suite
2645
class
classdef -> class NAME ( ) : suite
2645
continue
classdef -> class NAME ( ) : suite
2645
pass
classdef -> class NAME ( ) : suite
2645
-
classdef -> class NAME ( ) : suite
2645
raise
classdef -> class NAME ( ) : suite
2645
None
classdef -> class NAME ( ) : suite
2645
return
classdef -> class NAME ( ) : suite
2645
yield
classdef -> class NAME ( ) : suite
2645
def
classdef -> class NAME ( ) : suite
2645
del
classdef -> class NAME ( ) : suite
2645
while
classdef -> class NAME ( ) : suite
2645
{
classdef -> class NAME ( ) : suite
2645
resetstats
classdef -> class NAME ( ) : suite
2645
lambda
classdef -> class NAME ( ) : suite
2645
with
classdef -> class NAME ( ) : suite
2645
(
classdef -> class NAME ( ) : suite
2645
try
classdef -> class NAME ( ) : suite
2645
STRING
classdef -> class NAME ( ) : suite
2645
not
classdef -> class NAME ( ) : suite
2645
nonlocal
classdef -> class NAME ( ) : suite
2645
server
classdef -> class NAME ( ) : suite
2645
True
classdef -> class NAME ( ) : suite
2645
global
classdef -> class NAME ( ) : suite
2645
NUMBER
classdef -> class NAME ( ) : suite
2645
DEDENT
classdef -> class NAME ( ) : suite
2645
False
classdef -> class NAME ( ) : suite
2646
DEDENT
2681
2647
arith_expr
1
2647
small_stmt
1542
2647
factor
17
2647
True
38
2647
atom_expr
31
2647
term
22
2647
-
26
2647
None
55
2647
atom
57
2647
test
5
2647
comparison
49
2647
and_expr
8
2647
power
9
2647
STRING
10
2647
NAME
52
2647
shift_expr
48
2647
lambdef
15
2647
NUMBER
58
2647
simple_stmt
2469
2647
(
16
2647
expr
47
2647
[
18
2647
NEWLINE
2470
2647
not_test
32
2647
{
21
2647
and_test
46
2647
suite
2682
2647
+
27
2647
lambda
29
2647
xor_expr
41
2647
yield
34
2647
not
62
2647
test_list
36
2647
~
37
2647
or_test
53
2647
False
39
2647
sim_stmt
45
2647
nonlocal
72
2647
nonlocal_stmt
73
2647
return
59
2647
break_stmt
60
2647
return_stmt
61
2647
raise_stmt
74
2647
break
63
2647
yield_stmt
75
2647
raise
64
2647
continue
77
2647
expr_stmt
65
2647
endsim
78
2647
del
80
2647
pass_stmt
81
2647
flow_stmt
82
2647
stat_stmt
66
2647
assert_stmt
68
2647
resetstats
84
2647
del_stmt
85
2647
continue_stmt
86
2647
begsim
69
2647
global_stmt
87
2647
pass
88
2647
global
70
2647
assert
71
2648
{
funcdef -> def NAME ( ) : suite
2648
conf
funcdef -> def NAME ( ) : suite
2648
try
funcdef -> def NAME ( ) : suite
2648
yield
funcdef -> def NAME ( ) : suite
2648
server
funcdef -> def NAME ( ) : suite
2648
STRING
funcdef -> def NAME ( ) : suite
2648
while
funcdef -> def NAME ( ) : suite
2648
servmod
funcdef -> def NAME ( ) : suite
2648
(
funcdef -> def NAME ( ) : suite
2648
lambda
funcdef -> def NAME ( ) : suite
2648
False
funcdef -> def NAME ( ) : suite
2648
continue
funcdef -> def NAME ( ) : suite
2648
begsim
funcdef -> def NAME ( ) : suite
2648
class
funcdef -> def NAME ( ) : suite
2648
[
funcdef -> def NAME ( ) : suite
2648
~
funcdef -> def NAME ( ) : suite
2648
del
funcdef -> def NAME ( ) : suite
2648
NUMBER
funcdef -> def NAME ( ) : suite
2648
assert
funcdef -> def NAME ( ) : suite
2648
DEDENT
funcdef -> def NAME ( ) : suite
2648
resetstats
funcdef -> def NAME ( ) : suite
2648
return
funcdef -> def NAME ( ) : suite
2648
with
funcdef -> def NAME ( ) : suite
2648
raise
funcdef -> def NAME ( ) : suite
2648
for
funcdef -> def NAME ( ) : suite
2648
def
funcdef -> def NAME ( ) : suite
2648
endsim
funcdef -> def NAME ( ) : suite
2648
NAME
funcdef -> def NAME ( ) : suite
2648
nonlocal
funcdef -> def NAME ( ) : suite
2648
global
funcdef -> def NAME ( ) : suite
2648
True
funcdef -> def NAME ( ) : suite
2648
if
funcdef -> def NAME ( ) : suite
2648
modopt
funcdef -> def NAME ( ) : suite
2648
not
funcdef -> def NAME ( ) : suite
2648
-
funcdef -> def NAME ( ) : suite
2648
None
funcdef -> def NAME ( ) : suite
2648
+
funcdef -> def NAME ( ) : suite
2648
@
funcdef -> def NAME ( ) : suite
2648
break
funcdef -> def NAME ( ) : suite
2648
pass
funcdef -> def NAME ( ) : suite
2649
DEDENT
2683
2650
class
for_stmt -> for expr_list in test_list : suite
2650
lambda
for_stmt -> for expr_list in test_list : suite
2650
assert
for_stmt -> for expr_list in test_list : suite
2650
else
2684
2650
return
for_stmt -> for expr_list in test_list : suite
2650
-
for_stmt -> for expr_list in test_list : suite
2650
while
for_stmt -> for expr_list in test_list : suite
2650
continue
for_stmt -> for expr_list in test_list : suite
2650
not
for_stmt -> for expr_list in test_list : suite
2650
+
for_stmt -> for expr_list in test_list : suite
2650
pass
for_stmt -> for expr_list in test_list : suite
2650
del
for_stmt -> for expr_list in test_list : suite
2650
servmod
for_stmt -> for expr_list in test_list : suite
2650
modopt
for_stmt -> for expr_list in test_list : suite
2650
None
for_stmt -> for expr_list in test_list : suite
2650
if
for_stmt -> for expr_list in test_list : suite
2650
yield
for_stmt -> for expr_list in test_list : suite
2650
{
for_stmt -> for expr_list in test_list : suite
2650
with
for_stmt -> for expr_list in test_list : suite
2650
@
for_stmt -> for expr_list in test_list : suite
2650
raise
for_stmt -> for expr_list in test_list : suite
2650
endsim
for_stmt -> for expr_list in test_list : suite
2650
STRING
for_stmt -> for expr_list in test_list : suite
2650
nonlocal
for_stmt -> for expr_list in test_list : suite
2650
~
for_stmt -> for expr_list in test_list : suite
2650
False
for_stmt -> for expr_list in test_list : suite
2650
def
for_stmt -> for expr_list in test_list : suite
2650
[
for_stmt -> for expr_list in test_list : suite
2650
NAME
for_stmt -> for expr_list in test_list : suite
2650
server
for_stmt -> for expr_list in test_list : suite
2650
conf
for_stmt -> for expr_list in test_list : suite
2650
(
for_stmt -> for expr_list in test_list : suite
2650
break
for_stmt -> for expr_list in test_list : suite
2650
for
for_stmt -> for expr_list in test_list : suite
2650
try
for_stmt -> for expr_list in test_list : suite
2650
NUMBER
for_stmt -> for expr_list in test_list : suite
2650
begsim
for_stmt -> for expr_list in test_list : suite
2650
True
for_stmt -> for expr_list in test_list : suite
2650
global
for_stmt -> for expr_list in test_list : suite
2650
DEDENT
for_stmt -> for expr_list in test_list : suite
2650
resetstats
for_stmt -> for expr_list in test_list : suite
2651
:
2685
2652
:
2686
2653
DEDENT
2687
2654
NEWLINE
2688
2655
DEDENT
2689
2656
for
lambdef_nocond -> lambda : test_nocond
2656
if
lambdef_nocond -> lambda : test_nocond
2656
)
lambdef_nocond -> lambda : test_nocond
2657
[
2004
2657
factor
2005
2657
True
2006
2657
atom_expr
2007
2657
~
2008
2657
and_expr
2009
2657
-
2010
2657
{
2011
2657
atom
2012
2657
arith_expr
2014
2657
power
2015
2657
STRING
2016
2657
NAME
2017
2657
test_nocond
2690
2657
(
2018
2657
and_test
2019
2657
term
2020
2657
+
2021
2657
xor_expr
2022
2657
shift_expr
2023
2657
lambda
2498
2657
or_test
2499
2657
NUMBER
2024
2657
not
2025
2657
False
2026
2657
expr
2027
2657
comparison
2028
2657
not_test
2029
2657
None
2030
2657
lambdef_nocond
2500
2658
]
lambdef_nocond -> lambda : test_nocond
2658
if
lambdef_nocond -> lambda : test_nocond
2658
for
lambdef_nocond -> lambda : test_nocond
2659
[
2031
2659
factor
2032
2659
True
2033
2659
atom_expr
2034
2659
~
2035
2659
not
2036
2659
and_expr
2037
2659
-
2038
2659
{
2039
2659
atom
2040
2659
(
2041
2659
arith_expr
2042
2659
power
2043
2659
STRING
2044
2659
NAME
2045
2659
and_test
2046
2659
term
2047
2659
+
2048
2659
xor_expr
2049
2659
shift_expr
2050
2659
lambda
2536
2659
NUMBER
2051
2659
False
2052
2659
expr
2053
2659
or_test
2537
2659
comparison
2054
2659
not_test
2055
2659
None
2056
2659
test_nocond
2691
2659
lambdef_nocond
2538
2660
=
test -> or_test if or_test else test
2660
,
test -> or_test if or_test else test
2660
)
test -> or_test if or_test else test
2661
del
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
None
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
raise
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
STRING
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
resetstats
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
nonlocal
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
server
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
modopt
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
global
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
begsim
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
assert
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
pass
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
(
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
lambda
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
NUMBER
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
{
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
class
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
False
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
if
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
@
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
endsim
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
-
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
NAME
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
break
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
True
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
~
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
return
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
servmod
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
+
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
yield
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
while
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
[
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
$
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
with
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
NEWLINE
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
continue
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
not
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
for
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
def
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
try
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2661
conf
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2662
[
128
2662
factor
129
2662
True
130
2662
atom_expr
131
2662
~
132
2662
and_expr
133
2662
-
134
2662
{
135
2662
shift_expr
137
2662
atom
138
2662
comparison
140
2662
arith_expr
141
2662
power
142
2662
STRING
143
2662
NAME
144
2662
(
145
2662
and_test
146
2662
term
147
2662
+
148
2662
xor_expr
149
2662
lambda
2625
2662
or_test
2626
2662
NUMBER
151
2662
not
152
2662
False
153
2662
expr
154
2662
not_test
155
2662
None
156
2662
lambdef_nocond
2627
2662
test_nocond
2692
2663
:
2693
2664
,
comp_if -> if test_nocond comp_iter
2664
)
comp_if -> if test_nocond comp_iter
2665
True
try_stmt -> try : suite except_clause finally : suite
2665
assert
try_stmt -> try : suite except_clause finally : suite
2665
conf
try_stmt -> try : suite except_clause finally : suite
2665
with
try_stmt -> try : suite except_clause finally : suite
2665
return
try_stmt -> try : suite except_clause finally : suite
2665
if
try_stmt -> try : suite except_clause finally : suite
2665
raise
try_stmt -> try : suite except_clause finally : suite
2665
~
try_stmt -> try : suite except_clause finally : suite
2665
not
try_stmt -> try : suite except_clause finally : suite
2665
@
try_stmt -> try : suite except_clause finally : suite
2665
del
try_stmt -> try : suite except_clause finally : suite
2665
continue
try_stmt -> try : suite except_clause finally : suite
2665
NUMBER
try_stmt -> try : suite except_clause finally : suite
2665
yield
try_stmt -> try : suite except_clause finally : suite
2665
server
try_stmt -> try : suite except_clause finally : suite
2665
try
try_stmt -> try : suite except_clause finally : suite
2665
resetstats
try_stmt -> try : suite except_clause finally : suite
2665
for
try_stmt -> try : suite except_clause finally : suite
2665
begsim
try_stmt -> try : suite except_clause finally : suite
2665
class
try_stmt -> try : suite except_clause finally : suite
2665
-
try_stmt -> try : suite except_clause finally : suite
2665
pass
try_stmt -> try : suite except_clause finally : suite
2665
endsim
try_stmt -> try : suite except_clause finally : suite
2665
None
try_stmt -> try : suite except_clause finally : suite
2665
while
try_stmt -> try : suite except_clause finally : suite
2665
break
try_stmt -> try : suite except_clause finally : suite
2665
STRING
try_stmt -> try : suite except_clause finally : suite
2665
[
try_stmt -> try : suite except_clause finally : suite
2665
nonlocal
try_stmt -> try : suite except_clause finally : suite
2665
DEDENT
try_stmt -> try : suite except_clause finally : suite
2665
(
try_stmt -> try : suite except_clause finally : suite
2665
lambda
try_stmt -> try : suite except_clause finally : suite
2665
+
try_stmt -> try : suite except_clause finally : suite
2665
modopt
try_stmt -> try : suite except_clause finally : suite
2665
global
try_stmt -> try : suite except_clause finally : suite
2665
False
try_stmt -> try : suite except_clause finally : suite
2665
NAME
try_stmt -> try : suite except_clause finally : suite
2665
def
try_stmt -> try : suite except_clause finally : suite
2665
servmod
try_stmt -> try : suite except_clause finally : suite
2665
{
try_stmt -> try : suite except_clause finally : suite
2666
NEWLINE
2694
2667
INDENT
2695
2668
modopt
suite -> simple_stmt
2668
~
suite -> simple_stmt
2668
False
suite -> simple_stmt
2668
@
suite -> simple_stmt
2668
begsim
suite -> simple_stmt
2668
NUMBER
suite -> simple_stmt
2668
conf
suite -> simple_stmt
2668
class
suite -> simple_stmt
2668
finally
suite -> simple_stmt
2668
if
suite -> simple_stmt
2668
yield
suite -> simple_stmt
2668
try
suite -> simple_stmt
2668
pass
suite -> simple_stmt
2668
[
suite -> simple_stmt
2668
break
suite -> simple_stmt
2668
True
suite -> simple_stmt
2668
DEDENT
suite -> simple_stmt
2668
None
suite -> simple_stmt
2668
server
suite -> simple_stmt
2668
assert
suite -> simple_stmt
2668
servmod
suite -> simple_stmt
2668
raise
suite -> simple_stmt
2668
nonlocal
suite -> simple_stmt
2668
lambda
suite -> simple_stmt
2668
return
suite -> simple_stmt
2668
+
suite -> simple_stmt
2668
-
suite -> simple_stmt
2668
NAME
suite -> simple_stmt
2668
while
suite -> simple_stmt
2668
def
suite -> simple_stmt
2668
with
suite -> simple_stmt
2668
del
suite -> simple_stmt
2668
STRING
suite -> simple_stmt
2668
for
suite -> simple_stmt
2668
resetstats
suite -> simple_stmt
2668
global
suite -> simple_stmt
2668
continue
suite -> simple_stmt
2668
endsim
suite -> simple_stmt
2668
not
suite -> simple_stmt
2668
{
suite -> simple_stmt
2668
(
suite -> simple_stmt
2669
finally
2696
2669
server
try_stmt -> try : suite except_clause else : suite
2669
endsim
try_stmt -> try : suite except_clause else : suite
2669
lambda
try_stmt -> try : suite except_clause else : suite
2669
False
try_stmt -> try : suite except_clause else : suite
2669
del
try_stmt -> try : suite except_clause else : suite
2669
(
try_stmt -> try : suite except_clause else : suite
2669
global
try_stmt -> try : suite except_clause else : suite
2669
continue
try_stmt -> try : suite except_clause else : suite
2669
with
try_stmt -> try : suite except_clause else : suite
2669
nonlocal
try_stmt -> try : suite except_clause else : suite
2669
conf
try_stmt -> try : suite except_clause else : suite
2669
begsim
try_stmt -> try : suite except_clause else : suite
2669
NUMBER
try_stmt -> try : suite except_clause else : suite
2669
[
try_stmt -> try : suite except_clause else : suite
2669
~
try_stmt -> try : suite except_clause else : suite
2669
True
try_stmt -> try : suite except_clause else : suite
2669
class
try_stmt -> try : suite except_clause else : suite
2669
{
try_stmt -> try : suite except_clause else : suite
2669
assert
try_stmt -> try : suite except_clause else : suite
2669
break
try_stmt -> try : suite except_clause else : suite
2669
for
try_stmt -> try : suite except_clause else : suite
2669
not
try_stmt -> try : suite except_clause else : suite
2669
NAME
try_stmt -> try : suite except_clause else : suite
2669
try
try_stmt -> try : suite except_clause else : suite
2669
def
try_stmt -> try : suite except_clause else : suite
2669
while
try_stmt -> try : suite except_clause else : suite
2669
return
try_stmt -> try : suite except_clause else : suite
2669
@
try_stmt -> try : suite except_clause else : suite
2669
None
try_stmt -> try : suite except_clause else : suite
2669
DEDENT
try_stmt -> try : suite except_clause else : suite
2669
+
try_stmt -> try : suite except_clause else : suite
2669
STRING
try_stmt -> try : suite except_clause else : suite
2669
if
try_stmt -> try : suite except_clause else : suite
2669
yield
try_stmt -> try : suite except_clause else : suite
2669
servmod
try_stmt -> try : suite except_clause else : suite
2669
raise
try_stmt -> try : suite except_clause else : suite
2669
-
try_stmt -> try : suite except_clause else : suite
2669
modopt
try_stmt -> try : suite except_clause else : suite
2669
pass
try_stmt -> try : suite except_clause else : suite
2669
resetstats
try_stmt -> try : suite except_clause else : suite
2670
:
2697
2671
except
2460
2671
None
maybe_except_clause -> 
2671
if
maybe_except_clause -> 
2671
while
maybe_except_clause -> 
2671
return
maybe_except_clause -> 
2671
continue
maybe_except_clause -> 
2671
except_clause
2675
2671
server
maybe_except_clause -> 
2671
nonlocal
maybe_except_clause -> 
2671
maybe_except_clause
2698
2671
def
maybe_except_clause -> 
2671
servmod
maybe_except_clause -> 
2671
endsim
maybe_except_clause -> 
2671
else
maybe_except_clause -> 
2671
global
maybe_except_clause -> 
2671
conf
maybe_except_clause -> 
2671
pass
maybe_except_clause -> 
2671
True
maybe_except_clause -> 
2671
NUMBER
maybe_except_clause -> 
2671
try
maybe_except_clause -> 
2671
False
maybe_except_clause -> 
2671
~
maybe_except_clause -> 
2671
with
maybe_except_clause -> 
2671
not
maybe_except_clause -> 
2671
NAME
maybe_except_clause -> 
2671
@
maybe_except_clause -> 
2671
(
maybe_except_clause -> 
2671
yield
maybe_except_clause -> 
2671
[
maybe_except_clause -> 
2671
finally
maybe_except_clause -> 
2671
-
maybe_except_clause -> 
2671
raise
maybe_except_clause -> 
2671
{
maybe_except_clause -> 
2671
assert
maybe_except_clause -> 
2671
class
maybe_except_clause -> 
2671
break
maybe_except_clause -> 
2671
+
maybe_except_clause -> 
2671
STRING
maybe_except_clause -> 
2671
del
maybe_except_clause -> 
2671
begsim
maybe_except_clause -> 
2671
lambda
maybe_except_clause -> 
2671
resetstats
maybe_except_clause -> 
2671
DEDENT
maybe_except_clause -> 
2671
for
maybe_except_clause -> 
2671
modopt
maybe_except_clause -> 
2672
del
simple_stmt -> small_stmt NEWLINE
2672
finally
simple_stmt -> small_stmt NEWLINE
2672
break
simple_stmt -> small_stmt NEWLINE
2672
raise
simple_stmt -> small_stmt NEWLINE
2672
servmod
simple_stmt -> small_stmt NEWLINE
2672
class
simple_stmt -> small_stmt NEWLINE
2672
not
simple_stmt -> small_stmt NEWLINE
2672
-
simple_stmt -> small_stmt NEWLINE
2672
except
simple_stmt -> small_stmt NEWLINE
2672
False
simple_stmt -> small_stmt NEWLINE
2672
(
simple_stmt -> small_stmt NEWLINE
2672
endsim
simple_stmt -> small_stmt NEWLINE
2672
+
simple_stmt -> small_stmt NEWLINE
2672
None
simple_stmt -> small_stmt NEWLINE
2672
resetstats
simple_stmt -> small_stmt NEWLINE
2672
conf
simple_stmt -> small_stmt NEWLINE
2672
server
simple_stmt -> small_stmt NEWLINE
2672
STRING
simple_stmt -> small_stmt NEWLINE
2672
else
simple_stmt -> small_stmt NEWLINE
2672
if
simple_stmt -> small_stmt NEWLINE
2672
NUMBER
simple_stmt -> small_stmt NEWLINE
2672
global
simple_stmt -> small_stmt NEWLINE
2672
@
simple_stmt -> small_stmt NEWLINE
2672
True
simple_stmt -> small_stmt NEWLINE
2672
lambda
simple_stmt -> small_stmt NEWLINE
2672
pass
simple_stmt -> small_stmt NEWLINE
2672
return
simple_stmt -> small_stmt NEWLINE
2672
def
simple_stmt -> small_stmt NEWLINE
2672
with
simple_stmt -> small_stmt NEWLINE
2672
nonlocal
simple_stmt -> small_stmt NEWLINE
2672
assert
simple_stmt -> small_stmt NEWLINE
2672
NAME
simple_stmt -> small_stmt NEWLINE
2672
try
simple_stmt -> small_stmt NEWLINE
2672
begsim
simple_stmt -> small_stmt NEWLINE
2672
while
simple_stmt -> small_stmt NEWLINE
2672
for
simple_stmt -> small_stmt NEWLINE
2672
[
simple_stmt -> small_stmt NEWLINE
2672
modopt
simple_stmt -> small_stmt NEWLINE
2672
yield
simple_stmt -> small_stmt NEWLINE
2672
DEDENT
simple_stmt -> small_stmt NEWLINE
2672
continue
simple_stmt -> small_stmt NEWLINE
2672
{
simple_stmt -> small_stmt NEWLINE
2672
~
simple_stmt -> small_stmt NEWLINE
2673
arith_expr
1
2673
try
1533
2673
modopt
1534
2673
compound_stmt
1535
2673
test
5
2673
servmod
1536
2673
while
1537
2673
and_expr
8
2673
power
9
2673
STRING
10
2673
decorated
1538
2673
cli_serv_model
1539
2673
@
13
2673
try_stmt
1540
2673
lambdef
15
2673
stmt_list
2699
2673
(
16
2673
factor
17
2673
[
18
2673
class
1541
2673
small_stmt
1542
2673
{
21
2673
term
22
2673
def
1543
2673
server
1544
2673
while_stmt
1545
2673
-
26
2673
+
27
2673
for
1546
2673
if
1547
2673
lambda
29
2673
decorators
1548
2673
atom_expr
31
2673
not_test
32
2673
if_stmt
1549
2673
yield
34
2673
conf
1550
2673
test_list
36
2673
~
37
2673
True
38
2673
False
39
2673
funcdef
1551
2673
xor_expr
41
2673
with
1552
2673
for_stmt
1553
2673
sim_stmt
45
2673
and_test
46
2673
expr
47
2673
shift_expr
48
2673
comparison
49
2673
with_stmt
1554
2673
simple_stmt
1555
2673
NAME
52
2673
or_test
53
2673
confdef
1556
2673
None
55
2673
classdef
1557
2673
atom
57
2673
NUMBER
58
2673
return
59
2673
break_stmt
60
2673
return_stmt
61
2673
stmt
1558
2673
not
62
2673
break
63
2673
raise
64
2673
expr_stmt
65
2673
stat_stmt
66
2673
decorator
67
2673
assert_stmt
68
2673
begsim
69
2673
global
70
2673
assert
71
2673
nonlocal
72
2673
nonlocal_stmt
73
2673
raise_stmt
74
2673
yield_stmt
75
2673
continue
77
2673
endsim
78
2673
del
80
2673
pass_stmt
81
2673
flow_stmt
82
2673
resetstats
84
2673
del_stmt
85
2673
continue_stmt
86
2673
global_stmt
87
2673
pass
88
2674
server
except_clause -> except : suite maybe_except_clause
2674
class
except_clause -> except : suite maybe_except_clause
2674
global
except_clause -> except : suite maybe_except_clause
2674
endsim
except_clause -> except : suite maybe_except_clause
2674
pass
except_clause -> except : suite maybe_except_clause
2674
yield
except_clause -> except : suite maybe_except_clause
2674
resetstats
except_clause -> except : suite maybe_except_clause
2674
~
except_clause -> except : suite maybe_except_clause
2674
not
except_clause -> except : suite maybe_except_clause
2674
while
except_clause -> except : suite maybe_except_clause
2674
@
except_clause -> except : suite maybe_except_clause
2674
{
except_clause -> except : suite maybe_except_clause
2674
True
except_clause -> except : suite maybe_except_clause
2674
finally
except_clause -> except : suite maybe_except_clause
2674
else
except_clause -> except : suite maybe_except_clause
2674
with
except_clause -> except : suite maybe_except_clause
2674
DEDENT
except_clause -> except : suite maybe_except_clause
2674
if
except_clause -> except : suite maybe_except_clause
2674
NAME
except_clause -> except : suite maybe_except_clause
2674
False
except_clause -> except : suite maybe_except_clause
2674
nonlocal
except_clause -> except : suite maybe_except_clause
2674
return
except_clause -> except : suite maybe_except_clause
2674
None
except_clause -> except : suite maybe_except_clause
2674
+
except_clause -> except : suite maybe_except_clause
2674
begsim
except_clause -> except : suite maybe_except_clause
2674
def
except_clause -> except : suite maybe_except_clause
2674
assert
except_clause -> except : suite maybe_except_clause
2674
modopt
except_clause -> except : suite maybe_except_clause
2674
try
except_clause -> except : suite maybe_except_clause
2674
break
except_clause -> except : suite maybe_except_clause
2674
STRING
except_clause -> except : suite maybe_except_clause
2674
NUMBER
except_clause -> except : suite maybe_except_clause
2674
raise
except_clause -> except : suite maybe_except_clause
2674
-
except_clause -> except : suite maybe_except_clause
2674
continue
except_clause -> except : suite maybe_except_clause
2674
servmod
except_clause -> except : suite maybe_except_clause
2674
(
except_clause -> except : suite maybe_except_clause
2674
del
except_clause -> except : suite maybe_except_clause
2674
[
except_clause -> except : suite maybe_except_clause
2674
conf
except_clause -> except : suite maybe_except_clause
2674
for
except_clause -> except : suite maybe_except_clause
2674
lambda
except_clause -> except : suite maybe_except_clause
2675
DEDENT
maybe_except_clause -> except_clause
2675
continue
maybe_except_clause -> except_clause
2675
def
maybe_except_clause -> except_clause
2675
lambda
maybe_except_clause -> except_clause
2675
servmod
maybe_except_clause -> except_clause
2675
(
maybe_except_clause -> except_clause
2675
for
maybe_except_clause -> except_clause
2675
True
maybe_except_clause -> except_clause
2675
yield
maybe_except_clause -> except_clause
2675
not
maybe_except_clause -> except_clause
2675
while
maybe_except_clause -> except_clause
2675
+
maybe_except_clause -> except_clause
2675
with
maybe_except_clause -> except_clause
2675
endsim
maybe_except_clause -> except_clause
2675
server
maybe_except_clause -> except_clause
2675
break
maybe_except_clause -> except_clause
2675
-
maybe_except_clause -> except_clause
2675
NUMBER
maybe_except_clause -> except_clause
2675
class
maybe_except_clause -> except_clause
2675
return
maybe_except_clause -> except_clause
2675
modopt
maybe_except_clause -> except_clause
2675
None
maybe_except_clause -> except_clause
2675
global
maybe_except_clause -> except_clause
2675
NAME
maybe_except_clause -> except_clause
2675
finally
maybe_except_clause -> except_clause
2675
STRING
maybe_except_clause -> except_clause
2675
try
maybe_except_clause -> except_clause
2675
pass
maybe_except_clause -> except_clause
2675
[
maybe_except_clause -> except_clause
2675
@
maybe_except_clause -> except_clause
2675
raise
maybe_except_clause -> except_clause
2675
del
maybe_except_clause -> except_clause
2675
conf
maybe_except_clause -> except_clause
2675
~
maybe_except_clause -> except_clause
2675
False
maybe_except_clause -> except_clause
2675
{
maybe_except_clause -> except_clause
2675
begsim
maybe_except_clause -> except_clause
2675
else
maybe_except_clause -> except_clause
2675
resetstats
maybe_except_clause -> except_clause
2675
if
maybe_except_clause -> except_clause
2675
assert
maybe_except_clause -> except_clause
2675
nonlocal
maybe_except_clause -> except_clause
2676
servmod
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
del
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
-
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
conf
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
yield
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
None
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
server
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
resetstats
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
continue
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
while
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
begsim
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
for
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
endsim
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
with
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
NUMBER
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
lambda
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
[
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
pass
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
raise
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
if
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
assert
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
modopt
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
try
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
+
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
True
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
class
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
not
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
nonlocal
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
(
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
~
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
DEDENT
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
break
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
NAME
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
@
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
def
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
False
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
STRING
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
return
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
global
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2676
{
cli_serv_model -> modopt NAME : NEWLINE INDENT confbody DEDENT
2677
yield
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
continue
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
conf
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
NUMBER
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
nonlocal
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
del
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
try
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
None
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
assert
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
while
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
pass
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
servmod
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
with
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
break
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
lambda
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
begsim
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
{
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
[
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
-
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
+
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
global
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
server
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
if
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
def
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
True
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
class
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
for
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
~
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
modopt
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
(
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
STRING
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
NAME
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
return
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
not
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
@
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
resetstats
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
DEDENT
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
False
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
raise
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2677
endsim
cli_serv_model -> servmod NAME : NEWLINE INDENT confbody DEDENT
2678
None
while_stmt -> while test : suite else : suite
2678
try
while_stmt -> while test : suite else : suite
2678
resetstats
while_stmt -> while test : suite else : suite
2678
return
while_stmt -> while test : suite else : suite
2678
-
while_stmt -> while test : suite else : suite
2678
{
while_stmt -> while test : suite else : suite
2678
(
while_stmt -> while test : suite else : suite
2678
conf
while_stmt -> while test : suite else : suite
2678
nonlocal
while_stmt -> while test : suite else : suite
2678
+
while_stmt -> while test : suite else : suite
2678
while
while_stmt -> while test : suite else : suite
2678
endsim
while_stmt -> while test : suite else : suite
2678
NUMBER
while_stmt -> while test : suite else : suite
2678
True
while_stmt -> while test : suite else : suite
2678
NAME
while_stmt -> while test : suite else : suite
2678
yield
while_stmt -> while test : suite else : suite
2678
servmod
while_stmt -> while test : suite else : suite
2678
@
while_stmt -> while test : suite else : suite
2678
server
while_stmt -> while test : suite else : suite
2678
raise
while_stmt -> while test : suite else : suite
2678
continue
while_stmt -> while test : suite else : suite
2678
break
while_stmt -> while test : suite else : suite
2678
begsim
while_stmt -> while test : suite else : suite
2678
STRING
while_stmt -> while test : suite else : suite
2678
modopt
while_stmt -> while test : suite else : suite
2678
for
while_stmt -> while test : suite else : suite
2678
not
while_stmt -> while test : suite else : suite
2678
def
while_stmt -> while test : suite else : suite
2678
assert
while_stmt -> while test : suite else : suite
2678
if
while_stmt -> while test : suite else : suite
2678
del
while_stmt -> while test : suite else : suite
2678
class
while_stmt -> while test : suite else : suite
2678
~
while_stmt -> while test : suite else : suite
2678
pass
while_stmt -> while test : suite else : suite
2678
with
while_stmt -> while test : suite else : suite
2678
lambda
while_stmt -> while test : suite else : suite
2678
global
while_stmt -> while test : suite else : suite
2678
DEDENT
while_stmt -> while test : suite else : suite
2678
[
while_stmt -> while test : suite else : suite
2678
False
while_stmt -> while test : suite else : suite
2679
+
suite -> NEWLINE INDENT stmt_list DEDENT
2679
False
suite -> NEWLINE INDENT stmt_list DEDENT
2679
[
suite -> NEWLINE INDENT stmt_list DEDENT
2679
pass
suite -> NEWLINE INDENT stmt_list DEDENT
2679
continue
suite -> NEWLINE INDENT stmt_list DEDENT
2679
break
suite -> NEWLINE INDENT stmt_list DEDENT
2679
lambda
suite -> NEWLINE INDENT stmt_list DEDENT
2679
NUMBER
suite -> NEWLINE INDENT stmt_list DEDENT
2679
True
suite -> NEWLINE INDENT stmt_list DEDENT
2679
conf
suite -> NEWLINE INDENT stmt_list DEDENT
2679
endsim
suite -> NEWLINE INDENT stmt_list DEDENT
2679
server
suite -> NEWLINE INDENT stmt_list DEDENT
2679
raise
suite -> NEWLINE INDENT stmt_list DEDENT
2679
del
suite -> NEWLINE INDENT stmt_list DEDENT
2679
class
suite -> NEWLINE INDENT stmt_list DEDENT
2679
global
suite -> NEWLINE INDENT stmt_list DEDENT
2679
DEDENT
suite -> NEWLINE INDENT stmt_list DEDENT
2679
def
suite -> NEWLINE INDENT stmt_list DEDENT
2679
@
suite -> NEWLINE INDENT stmt_list DEDENT
2679
if
suite -> NEWLINE INDENT stmt_list DEDENT
2679
else
suite -> NEWLINE INDENT stmt_list DEDENT
2679
nonlocal
suite -> NEWLINE INDENT stmt_list DEDENT
2679
-
suite -> NEWLINE INDENT stmt_list DEDENT
2679
NAME
suite -> NEWLINE INDENT stmt_list DEDENT
2679
yield
suite -> NEWLINE INDENT stmt_list DEDENT
2679
~
suite -> NEWLINE INDENT stmt_list DEDENT
2679
modopt
suite -> NEWLINE INDENT stmt_list DEDENT
2679
{
suite -> NEWLINE INDENT stmt_list DEDENT
2679
servmod
suite -> NEWLINE INDENT stmt_list DEDENT
2679
begsim
suite -> NEWLINE INDENT stmt_list DEDENT
2679
not
suite -> NEWLINE INDENT stmt_list DEDENT
2679
assert
suite -> NEWLINE INDENT stmt_list DEDENT
2679
with
suite -> NEWLINE INDENT stmt_list DEDENT
2679
None
suite -> NEWLINE INDENT stmt_list DEDENT
2679
resetstats
suite -> NEWLINE INDENT stmt_list DEDENT
2679
try
suite -> NEWLINE INDENT stmt_list DEDENT
2679
while
suite -> NEWLINE INDENT stmt_list DEDENT
2679
return
suite -> NEWLINE INDENT stmt_list DEDENT
2679
for
suite -> NEWLINE INDENT stmt_list DEDENT
2679
STRING
suite -> NEWLINE INDENT stmt_list DEDENT
2679
(
suite -> NEWLINE INDENT stmt_list DEDENT
2680
-
classdef -> class NAME ( arglist ) : suite
2680
~
classdef -> class NAME ( arglist ) : suite
2680
class
classdef -> class NAME ( arglist ) : suite
2680
endsim
classdef -> class NAME ( arglist ) : suite
2680
NAME
classdef -> class NAME ( arglist ) : suite
2680
{
classdef -> class NAME ( arglist ) : suite
2680
begsim
classdef -> class NAME ( arglist ) : suite
2680
+
classdef -> class NAME ( arglist ) : suite
2680
None
classdef -> class NAME ( arglist ) : suite
2680
not
classdef -> class NAME ( arglist ) : suite
2680
return
classdef -> class NAME ( arglist ) : suite
2680
pass
classdef -> class NAME ( arglist ) : suite
2680
resetstats
classdef -> class NAME ( arglist ) : suite
2680
global
classdef -> class NAME ( arglist ) : suite
2680
[
classdef -> class NAME ( arglist ) : suite
2680
@
classdef -> class NAME ( arglist ) : suite
2680
modopt
classdef -> class NAME ( arglist ) : suite
2680
with
classdef -> class NAME ( arglist ) : suite
2680
server
classdef -> class NAME ( arglist ) : suite
2680
assert
classdef -> class NAME ( arglist ) : suite
2680
conf
classdef -> class NAME ( arglist ) : suite
2680
lambda
classdef -> class NAME ( arglist ) : suite
2680
while
classdef -> class NAME ( arglist ) : suite
2680
continue
classdef -> class NAME ( arglist ) : suite
2680
False
classdef -> class NAME ( arglist ) : suite
2680
DEDENT
classdef -> class NAME ( arglist ) : suite
2680
break
classdef -> class NAME ( arglist ) : suite
2680
del
classdef -> class NAME ( arglist ) : suite
2680
NUMBER
classdef -> class NAME ( arglist ) : suite
2680
try
classdef -> class NAME ( arglist ) : suite
2680
yield
classdef -> class NAME ( arglist ) : suite
2680
if
classdef -> class NAME ( arglist ) : suite
2680
nonlocal
classdef -> class NAME ( arglist ) : suite
2680
for
classdef -> class NAME ( arglist ) : suite
2680
raise
classdef -> class NAME ( arglist ) : suite
2680
STRING
classdef -> class NAME ( arglist ) : suite
2680
(
classdef -> class NAME ( arglist ) : suite
2680
servmod
classdef -> class NAME ( arglist ) : suite
2680
def
classdef -> class NAME ( arglist ) : suite
2680
True
classdef -> class NAME ( arglist ) : suite
2681
+
suite -> NEWLINE INDENT stmt_list DEDENT
2681
False
suite -> NEWLINE INDENT stmt_list DEDENT
2681
[
suite -> NEWLINE INDENT stmt_list DEDENT
2681
pass
suite -> NEWLINE INDENT stmt_list DEDENT
2681
continue
suite -> NEWLINE INDENT stmt_list DEDENT
2681
break
suite -> NEWLINE INDENT stmt_list DEDENT
2681
lambda
suite -> NEWLINE INDENT stmt_list DEDENT
2681
NUMBER
suite -> NEWLINE INDENT stmt_list DEDENT
2681
True
suite -> NEWLINE INDENT stmt_list DEDENT
2681
conf
suite -> NEWLINE INDENT stmt_list DEDENT
2681
endsim
suite -> NEWLINE INDENT stmt_list DEDENT
2681
server
suite -> NEWLINE INDENT stmt_list DEDENT
2681
raise
suite -> NEWLINE INDENT stmt_list DEDENT
2681
del
suite -> NEWLINE INDENT stmt_list DEDENT
2681
class
suite -> NEWLINE INDENT stmt_list DEDENT
2681
global
suite -> NEWLINE INDENT stmt_list DEDENT
2681
DEDENT
suite -> NEWLINE INDENT stmt_list DEDENT
2681
def
suite -> NEWLINE INDENT stmt_list DEDENT
2681
@
suite -> NEWLINE INDENT stmt_list DEDENT
2681
if
suite -> NEWLINE INDENT stmt_list DEDENT
2681
nonlocal
suite -> NEWLINE INDENT stmt_list DEDENT
2681
-
suite -> NEWLINE INDENT stmt_list DEDENT
2681
NAME
suite -> NEWLINE INDENT stmt_list DEDENT
2681
yield
suite -> NEWLINE INDENT stmt_list DEDENT
2681
~
suite -> NEWLINE INDENT stmt_list DEDENT
2681
modopt
suite -> NEWLINE INDENT stmt_list DEDENT
2681
{
suite -> NEWLINE INDENT stmt_list DEDENT
2681
servmod
suite -> NEWLINE INDENT stmt_list DEDENT
2681
begsim
suite -> NEWLINE INDENT stmt_list DEDENT
2681
not
suite -> NEWLINE INDENT stmt_list DEDENT
2681
assert
suite -> NEWLINE INDENT stmt_list DEDENT
2681
with
suite -> NEWLINE INDENT stmt_list DEDENT
2681
None
suite -> NEWLINE INDENT stmt_list DEDENT
2681
resetstats
suite -> NEWLINE INDENT stmt_list DEDENT
2681
try
suite -> NEWLINE INDENT stmt_list DEDENT
2681
while
suite -> NEWLINE INDENT stmt_list DEDENT
2681
return
suite -> NEWLINE INDENT stmt_list DEDENT
2681
for
suite -> NEWLINE INDENT stmt_list DEDENT
2681
STRING
suite -> NEWLINE INDENT stmt_list DEDENT
2681
(
suite -> NEWLINE INDENT stmt_list DEDENT
2682
resetstats
funcdef -> def NAME ( parameters ) : suite
2682
return
funcdef -> def NAME ( parameters ) : suite
2682
servmod
funcdef -> def NAME ( parameters ) : suite
2682
begsim
funcdef -> def NAME ( parameters ) : suite
2682
STRING
funcdef -> def NAME ( parameters ) : suite
2682
DEDENT
funcdef -> def NAME ( parameters ) : suite
2682
with
funcdef -> def NAME ( parameters ) : suite
2682
continue
funcdef -> def NAME ( parameters ) : suite
2682
endsim
funcdef -> def NAME ( parameters ) : suite
2682
def
funcdef -> def NAME ( parameters ) : suite
2682
NAME
funcdef -> def NAME ( parameters ) : suite
2682
raise
funcdef -> def NAME ( parameters ) : suite
2682
pass
funcdef -> def NAME ( parameters ) : suite
2682
try
funcdef -> def NAME ( parameters ) : suite
2682
-
funcdef -> def NAME ( parameters ) : suite
2682
{
funcdef -> def NAME ( parameters ) : suite
2682
modopt
funcdef -> def NAME ( parameters ) : suite
2682
server
funcdef -> def NAME ( parameters ) : suite
2682
conf
funcdef -> def NAME ( parameters ) : suite
2682
nonlocal
funcdef -> def NAME ( parameters ) : suite
2682
assert
funcdef -> def NAME ( parameters ) : suite
2682
global
funcdef -> def NAME ( parameters ) : suite
2682
(
funcdef -> def NAME ( parameters ) : suite
2682
[
funcdef -> def NAME ( parameters ) : suite
2682
del
funcdef -> def NAME ( parameters ) : suite
2682
for
funcdef -> def NAME ( parameters ) : suite
2682
lambda
funcdef -> def NAME ( parameters ) : suite
2682
+
funcdef -> def NAME ( parameters ) : suite
2682
True
funcdef -> def NAME ( parameters ) : suite
2682
break
funcdef -> def NAME ( parameters ) : suite
2682
not
funcdef -> def NAME ( parameters ) : suite
2682
while
funcdef -> def NAME ( parameters ) : suite
2682
class
funcdef -> def NAME ( parameters ) : suite
2682
NUMBER
funcdef -> def NAME ( parameters ) : suite
2682
@
funcdef -> def NAME ( parameters ) : suite
2682
~
funcdef -> def NAME ( parameters ) : suite
2682
yield
funcdef -> def NAME ( parameters ) : suite
2682
if
funcdef -> def NAME ( parameters ) : suite
2682
None
funcdef -> def NAME ( parameters ) : suite
2682
False
funcdef -> def NAME ( parameters ) : suite
2683
@
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
+
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
server
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
STRING
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
-
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
~
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
servmod
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
{
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
break
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
True
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
raise
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
NUMBER
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
modopt
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
return
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
with
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
NAME
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
False
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
nonlocal
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
begsim
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
if
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
lambda
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
endsim
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
continue
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
try
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
not
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
global
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
yield
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
assert
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
pass
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
resetstats
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
DEDENT
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
[
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
for
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
while
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
class
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
conf
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
(
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
None
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
def
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2683
del
cli_serv_model -> server NAME : NEWLINE INDENT confbody DEDENT
2684
:
2700
2685
arith_expr
1
2685
small_stmt
1542
2685
factor
17
2685
True
38
2685
atom_expr
31
2685
term
22
2685
-
26
2685
None
55
2685
atom
57
2685
test
5
2685
comparison
49
2685
and_expr
8
2685
power
9
2685
STRING
10
2685
NAME
52
2685
shift_expr
48
2685
lambdef
15
2685
NUMBER
58
2685
simple_stmt
2469
2685
(
16
2685
expr
47
2685
[
18
2685
NEWLINE
2470
2685
not_test
32
2685
{
21
2685
and_test
46
2685
+
27
2685
lambda
29
2685
xor_expr
41
2685
suite
2701
2685
yield
34
2685
not
62
2685
test_list
36
2685
~
37
2685
or_test
53
2685
False
39
2685
sim_stmt
45
2685
nonlocal
72
2685
nonlocal_stmt
73
2685
return
59
2685
break_stmt
60
2685
return_stmt
61
2685
raise_stmt
74
2685
break
63
2685
yield_stmt
75
2685
raise
64
2685
continue
77
2685
expr_stmt
65
2685
endsim
78
2685
del
80
2685
pass_stmt
81
2685
flow_stmt
82
2685
stat_stmt
66
2685
assert_stmt
68
2685
resetstats
84
2685
del_stmt
85
2685
continue_stmt
86
2685
begsim
69
2685
global_stmt
87
2685
pass
88
2685
global
70
2685
assert
71
2686
arith_expr
1
2686
small_stmt
2476
2686
factor
17
2686
True
38
2686
atom_expr
31
2686
term
22
2686
-
26
2686
None
55
2686
atom
57
2686
test
5
2686
comparison
49
2686
suite
2702
2686
and_expr
8
2686
power
9
2686
STRING
10
2686
NAME
52
2686
shift_expr
48
2686
lambdef
15
2686
NUMBER
58
2686
simple_stmt
2477
2686
(
16
2686
expr
47
2686
[
18
2686
NEWLINE
2479
2686
not_test
32
2686
{
21
2686
and_test
46
2686
+
27
2686
lambda
29
2686
xor_expr
41
2686
yield
34
2686
not
62
2686
test_list
36
2686
~
37
2686
or_test
53
2686
False
39
2686
sim_stmt
45
2686
nonlocal
72
2686
nonlocal_stmt
73
2686
return
59
2686
break_stmt
60
2686
return_stmt
61
2686
raise_stmt
74
2686
break
63
2686
yield_stmt
75
2686
raise
64
2686
continue
77
2686
expr_stmt
65
2686
endsim
78
2686
del
80
2686
pass_stmt
81
2686
flow_stmt
82
2686
stat_stmt
66
2686
assert_stmt
68
2686
resetstats
84
2686
del_stmt
85
2686
continue_stmt
86
2686
begsim
69
2686
global_stmt
87
2686
pass
88
2686
global
70
2686
assert
71
2687
+
suite -> NEWLINE INDENT stmt_list DEDENT
2687
False
suite -> NEWLINE INDENT stmt_list DEDENT
2687
[
suite -> NEWLINE INDENT stmt_list DEDENT
2687
pass
suite -> NEWLINE INDENT stmt_list DEDENT
2687
continue
suite -> NEWLINE INDENT stmt_list DEDENT
2687
break
suite -> NEWLINE INDENT stmt_list DEDENT
2687
lambda
suite -> NEWLINE INDENT stmt_list DEDENT
2687
NUMBER
suite -> NEWLINE INDENT stmt_list DEDENT
2687
True
suite -> NEWLINE INDENT stmt_list DEDENT
2687
elif
suite -> NEWLINE INDENT stmt_list DEDENT
2687
conf
suite -> NEWLINE INDENT stmt_list DEDENT
2687
endsim
suite -> NEWLINE INDENT stmt_list DEDENT
2687
server
suite -> NEWLINE INDENT stmt_list DEDENT
2687
raise
suite -> NEWLINE INDENT stmt_list DEDENT
2687
del
suite -> NEWLINE INDENT stmt_list DEDENT
2687
class
suite -> NEWLINE INDENT stmt_list DEDENT
2687
global
suite -> NEWLINE INDENT stmt_list DEDENT
2687
DEDENT
suite -> NEWLINE INDENT stmt_list DEDENT
2687
def
suite -> NEWLINE INDENT stmt_list DEDENT
2687
@
suite -> NEWLINE INDENT stmt_list DEDENT
2687
if
suite -> NEWLINE INDENT stmt_list DEDENT
2687
else
suite -> NEWLINE INDENT stmt_list DEDENT
2687
nonlocal
suite -> NEWLINE INDENT stmt_list DEDENT
2687
-
suite -> NEWLINE INDENT stmt_list DEDENT
2687
NAME
suite -> NEWLINE INDENT stmt_list DEDENT
2687
yield
suite -> NEWLINE INDENT stmt_list DEDENT
2687
~
suite -> NEWLINE INDENT stmt_list DEDENT
2687
modopt
suite -> NEWLINE INDENT stmt_list DEDENT
2687
{
suite -> NEWLINE INDENT stmt_list DEDENT
2687
servmod
suite -> NEWLINE INDENT stmt_list DEDENT
2687
begsim
suite -> NEWLINE INDENT stmt_list DEDENT
2687
not
suite -> NEWLINE INDENT stmt_list DEDENT
2687
assert
suite -> NEWLINE INDENT stmt_list DEDENT
2687
with
suite -> NEWLINE INDENT stmt_list DEDENT
2687
None
suite -> NEWLINE INDENT stmt_list DEDENT
2687
resetstats
suite -> NEWLINE INDENT stmt_list DEDENT
2687
try
suite -> NEWLINE INDENT stmt_list DEDENT
2687
while
suite -> NEWLINE INDENT stmt_list DEDENT
2687
return
suite -> NEWLINE INDENT stmt_list DEDENT
2687
for
suite -> NEWLINE INDENT stmt_list DEDENT
2687
STRING
suite -> NEWLINE INDENT stmt_list DEDENT
2687
(
suite -> NEWLINE INDENT stmt_list DEDENT
2688
INDENT
2703
2689
class
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
DEDENT
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
try
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
modopt
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
nonlocal
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
@
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
-
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
continue
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
for
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
True
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
pass
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
raise
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
endsim
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
STRING
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
resetstats
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
None
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
del
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
(
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
False
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
if
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
NUMBER
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
def
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
not
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
while
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
[
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
~
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
break
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
return
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
with
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
global
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
lambda
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
NAME
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
begsim
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
conf
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
{
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
server
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
assert
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
servmod
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
yield
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2689
+
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2690
for
lambdef_nocond -> lambda varargslist : test_nocond
2690
if
lambdef_nocond -> lambda varargslist : test_nocond
2690
)
lambdef_nocond -> lambda varargslist : test_nocond
2691
for
lambdef_nocond -> lambda varargslist : test_nocond
2691
if
lambdef_nocond -> lambda varargslist : test_nocond
2691
]
lambdef_nocond -> lambda varargslist : test_nocond
2692
,
lambdef_nocond -> lambda : test_nocond
2692
if
lambdef_nocond -> lambda : test_nocond
2692
)
lambdef_nocond -> lambda : test_nocond
2692
for
lambdef_nocond -> lambda : test_nocond
2693
[
128
2693
factor
129
2693
True
130
2693
atom_expr
131
2693
~
132
2693
and_expr
133
2693
-
134
2693
{
135
2693
shift_expr
137
2693
atom
138
2693
comparison
140
2693
arith_expr
141
2693
power
142
2693
STRING
143
2693
NAME
144
2693
test_nocond
2704
2693
(
145
2693
and_test
146
2693
term
147
2693
+
148
2693
xor_expr
149
2693
lambda
2625
2693
or_test
2626
2693
NUMBER
151
2693
not
152
2693
False
153
2693
expr
154
2693
not_test
155
2693
None
156
2693
lambdef_nocond
2627
2694
del
simple_stmt -> small_stmt NEWLINE
2694
finally
simple_stmt -> small_stmt NEWLINE
2694
break
simple_stmt -> small_stmt NEWLINE
2694
raise
simple_stmt -> small_stmt NEWLINE
2694
servmod
simple_stmt -> small_stmt NEWLINE
2694
class
simple_stmt -> small_stmt NEWLINE
2694
not
simple_stmt -> small_stmt NEWLINE
2694
-
simple_stmt -> small_stmt NEWLINE
2694
False
simple_stmt -> small_stmt NEWLINE
2694
(
simple_stmt -> small_stmt NEWLINE
2694
endsim
simple_stmt -> small_stmt NEWLINE
2694
+
simple_stmt -> small_stmt NEWLINE
2694
None
simple_stmt -> small_stmt NEWLINE
2694
resetstats
simple_stmt -> small_stmt NEWLINE
2694
conf
simple_stmt -> small_stmt NEWLINE
2694
server
simple_stmt -> small_stmt NEWLINE
2694
STRING
simple_stmt -> small_stmt NEWLINE
2694
if
simple_stmt -> small_stmt NEWLINE
2694
NUMBER
simple_stmt -> small_stmt NEWLINE
2694
global
simple_stmt -> small_stmt NEWLINE
2694
@
simple_stmt -> small_stmt NEWLINE
2694
True
simple_stmt -> small_stmt NEWLINE
2694
lambda
simple_stmt -> small_stmt NEWLINE
2694
pass
simple_stmt -> small_stmt NEWLINE
2694
return
simple_stmt -> small_stmt NEWLINE
2694
def
simple_stmt -> small_stmt NEWLINE
2694
with
simple_stmt -> small_stmt NEWLINE
2694
nonlocal
simple_stmt -> small_stmt NEWLINE
2694
assert
simple_stmt -> small_stmt NEWLINE
2694
NAME
simple_stmt -> small_stmt NEWLINE
2694
try
simple_stmt -> small_stmt NEWLINE
2694
begsim
simple_stmt -> small_stmt NEWLINE
2694
while
simple_stmt -> small_stmt NEWLINE
2694
for
simple_stmt -> small_stmt NEWLINE
2694
[
simple_stmt -> small_stmt NEWLINE
2694
modopt
simple_stmt -> small_stmt NEWLINE
2694
yield
simple_stmt -> small_stmt NEWLINE
2694
DEDENT
simple_stmt -> small_stmt NEWLINE
2694
continue
simple_stmt -> small_stmt NEWLINE
2694
{
simple_stmt -> small_stmt NEWLINE
2694
~
simple_stmt -> small_stmt NEWLINE
2695
arith_expr
1
2695
try
1533
2695
modopt
1534
2695
compound_stmt
1535
2695
test
5
2695
servmod
1536
2695
while
1537
2695
and_expr
8
2695
power
9
2695
STRING
10
2695
decorated
1538
2695
cli_serv_model
1539
2695
@
13
2695
try_stmt
1540
2695
lambdef
15
2695
stmt_list
2705
2695
(
16
2695
factor
17
2695
[
18
2695
class
1541
2695
small_stmt
1542
2695
{
21
2695
term
22
2695
def
1543
2695
server
1544
2695
while_stmt
1545
2695
-
26
2695
+
27
2695
for
1546
2695
if
1547
2695
lambda
29
2695
decorators
1548
2695
atom_expr
31
2695
not_test
32
2695
if_stmt
1549
2695
yield
34
2695
conf
1550
2695
test_list
36
2695
~
37
2695
True
38
2695
False
39
2695
funcdef
1551
2695
xor_expr
41
2695
with
1552
2695
for_stmt
1553
2695
sim_stmt
45
2695
and_test
46
2695
expr
47
2695
shift_expr
48
2695
comparison
49
2695
with_stmt
1554
2695
simple_stmt
1555
2695
NAME
52
2695
or_test
53
2695
confdef
1556
2695
None
55
2695
classdef
1557
2695
atom
57
2695
NUMBER
58
2695
return
59
2695
break_stmt
60
2695
return_stmt
61
2695
stmt
1558
2695
not
62
2695
break
63
2695
raise
64
2695
expr_stmt
65
2695
stat_stmt
66
2695
decorator
67
2695
assert_stmt
68
2695
begsim
69
2695
global
70
2695
assert
71
2695
nonlocal
72
2695
nonlocal_stmt
73
2695
raise_stmt
74
2695
yield_stmt
75
2695
continue
77
2695
endsim
78
2695
del
80
2695
pass_stmt
81
2695
flow_stmt
82
2695
resetstats
84
2695
del_stmt
85
2695
continue_stmt
86
2695
global_stmt
87
2695
pass
88
2696
:
2706
2697
arith_expr
1
2697
small_stmt
2636
2697
factor
17
2697
True
38
2697
atom_expr
31
2697
term
22
2697
-
26
2697
None
55
2697
atom
57
2697
test
5
2697
comparison
49
2697
suite
2707
2697
and_expr
8
2697
power
9
2697
STRING
10
2697
NAME
52
2697
shift_expr
48
2697
NEWLINE
2637
2697
lambdef
15
2697
NUMBER
58
2697
simple_stmt
2638
2697
(
16
2697
expr
47
2697
[
18
2697
not_test
32
2697
{
21
2697
and_test
46
2697
+
27
2697
lambda
29
2697
xor_expr
41
2697
yield
34
2697
not
62
2697
test_list
36
2697
~
37
2697
or_test
53
2697
False
39
2697
sim_stmt
45
2697
nonlocal
72
2697
nonlocal_stmt
73
2697
return
59
2697
break_stmt
60
2697
return_stmt
61
2697
raise_stmt
74
2697
break
63
2697
yield_stmt
75
2697
raise
64
2697
continue
77
2697
expr_stmt
65
2697
endsim
78
2697
del
80
2697
pass_stmt
81
2697
flow_stmt
82
2697
stat_stmt
66
2697
assert_stmt
68
2697
resetstats
84
2697
del_stmt
85
2697
continue_stmt
86
2697
begsim
69
2697
global_stmt
87
2697
pass
88
2697
global
70
2697
assert
71
2698
else
except_clause -> except test : suite maybe_except_clause
2698
NAME
except_clause -> except test : suite maybe_except_clause
2698
DEDENT
except_clause -> except test : suite maybe_except_clause
2698
begsim
except_clause -> except test : suite maybe_except_clause
2698
@
except_clause -> except test : suite maybe_except_clause
2698
lambda
except_clause -> except test : suite maybe_except_clause
2698
-
except_clause -> except test : suite maybe_except_clause
2698
global
except_clause -> except test : suite maybe_except_clause
2698
resetstats
except_clause -> except test : suite maybe_except_clause
2698
+
except_clause -> except test : suite maybe_except_clause
2698
server
except_clause -> except test : suite maybe_except_clause
2698
if
except_clause -> except test : suite maybe_except_clause
2698
not
except_clause -> except test : suite maybe_except_clause
2698
try
except_clause -> except test : suite maybe_except_clause
2698
for
except_clause -> except test : suite maybe_except_clause
2698
True
except_clause -> except test : suite maybe_except_clause
2698
return
except_clause -> except test : suite maybe_except_clause
2698
yield
except_clause -> except test : suite maybe_except_clause
2698
while
except_clause -> except test : suite maybe_except_clause
2698
servmod
except_clause -> except test : suite maybe_except_clause
2698
{
except_clause -> except test : suite maybe_except_clause
2698
STRING
except_clause -> except test : suite maybe_except_clause
2698
modopt
except_clause -> except test : suite maybe_except_clause
2698
with
except_clause -> except test : suite maybe_except_clause
2698
finally
except_clause -> except test : suite maybe_except_clause
2698
pass
except_clause -> except test : suite maybe_except_clause
2698
break
except_clause -> except test : suite maybe_except_clause
2698
nonlocal
except_clause -> except test : suite maybe_except_clause
2698
endsim
except_clause -> except test : suite maybe_except_clause
2698
raise
except_clause -> except test : suite maybe_except_clause
2698
conf
except_clause -> except test : suite maybe_except_clause
2698
class
except_clause -> except test : suite maybe_except_clause
2698
[
except_clause -> except test : suite maybe_except_clause
2698
assert
except_clause -> except test : suite maybe_except_clause
2698
None
except_clause -> except test : suite maybe_except_clause
2698
~
except_clause -> except test : suite maybe_except_clause
2698
False
except_clause -> except test : suite maybe_except_clause
2698
NUMBER
except_clause -> except test : suite maybe_except_clause
2698
continue
except_clause -> except test : suite maybe_except_clause
2698
del
except_clause -> except test : suite maybe_except_clause
2698
(
except_clause -> except test : suite maybe_except_clause
2698
def
except_clause -> except test : suite maybe_except_clause
2699
DEDENT
2708
2700
arith_expr
1
2700
small_stmt
1542
2700
factor
17
2700
True
38
2700
atom_expr
31
2700
term
22
2700
-
26
2700
None
55
2700
atom
57
2700
test
5
2700
comparison
49
2700
and_expr
8
2700
power
9
2700
STRING
10
2700
NAME
52
2700
shift_expr
48
2700
lambdef
15
2700
NUMBER
58
2700
simple_stmt
2469
2700
(
16
2700
expr
47
2700
[
18
2700
NEWLINE
2470
2700
not_test
32
2700
{
21
2700
and_test
46
2700
+
27
2700
lambda
29
2700
xor_expr
41
2700
yield
34
2700
not
62
2700
test_list
36
2700
~
37
2700
or_test
53
2700
False
39
2700
suite
2709
2700
sim_stmt
45
2700
nonlocal
72
2700
nonlocal_stmt
73
2700
return
59
2700
break_stmt
60
2700
return_stmt
61
2700
raise_stmt
74
2700
break
63
2700
yield_stmt
75
2700
raise
64
2700
continue
77
2700
expr_stmt
65
2700
endsim
78
2700
del
80
2700
pass_stmt
81
2700
flow_stmt
82
2700
stat_stmt
66
2700
assert_stmt
68
2700
resetstats
84
2700
del_stmt
85
2700
continue_stmt
86
2700
begsim
69
2700
global_stmt
87
2700
pass
88
2700
global
70
2700
assert
71
2701
pass
if_stmt -> if test : suite elif_clause else : suite
2701
if
if_stmt -> if test : suite elif_clause else : suite
2701
endsim
if_stmt -> if test : suite elif_clause else : suite
2701
modopt
if_stmt -> if test : suite elif_clause else : suite
2701
~
if_stmt -> if test : suite elif_clause else : suite
2701
conf
if_stmt -> if test : suite elif_clause else : suite
2701
resetstats
if_stmt -> if test : suite elif_clause else : suite
2701
return
if_stmt -> if test : suite elif_clause else : suite
2701
assert
if_stmt -> if test : suite elif_clause else : suite
2701
-
if_stmt -> if test : suite elif_clause else : suite
2701
raise
if_stmt -> if test : suite elif_clause else : suite
2701
while
if_stmt -> if test : suite elif_clause else : suite
2701
for
if_stmt -> if test : suite elif_clause else : suite
2701
global
if_stmt -> if test : suite elif_clause else : suite
2701
None
if_stmt -> if test : suite elif_clause else : suite
2701
servmod
if_stmt -> if test : suite elif_clause else : suite
2701
continue
if_stmt -> if test : suite elif_clause else : suite
2701
True
if_stmt -> if test : suite elif_clause else : suite
2701
STRING
if_stmt -> if test : suite elif_clause else : suite
2701
try
if_stmt -> if test : suite elif_clause else : suite
2701
lambda
if_stmt -> if test : suite elif_clause else : suite
2701
@
if_stmt -> if test : suite elif_clause else : suite
2701
with
if_stmt -> if test : suite elif_clause else : suite
2701
not
if_stmt -> if test : suite elif_clause else : suite
2701
del
if_stmt -> if test : suite elif_clause else : suite
2701
server
if_stmt -> if test : suite elif_clause else : suite
2701
{
if_stmt -> if test : suite elif_clause else : suite
2701
NAME
if_stmt -> if test : suite elif_clause else : suite
2701
break
if_stmt -> if test : suite elif_clause else : suite
2701
nonlocal
if_stmt -> if test : suite elif_clause else : suite
2701
[
if_stmt -> if test : suite elif_clause else : suite
2701
DEDENT
if_stmt -> if test : suite elif_clause else : suite
2701
yield
if_stmt -> if test : suite elif_clause else : suite
2701
(
if_stmt -> if test : suite elif_clause else : suite
2701
False
if_stmt -> if test : suite elif_clause else : suite
2701
class
if_stmt -> if test : suite elif_clause else : suite
2701
begsim
if_stmt -> if test : suite elif_clause else : suite
2701
def
if_stmt -> if test : suite elif_clause else : suite
2701
+
if_stmt -> if test : suite elif_clause else : suite
2701
NUMBER
if_stmt -> if test : suite elif_clause else : suite
2702
elif
2602
2702
elif_clause
2710
2702
pass
elif_clause -> 
2702
None
elif_clause -> 
2702
return
elif_clause -> 
2702
del
elif_clause -> 
2702
class
elif_clause -> 
2702
resetstats
elif_clause -> 
2702
+
elif_clause -> 
2702
DEDENT
elif_clause -> 
2702
break
elif_clause -> 
2702
if
elif_clause -> 
2702
[
elif_clause -> 
2702
~
elif_clause -> 
2702
servmod
elif_clause -> 
2702
endsim
elif_clause -> 
2702
else
elif_clause -> 
2702
for
elif_clause -> 
2702
begsim
elif_clause -> 
2702
not
elif_clause -> 
2702
try
elif_clause -> 
2702
lambda
elif_clause -> 
2702
@
elif_clause -> 
2702
conf
elif_clause -> 
2702
with
elif_clause -> 
2702
-
elif_clause -> 
2702
(
elif_clause -> 
2702
True
elif_clause -> 
2702
STRING
elif_clause -> 
2702
NUMBER
elif_clause -> 
2702
def
elif_clause -> 
2702
global
elif_clause -> 
2702
raise
elif_clause -> 
2702
yield
elif_clause -> 
2702
nonlocal
elif_clause -> 
2702
{
elif_clause -> 
2702
False
elif_clause -> 
2702
server
elif_clause -> 
2702
assert
elif_clause -> 
2702
continue
elif_clause -> 
2702
modopt
elif_clause -> 
2702
while
elif_clause -> 
2702
NAME
elif_clause -> 
2703
confbody
2711
2703
NAME
1971
2704
,
lambdef_nocond -> lambda varargslist : test_nocond
2704
for
lambdef_nocond -> lambda varargslist : test_nocond
2704
if
lambdef_nocond -> lambda varargslist : test_nocond
2704
)
lambdef_nocond -> lambda varargslist : test_nocond
2705
DEDENT
2712
2706
arith_expr
1
2706
small_stmt
1542
2706
factor
17
2706
True
38
2706
atom_expr
31
2706
term
22
2706
-
26
2706
None
55
2706
suite
2713
2706
atom
57
2706
test
5
2706
comparison
49
2706
and_expr
8
2706
power
9
2706
STRING
10
2706
NAME
52
2706
shift_expr
48
2706
lambdef
15
2706
NUMBER
58
2706
simple_stmt
2469
2706
(
16
2706
expr
47
2706
[
18
2706
NEWLINE
2470
2706
not_test
32
2706
{
21
2706
and_test
46
2706
+
27
2706
lambda
29
2706
xor_expr
41
2706
yield
34
2706
not
62
2706
test_list
36
2706
~
37
2706
or_test
53
2706
False
39
2706
sim_stmt
45
2706
nonlocal
72
2706
nonlocal_stmt
73
2706
return
59
2706
break_stmt
60
2706
return_stmt
61
2706
raise_stmt
74
2706
break
63
2706
yield_stmt
75
2706
raise
64
2706
continue
77
2706
expr_stmt
65
2706
endsim
78
2706
del
80
2706
pass_stmt
81
2706
flow_stmt
82
2706
stat_stmt
66
2706
assert_stmt
68
2706
resetstats
84
2706
del_stmt
85
2706
continue_stmt
86
2706
begsim
69
2706
global_stmt
87
2706
pass
88
2706
global
70
2706
assert
71
2707
maybe_except_clause
2714
2707
except
2460
2707
None
maybe_except_clause -> 
2707
if
maybe_except_clause -> 
2707
while
maybe_except_clause -> 
2707
return
maybe_except_clause -> 
2707
continue
maybe_except_clause -> 
2707
except_clause
2675
2707
server
maybe_except_clause -> 
2707
nonlocal
maybe_except_clause -> 
2707
def
maybe_except_clause -> 
2707
servmod
maybe_except_clause -> 
2707
endsim
maybe_except_clause -> 
2707
else
maybe_except_clause -> 
2707
global
maybe_except_clause -> 
2707
conf
maybe_except_clause -> 
2707
pass
maybe_except_clause -> 
2707
True
maybe_except_clause -> 
2707
NUMBER
maybe_except_clause -> 
2707
try
maybe_except_clause -> 
2707
False
maybe_except_clause -> 
2707
~
maybe_except_clause -> 
2707
with
maybe_except_clause -> 
2707
not
maybe_except_clause -> 
2707
NAME
maybe_except_clause -> 
2707
@
maybe_except_clause -> 
2707
(
maybe_except_clause -> 
2707
yield
maybe_except_clause -> 
2707
[
maybe_except_clause -> 
2707
finally
maybe_except_clause -> 
2707
-
maybe_except_clause -> 
2707
raise
maybe_except_clause -> 
2707
{
maybe_except_clause -> 
2707
assert
maybe_except_clause -> 
2707
class
maybe_except_clause -> 
2707
break
maybe_except_clause -> 
2707
+
maybe_except_clause -> 
2707
STRING
maybe_except_clause -> 
2707
del
maybe_except_clause -> 
2707
begsim
maybe_except_clause -> 
2707
lambda
maybe_except_clause -> 
2707
resetstats
maybe_except_clause -> 
2707
DEDENT
maybe_except_clause -> 
2707
for
maybe_except_clause -> 
2707
modopt
maybe_except_clause -> 
2708
+
suite -> NEWLINE INDENT stmt_list DEDENT
2708
False
suite -> NEWLINE INDENT stmt_list DEDENT
2708
[
suite -> NEWLINE INDENT stmt_list DEDENT
2708
pass
suite -> NEWLINE INDENT stmt_list DEDENT
2708
continue
suite -> NEWLINE INDENT stmt_list DEDENT
2708
break
suite -> NEWLINE INDENT stmt_list DEDENT
2708
lambda
suite -> NEWLINE INDENT stmt_list DEDENT
2708
NUMBER
suite -> NEWLINE INDENT stmt_list DEDENT
2708
finally
suite -> NEWLINE INDENT stmt_list DEDENT
2708
True
suite -> NEWLINE INDENT stmt_list DEDENT
2708
conf
suite -> NEWLINE INDENT stmt_list DEDENT
2708
endsim
suite -> NEWLINE INDENT stmt_list DEDENT
2708
server
suite -> NEWLINE INDENT stmt_list DEDENT
2708
raise
suite -> NEWLINE INDENT stmt_list DEDENT
2708
del
suite -> NEWLINE INDENT stmt_list DEDENT
2708
class
suite -> NEWLINE INDENT stmt_list DEDENT
2708
global
suite -> NEWLINE INDENT stmt_list DEDENT
2708
DEDENT
suite -> NEWLINE INDENT stmt_list DEDENT
2708
def
suite -> NEWLINE INDENT stmt_list DEDENT
2708
@
suite -> NEWLINE INDENT stmt_list DEDENT
2708
if
suite -> NEWLINE INDENT stmt_list DEDENT
2708
else
suite -> NEWLINE INDENT stmt_list DEDENT
2708
nonlocal
suite -> NEWLINE INDENT stmt_list DEDENT
2708
-
suite -> NEWLINE INDENT stmt_list DEDENT
2708
NAME
suite -> NEWLINE INDENT stmt_list DEDENT
2708
yield
suite -> NEWLINE INDENT stmt_list DEDENT
2708
~
suite -> NEWLINE INDENT stmt_list DEDENT
2708
except
suite -> NEWLINE INDENT stmt_list DEDENT
2708
modopt
suite -> NEWLINE INDENT stmt_list DEDENT
2708
{
suite -> NEWLINE INDENT stmt_list DEDENT
2708
servmod
suite -> NEWLINE INDENT stmt_list DEDENT
2708
begsim
suite -> NEWLINE INDENT stmt_list DEDENT
2708
not
suite -> NEWLINE INDENT stmt_list DEDENT
2708
assert
suite -> NEWLINE INDENT stmt_list DEDENT
2708
with
suite -> NEWLINE INDENT stmt_list DEDENT
2708
None
suite -> NEWLINE INDENT stmt_list DEDENT
2708
resetstats
suite -> NEWLINE INDENT stmt_list DEDENT
2708
try
suite -> NEWLINE INDENT stmt_list DEDENT
2708
while
suite -> NEWLINE INDENT stmt_list DEDENT
2708
return
suite -> NEWLINE INDENT stmt_list DEDENT
2708
for
suite -> NEWLINE INDENT stmt_list DEDENT
2708
STRING
suite -> NEWLINE INDENT stmt_list DEDENT
2708
(
suite -> NEWLINE INDENT stmt_list DEDENT
2709
global
for_stmt -> for expr_list in test_list : suite else : suite
2709
raise
for_stmt -> for expr_list in test_list : suite else : suite
2709
NAME
for_stmt -> for expr_list in test_list : suite else : suite
2709
if
for_stmt -> for expr_list in test_list : suite else : suite
2709
(
for_stmt -> for expr_list in test_list : suite else : suite
2709
del
for_stmt -> for expr_list in test_list : suite else : suite
2709
while
for_stmt -> for expr_list in test_list : suite else : suite
2709
for
for_stmt -> for expr_list in test_list : suite else : suite
2709
modopt
for_stmt -> for expr_list in test_list : suite else : suite
2709
True
for_stmt -> for expr_list in test_list : suite else : suite
2709
not
for_stmt -> for expr_list in test_list : suite else : suite
2709
with
for_stmt -> for expr_list in test_list : suite else : suite
2709
+
for_stmt -> for expr_list in test_list : suite else : suite
2709
yield
for_stmt -> for expr_list in test_list : suite else : suite
2709
assert
for_stmt -> for expr_list in test_list : suite else : suite
2709
@
for_stmt -> for expr_list in test_list : suite else : suite
2709
STRING
for_stmt -> for expr_list in test_list : suite else : suite
2709
def
for_stmt -> for expr_list in test_list : suite else : suite
2709
break
for_stmt -> for expr_list in test_list : suite else : suite
2709
continue
for_stmt -> for expr_list in test_list : suite else : suite
2709
server
for_stmt -> for expr_list in test_list : suite else : suite
2709
pass
for_stmt -> for expr_list in test_list : suite else : suite
2709
False
for_stmt -> for expr_list in test_list : suite else : suite
2709
nonlocal
for_stmt -> for expr_list in test_list : suite else : suite
2709
DEDENT
for_stmt -> for expr_list in test_list : suite else : suite
2709
None
for_stmt -> for expr_list in test_list : suite else : suite
2709
lambda
for_stmt -> for expr_list in test_list : suite else : suite
2709
class
for_stmt -> for expr_list in test_list : suite else : suite
2709
resetstats
for_stmt -> for expr_list in test_list : suite else : suite
2709
[
for_stmt -> for expr_list in test_list : suite else : suite
2709
begsim
for_stmt -> for expr_list in test_list : suite else : suite
2709
try
for_stmt -> for expr_list in test_list : suite else : suite
2709
{
for_stmt -> for expr_list in test_list : suite else : suite
2709
NUMBER
for_stmt -> for expr_list in test_list : suite else : suite
2709
servmod
for_stmt -> for expr_list in test_list : suite else : suite
2709
conf
for_stmt -> for expr_list in test_list : suite else : suite
2709
return
for_stmt -> for expr_list in test_list : suite else : suite
2709
endsim
for_stmt -> for expr_list in test_list : suite else : suite
2709
-
for_stmt -> for expr_list in test_list : suite else : suite
2709
~
for_stmt -> for expr_list in test_list : suite else : suite
2710
endsim
elif_clause -> elif test : suite elif_clause
2710
None
elif_clause -> elif test : suite elif_clause
2710
else
elif_clause -> elif test : suite elif_clause
2710
modopt
elif_clause -> elif test : suite elif_clause
2710
with
elif_clause -> elif test : suite elif_clause
2710
@
elif_clause -> elif test : suite elif_clause
2710
nonlocal
elif_clause -> elif test : suite elif_clause
2710
for
elif_clause -> elif test : suite elif_clause
2710
def
elif_clause -> elif test : suite elif_clause
2710
True
elif_clause -> elif test : suite elif_clause
2710
NAME
elif_clause -> elif test : suite elif_clause
2710
resetstats
elif_clause -> elif test : suite elif_clause
2710
conf
elif_clause -> elif test : suite elif_clause
2710
break
elif_clause -> elif test : suite elif_clause
2710
lambda
elif_clause -> elif test : suite elif_clause
2710
global
elif_clause -> elif test : suite elif_clause
2710
(
elif_clause -> elif test : suite elif_clause
2710
if
elif_clause -> elif test : suite elif_clause
2710
servmod
elif_clause -> elif test : suite elif_clause
2710
try
elif_clause -> elif test : suite elif_clause
2710
DEDENT
elif_clause -> elif test : suite elif_clause
2710
yield
elif_clause -> elif test : suite elif_clause
2710
False
elif_clause -> elif test : suite elif_clause
2710
while
elif_clause -> elif test : suite elif_clause
2710
+
elif_clause -> elif test : suite elif_clause
2710
assert
elif_clause -> elif test : suite elif_clause
2710
not
elif_clause -> elif test : suite elif_clause
2710
NUMBER
elif_clause -> elif test : suite elif_clause
2710
STRING
elif_clause -> elif test : suite elif_clause
2710
continue
elif_clause -> elif test : suite elif_clause
2710
class
elif_clause -> elif test : suite elif_clause
2710
return
elif_clause -> elif test : suite elif_clause
2710
[
elif_clause -> elif test : suite elif_clause
2710
~
elif_clause -> elif test : suite elif_clause
2710
server
elif_clause -> elif test : suite elif_clause
2710
del
elif_clause -> elif test : suite elif_clause
2710
-
elif_clause -> elif test : suite elif_clause
2710
{
elif_clause -> elif test : suite elif_clause
2710
pass
elif_clause -> elif test : suite elif_clause
2710
begsim
elif_clause -> elif test : suite elif_clause
2710
raise
elif_clause -> elif test : suite elif_clause
2711
DEDENT
2715
2712
+
suite -> NEWLINE INDENT stmt_list DEDENT
2712
False
suite -> NEWLINE INDENT stmt_list DEDENT
2712
[
suite -> NEWLINE INDENT stmt_list DEDENT
2712
pass
suite -> NEWLINE INDENT stmt_list DEDENT
2712
continue
suite -> NEWLINE INDENT stmt_list DEDENT
2712
break
suite -> NEWLINE INDENT stmt_list DEDENT
2712
lambda
suite -> NEWLINE INDENT stmt_list DEDENT
2712
NUMBER
suite -> NEWLINE INDENT stmt_list DEDENT
2712
finally
suite -> NEWLINE INDENT stmt_list DEDENT
2712
True
suite -> NEWLINE INDENT stmt_list DEDENT
2712
conf
suite -> NEWLINE INDENT stmt_list DEDENT
2712
endsim
suite -> NEWLINE INDENT stmt_list DEDENT
2712
server
suite -> NEWLINE INDENT stmt_list DEDENT
2712
raise
suite -> NEWLINE INDENT stmt_list DEDENT
2712
del
suite -> NEWLINE INDENT stmt_list DEDENT
2712
class
suite -> NEWLINE INDENT stmt_list DEDENT
2712
global
suite -> NEWLINE INDENT stmt_list DEDENT
2712
DEDENT
suite -> NEWLINE INDENT stmt_list DEDENT
2712
def
suite -> NEWLINE INDENT stmt_list DEDENT
2712
@
suite -> NEWLINE INDENT stmt_list DEDENT
2712
if
suite -> NEWLINE INDENT stmt_list DEDENT
2712
nonlocal
suite -> NEWLINE INDENT stmt_list DEDENT
2712
-
suite -> NEWLINE INDENT stmt_list DEDENT
2712
NAME
suite -> NEWLINE INDENT stmt_list DEDENT
2712
yield
suite -> NEWLINE INDENT stmt_list DEDENT
2712
~
suite -> NEWLINE INDENT stmt_list DEDENT
2712
modopt
suite -> NEWLINE INDENT stmt_list DEDENT
2712
{
suite -> NEWLINE INDENT stmt_list DEDENT
2712
servmod
suite -> NEWLINE INDENT stmt_list DEDENT
2712
begsim
suite -> NEWLINE INDENT stmt_list DEDENT
2712
not
suite -> NEWLINE INDENT stmt_list DEDENT
2712
assert
suite -> NEWLINE INDENT stmt_list DEDENT
2712
with
suite -> NEWLINE INDENT stmt_list DEDENT
2712
None
suite -> NEWLINE INDENT stmt_list DEDENT
2712
resetstats
suite -> NEWLINE INDENT stmt_list DEDENT
2712
try
suite -> NEWLINE INDENT stmt_list DEDENT
2712
while
suite -> NEWLINE INDENT stmt_list DEDENT
2712
return
suite -> NEWLINE INDENT stmt_list DEDENT
2712
for
suite -> NEWLINE INDENT stmt_list DEDENT
2712
STRING
suite -> NEWLINE INDENT stmt_list DEDENT
2712
(
suite -> NEWLINE INDENT stmt_list DEDENT
2713
yield
try_stmt -> try : suite except_clause else : suite finally : suite
2713
conf
try_stmt -> try : suite except_clause else : suite finally : suite
2713
modopt
try_stmt -> try : suite except_clause else : suite finally : suite
2713
~
try_stmt -> try : suite except_clause else : suite finally : suite
2713
DEDENT
try_stmt -> try : suite except_clause else : suite finally : suite
2713
class
try_stmt -> try : suite except_clause else : suite finally : suite
2713
begsim
try_stmt -> try : suite except_clause else : suite finally : suite
2713
try
try_stmt -> try : suite except_clause else : suite finally : suite
2713
def
try_stmt -> try : suite except_clause else : suite finally : suite
2713
NAME
try_stmt -> try : suite except_clause else : suite finally : suite
2713
return
try_stmt -> try : suite except_clause else : suite finally : suite
2713
pass
try_stmt -> try : suite except_clause else : suite finally : suite
2713
for
try_stmt -> try : suite except_clause else : suite finally : suite
2713
+
try_stmt -> try : suite except_clause else : suite finally : suite
2713
del
try_stmt -> try : suite except_clause else : suite finally : suite
2713
STRING
try_stmt -> try : suite except_clause else : suite finally : suite
2713
nonlocal
try_stmt -> try : suite except_clause else : suite finally : suite
2713
if
try_stmt -> try : suite except_clause else : suite finally : suite
2713
@
try_stmt -> try : suite except_clause else : suite finally : suite
2713
with
try_stmt -> try : suite except_clause else : suite finally : suite
2713
server
try_stmt -> try : suite except_clause else : suite finally : suite
2713
-
try_stmt -> try : suite except_clause else : suite finally : suite
2713
{
try_stmt -> try : suite except_clause else : suite finally : suite
2713
continue
try_stmt -> try : suite except_clause else : suite finally : suite
2713
not
try_stmt -> try : suite except_clause else : suite finally : suite
2713
True
try_stmt -> try : suite except_clause else : suite finally : suite
2713
raise
try_stmt -> try : suite except_clause else : suite finally : suite
2713
global
try_stmt -> try : suite except_clause else : suite finally : suite
2713
endsim
try_stmt -> try : suite except_clause else : suite finally : suite
2713
lambda
try_stmt -> try : suite except_clause else : suite finally : suite
2713
False
try_stmt -> try : suite except_clause else : suite finally : suite
2713
servmod
try_stmt -> try : suite except_clause else : suite finally : suite
2713
break
try_stmt -> try : suite except_clause else : suite finally : suite
2713
(
try_stmt -> try : suite except_clause else : suite finally : suite
2713
NUMBER
try_stmt -> try : suite except_clause else : suite finally : suite
2713
[
try_stmt -> try : suite except_clause else : suite finally : suite
2713
resetstats
try_stmt -> try : suite except_clause else : suite finally : suite
2713
None
try_stmt -> try : suite except_clause else : suite finally : suite
2713
while
try_stmt -> try : suite except_clause else : suite finally : suite
2713
assert
try_stmt -> try : suite except_clause else : suite finally : suite
2714
finally
except_clause -> except test as NAME : suite maybe_except_clause
2714
[
except_clause -> except test as NAME : suite maybe_except_clause
2714
continue
except_clause -> except test as NAME : suite maybe_except_clause
2714
False
except_clause -> except test as NAME : suite maybe_except_clause
2714
return
except_clause -> except test as NAME : suite maybe_except_clause
2714
NUMBER
except_clause -> except test as NAME : suite maybe_except_clause
2714
DEDENT
except_clause -> except test as NAME : suite maybe_except_clause
2714
del
except_clause -> except test as NAME : suite maybe_except_clause
2714
modopt
except_clause -> except test as NAME : suite maybe_except_clause
2714
@
except_clause -> except test as NAME : suite maybe_except_clause
2714
servmod
except_clause -> except test as NAME : suite maybe_except_clause
2714
raise
except_clause -> except test as NAME : suite maybe_except_clause
2714
-
except_clause -> except test as NAME : suite maybe_except_clause
2714
None
except_clause -> except test as NAME : suite maybe_except_clause
2714
endsim
except_clause -> except test as NAME : suite maybe_except_clause
2714
try
except_clause -> except test as NAME : suite maybe_except_clause
2714
server
except_clause -> except test as NAME : suite maybe_except_clause
2714
else
except_clause -> except test as NAME : suite maybe_except_clause
2714
+
except_clause -> except test as NAME : suite maybe_except_clause
2714
NAME
except_clause -> except test as NAME : suite maybe_except_clause
2714
{
except_clause -> except test as NAME : suite maybe_except_clause
2714
for
except_clause -> except test as NAME : suite maybe_except_clause
2714
assert
except_clause -> except test as NAME : suite maybe_except_clause
2714
~
except_clause -> except test as NAME : suite maybe_except_clause
2714
with
except_clause -> except test as NAME : suite maybe_except_clause
2714
yield
except_clause -> except test as NAME : suite maybe_except_clause
2714
lambda
except_clause -> except test as NAME : suite maybe_except_clause
2714
not
except_clause -> except test as NAME : suite maybe_except_clause
2714
(
except_clause -> except test as NAME : suite maybe_except_clause
2714
while
except_clause -> except test as NAME : suite maybe_except_clause
2714
True
except_clause -> except test as NAME : suite maybe_except_clause
2714
if
except_clause -> except test as NAME : suite maybe_except_clause
2714
STRING
except_clause -> except test as NAME : suite maybe_except_clause
2714
class
except_clause -> except test as NAME : suite maybe_except_clause
2714
def
except_clause -> except test as NAME : suite maybe_except_clause
2714
nonlocal
except_clause -> except test as NAME : suite maybe_except_clause
2714
conf
except_clause -> except test as NAME : suite maybe_except_clause
2714
break
except_clause -> except test as NAME : suite maybe_except_clause
2714
resetstats
except_clause -> except test as NAME : suite maybe_except_clause
2714
global
except_clause -> except test as NAME : suite maybe_except_clause
2714
pass
except_clause -> except test as NAME : suite maybe_except_clause
2714
begsim
except_clause -> except test as NAME : suite maybe_except_clause
2715
del
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
None
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
raise
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
STRING
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
resetstats
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
nonlocal
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
server
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
modopt
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
global
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
DEDENT
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
begsim
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
assert
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
pass
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
(
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
lambda
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
NUMBER
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
{
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
class
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
False
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
if
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
@
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
endsim
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
-
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
NAME
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
break
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
True
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
~
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
return
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
servmod
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
+
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
yield
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
while
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
[
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
with
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
continue
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
not
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
for
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
def
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
try
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2715
conf
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
