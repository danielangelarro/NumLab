0
if
1
0
arith_expr
2
0
[
3
0
try
4
0
class
5
0
for
6
0
with_stmt
7
0
while_stmt
8
0
factor
9
0
@
10
0
simple_stmt
11
0
decorators
12
0
return
13
0
confdef
14
0
flow_stmt
15
0
expr
16
0
True
17
0
not_test
18
0
and_expr
19
0
def
20
0
term
21
0
xor_expr
22
0
or_test
23
0
atom_expr
24
0
global
25
0
for_stmt
26
0
NUMBER
27
0
STRING
28
0
NAME
29
0
decorator
30
0
if_stmt
31
0
with
32
0
endsim
33
0
classdef
34
0
False
35
0
(
36
0
and_test
37
0
conf
38
0
comparison
39
0
lambda
40
0
while
41
0
None
42
0
try_stmt
43
0
funcdef
44
0
~
45
0
decorated
46
0
small_stmt
47
0
test
48
0
-
49
0
shift_expr
50
0
compound_stmt
51
0
{
52
0
lambdef
53
0
atom
54
0
+
55
0
power
56
0
not
57
0
stmt
58
0
continue
59
0
del_stmt
60
0
test_list
61
0
raise
62
0
raise_stmt
63
0
resetstats
64
0
pass_stmt
65
0
nonlocal
66
0
global_stmt
67
0
yield
68
0
continue_stmt
69
0
assert
70
0
nonlocal_stmt
71
0
expr_stmt
72
0
NEWLINE
73
0
break_stmt
74
0
return_stmt
75
0
break
76
0
sim_stmt
77
0
stat_stmt
78
0
yield_stmt
79
0
$
program -> 
0
assert_stmt
80
0
pass
81
0
program
82
0
begsim
83
0
del
84
1
factor
85
1
(
86
1
arith_expr
87
1
NAME
88
1
term
89
1
[
90
1
~
91
1
+
92
1
expr
93
1
atom_expr
94
1
atom
95
1
NUMBER
96
1
STRING
97
1
test
98
1
shift_expr
99
1
-
100
1
True
101
1
and_expr
102
1
xor_expr
103
1
False
104
1
{
105
1
None
106
1
and_test
107
1
power
108
1
not_test
109
1
lambdef
110
1
or_test
111
1
comparison
112
1
not
113
1
lambda
114
2
>>
115
2
<<
116
2
%=
shift_expr -> arith_expr
2
//=
shift_expr -> arith_expr
2
==
shift_expr -> arith_expr
2
&
shift_expr -> arith_expr
2
>
shift_expr -> arith_expr
2
+=
shift_expr -> arith_expr
2
!=
shift_expr -> arith_expr
2
^
shift_expr -> arith_expr
2
is
shift_expr -> arith_expr
2
|
shift_expr -> arith_expr
2
,
shift_expr -> arith_expr
2
-=
shift_expr -> arith_expr
2
**=
shift_expr -> arith_expr
2
&=
shift_expr -> arith_expr
2
/=
shift_expr -> arith_expr
2
NEWLINE
shift_expr -> arith_expr
2
>>=
shift_expr -> arith_expr
2
@=
shift_expr -> arith_expr
2
>=
shift_expr -> arith_expr
2
^=
shift_expr -> arith_expr
2
or
shift_expr -> arith_expr
2
*=
shift_expr -> arith_expr
2
<=
shift_expr -> arith_expr
2
|=
shift_expr -> arith_expr
2
not
shift_expr -> arith_expr
2
=
shift_expr -> arith_expr
2
if
shift_expr -> arith_expr
2
<<=
shift_expr -> arith_expr
2
and
shift_expr -> arith_expr
2
<
shift_expr -> arith_expr
2
:
shift_expr -> arith_expr
2
in
shift_expr -> arith_expr
3
factor
117
3
or_test
118
3
term
119
3
(
120
3
arith_expr
121
3
NAME
122
3
[
123
3
]
124
3
+
125
3
atom_expr
126
3
NUMBER
127
3
atom
128
3
STRING
129
3
shift_expr
130
3
-
131
3
test_list_comp
132
3
True
133
3
not_test
134
3
lambdef
135
3
and_expr
136
3
xor_expr
137
3
False
138
3
None
139
3
expr
140
3
and_test
141
3
{
142
3
~
143
3
lambda
144
3
power
145
3
comparison
146
3
test_list
147
3
test
148
3
not
149
4
:
150
5
NAME
151
6
factor
152
6
NUMBER
153
6
expr_list
154
6
term
155
6
(
156
6
True
157
6
[
158
6
+
159
6
STRING
160
6
atom_expr
161
6
arith_expr
162
6
expr
163
6
~
164
6
NAME
165
6
False
166
6
{
167
6
and_expr
168
6
xor_expr
169
6
None
170
6
power
171
6
-
172
6
shift_expr
173
6
atom
174
7
STRING
compound_stmt -> with_stmt
7
$
compound_stmt -> with_stmt
7
global
compound_stmt -> with_stmt
7
(
compound_stmt -> with_stmt
7
-
compound_stmt -> with_stmt
7
yield
compound_stmt -> with_stmt
7
continue
compound_stmt -> with_stmt
7
[
compound_stmt -> with_stmt
7
+
compound_stmt -> with_stmt
7
True
compound_stmt -> with_stmt
7
@
compound_stmt -> with_stmt
7
begsim
compound_stmt -> with_stmt
7
not
compound_stmt -> with_stmt
7
nonlocal
compound_stmt -> with_stmt
7
break
compound_stmt -> with_stmt
7
pass
compound_stmt -> with_stmt
7
NAME
compound_stmt -> with_stmt
7
del
compound_stmt -> with_stmt
7
resetstats
compound_stmt -> with_stmt
7
def
compound_stmt -> with_stmt
7
raise
compound_stmt -> with_stmt
7
~
compound_stmt -> with_stmt
7
with
compound_stmt -> with_stmt
7
conf
compound_stmt -> with_stmt
7
class
compound_stmt -> with_stmt
7
NUMBER
compound_stmt -> with_stmt
7
None
compound_stmt -> with_stmt
7
endsim
compound_stmt -> with_stmt
7
while
compound_stmt -> with_stmt
7
False
compound_stmt -> with_stmt
7
return
compound_stmt -> with_stmt
7
{
compound_stmt -> with_stmt
7
for
compound_stmt -> with_stmt
7
if
compound_stmt -> with_stmt
7
lambda
compound_stmt -> with_stmt
7
assert
compound_stmt -> with_stmt
7
try
compound_stmt -> with_stmt
7
NEWLINE
compound_stmt -> with_stmt
8
def
compound_stmt -> while_stmt
8
if
compound_stmt -> while_stmt
8
assert
compound_stmt -> while_stmt
8
-
compound_stmt -> while_stmt
8
+
compound_stmt -> while_stmt
8
{
compound_stmt -> while_stmt
8
NUMBER
compound_stmt -> while_stmt
8
begsim
compound_stmt -> while_stmt
8
pass
compound_stmt -> while_stmt
8
raise
compound_stmt -> while_stmt
8
NEWLINE
compound_stmt -> while_stmt
8
continue
compound_stmt -> while_stmt
8
try
compound_stmt -> while_stmt
8
False
compound_stmt -> while_stmt
8
lambda
compound_stmt -> while_stmt
8
conf
compound_stmt -> while_stmt
8
(
compound_stmt -> while_stmt
8
del
compound_stmt -> while_stmt
8
resetstats
compound_stmt -> while_stmt
8
yield
compound_stmt -> while_stmt
8
None
compound_stmt -> while_stmt
8
~
compound_stmt -> while_stmt
8
for
compound_stmt -> while_stmt
8
STRING
compound_stmt -> while_stmt
8
$
compound_stmt -> while_stmt
8
endsim
compound_stmt -> while_stmt
8
nonlocal
compound_stmt -> while_stmt
8
True
compound_stmt -> while_stmt
8
@
compound_stmt -> while_stmt
8
NAME
compound_stmt -> while_stmt
8
[
compound_stmt -> while_stmt
8
while
compound_stmt -> while_stmt
8
return
compound_stmt -> while_stmt
8
class
compound_stmt -> while_stmt
8
global
compound_stmt -> while_stmt
8
break
compound_stmt -> while_stmt
8
not
compound_stmt -> while_stmt
8
with
compound_stmt -> while_stmt
9
//=
term -> factor
9
|=
term -> factor
9
//
175
9
/
176
9
in
term -> factor
9
%
177
9
^=
term -> factor
9
@
178
9
/=
term -> factor
9
-
term -> factor
9
<<=
term -> factor
9
*
179
9
:
term -> factor
9
>=
term -> factor
9
=
term -> factor
9
<
term -> factor
9
<=
term -> factor
9
%=
term -> factor
9
==
term -> factor
9
!=
term -> factor
9
+=
term -> factor
9
>>
term -> factor
9
is
term -> factor
9
or
term -> factor
9
and
term -> factor
9
NEWLINE
term -> factor
9
^
term -> factor
9
,
term -> factor
9
+
term -> factor
9
**=
term -> factor
9
*=
term -> factor
9
&
term -> factor
9
&=
term -> factor
9
-=
term -> factor
9
>>=
term -> factor
9
<<
term -> factor
9
|
term -> factor
9
@=
term -> factor
9
>
term -> factor
9
if
term -> factor
9
not
term -> factor
10
dotted_name
180
10
NAME
181
11
return
stmt -> simple_stmt
11
continue
stmt -> simple_stmt
11
False
stmt -> simple_stmt
11
-
stmt -> simple_stmt
11
~
stmt -> simple_stmt
11
not
stmt -> simple_stmt
11
if
stmt -> simple_stmt
11
class
stmt -> simple_stmt
11
[
stmt -> simple_stmt
11
raise
stmt -> simple_stmt
11
@
stmt -> simple_stmt
11
pass
stmt -> simple_stmt
11
def
stmt -> simple_stmt
11
+
stmt -> simple_stmt
11
del
stmt -> simple_stmt
11
yield
stmt -> simple_stmt
11
(
stmt -> simple_stmt
11
conf
stmt -> simple_stmt
11
{
stmt -> simple_stmt
11
break
stmt -> simple_stmt
11
while
stmt -> simple_stmt
11
True
stmt -> simple_stmt
11
with
stmt -> simple_stmt
11
lambda
stmt -> simple_stmt
11
begsim
stmt -> simple_stmt
11
endsim
stmt -> simple_stmt
11
$
stmt -> simple_stmt
11
try
stmt -> simple_stmt
11
nonlocal
stmt -> simple_stmt
11
None
stmt -> simple_stmt
11
for
stmt -> simple_stmt
11
assert
stmt -> simple_stmt
11
NAME
stmt -> simple_stmt
11
resetstats
stmt -> simple_stmt
11
NEWLINE
stmt -> simple_stmt
11
STRING
stmt -> simple_stmt
11
global
stmt -> simple_stmt
11
NUMBER
stmt -> simple_stmt
12
def
20
12
class
5
12
classdef
182
12
funcdef
183
13
factor
184
13
term
185
13
(
186
13
arith_expr
187
13
NAME
188
13
[
189
13
+
190
13
atom_expr
191
13
atom
192
13
NUMBER
193
13
STRING
194
13
shift_expr
195
13
-
196
13
True
197
13
not_test
198
13
and_expr
199
13
xor_expr
200
13
None
201
13
expr
202
13
False
203
13
NEWLINE
return_stmt -> return
13
and_test
204
13
lambda
205
13
{
206
13
~
207
13
power
208
13
test
209
13
not
210
13
or_test
211
13
comparison
212
13
test_list
213
13
lambdef
214
14
with
compound_stmt -> confdef
14
@
compound_stmt -> confdef
14
break
compound_stmt -> confdef
14
pass
compound_stmt -> confdef
14
not
compound_stmt -> confdef
14
+
compound_stmt -> confdef
14
nonlocal
compound_stmt -> confdef
14
class
compound_stmt -> confdef
14
endsim
compound_stmt -> confdef
14
STRING
compound_stmt -> confdef
14
conf
compound_stmt -> confdef
14
def
compound_stmt -> confdef
14
for
compound_stmt -> confdef
14
global
compound_stmt -> confdef
14
resetstats
compound_stmt -> confdef
14
if
compound_stmt -> confdef
14
NUMBER
compound_stmt -> confdef
14
begsim
compound_stmt -> confdef
14
yield
compound_stmt -> confdef
14
[
compound_stmt -> confdef
14
lambda
compound_stmt -> confdef
14
NEWLINE
compound_stmt -> confdef
14
-
compound_stmt -> confdef
14
$
compound_stmt -> confdef
14
True
compound_stmt -> confdef
14
return
compound_stmt -> confdef
14
while
compound_stmt -> confdef
14
assert
compound_stmt -> confdef
14
NAME
compound_stmt -> confdef
14
del
compound_stmt -> confdef
14
None
compound_stmt -> confdef
14
(
compound_stmt -> confdef
14
False
compound_stmt -> confdef
14
{
compound_stmt -> confdef
14
~
compound_stmt -> confdef
14
try
compound_stmt -> confdef
14
continue
compound_stmt -> confdef
14
raise
compound_stmt -> confdef
15
NEWLINE
small_stmt -> flow_stmt
16
is
215
16
comp_op
216
16
<
217
16
-=
comparison -> expr
16
!=
218
16
in
219
16
<=
220
16
^=
comparison -> expr
16
not
221
16
>=
222
16
>
223
16
*=
comparison -> expr
16
==
224
16
|=
comparison -> expr
16
<<=
comparison -> expr
16
and
comparison -> expr
16
@=
comparison -> expr
16
or
comparison -> expr
16
=
comparison -> expr
16
+=
comparison -> expr
16
%=
comparison -> expr
16
>>=
comparison -> expr
16
&=
comparison -> expr
16
:
comparison -> expr
16
if
comparison -> expr
16
//=
comparison -> expr
16
NEWLINE
comparison -> expr
16
,
comparison -> expr
16
**=
comparison -> expr
16
/=
comparison -> expr
17
(
atom -> True
17
[
atom -> True
17
+
atom -> True
17
<<=
atom -> True
17
%=
atom -> True
17
@
atom -> True
17
|=
atom -> True
17
>>=
atom -> True
17
not
atom -> True
17
<=
atom -> True
17
&
atom -> True
17
=
atom -> True
17
<<
atom -> True
17
*=
atom -> True
17
-
atom -> True
17
/
atom -> True
17
-=
atom -> True
17
or
atom -> True
17
//=
atom -> True
17
^=
atom -> True
17
>
atom -> True
17
%
atom -> True
17
^
atom -> True
17
if
atom -> True
17
&=
atom -> True
17
!=
atom -> True
17
+=
atom -> True
17
**=
atom -> True
17
is
atom -> True
17
*
atom -> True
17
<
atom -> True
17
,
atom -> True
17
and
atom -> True
17
.
atom -> True
17
==
atom -> True
17
**
atom -> True
17
>>
atom -> True
17
in
atom -> True
17
|
atom -> True
17
>=
atom -> True
17
//
atom -> True
17
/=
atom -> True
17
:
atom -> True
17
NEWLINE
atom -> True
17
@=
atom -> True
18
and
225
18
NEWLINE
and_test -> not_test
18
%=
and_test -> not_test
18
-=
and_test -> not_test
18
|=
and_test -> not_test
18
/=
and_test -> not_test
18
<<=
and_test -> not_test
18
,
and_test -> not_test
18
>>=
and_test -> not_test
18
&=
and_test -> not_test
18
or
and_test -> not_test
18
=
and_test -> not_test
18
//=
and_test -> not_test
18
if
and_test -> not_test
18
:
and_test -> not_test
18
**=
and_test -> not_test
18
^=
and_test -> not_test
18
+=
and_test -> not_test
18
*=
and_test -> not_test
18
@=
and_test -> not_test
19
^
226
19
=
xor_expr -> and_expr
19
^=
xor_expr -> and_expr
19
if
xor_expr -> and_expr
19
not
xor_expr -> and_expr
19
&=
xor_expr -> and_expr
19
<=
xor_expr -> and_expr
19
:
xor_expr -> and_expr
19
>
xor_expr -> and_expr
19
,
xor_expr -> and_expr
19
>>=
xor_expr -> and_expr
19
NEWLINE
xor_expr -> and_expr
19
<
xor_expr -> and_expr
19
*=
xor_expr -> and_expr
19
/=
xor_expr -> and_expr
19
in
xor_expr -> and_expr
19
>=
xor_expr -> and_expr
19
-=
xor_expr -> and_expr
19
%=
xor_expr -> and_expr
19
==
xor_expr -> and_expr
19
|=
xor_expr -> and_expr
19
<<=
xor_expr -> and_expr
19
|
xor_expr -> and_expr
19
is
xor_expr -> and_expr
19
and
xor_expr -> and_expr
19
or
xor_expr -> and_expr
19
**=
xor_expr -> and_expr
19
+=
xor_expr -> and_expr
19
//=
xor_expr -> and_expr
19
!=
xor_expr -> and_expr
19
@=
xor_expr -> and_expr
20
NAME
227
21
+
228
21
-
229
21
|=
arith_expr -> term
21
NEWLINE
arith_expr -> term
21
or
arith_expr -> term
21
*=
arith_expr -> term
21
,
arith_expr -> term
21
!=
arith_expr -> term
21
if
arith_expr -> term
21
&=
arith_expr -> term
21
==
arith_expr -> term
21
<<=
arith_expr -> term
21
+=
arith_expr -> term
21
//=
arith_expr -> term
21
and
arith_expr -> term
21
:
arith_expr -> term
21
**=
arith_expr -> term
21
not
arith_expr -> term
21
<=
arith_expr -> term
21
@=
arith_expr -> term
21
<
arith_expr -> term
21
=
arith_expr -> term
21
>>=
arith_expr -> term
21
in
arith_expr -> term
21
-=
arith_expr -> term
21
>
arith_expr -> term
21
>>
arith_expr -> term
21
%=
arith_expr -> term
21
|
arith_expr -> term
21
&
arith_expr -> term
21
>=
arith_expr -> term
21
/=
arith_expr -> term
21
^
arith_expr -> term
21
^=
arith_expr -> term
21
is
arith_expr -> term
21
<<
arith_expr -> term
22
|
230
22
>=
expr -> xor_expr
22
@=
expr -> xor_expr
22
<<=
expr -> xor_expr
22
,
expr -> xor_expr
22
==
expr -> xor_expr
22
-=
expr -> xor_expr
22
NEWLINE
expr -> xor_expr
22
is
expr -> xor_expr
22
&=
expr -> xor_expr
22
:
expr -> xor_expr
22
or
expr -> xor_expr
22
^=
expr -> xor_expr
22
>>=
expr -> xor_expr
22
+=
expr -> xor_expr
22
if
expr -> xor_expr
22
/=
expr -> xor_expr
22
>
expr -> xor_expr
22
//=
expr -> xor_expr
22
and
expr -> xor_expr
22
**=
expr -> xor_expr
22
<
expr -> xor_expr
22
in
expr -> xor_expr
22
%=
expr -> xor_expr
22
<=
expr -> xor_expr
22
=
expr -> xor_expr
22
not
expr -> xor_expr
22
|=
expr -> xor_expr
22
!=
expr -> xor_expr
22
*=
expr -> xor_expr
23
+=
test -> or_test
23
NEWLINE
test -> or_test
23
&=
test -> or_test
23
-=
test -> or_test
23
//=
test -> or_test
23
if
231
23
*=
test -> or_test
23
^=
test -> or_test
23
=
test -> or_test
23
>>=
test -> or_test
23
/=
test -> or_test
23
,
test -> or_test
23
@=
test -> or_test
23
:
test -> or_test
23
**=
test -> or_test
23
|=
test -> or_test
23
<<=
test -> or_test
23
%=
test -> or_test
24
!=
power -> atom_expr
24
**
232
24
>
power -> atom_expr
24
&=
power -> atom_expr
24
&
power -> atom_expr
24
^
power -> atom_expr
24
:
power -> atom_expr
24
if
power -> atom_expr
24
>>=
power -> atom_expr
24
NEWLINE
power -> atom_expr
24
or
power -> atom_expr
24
=
power -> atom_expr
24
<=
power -> atom_expr
24
+
power -> atom_expr
24
==
power -> atom_expr
24
+=
power -> atom_expr
24
/=
power -> atom_expr
24
%
power -> atom_expr
24
<<
power -> atom_expr
24
<
power -> atom_expr
24
%=
power -> atom_expr
24
-
power -> atom_expr
24
*=
power -> atom_expr
24
not
power -> atom_expr
24
|
power -> atom_expr
24
,
power -> atom_expr
24
//
power -> atom_expr
24
>=
power -> atom_expr
24
^=
power -> atom_expr
24
-=
power -> atom_expr
24
@=
power -> atom_expr
24
<<=
power -> atom_expr
24
//=
power -> atom_expr
24
>>
power -> atom_expr
24
in
power -> atom_expr
24
@
power -> atom_expr
24
*
power -> atom_expr
24
/
power -> atom_expr
24
is
power -> atom_expr
24
**=
power -> atom_expr
24
and
power -> atom_expr
24
|=
power -> atom_expr
25
namelist
233
25
NAME
234
26
class
compound_stmt -> for_stmt
26
conf
compound_stmt -> for_stmt
26
False
compound_stmt -> for_stmt
26
assert
compound_stmt -> for_stmt
26
{
compound_stmt -> for_stmt
26
yield
compound_stmt -> for_stmt
26
~
compound_stmt -> for_stmt
26
NEWLINE
compound_stmt -> for_stmt
26
global
compound_stmt -> for_stmt
26
not
compound_stmt -> for_stmt
26
break
compound_stmt -> for_stmt
26
NUMBER
compound_stmt -> for_stmt
26
def
compound_stmt -> for_stmt
26
for
compound_stmt -> for_stmt
26
del
compound_stmt -> for_stmt
26
if
compound_stmt -> for_stmt
26
[
compound_stmt -> for_stmt
26
$
compound_stmt -> for_stmt
26
return
compound_stmt -> for_stmt
26
try
compound_stmt -> for_stmt
26
raise
compound_stmt -> for_stmt
26
+
compound_stmt -> for_stmt
26
while
compound_stmt -> for_stmt
26
@
compound_stmt -> for_stmt
26
True
compound_stmt -> for_stmt
26
resetstats
compound_stmt -> for_stmt
26
begsim
compound_stmt -> for_stmt
26
STRING
compound_stmt -> for_stmt
26
None
compound_stmt -> for_stmt
26
nonlocal
compound_stmt -> for_stmt
26
endsim
compound_stmt -> for_stmt
26
pass
compound_stmt -> for_stmt
26
(
compound_stmt -> for_stmt
26
-
compound_stmt -> for_stmt
26
continue
compound_stmt -> for_stmt
26
NAME
compound_stmt -> for_stmt
26
with
compound_stmt -> for_stmt
26
lambda
compound_stmt -> for_stmt
27
[
atom -> NUMBER
27
%=
atom -> NUMBER
27
=
atom -> NUMBER
27
>=
atom -> NUMBER
27
/=
atom -> NUMBER
27
<=
atom -> NUMBER
27
-=
atom -> NUMBER
27
!=
atom -> NUMBER
27
//
atom -> NUMBER
27
in
atom -> NUMBER
27
&=
atom -> NUMBER
27
:
atom -> NUMBER
27
/
atom -> NUMBER
27
or
atom -> NUMBER
27
>
atom -> NUMBER
27
,
atom -> NUMBER
27
*=
atom -> NUMBER
27
not
atom -> NUMBER
27
>>
atom -> NUMBER
27
(
atom -> NUMBER
27
**
atom -> NUMBER
27
<<
atom -> NUMBER
27
and
atom -> NUMBER
27
+
atom -> NUMBER
27
%
atom -> NUMBER
27
+=
atom -> NUMBER
27
==
atom -> NUMBER
27
|=
atom -> NUMBER
27
if
atom -> NUMBER
27
//=
atom -> NUMBER
27
@=
atom -> NUMBER
27
@
atom -> NUMBER
27
is
atom -> NUMBER
27
*
atom -> NUMBER
27
|
atom -> NUMBER
27
NEWLINE
atom -> NUMBER
27
**=
atom -> NUMBER
27
-
atom -> NUMBER
27
.
atom -> NUMBER
27
<<=
atom -> NUMBER
27
^
atom -> NUMBER
27
^=
atom -> NUMBER
27
>>=
atom -> NUMBER
27
<
atom -> NUMBER
27
&
atom -> NUMBER
28
and
atom -> STRING
28
//=
atom -> STRING
28
%
atom -> STRING
28
//
atom -> STRING
28
>>
atom -> STRING
28
*
atom -> STRING
28
<
atom -> STRING
28
|=
atom -> STRING
28
.
atom -> STRING
28
@=
atom -> STRING
28
in
atom -> STRING
28
NEWLINE
atom -> STRING
28
&=
atom -> STRING
28
:
atom -> STRING
28
<<=
atom -> STRING
28
^
atom -> STRING
28
**=
atom -> STRING
28
=
atom -> STRING
28
(
atom -> STRING
28
if
atom -> STRING
28
==
atom -> STRING
28
-
atom -> STRING
28
**
atom -> STRING
28
<<
atom -> STRING
28
<=
atom -> STRING
28
[
atom -> STRING
28
>>=
atom -> STRING
28
/=
atom -> STRING
28
not
atom -> STRING
28
or
atom -> STRING
28
+
atom -> STRING
28
%=
atom -> STRING
28
>=
atom -> STRING
28
@
atom -> STRING
28
-=
atom -> STRING
28
&
atom -> STRING
28
+=
atom -> STRING
28
>
atom -> STRING
28
*=
atom -> STRING
28
,
atom -> STRING
28
^=
atom -> STRING
28
|
atom -> STRING
28
is
atom -> STRING
28
!=
atom -> STRING
28
/
atom -> STRING
29
-=
atom -> NAME
29
:
atom -> NAME
29
-
atom -> NAME
29
,
atom -> NAME
29
or
atom -> NAME
29
>>
atom -> NAME
29
NEWLINE
atom -> NAME
29
*=
atom -> NAME
29
&
atom -> NAME
29
//=
atom -> NAME
29
<=
atom -> NAME
29
[
atom -> NAME
29
<
atom -> NAME
29
.
atom -> NAME
29
@=
atom -> NAME
29
|
atom -> NAME
29
>>=
atom -> NAME
29
/=
atom -> NAME
29
<<=
atom -> NAME
29
*
atom -> NAME
29
/
atom -> NAME
29
<<
atom -> NAME
29
^=
atom -> NAME
29
not
atom -> NAME
29
>
atom -> NAME
29
=
atom -> NAME
29
is
atom -> NAME
29
|=
atom -> NAME
29
**=
atom -> NAME
29
+
atom -> NAME
29
//
atom -> NAME
29
%=
atom -> NAME
29
+=
atom -> NAME
29
if
atom -> NAME
29
in
atom -> NAME
29
**
atom -> NAME
29
&=
atom -> NAME
29
!=
atom -> NAME
29
>=
atom -> NAME
29
^
atom -> NAME
29
@
atom -> NAME
29
(
atom -> NAME
29
==
atom -> NAME
29
and
atom -> NAME
29
%
atom -> NAME
30
decorator
30
30
class
decorators -> decorator
30
@
10
30
decorators
235
30
def
decorators -> decorator
31
STRING
compound_stmt -> if_stmt
31
NEWLINE
compound_stmt -> if_stmt
31
try
compound_stmt -> if_stmt
31
{
compound_stmt -> if_stmt
31
del
compound_stmt -> if_stmt
31
True
compound_stmt -> if_stmt
31
+
compound_stmt -> if_stmt
31
class
compound_stmt -> if_stmt
31
None
compound_stmt -> if_stmt
31
return
compound_stmt -> if_stmt
31
[
compound_stmt -> if_stmt
31
NUMBER
compound_stmt -> if_stmt
31
for
compound_stmt -> if_stmt
31
assert
compound_stmt -> if_stmt
31
lambda
compound_stmt -> if_stmt
31
False
compound_stmt -> if_stmt
31
with
compound_stmt -> if_stmt
31
global
compound_stmt -> if_stmt
31
endsim
compound_stmt -> if_stmt
31
@
compound_stmt -> if_stmt
31
begsim
compound_stmt -> if_stmt
31
yield
compound_stmt -> if_stmt
31
$
compound_stmt -> if_stmt
31
(
compound_stmt -> if_stmt
31
conf
compound_stmt -> if_stmt
31
nonlocal
compound_stmt -> if_stmt
31
not
compound_stmt -> if_stmt
31
break
compound_stmt -> if_stmt
31
NAME
compound_stmt -> if_stmt
31
if
compound_stmt -> if_stmt
31
-
compound_stmt -> if_stmt
31
raise
compound_stmt -> if_stmt
31
while
compound_stmt -> if_stmt
31
def
compound_stmt -> if_stmt
31
pass
compound_stmt -> if_stmt
31
resetstats
compound_stmt -> if_stmt
31
continue
compound_stmt -> if_stmt
31
~
compound_stmt -> if_stmt
32
factor
236
32
term
237
32
(
238
32
arith_expr
239
32
with_items
240
32
NAME
241
32
False
242
32
[
243
32
~
244
32
+
245
32
lambda
246
32
expr
247
32
atom_expr
248
32
shift_expr
249
32
atom
250
32
NUMBER
251
32
STRING
252
32
-
253
32
True
254
32
not_test
255
32
and_expr
256
32
xor_expr
257
32
{
258
32
or_test
259
32
None
260
32
comparison
261
32
and_test
262
32
lambdef
263
32
power
264
32
not
265
32
test
266
32
with_item
267
33
NEWLINE
sim_stmt -> endsim
34
pass
compound_stmt -> classdef
34
endsim
compound_stmt -> classdef
34
conf
compound_stmt -> classdef
34
False
compound_stmt -> classdef
34
~
compound_stmt -> classdef
34
continue
compound_stmt -> classdef
34
NEWLINE
compound_stmt -> classdef
34
$
compound_stmt -> classdef
34
with
compound_stmt -> classdef
34
class
compound_stmt -> classdef
34
if
compound_stmt -> classdef
34
nonlocal
compound_stmt -> classdef
34
while
compound_stmt -> classdef
34
{
compound_stmt -> classdef
34
True
compound_stmt -> classdef
34
raise
compound_stmt -> classdef
34
NUMBER
compound_stmt -> classdef
34
global
compound_stmt -> classdef
34
for
compound_stmt -> classdef
34
@
compound_stmt -> classdef
34
resetstats
compound_stmt -> classdef
34
STRING
compound_stmt -> classdef
34
def
compound_stmt -> classdef
34
[
compound_stmt -> classdef
34
(
compound_stmt -> classdef
34
NAME
compound_stmt -> classdef
34
try
compound_stmt -> classdef
34
not
compound_stmt -> classdef
34
del
compound_stmt -> classdef
34
yield
compound_stmt -> classdef
34
-
compound_stmt -> classdef
34
return
compound_stmt -> classdef
34
begsim
compound_stmt -> classdef
34
lambda
compound_stmt -> classdef
34
+
compound_stmt -> classdef
34
assert
compound_stmt -> classdef
34
None
compound_stmt -> classdef
34
break
compound_stmt -> classdef
35
in
atom -> False
35
>
atom -> False
35
-
atom -> False
35
%
atom -> False
35
<
atom -> False
35
|=
atom -> False
35
<<
atom -> False
35
NEWLINE
atom -> False
35
|
atom -> False
35
==
atom -> False
35
&
atom -> False
35
//
atom -> False
35
and
atom -> False
35
**=
atom -> False
35
+=
atom -> False
35
:
atom -> False
35
not
atom -> False
35
+
atom -> False
35
!=
atom -> False
35
^=
atom -> False
35
if
atom -> False
35
@=
atom -> False
35
%=
atom -> False
35
@
atom -> False
35
[
atom -> False
35
or
atom -> False
35
//=
atom -> False
35
<=
atom -> False
35
<<=
atom -> False
35
=
atom -> False
35
*
atom -> False
35
^
atom -> False
35
is
atom -> False
35
-=
atom -> False
35
/
atom -> False
35
*=
atom -> False
35
.
atom -> False
35
>=
atom -> False
35
>>=
atom -> False
35
**
atom -> False
35
>>
atom -> False
35
&=
atom -> False
35
,
atom -> False
35
/=
atom -> False
35
(
atom -> False
36
factor
268
36
)
269
36
term
270
36
(
271
36
arith_expr
272
36
NAME
273
36
[
274
36
+
275
36
test_list_comp
276
36
atom_expr
277
36
NUMBER
278
36
atom
279
36
STRING
280
36
shift_expr
281
36
-
282
36
True
283
36
not_test
284
36
lambdef
285
36
and_expr
286
36
xor_expr
287
36
False
288
36
None
289
36
expr
290
36
and_test
291
36
{
292
36
~
293
36
power
294
36
lambda
295
36
comparison
296
36
or_test
297
36
not
298
36
test
299
36
test_list
300
37
**=
or_test -> and_test
37
-=
or_test -> and_test
37
or
301
37
//=
or_test -> and_test
37
>>=
or_test -> and_test
37
<<=
or_test -> and_test
37
|=
or_test -> and_test
37
:
or_test -> and_test
37
NEWLINE
or_test -> and_test
37
if
or_test -> and_test
37
^=
or_test -> and_test
37
*=
or_test -> and_test
37
,
or_test -> and_test
37
%=
or_test -> and_test
37
=
or_test -> and_test
37
&=
or_test -> and_test
37
+=
or_test -> and_test
37
@=
or_test -> and_test
37
/=
or_test -> and_test
38
NAME
302
39
=
not_test -> comparison
39
%=
not_test -> comparison
39
NEWLINE
not_test -> comparison
39
/=
not_test -> comparison
39
@=
not_test -> comparison
39
*=
not_test -> comparison
39
|=
not_test -> comparison
39
if
not_test -> comparison
39
&=
not_test -> comparison
39
:
not_test -> comparison
39
**=
not_test -> comparison
39
or
not_test -> comparison
39
<<=
not_test -> comparison
39
//=
not_test -> comparison
39
-=
not_test -> comparison
39
and
not_test -> comparison
39
,
not_test -> comparison
39
+=
not_test -> comparison
39
>>=
not_test -> comparison
39
^=
not_test -> comparison
40
varargslist
303
40
:
304
40
NAME
305
40
vfpdef
306
41
factor
85
41
(
86
41
arith_expr
87
41
NAME
88
41
term
89
41
[
90
41
~
91
41
+
92
41
expr
93
41
atom_expr
94
41
atom
95
41
NUMBER
96
41
STRING
97
41
shift_expr
99
41
-
100
41
test
307
41
True
101
41
and_expr
102
41
xor_expr
103
41
False
104
41
{
105
41
None
106
41
and_test
107
41
power
108
41
not_test
109
41
lambdef
110
41
or_test
111
41
comparison
112
41
not
113
41
lambda
114
42
|=
atom -> None
42
is
atom -> None
42
.
atom -> None
42
==
atom -> None
42
^
atom -> None
42
&=
atom -> None
42
<<
atom -> None
42
>>
atom -> None
42
(
atom -> None
42
|
atom -> None
42
=
atom -> None
42
+
atom -> None
42
@=
atom -> None
42
*
atom -> None
42
**=
atom -> None
42
//
atom -> None
42
@
atom -> None
42
^=
atom -> None
42
in
atom -> None
42
>=
atom -> None
42
!=
atom -> None
42
%
atom -> None
42
[
atom -> None
42
and
atom -> None
42
>>=
atom -> None
42
%=
atom -> None
42
/=
atom -> None
42
-
atom -> None
42
NEWLINE
atom -> None
42
if
atom -> None
42
&
atom -> None
42
+=
atom -> None
42
<=
atom -> None
42
<
atom -> None
42
*=
atom -> None
42
>
atom -> None
42
,
atom -> None
42
//=
atom -> None
42
**
atom -> None
42
<<=
atom -> None
42
-=
atom -> None
42
:
atom -> None
42
or
atom -> None
42
/
atom -> None
42
not
atom -> None
43
assert
compound_stmt -> try_stmt
43
@
compound_stmt -> try_stmt
43
with
compound_stmt -> try_stmt
43
NEWLINE
compound_stmt -> try_stmt
43
{
compound_stmt -> try_stmt
43
endsim
compound_stmt -> try_stmt
43
pass
compound_stmt -> try_stmt
43
not
compound_stmt -> try_stmt
43
False
compound_stmt -> try_stmt
43
-
compound_stmt -> try_stmt
43
begsim
compound_stmt -> try_stmt
43
resetstats
compound_stmt -> try_stmt
43
return
compound_stmt -> try_stmt
43
break
compound_stmt -> try_stmt
43
def
compound_stmt -> try_stmt
43
NAME
compound_stmt -> try_stmt
43
raise
compound_stmt -> try_stmt
43
for
compound_stmt -> try_stmt
43
$
compound_stmt -> try_stmt
43
NUMBER
compound_stmt -> try_stmt
43
+
compound_stmt -> try_stmt
43
nonlocal
compound_stmt -> try_stmt
43
global
compound_stmt -> try_stmt
43
STRING
compound_stmt -> try_stmt
43
while
compound_stmt -> try_stmt
43
if
compound_stmt -> try_stmt
43
class
compound_stmt -> try_stmt
43
del
compound_stmt -> try_stmt
43
continue
compound_stmt -> try_stmt
43
True
compound_stmt -> try_stmt
43
yield
compound_stmt -> try_stmt
43
(
compound_stmt -> try_stmt
43
~
compound_stmt -> try_stmt
43
conf
compound_stmt -> try_stmt
43
None
compound_stmt -> try_stmt
43
lambda
compound_stmt -> try_stmt
43
[
compound_stmt -> try_stmt
43
try
compound_stmt -> try_stmt
44
NEWLINE
compound_stmt -> funcdef
44
pass
compound_stmt -> funcdef
44
[
compound_stmt -> funcdef
44
~
compound_stmt -> funcdef
44
yield
compound_stmt -> funcdef
44
endsim
compound_stmt -> funcdef
44
False
compound_stmt -> funcdef
44
while
compound_stmt -> funcdef
44
not
compound_stmt -> funcdef
44
nonlocal
compound_stmt -> funcdef
44
+
compound_stmt -> funcdef
44
for
compound_stmt -> funcdef
44
assert
compound_stmt -> funcdef
44
None
compound_stmt -> funcdef
44
resetstats
compound_stmt -> funcdef
44
global
compound_stmt -> funcdef
44
True
compound_stmt -> funcdef
44
-
compound_stmt -> funcdef
44
{
compound_stmt -> funcdef
44
continue
compound_stmt -> funcdef
44
$
compound_stmt -> funcdef
44
(
compound_stmt -> funcdef
44
break
compound_stmt -> funcdef
44
lambda
compound_stmt -> funcdef
44
begsim
compound_stmt -> funcdef
44
def
compound_stmt -> funcdef
44
raise
compound_stmt -> funcdef
44
STRING
compound_stmt -> funcdef
44
class
compound_stmt -> funcdef
44
return
compound_stmt -> funcdef
44
NAME
compound_stmt -> funcdef
44
@
compound_stmt -> funcdef
44
try
compound_stmt -> funcdef
44
with
compound_stmt -> funcdef
44
NUMBER
compound_stmt -> funcdef
44
del
compound_stmt -> funcdef
44
if
compound_stmt -> funcdef
44
conf
compound_stmt -> funcdef
45
+
55
45
atom_expr
24
45
(
36
45
NAME
29
45
{
52
45
[
3
45
~
45
45
atom
54
45
factor
308
45
power
56
45
NUMBER
27
45
STRING
28
45
-
49
45
True
17
45
False
35
45
None
42
46
-
compound_stmt -> decorated
46
return
compound_stmt -> decorated
46
False
compound_stmt -> decorated
46
with
compound_stmt -> decorated
46
if
compound_stmt -> decorated
46
def
compound_stmt -> decorated
46
assert
compound_stmt -> decorated
46
None
compound_stmt -> decorated
46
True
compound_stmt -> decorated
46
pass
compound_stmt -> decorated
46
del
compound_stmt -> decorated
46
lambda
compound_stmt -> decorated
46
continue
compound_stmt -> decorated
46
nonlocal
compound_stmt -> decorated
46
NAME
compound_stmt -> decorated
46
(
compound_stmt -> decorated
46
global
compound_stmt -> decorated
46
endsim
compound_stmt -> decorated
46
begsim
compound_stmt -> decorated
46
try
compound_stmt -> decorated
46
[
compound_stmt -> decorated
46
$
compound_stmt -> decorated
46
NEWLINE
compound_stmt -> decorated
46
{
compound_stmt -> decorated
46
for
compound_stmt -> decorated
46
not
compound_stmt -> decorated
46
class
compound_stmt -> decorated
46
+
compound_stmt -> decorated
46
yield
compound_stmt -> decorated
46
~
compound_stmt -> decorated
46
@
compound_stmt -> decorated
46
NUMBER
compound_stmt -> decorated
46
break
compound_stmt -> decorated
46
while
compound_stmt -> decorated
46
STRING
compound_stmt -> decorated
46
raise
compound_stmt -> decorated
46
conf
compound_stmt -> decorated
46
resetstats
compound_stmt -> decorated
47
NEWLINE
309
48
^=
test_list -> test
48
,
310
48
&=
test_list -> test
48
<<=
test_list -> test
48
:
test_list -> test
48
|=
test_list -> test
48
-=
test_list -> test
48
>>=
test_list -> test
48
*=
test_list -> test
48
+=
test_list -> test
48
NEWLINE
test_list -> test
48
%=
test_list -> test
48
@=
test_list -> test
48
=
test_list -> test
48
/=
test_list -> test
48
**=
test_list -> test
48
//=
test_list -> test
49
+
55
49
atom_expr
24
49
(
36
49
NAME
29
49
{
52
49
[
3
49
~
45
49
atom
54
49
power
56
49
NUMBER
27
49
STRING
28
49
factor
311
49
-
49
49
True
17
49
False
35
49
None
42
50
&
312
50
/=
and_expr -> shift_expr
50
-=
and_expr -> shift_expr
50
^
and_expr -> shift_expr
50
^=
and_expr -> shift_expr
50
|
and_expr -> shift_expr
50
**=
and_expr -> shift_expr
50
<=
and_expr -> shift_expr
50
>>=
and_expr -> shift_expr
50
=
and_expr -> shift_expr
50
%=
and_expr -> shift_expr
50
NEWLINE
and_expr -> shift_expr
50
or
and_expr -> shift_expr
50
>
and_expr -> shift_expr
50
not
and_expr -> shift_expr
50
,
and_expr -> shift_expr
50
!=
and_expr -> shift_expr
50
and
and_expr -> shift_expr
50
is
and_expr -> shift_expr
50
&=
and_expr -> shift_expr
50
<
and_expr -> shift_expr
50
|=
and_expr -> shift_expr
50
if
and_expr -> shift_expr
50
in
and_expr -> shift_expr
50
>=
and_expr -> shift_expr
50
@=
and_expr -> shift_expr
50
:
and_expr -> shift_expr
50
+=
and_expr -> shift_expr
50
<<=
and_expr -> shift_expr
50
//=
and_expr -> shift_expr
50
==
and_expr -> shift_expr
50
*=
and_expr -> shift_expr
51
(
stmt -> compound_stmt
51
[
stmt -> compound_stmt
51
assert
stmt -> compound_stmt
51
raise
stmt -> compound_stmt
51
{
stmt -> compound_stmt
51
def
stmt -> compound_stmt
51
continue
stmt -> compound_stmt
51
@
stmt -> compound_stmt
51
lambda
stmt -> compound_stmt
51
False
stmt -> compound_stmt
51
+
stmt -> compound_stmt
51
class
stmt -> compound_stmt
51
not
stmt -> compound_stmt
51
conf
stmt -> compound_stmt
51
True
stmt -> compound_stmt
51
if
stmt -> compound_stmt
51
-
stmt -> compound_stmt
51
del
stmt -> compound_stmt
51
NUMBER
stmt -> compound_stmt
51
NEWLINE
stmt -> compound_stmt
51
NAME
stmt -> compound_stmt
51
return
stmt -> compound_stmt
51
try
stmt -> compound_stmt
51
~
stmt -> compound_stmt
51
$
stmt -> compound_stmt
51
nonlocal
stmt -> compound_stmt
51
global
stmt -> compound_stmt
51
yield
stmt -> compound_stmt
51
None
stmt -> compound_stmt
51
while
stmt -> compound_stmt
51
break
stmt -> compound_stmt
51
with
stmt -> compound_stmt
51
pass
stmt -> compound_stmt
51
STRING
stmt -> compound_stmt
51
for
stmt -> compound_stmt
51
endsim
stmt -> compound_stmt
51
resetstats
stmt -> compound_stmt
51
begsim
stmt -> compound_stmt
52
}
313
53
&=
test -> lambdef
53
|=
test -> lambdef
53
^=
test -> lambdef
53
>>=
test -> lambdef
53
@=
test -> lambdef
53
+=
test -> lambdef
53
-=
test -> lambdef
53
%=
test -> lambdef
53
**=
test -> lambdef
53
,
test -> lambdef
53
<<=
test -> lambdef
53
*=
test -> lambdef
53
//=
test -> lambdef
53
=
test -> lambdef
53
NEWLINE
test -> lambdef
53
:
test -> lambdef
53
/=
test -> lambdef
54
trailer
314
54
(
315
54
[
316
54
.
317
54
trailer_expr
318
54
==
trailer_expr -> 
54
/
trailer_expr -> 
54
+=
trailer_expr -> 
54
**
trailer_expr -> 
54
@=
trailer_expr -> 
54
is
trailer_expr -> 
54
**=
trailer_expr -> 
54
//=
trailer_expr -> 
54
,
trailer_expr -> 
54
<=
trailer_expr -> 
54
>=
trailer_expr -> 
54
*=
trailer_expr -> 
54
|=
trailer_expr -> 
54
>
trailer_expr -> 
54
!=
trailer_expr -> 
54
&=
trailer_expr -> 
54
-=
trailer_expr -> 
54
%=
trailer_expr -> 
54
<<
trailer_expr -> 
54
%
trailer_expr -> 
54
/=
trailer_expr -> 
54
<<=
trailer_expr -> 
54
-
trailer_expr -> 
54
<
trailer_expr -> 
54
NEWLINE
trailer_expr -> 
54
if
trailer_expr -> 
54
or
trailer_expr -> 
54
and
trailer_expr -> 
54
@
trailer_expr -> 
54
=
trailer_expr -> 
54
*
trailer_expr -> 
54
|
trailer_expr -> 
54
^=
trailer_expr -> 
54
+
trailer_expr -> 
54
in
trailer_expr -> 
54
&
trailer_expr -> 
54
^
trailer_expr -> 
54
not
trailer_expr -> 
54
>>
trailer_expr -> 
54
//
trailer_expr -> 
54
>>=
trailer_expr -> 
54
:
trailer_expr -> 
55
+
55
55
atom_expr
24
55
(
36
55
NAME
29
55
{
52
55
[
3
55
~
45
55
atom
54
55
factor
319
55
power
56
55
NUMBER
27
55
STRING
28
55
-
49
55
True
17
55
False
35
55
None
42
56
&
factor -> power
56
NEWLINE
factor -> power
56
%
factor -> power
56
<<
factor -> power
56
-
factor -> power
56
<=
factor -> power
56
not
factor -> power
56
//
factor -> power
56
**=
factor -> power
56
/
factor -> power
56
is
factor -> power
56
@=
factor -> power
56
|
factor -> power
56
-=
factor -> power
56
<
factor -> power
56
and
factor -> power
56
>>
factor -> power
56
>=
factor -> power
56
>
factor -> power
56
>>=
factor -> power
56
in
factor -> power
56
*=
factor -> power
56
=
factor -> power
56
if
factor -> power
56
//=
factor -> power
56
<<=
factor -> power
56
^
factor -> power
56
+=
factor -> power
56
==
factor -> power
56
/=
factor -> power
56
%=
factor -> power
56
+
factor -> power
56
,
factor -> power
56
|=
factor -> power
56
@
factor -> power
56
^=
factor -> power
56
or
factor -> power
56
*
factor -> power
56
:
factor -> power
56
&=
factor -> power
56
!=
factor -> power
57
factor
9
57
arith_expr
2
57
NAME
29
57
term
21
57
[
3
57
~
45
57
atom_expr
24
57
expr
16
57
power
56
57
(
36
57
True
17
57
and_expr
19
57
xor_expr
22
57
atom
54
57
shift_expr
50
57
False
35
57
-
49
57
None
42
57
NUMBER
27
57
STRING
28
57
{
52
57
comparison
39
57
not_test
320
57
+
55
57
not
57
58
if
1
58
arith_expr
2
58
[
3
58
try
4
58
class
5
58
for
6
58
with_stmt
7
58
while_stmt
8
58
factor
9
58
@
10
58
simple_stmt
11
58
decorators
12
58
return
13
58
confdef
14
58
flow_stmt
15
58
expr
16
58
True
17
58
not_test
18
58
and_expr
19
58
def
20
58
term
21
58
xor_expr
22
58
or_test
23
58
atom_expr
24
58
global
25
58
for_stmt
26
58
NUMBER
27
58
STRING
28
58
NAME
29
58
decorator
30
58
if_stmt
31
58
with
32
58
endsim
33
58
classdef
34
58
False
35
58
(
36
58
and_test
37
58
conf
38
58
comparison
39
58
lambda
40
58
while
41
58
None
42
58
try_stmt
43
58
funcdef
44
58
~
45
58
decorated
46
58
small_stmt
47
58
test
48
58
-
49
58
shift_expr
50
58
compound_stmt
51
58
{
52
58
lambdef
53
58
atom
54
58
+
55
58
power
56
58
not
57
58
stmt
58
58
continue
59
58
del_stmt
60
58
test_list
61
58
raise
62
58
raise_stmt
63
58
resetstats
64
58
pass_stmt
65
58
nonlocal
66
58
global_stmt
67
58
yield
68
58
continue_stmt
69
58
assert
70
58
nonlocal_stmt
71
58
expr_stmt
72
58
NEWLINE
73
58
break_stmt
74
58
return_stmt
75
58
break
76
58
sim_stmt
77
58
stat_stmt
78
58
yield_stmt
79
58
$
program -> 
58
assert_stmt
80
58
pass
81
58
program
321
58
begsim
83
58
del
84
59
NEWLINE
continue_stmt -> continue
60
NEWLINE
small_stmt -> del_stmt
61
//=
322
61
/=
323
61
*=
324
61
&=
325
61
>>=
326
61
=
327
61
%=
328
61
-=
329
61
^=
330
61
|=
331
61
<<=
332
61
@=
333
61
**=
334
61
+=
335
61
assign
336
61
annassign
337
61
NEWLINE
assign -> 
61
augassign
338
61
:
339
62
factor
340
62
atom_expr
341
62
(
342
62
arith_expr
343
62
lambda
344
62
NAME
345
62
[
346
62
+
347
62
term
348
62
atom
349
62
NUMBER
350
62
shift_expr
351
62
STRING
352
62
-
353
62
or_test
354
62
True
355
62
and_expr
356
62
not
357
62
xor_expr
358
62
None
359
62
expr
360
62
False
361
62
and_test
362
62
{
363
62
~
364
62
power
365
62
not_test
366
62
comparison
367
62
NEWLINE
raise_stmt -> raise
62
lambdef
368
62
test
369
63
NEWLINE
flow_stmt -> raise_stmt
64
NEWLINE
stat_stmt -> resetstats
65
NEWLINE
small_stmt -> pass_stmt
66
namelist
370
66
NAME
234
67
NEWLINE
small_stmt -> global_stmt
68
factor
371
68
term
372
68
(
373
68
True
374
68
[
375
68
+
376
68
STRING
377
68
atom_expr
378
68
arith_expr
379
68
NUMBER
380
68
~
381
68
NAME
382
68
False
383
68
{
384
68
and_expr
385
68
shift_expr
386
68
NEWLINE
yield_stmt -> yield
68
None
387
68
power
388
68
-
389
68
expr
390
68
expr_list
391
68
xor_expr
392
68
atom
393
69
NEWLINE
flow_stmt -> continue_stmt
70
factor
184
70
term
185
70
(
186
70
arith_expr
187
70
NAME
188
70
[
189
70
+
190
70
atom_expr
191
70
atom
192
70
NUMBER
193
70
STRING
194
70
shift_expr
195
70
-
196
70
True
197
70
not_test
198
70
and_expr
199
70
xor_expr
200
70
None
201
70
expr
202
70
False
203
70
and_test
204
70
lambda
205
70
{
206
70
~
207
70
power
208
70
test
209
70
not
210
70
or_test
211
70
comparison
212
70
test_list
394
70
lambdef
214
71
NEWLINE
small_stmt -> nonlocal_stmt
72
NEWLINE
small_stmt -> expr_stmt
73
if
1
73
arith_expr
2
73
[
3
73
try
4
73
class
5
73
for
6
73
with_stmt
7
73
while_stmt
8
73
factor
9
73
@
10
73
simple_stmt
11
73
decorators
12
73
return
13
73
confdef
14
73
flow_stmt
15
73
expr
16
73
True
17
73
not_test
18
73
and_expr
19
73
def
20
73
term
21
73
xor_expr
22
73
or_test
23
73
atom_expr
24
73
global
25
73
for_stmt
26
73
NUMBER
27
73
STRING
28
73
NAME
29
73
decorator
30
73
if_stmt
31
73
with
32
73
endsim
33
73
classdef
34
73
False
35
73
(
36
73
and_test
37
73
conf
38
73
comparison
39
73
lambda
40
73
while
41
73
None
42
73
try_stmt
43
73
funcdef
44
73
~
45
73
decorated
46
73
small_stmt
47
73
test
48
73
-
49
73
shift_expr
50
73
compound_stmt
51
73
{
52
73
lambdef
53
73
atom
54
73
+
55
73
power
56
73
not
57
73
stmt
58
73
continue
59
73
del_stmt
60
73
test_list
61
73
raise
62
73
raise_stmt
63
73
resetstats
64
73
pass_stmt
65
73
nonlocal
66
73
global_stmt
67
73
yield
68
73
continue_stmt
69
73
assert
70
73
nonlocal_stmt
71
73
expr_stmt
72
73
NEWLINE
73
73
break_stmt
74
73
return_stmt
75
73
program
395
73
break
76
73
sim_stmt
77
73
stat_stmt
78
73
yield_stmt
79
73
$
program -> 
73
assert_stmt
80
73
pass
81
73
begsim
83
73
del
84
74
NEWLINE
flow_stmt -> break_stmt
75
NEWLINE
flow_stmt -> return_stmt
76
NEWLINE
break_stmt -> break
77
NEWLINE
small_stmt -> sim_stmt
78
NEWLINE
small_stmt -> stat_stmt
79
NEWLINE
flow_stmt -> yield_stmt
80
NEWLINE
small_stmt -> assert_stmt
81
NEWLINE
pass_stmt -> pass
82
$
OK
83
factor
396
83
(
397
83
arith_expr
398
83
NAME
399
83
[
400
83
+
401
83
term
402
83
atom_expr
403
83
atom
404
83
NUMBER
405
83
STRING
406
83
shift_expr
407
83
-
408
83
True
409
83
and_expr
410
83
xor_expr
411
83
None
412
83
expr
413
83
False
414
83
and_test
415
83
lambda
416
83
{
417
83
~
418
83
power
419
83
not_test
420
83
not
421
83
comparison
422
83
or_test
423
83
lambdef
424
83
test
425
84
factor
371
84
term
372
84
(
373
84
True
374
84
[
375
84
+
376
84
STRING
377
84
atom_expr
378
84
arith_expr
379
84
NUMBER
380
84
~
381
84
NAME
382
84
False
383
84
{
384
84
and_expr
385
84
shift_expr
386
84
None
387
84
power
388
84
-
389
84
expr
390
84
xor_expr
392
84
atom
393
84
expr_list
426
85
//
427
85
/
428
85
in
term -> factor
85
-
term -> factor
85
*
429
85
%
430
85
@
431
85
:
term -> factor
85
>=
term -> factor
85
<
term -> factor
85
<=
term -> factor
85
==
term -> factor
85
!=
term -> factor
85
>>
term -> factor
85
is
term -> factor
85
or
term -> factor
85
and
term -> factor
85
^
term -> factor
85
+
term -> factor
85
&
term -> factor
85
<<
term -> factor
85
|
term -> factor
85
>
term -> factor
85
if
term -> factor
85
not
term -> factor
86
factor
268
86
term
270
86
(
271
86
arith_expr
272
86
NAME
273
86
[
274
86
+
275
86
test_list_comp
432
86
atom_expr
277
86
NUMBER
278
86
atom
279
86
STRING
280
86
shift_expr
281
86
-
282
86
True
283
86
not_test
284
86
lambdef
285
86
and_expr
286
86
xor_expr
287
86
False
288
86
None
289
86
expr
290
86
and_test
291
86
)
433
86
{
292
86
~
293
86
power
294
86
lambda
295
86
comparison
296
86
or_test
297
86
not
298
86
test
299
86
test_list
300
87
>>
434
87
<<
435
87
&
shift_expr -> arith_expr
87
<=
shift_expr -> arith_expr
87
>
shift_expr -> arith_expr
87
not
shift_expr -> arith_expr
87
!=
shift_expr -> arith_expr
87
^
shift_expr -> arith_expr
87
is
shift_expr -> arith_expr
87
|
shift_expr -> arith_expr
87
>=
shift_expr -> arith_expr
87
or
shift_expr -> arith_expr
87
==
shift_expr -> arith_expr
87
if
shift_expr -> arith_expr
87
and
shift_expr -> arith_expr
87
<
shift_expr -> arith_expr
87
:
shift_expr -> arith_expr
87
in
shift_expr -> arith_expr
88
:
atom -> NAME
88
-
atom -> NAME
88
or
atom -> NAME
88
>>
atom -> NAME
88
&
atom -> NAME
88
[
atom -> NAME
88
<=
atom -> NAME
88
<
atom -> NAME
88
.
atom -> NAME
88
|
atom -> NAME
88
*
atom -> NAME
88
/
atom -> NAME
88
<<
atom -> NAME
88
not
atom -> NAME
88
>
atom -> NAME
88
is
atom -> NAME
88
//
atom -> NAME
88
+
atom -> NAME
88
if
atom -> NAME
88
in
atom -> NAME
88
**
atom -> NAME
88
!=
atom -> NAME
88
>=
atom -> NAME
88
^
atom -> NAME
88
@
atom -> NAME
88
(
atom -> NAME
88
==
atom -> NAME
88
and
atom -> NAME
88
%
atom -> NAME
89
+
436
89
-
437
89
|
arith_expr -> term
89
:
arith_expr -> term
89
or
arith_expr -> term
89
not
arith_expr -> term
89
<=
arith_expr -> term
89
!=
arith_expr -> term
89
<
arith_expr -> term
89
&
arith_expr -> term
89
>=
arith_expr -> term
89
if
arith_expr -> term
89
==
arith_expr -> term
89
^
arith_expr -> term
89
in
arith_expr -> term
89
is
arith_expr -> term
89
<<
arith_expr -> term
89
>
arith_expr -> term
89
and
arith_expr -> term
89
>>
arith_expr -> term
90
factor
117
90
or_test
118
90
term
119
90
(
120
90
arith_expr
121
90
NAME
122
90
[
123
90
]
438
90
+
125
90
atom_expr
126
90
NUMBER
127
90
atom
128
90
STRING
129
90
shift_expr
130
90
-
131
90
test_list_comp
439
90
True
133
90
not_test
134
90
lambdef
135
90
and_expr
136
90
xor_expr
137
90
False
138
90
None
139
90
expr
140
90
and_test
141
90
{
142
90
~
143
90
lambda
144
90
power
145
90
comparison
146
90
test_list
147
90
test
148
90
not
149
91
(
86
91
NAME
88
91
[
90
91
~
91
91
+
92
91
factor
440
91
atom_expr
94
91
NUMBER
96
91
atom
95
91
STRING
97
91
-
100
91
True
101
91
False
104
91
{
105
91
None
106
91
power
108
92
(
86
92
NAME
88
92
[
90
92
~
91
92
+
92
92
atom_expr
94
92
NUMBER
96
92
atom
95
92
STRING
97
92
-
100
92
factor
441
92
True
101
92
False
104
92
{
105
92
None
106
92
power
108
93
is
215
93
<
217
93
!=
218
93
in
219
93
<=
220
93
not
221
93
>=
222
93
>
223
93
==
224
93
comp_op
442
93
and
comparison -> expr
93
or
comparison -> expr
93
:
comparison -> expr
93
if
comparison -> expr
94
!=
power -> atom_expr
94
**
443
94
>
power -> atom_expr
94
+
power -> atom_expr
94
not
power -> atom_expr
94
&
power -> atom_expr
94
|
power -> atom_expr
94
>>
power -> atom_expr
94
:
power -> atom_expr
94
^
power -> atom_expr
94
==
power -> atom_expr
94
if
power -> atom_expr
94
in
power -> atom_expr
94
%
power -> atom_expr
94
<<
power -> atom_expr
94
or
power -> atom_expr
94
@
power -> atom_expr
94
*
power -> atom_expr
94
/
power -> atom_expr
94
<
power -> atom_expr
94
//
power -> atom_expr
94
>=
power -> atom_expr
94
-
power -> atom_expr
94
is
power -> atom_expr
94
<=
power -> atom_expr
94
and
power -> atom_expr
95
trailer
444
95
.
445
95
(
446
95
[
447
95
trailer_expr
448
95
<<
trailer_expr -> 
95
%
trailer_expr -> 
95
==
trailer_expr -> 
95
-
trailer_expr -> 
95
<
trailer_expr -> 
95
if
trailer_expr -> 
95
or
trailer_expr -> 
95
/
trailer_expr -> 
95
**
trailer_expr -> 
95
and
trailer_expr -> 
95
@
trailer_expr -> 
95
*
trailer_expr -> 
95
|
trailer_expr -> 
95
is
trailer_expr -> 
95
+
trailer_expr -> 
95
in
trailer_expr -> 
95
&
trailer_expr -> 
95
<=
trailer_expr -> 
95
>=
trailer_expr -> 
95
^
trailer_expr -> 
95
>
trailer_expr -> 
95
!=
trailer_expr -> 
95
not
trailer_expr -> 
95
>>
trailer_expr -> 
95
//
trailer_expr -> 
95
:
trailer_expr -> 
96
[
atom -> NUMBER
96
>=
atom -> NUMBER
96
<=
atom -> NUMBER
96
!=
atom -> NUMBER
96
//
atom -> NUMBER
96
in
atom -> NUMBER
96
/
atom -> NUMBER
96
:
atom -> NUMBER
96
or
atom -> NUMBER
96
>
atom -> NUMBER
96
not
atom -> NUMBER
96
>>
atom -> NUMBER
96
(
atom -> NUMBER
96
**
atom -> NUMBER
96
<<
atom -> NUMBER
96
and
atom -> NUMBER
96
+
atom -> NUMBER
96
%
atom -> NUMBER
96
==
atom -> NUMBER
96
if
atom -> NUMBER
96
is
atom -> NUMBER
96
*
atom -> NUMBER
96
@
atom -> NUMBER
96
|
atom -> NUMBER
96
-
atom -> NUMBER
96
.
atom -> NUMBER
96
^
atom -> NUMBER
96
<
atom -> NUMBER
96
&
atom -> NUMBER
97
and
atom -> STRING
97
%
atom -> STRING
97
//
atom -> STRING
97
>>
atom -> STRING
97
*
atom -> STRING
97
<
atom -> STRING
97
.
atom -> STRING
97
in
atom -> STRING
97
:
atom -> STRING
97
^
atom -> STRING
97
(
atom -> STRING
97
if
atom -> STRING
97
==
atom -> STRING
97
-
atom -> STRING
97
**
atom -> STRING
97
<<
atom -> STRING
97
<=
atom -> STRING
97
[
atom -> STRING
97
not
atom -> STRING
97
or
atom -> STRING
97
+
atom -> STRING
97
>=
atom -> STRING
97
@
atom -> STRING
97
&
atom -> STRING
97
>
atom -> STRING
97
is
atom -> STRING
97
|
atom -> STRING
97
!=
atom -> STRING
97
/
atom -> STRING
98
:
449
99
&
450
99
^
and_expr -> shift_expr
99
|
and_expr -> shift_expr
99
<=
and_expr -> shift_expr
99
or
and_expr -> shift_expr
99
>
and_expr -> shift_expr
99
not
and_expr -> shift_expr
99
!=
and_expr -> shift_expr
99
and
and_expr -> shift_expr
99
is
and_expr -> shift_expr
99
<
and_expr -> shift_expr
99
if
and_expr -> shift_expr
99
in
and_expr -> shift_expr
99
>=
and_expr -> shift_expr
99
:
and_expr -> shift_expr
99
==
and_expr -> shift_expr
100
(
86
100
NAME
88
100
[
90
100
~
91
100
+
92
100
atom_expr
94
100
NUMBER
96
100
atom
95
100
STRING
97
100
-
100
100
True
101
100
False
104
100
{
105
100
None
106
100
power
108
100
factor
451
101
(
atom -> True
101
[
atom -> True
101
+
atom -> True
101
@
atom -> True
101
not
atom -> True
101
<=
atom -> True
101
&
atom -> True
101
<<
atom -> True
101
-
atom -> True
101
/
atom -> True
101
or
atom -> True
101
>
atom -> True
101
%
atom -> True
101
^
atom -> True
101
if
atom -> True
101
!=
atom -> True
101
is
atom -> True
101
*
atom -> True
101
<
atom -> True
101
and
atom -> True
101
.
atom -> True
101
==
atom -> True
101
**
atom -> True
101
>>
atom -> True
101
in
atom -> True
101
|
atom -> True
101
>=
atom -> True
101
//
atom -> True
101
:
atom -> True
102
^
452
102
not
xor_expr -> and_expr
102
if
xor_expr -> and_expr
102
<=
xor_expr -> and_expr
102
:
xor_expr -> and_expr
102
>
xor_expr -> and_expr
102
<
xor_expr -> and_expr
102
in
xor_expr -> and_expr
102
>=
xor_expr -> and_expr
102
==
xor_expr -> and_expr
102
|
xor_expr -> and_expr
102
is
xor_expr -> and_expr
102
and
xor_expr -> and_expr
102
or
xor_expr -> and_expr
102
!=
xor_expr -> and_expr
103
|
453
103
>=
expr -> xor_expr
103
==
expr -> xor_expr
103
is
expr -> xor_expr
103
:
expr -> xor_expr
103
if
expr -> xor_expr
103
or
expr -> xor_expr
103
>
expr -> xor_expr
103
and
expr -> xor_expr
103
<
expr -> xor_expr
103
in
expr -> xor_expr
103
<=
expr -> xor_expr
103
not
expr -> xor_expr
103
!=
expr -> xor_expr
104
in
atom -> False
104
>
atom -> False
104
-
atom -> False
104
%
atom -> False
104
<
atom -> False
104
|
atom -> False
104
==
atom -> False
104
&
atom -> False
104
//
atom -> False
104
and
atom -> False
104
:
atom -> False
104
not
atom -> False
104
+
atom -> False
104
!=
atom -> False
104
if
atom -> False
104
@
atom -> False
104
[
atom -> False
104
or
atom -> False
104
<=
atom -> False
104
*
atom -> False
104
^
atom -> False
104
is
atom -> False
104
/
atom -> False
104
.
atom -> False
104
>=
atom -> False
104
**
atom -> False
104
>>
atom -> False
104
<<
atom -> False
104
(
atom -> False
105
}
454
106
is
atom -> None
106
.
atom -> None
106
==
atom -> None
106
^
atom -> None
106
<<
atom -> None
106
>>
atom -> None
106
(
atom -> None
106
|
atom -> None
106
+
atom -> None
106
*
atom -> None
106
//
atom -> None
106
@
atom -> None
106
in
atom -> None
106
>=
atom -> None
106
!=
atom -> None
106
%
atom -> None
106
[
atom -> None
106
and
atom -> None
106
-
atom -> None
106
if
atom -> None
106
&
atom -> None
106
<=
atom -> None
106
<
atom -> None
106
>
atom -> None
106
**
atom -> None
106
:
atom -> None
106
or
atom -> None
106
/
atom -> None
106
not
atom -> None
107
:
or_test -> and_test
107
or
455
107
if
or_test -> and_test
108
&
factor -> power
108
%
factor -> power
108
<<
factor -> power
108
-
factor -> power
108
<=
factor -> power
108
not
factor -> power
108
//
factor -> power
108
/
factor -> power
108
is
factor -> power
108
|
factor -> power
108
<
factor -> power
108
and
factor -> power
108
>=
factor -> power
108
>>
factor -> power
108
>
factor -> power
108
in
factor -> power
108
if
factor -> power
108
^
factor -> power
108
==
factor -> power
108
+
factor -> power
108
@
factor -> power
108
or
factor -> power
108
*
factor -> power
108
:
factor -> power
108
!=
factor -> power
109
and
456
109
or
and_test -> not_test
109
if
and_test -> not_test
109
:
and_test -> not_test
110
:
test -> lambdef
111
if
457
111
:
test -> or_test
112
if
not_test -> comparison
112
and
not_test -> comparison
112
or
not_test -> comparison
112
:
not_test -> comparison
113
factor
85
113
(
86
113
arith_expr
87
113
NAME
88
113
term
89
113
[
90
113
~
91
113
+
92
113
expr
93
113
atom_expr
94
113
atom
95
113
NUMBER
96
113
STRING
97
113
shift_expr
99
113
-
100
113
not_test
458
113
True
101
113
and_expr
102
113
xor_expr
103
113
False
104
113
{
105
113
None
106
113
power
108
113
comparison
112
113
not
113
114
:
459
114
varargslist
460
114
NAME
305
114
vfpdef
306
115
factor
9
115
arith_expr
2
115
NAME
29
115
term
21
115
[
3
115
~
45
115
atom_expr
24
115
power
56
115
(
36
115
True
17
115
atom
54
115
False
35
115
-
49
115
None
42
115
NUMBER
27
115
STRING
28
115
shift_expr
461
115
{
52
115
+
55
116
factor
9
116
arith_expr
2
116
NAME
29
116
term
21
116
[
3
116
~
45
116
atom_expr
24
116
power
56
116
(
36
116
True
17
116
atom
54
116
False
35
116
-
49
116
None
42
116
NUMBER
27
116
STRING
28
116
{
52
116
+
55
116
shift_expr
462
117
//
463
117
in
term -> factor
117
-
term -> factor
117
*
464
117
%
465
117
@
466
117
]
term -> factor
117
>=
term -> factor
117
/
467
117
<
term -> factor
117
<=
term -> factor
117
==
term -> factor
117
!=
term -> factor
117
>>
term -> factor
117
is
term -> factor
117
or
term -> factor
117
and
term -> factor
117
for
term -> factor
117
^
term -> factor
117
,
term -> factor
117
+
term -> factor
117
&
term -> factor
117
<<
term -> factor
117
|
term -> factor
117
>
term -> factor
117
if
term -> factor
117
not
term -> factor
118
if
468
118
]
test -> or_test
118
,
test -> or_test
118
for
test -> or_test
119
+
469
119
-
470
119
for
arith_expr -> term
119
|
arith_expr -> term
119
or
arith_expr -> term
119
not
arith_expr -> term
119
<=
arith_expr -> term
119
!=
arith_expr -> term
119
<
arith_expr -> term
119
&
arith_expr -> term
119
>=
arith_expr -> term
119
if
arith_expr -> term
119
==
arith_expr -> term
119
^
arith_expr -> term
119
in
arith_expr -> term
119
is
arith_expr -> term
119
<<
arith_expr -> term
119
,
arith_expr -> term
119
>
arith_expr -> term
119
and
arith_expr -> term
119
>>
arith_expr -> term
119
]
arith_expr -> term
120
factor
268
120
term
270
120
(
271
120
arith_expr
272
120
NAME
273
120
[
274
120
+
275
120
test_list_comp
471
120
atom_expr
277
120
NUMBER
278
120
atom
279
120
STRING
280
120
shift_expr
281
120
-
282
120
)
472
120
True
283
120
not_test
284
120
lambdef
285
120
and_expr
286
120
xor_expr
287
120
False
288
120
None
289
120
expr
290
120
and_test
291
120
{
292
120
~
293
120
power
294
120
lambda
295
120
comparison
296
120
or_test
297
120
not
298
120
test
299
120
test_list
300
121
>>
473
121
<<
474
121
&
shift_expr -> arith_expr
121
<=
shift_expr -> arith_expr
121
>
shift_expr -> arith_expr
121
not
shift_expr -> arith_expr
121
!=
shift_expr -> arith_expr
121
^
shift_expr -> arith_expr
121
is
shift_expr -> arith_expr
121
|
shift_expr -> arith_expr
121
>=
shift_expr -> arith_expr
121
or
shift_expr -> arith_expr
121
]
shift_expr -> arith_expr
121
,
shift_expr -> arith_expr
121
==
shift_expr -> arith_expr
121
if
shift_expr -> arith_expr
121
and
shift_expr -> arith_expr
121
<
shift_expr -> arith_expr
121
for
shift_expr -> arith_expr
121
in
shift_expr -> arith_expr
122
]
atom -> NAME
122
-
atom -> NAME
122
,
atom -> NAME
122
for
atom -> NAME
122
or
atom -> NAME
122
>>
atom -> NAME
122
&
atom -> NAME
122
[
atom -> NAME
122
<=
atom -> NAME
122
<
atom -> NAME
122
.
atom -> NAME
122
|
atom -> NAME
122
*
atom -> NAME
122
/
atom -> NAME
122
<<
atom -> NAME
122
not
atom -> NAME
122
>
atom -> NAME
122
is
atom -> NAME
122
//
atom -> NAME
122
+
atom -> NAME
122
if
atom -> NAME
122
in
atom -> NAME
122
**
atom -> NAME
122
!=
atom -> NAME
122
>=
atom -> NAME
122
^
atom -> NAME
122
@
atom -> NAME
122
(
atom -> NAME
122
==
atom -> NAME
122
and
atom -> NAME
122
%
atom -> NAME
123
factor
117
123
or_test
118
123
term
119
123
(
120
123
arith_expr
121
123
NAME
122
123
[
123
123
]
475
123
+
125
123
atom_expr
126
123
NUMBER
127
123
atom
128
123
STRING
129
123
shift_expr
130
123
-
131
123
test_list_comp
476
123
True
133
123
not_test
134
123
lambdef
135
123
and_expr
136
123
xor_expr
137
123
False
138
123
None
139
123
expr
140
123
and_test
141
123
{
142
123
~
143
123
lambda
144
123
power
145
123
comparison
146
123
test_list
147
123
test
148
123
not
149
124
<=
atom -> [ ]
124
&=
atom -> [ ]
124
^=
atom -> [ ]
124
is
atom -> [ ]
124
<<=
atom -> [ ]
124
-
atom -> [ ]
124
%=
atom -> [ ]
124
**
atom -> [ ]
124
/=
atom -> [ ]
124
//=
atom -> [ ]
124
^
atom -> [ ]
124
%
atom -> [ ]
124
/
atom -> [ ]
124
>=
atom -> [ ]
124
|
atom -> [ ]
124
not
atom -> [ ]
124
@
atom -> [ ]
124
*
atom -> [ ]
124
*=
atom -> [ ]
124
(
atom -> [ ]
124
>>
atom -> [ ]
124
[
atom -> [ ]
124
,
atom -> [ ]
124
**=
atom -> [ ]
124
@=
atom -> [ ]
124
:
atom -> [ ]
124
NEWLINE
atom -> [ ]
124
or
atom -> [ ]
124
!=
atom -> [ ]
124
and
atom -> [ ]
124
-=
atom -> [ ]
124
>>=
atom -> [ ]
124
<<
atom -> [ ]
124
|=
atom -> [ ]
124
if
atom -> [ ]
124
+=
atom -> [ ]
124
in
atom -> [ ]
124
+
atom -> [ ]
124
.
atom -> [ ]
124
==
atom -> [ ]
124
>
atom -> [ ]
124
=
atom -> [ ]
124
<
atom -> [ ]
124
&
atom -> [ ]
124
//
atom -> [ ]
125
(
120
125
NAME
122
125
[
123
125
+
125
125
atom_expr
126
125
NUMBER
127
125
atom
128
125
STRING
129
125
-
131
125
factor
477
125
True
133
125
False
138
125
None
139
125
{
142
125
~
143
125
power
145
126
!=
power -> atom_expr
126
**
478
126
>
power -> atom_expr
126
]
power -> atom_expr
126
+
power -> atom_expr
126
not
power -> atom_expr
126
&
power -> atom_expr
126
|
power -> atom_expr
126
>>
power -> atom_expr
126
^
power -> atom_expr
126
==
power -> atom_expr
126
if
power -> atom_expr
126
in
power -> atom_expr
126
%
power -> atom_expr
126
for
power -> atom_expr
126
<<
power -> atom_expr
126
or
power -> atom_expr
126
@
power -> atom_expr
126
*
power -> atom_expr
126
/
power -> atom_expr
126
<
power -> atom_expr
126
//
power -> atom_expr
126
>=
power -> atom_expr
126
-
power -> atom_expr
126
is
power -> atom_expr
126
<=
power -> atom_expr
126
and
power -> atom_expr
126
,
power -> atom_expr
127
[
atom -> NUMBER
127
>=
atom -> NUMBER
127
<=
atom -> NUMBER
127
!=
atom -> NUMBER
127
//
atom -> NUMBER
127
in
atom -> NUMBER
127
/
atom -> NUMBER
127
or
atom -> NUMBER
127
>
atom -> NUMBER
127
,
atom -> NUMBER
127
not
atom -> NUMBER
127
>>
atom -> NUMBER
127
(
atom -> NUMBER
127
**
atom -> NUMBER
127
<<
atom -> NUMBER
127
and
atom -> NUMBER
127
+
atom -> NUMBER
127
%
atom -> NUMBER
127
==
atom -> NUMBER
127
for
atom -> NUMBER
127
]
atom -> NUMBER
127
if
atom -> NUMBER
127
is
atom -> NUMBER
127
*
atom -> NUMBER
127
@
atom -> NUMBER
127
|
atom -> NUMBER
127
-
atom -> NUMBER
127
.
atom -> NUMBER
127
^
atom -> NUMBER
127
<
atom -> NUMBER
127
&
atom -> NUMBER
128
trailer
479
128
.
480
128
(
481
128
[
482
128
trailer_expr
483
128
<<
trailer_expr -> 
128
%
trailer_expr -> 
128
==
trailer_expr -> 
128
-
trailer_expr -> 
128
<
trailer_expr -> 
128
if
trailer_expr -> 
128
or
trailer_expr -> 
128
/
trailer_expr -> 
128
**
trailer_expr -> 
128
and
trailer_expr -> 
128
@
trailer_expr -> 
128
*
trailer_expr -> 
128
|
trailer_expr -> 
128
is
trailer_expr -> 
128
,
trailer_expr -> 
128
+
trailer_expr -> 
128
in
trailer_expr -> 
128
for
trailer_expr -> 
128
&
trailer_expr -> 
128
<=
trailer_expr -> 
128
>=
trailer_expr -> 
128
^
trailer_expr -> 
128
>
trailer_expr -> 
128
!=
trailer_expr -> 
128
not
trailer_expr -> 
128
>>
trailer_expr -> 
128
//
trailer_expr -> 
128
]
trailer_expr -> 
129
and
atom -> STRING
129
for
atom -> STRING
129
%
atom -> STRING
129
//
atom -> STRING
129
>>
atom -> STRING
129
*
atom -> STRING
129
<
atom -> STRING
129
.
atom -> STRING
129
in
atom -> STRING
129
]
atom -> STRING
129
^
atom -> STRING
129
(
atom -> STRING
129
if
atom -> STRING
129
==
atom -> STRING
129
-
atom -> STRING
129
**
atom -> STRING
129
<<
atom -> STRING
129
<=
atom -> STRING
129
[
atom -> STRING
129
not
atom -> STRING
129
or
atom -> STRING
129
+
atom -> STRING
129
>=
atom -> STRING
129
@
atom -> STRING
129
&
atom -> STRING
129
,
atom -> STRING
129
>
atom -> STRING
129
is
atom -> STRING
129
|
atom -> STRING
129
!=
atom -> STRING
129
/
atom -> STRING
130
&
484
130
^
and_expr -> shift_expr
130
|
and_expr -> shift_expr
130
<=
and_expr -> shift_expr
130
for
and_expr -> shift_expr
130
or
and_expr -> shift_expr
130
>
and_expr -> shift_expr
130
]
and_expr -> shift_expr
130
not
and_expr -> shift_expr
130
,
and_expr -> shift_expr
130
!=
and_expr -> shift_expr
130
and
and_expr -> shift_expr
130
is
and_expr -> shift_expr
130
<
and_expr -> shift_expr
130
if
and_expr -> shift_expr
130
in
and_expr -> shift_expr
130
>=
and_expr -> shift_expr
130
==
and_expr -> shift_expr
131
(
120
131
NAME
122
131
[
123
131
+
125
131
atom_expr
126
131
NUMBER
127
131
atom
128
131
STRING
129
131
-
131
131
True
133
131
False
138
131
None
139
131
{
142
131
~
143
131
power
145
131
factor
485
132
]
486
133
(
atom -> True
133
for
atom -> True
133
[
atom -> True
133
+
atom -> True
133
@
atom -> True
133
<=
atom -> True
133
&
atom -> True
133
<<
atom -> True
133
-
atom -> True
133
/
atom -> True
133
or
atom -> True
133
>
atom -> True
133
%
atom -> True
133
^
atom -> True
133
if
atom -> True
133
!=
atom -> True
133
is
atom -> True
133
*
atom -> True
133
<
atom -> True
133
,
atom -> True
133
and
atom -> True
133
.
atom -> True
133
==
atom -> True
133
]
atom -> True
133
**
atom -> True
133
>>
atom -> True
133
in
atom -> True
133
|
atom -> True
133
>=
atom -> True
133
//
atom -> True
133
not
atom -> True
134
and
487
134
]
and_test -> not_test
134
or
and_test -> not_test
134
,
and_test -> not_test
134
if
and_test -> not_test
134
for
and_test -> not_test
135
]
test -> lambdef
135
,
test -> lambdef
135
for
test -> lambdef
136
^
488
136
not
xor_expr -> and_expr
136
if
xor_expr -> and_expr
136
<=
xor_expr -> and_expr
136
,
xor_expr -> and_expr
136
>
xor_expr -> and_expr
136
]
xor_expr -> and_expr
136
<
xor_expr -> and_expr
136
in
xor_expr -> and_expr
136
>=
xor_expr -> and_expr
136
for
xor_expr -> and_expr
136
==
xor_expr -> and_expr
136
|
xor_expr -> and_expr
136
is
xor_expr -> and_expr
136
and
xor_expr -> and_expr
136
or
xor_expr -> and_expr
136
!=
xor_expr -> and_expr
137
|
489
137
>=
expr -> xor_expr
137
,
expr -> xor_expr
137
==
expr -> xor_expr
137
is
expr -> xor_expr
137
if
expr -> xor_expr
137
or
expr -> xor_expr
137
for
expr -> xor_expr
137
>
expr -> xor_expr
137
and
expr -> xor_expr
137
<
expr -> xor_expr
137
]
expr -> xor_expr
137
in
expr -> xor_expr
137
<=
expr -> xor_expr
137
not
expr -> xor_expr
137
!=
expr -> xor_expr
138
in
atom -> False
138
>
atom -> False
138
-
atom -> False
138
%
atom -> False
138
<
atom -> False
138
|
atom -> False
138
==
atom -> False
138
&
atom -> False
138
//
atom -> False
138
and
atom -> False
138
not
atom -> False
138
+
atom -> False
138
!=
atom -> False
138
if
atom -> False
138
for
atom -> False
138
@
atom -> False
138
]
atom -> False
138
[
atom -> False
138
or
atom -> False
138
<=
atom -> False
138
*
atom -> False
138
^
atom -> False
138
is
atom -> False
138
/
atom -> False
138
.
atom -> False
138
>=
atom -> False
138
**
atom -> False
138
>>
atom -> False
138
,
atom -> False
138
<<
atom -> False
138
(
atom -> False
139
is
atom -> None
139
.
atom -> None
139
==
atom -> None
139
^
atom -> None
139
<<
atom -> None
139
>>
atom -> None
139
(
atom -> None
139
|
atom -> None
139
+
atom -> None
139
for
atom -> None
139
*
atom -> None
139
//
atom -> None
139
@
atom -> None
139
in
atom -> None
139
>=
atom -> None
139
!=
atom -> None
139
%
atom -> None
139
]
atom -> None
139
[
atom -> None
139
and
atom -> None
139
-
atom -> None
139
if
atom -> None
139
&
atom -> None
139
<=
atom -> None
139
<
atom -> None
139
>
atom -> None
139
,
atom -> None
139
**
atom -> None
139
or
atom -> None
139
/
atom -> None
139
not
atom -> None
140
is
215
140
<
217
140
!=
218
140
in
219
140
<=
220
140
comp_op
490
140
not
221
140
>=
222
140
>
223
140
==
224
140
]
comparison -> expr
140
and
comparison -> expr
140
or
comparison -> expr
140
if
comparison -> expr
140
,
comparison -> expr
140
for
comparison -> expr
141
,
or_test -> and_test
141
or
491
141
for
or_test -> and_test
141
if
or_test -> and_test
141
]
or_test -> and_test
142
}
492
143
(
120
143
NAME
122
143
[
123
143
+
125
143
factor
493
143
atom_expr
126
143
NUMBER
127
143
atom
128
143
STRING
129
143
-
131
143
True
133
143
False
138
143
None
139
143
{
142
143
~
143
143
power
145
144
:
494
144
NAME
305
144
varargslist
495
144
vfpdef
306
145
&
factor -> power
145
%
factor -> power
145
<<
factor -> power
145
-
factor -> power
145
<=
factor -> power
145
not
factor -> power
145
//
factor -> power
145
/
factor -> power
145
is
factor -> power
145
for
factor -> power
145
|
factor -> power
145
<
factor -> power
145
and
factor -> power
145
>=
factor -> power
145
>>
factor -> power
145
>
factor -> power
145
in
factor -> power
145
if
factor -> power
145
^
factor -> power
145
==
factor -> power
145
+
factor -> power
145
,
factor -> power
145
@
factor -> power
145
or
factor -> power
145
*
factor -> power
145
]
factor -> power
145
!=
factor -> power
146
or
not_test -> comparison
146
and
not_test -> comparison
146
,
not_test -> comparison
146
for
not_test -> comparison
146
if
not_test -> comparison
146
]
not_test -> comparison
147
]
test_list_comp -> test_list
148
comp_for
496
148
for
497
148
]
test_list -> test
148
,
498
149
factor
117
149
term
119
149
(
120
149
arith_expr
121
149
NAME
122
149
[
123
149
+
125
149
atom_expr
126
149
NUMBER
127
149
atom
128
149
STRING
129
149
shift_expr
130
149
-
131
149
not_test
499
149
True
133
149
and_expr
136
149
xor_expr
137
149
False
138
149
None
139
149
expr
140
149
{
142
149
~
143
149
power
145
149
comparison
146
149
not
149
150
factor
9
150
arith_expr
2
150
NAME
29
150
term
21
150
[
3
150
~
45
150
atom_expr
24
150
expr
16
150
power
56
150
(
36
150
return
13
150
flow_stmt
15
150
True
17
150
not_test
18
150
suite
500
150
and_expr
19
150
xor_expr
22
150
{
52
150
lambdef
53
150
atom
54
150
or_test
23
150
shift_expr
50
150
False
35
150
-
49
150
None
42
150
lambda
40
150
global
25
150
NUMBER
27
150
STRING
28
150
test
48
150
endsim
33
150
and_test
37
150
comparison
39
150
break_stmt
74
150
+
55
150
not
57
150
small_stmt
501
150
raise
62
150
continue
59
150
return_stmt
75
150
del_stmt
60
150
test_list
61
150
raise_stmt
63
150
resetstats
64
150
pass_stmt
65
150
nonlocal
66
150
break
76
150
sim_stmt
77
150
stat_stmt
78
150
global_stmt
67
150
yield_stmt
79
150
NEWLINE
502
150
simple_stmt
503
150
assert_stmt
80
150
pass
81
150
yield
68
150
continue_stmt
69
150
assert
70
150
nonlocal_stmt
71
150
expr_stmt
72
150
begsim
83
150
del
84
151
(
504
151
:
505
152
<<
term -> factor
152
//
506
152
|
term -> factor
152
in
term -> factor
152
/
507
152
%
508
152
*
509
152
@
510
152
-
term -> factor
152
^
term -> factor
152
,
term -> factor
152
+
term -> factor
152
&
term -> factor
152
>>
term -> factor
153
+
atom -> NUMBER
153
%
atom -> NUMBER
153
[
atom -> NUMBER
153
,
atom -> NUMBER
153
*
atom -> NUMBER
153
-
atom -> NUMBER
153
&
atom -> NUMBER
153
.
atom -> NUMBER
153
>>
atom -> NUMBER
153
^
atom -> NUMBER
153
(
atom -> NUMBER
153
@
atom -> NUMBER
153
**
atom -> NUMBER
153
<<
atom -> NUMBER
153
|
atom -> NUMBER
153
//
atom -> NUMBER
153
in
atom -> NUMBER
153
/
atom -> NUMBER
154
in
511
155
-
512
155
+
513
155
|
arith_expr -> term
155
&
arith_expr -> term
155
in
arith_expr -> term
155
^
arith_expr -> term
155
<<
arith_expr -> term
155
,
arith_expr -> term
155
>>
arith_expr -> term
156
factor
268
156
term
270
156
(
271
156
arith_expr
272
156
NAME
273
156
[
274
156
+
275
156
test_list_comp
514
156
atom_expr
277
156
NUMBER
278
156
atom
279
156
STRING
280
156
shift_expr
281
156
-
282
156
True
283
156
not_test
284
156
lambdef
285
156
and_expr
286
156
xor_expr
287
156
False
288
156
None
289
156
expr
290
156
and_test
291
156
)
515
156
{
292
156
~
293
156
power
294
156
lambda
295
156
comparison
296
156
or_test
297
156
not
298
156
test
299
156
test_list
300
157
.
atom -> True
157
&
atom -> True
157
**
atom -> True
157
(
atom -> True
157
%
atom -> True
157
[
atom -> True
157
>>
atom -> True
157
<<
atom -> True
157
//
atom -> True
157
^
atom -> True
157
-
atom -> True
157
+
atom -> True
157
in
atom -> True
157
/
atom -> True
157
|
atom -> True
157
@
atom -> True
157
*
atom -> True
157
,
atom -> True
158
factor
117
158
or_test
118
158
term
119
158
(
120
158
arith_expr
121
158
NAME
122
158
[
123
158
+
125
158
atom_expr
126
158
NUMBER
127
158
atom
128
158
STRING
129
158
]
516
158
shift_expr
130
158
-
131
158
True
133
158
not_test
134
158
lambdef
135
158
and_expr
136
158
xor_expr
137
158
False
138
158
None
139
158
expr
140
158
and_test
141
158
test_list_comp
517
158
{
142
158
~
143
158
lambda
144
158
power
145
158
comparison
146
158
test_list
147
158
test
148
158
not
149
159
NUMBER
153
159
(
156
159
True
157
159
[
158
159
+
159
159
factor
518
159
STRING
160
159
atom_expr
161
159
~
164
159
NAME
165
159
False
166
159
{
167
159
None
170
159
power
171
159
-
172
159
atom
174
160
-
atom -> STRING
160
^
atom -> STRING
160
**
atom -> STRING
160
+
atom -> STRING
160
%
atom -> STRING
160
<<
atom -> STRING
160
//
atom -> STRING
160
@
atom -> STRING
160
(
atom -> STRING
160
>>
atom -> STRING
160
&
atom -> STRING
160
[
atom -> STRING
160
*
atom -> STRING
160
,
atom -> STRING
160
.
atom -> STRING
160
|
atom -> STRING
160
in
atom -> STRING
160
/
atom -> STRING
161
**
519
161
+
power -> atom_expr
161
&
power -> atom_expr
161
|
power -> atom_expr
161
>>
power -> atom_expr
161
^
power -> atom_expr
161
in
power -> atom_expr
161
%
power -> atom_expr
161
<<
power -> atom_expr
161
@
power -> atom_expr
161
*
power -> atom_expr
161
/
power -> atom_expr
161
//
power -> atom_expr
161
-
power -> atom_expr
161
,
power -> atom_expr
162
<<
520
162
>>
521
162
,
shift_expr -> arith_expr
162
&
shift_expr -> arith_expr
162
|
shift_expr -> arith_expr
162
in
shift_expr -> arith_expr
162
^
shift_expr -> arith_expr
163
in
expr_list -> expr
163
,
522
164
NUMBER
153
164
(
156
164
True
157
164
[
158
164
+
159
164
STRING
160
164
atom_expr
161
164
~
164
164
NAME
165
164
False
166
164
{
167
164
factor
523
164
None
170
164
power
171
164
-
172
164
atom
174
165
&
atom -> NAME
165
[
atom -> NAME
165
in
atom -> NAME
165
**
atom -> NAME
165
-
atom -> NAME
165
.
atom -> NAME
165
,
atom -> NAME
165
>>
atom -> NAME
165
//
atom -> NAME
165
^
atom -> NAME
165
|
atom -> NAME
165
@
atom -> NAME
165
(
atom -> NAME
165
+
atom -> NAME
165
*
atom -> NAME
165
%
atom -> NAME
165
/
atom -> NAME
165
<<
atom -> NAME
166
,
atom -> False
166
*
atom -> False
166
in
atom -> False
166
@
atom -> False
166
-
atom -> False
166
^
atom -> False
166
[
atom -> False
166
%
atom -> False
166
/
atom -> False
166
+
atom -> False
166
.
atom -> False
166
|
atom -> False
166
**
atom -> False
166
>>
atom -> False
166
&
atom -> False
166
//
atom -> False
166
<<
atom -> False
166
(
atom -> False
167
}
524
168
,
xor_expr -> and_expr
168
in
xor_expr -> and_expr
168
^
525
168
|
xor_expr -> and_expr
169
,
expr -> xor_expr
169
in
expr -> xor_expr
169
|
526
170
%
atom -> None
170
[
atom -> None
170
*
atom -> None
170
.
atom -> None
170
//
atom -> None
170
,
atom -> None
170
@
atom -> None
170
^
atom -> None
170
**
atom -> None
170
<<
atom -> None
170
-
atom -> None
170
>>
atom -> None
170
(
atom -> None
170
in
atom -> None
170
&
atom -> None
170
|
atom -> None
170
+
atom -> None
170
/
atom -> None
171
&
factor -> power
171
|
factor -> power
171
+
factor -> power
171
^
factor -> power
171
@
factor -> power
171
%
factor -> power
171
>>
factor -> power
171
<<
factor -> power
171
-
factor -> power
171
in
factor -> power
171
*
factor -> power
171
//
factor -> power
171
/
factor -> power
171
,
factor -> power
172
NUMBER
153
172
(
156
172
True
157
172
[
158
172
factor
527
172
+
159
172
STRING
160
172
atom_expr
161
172
~
164
172
NAME
165
172
False
166
172
{
167
172
None
170
172
power
171
172
-
172
172
atom
174
173
&
528
173
in
and_expr -> shift_expr
173
^
and_expr -> shift_expr
173
,
and_expr -> shift_expr
173
|
and_expr -> shift_expr
174
trailer_expr
529
174
trailer
530
174
(
531
174
.
532
174
[
533
174
<<
trailer_expr -> 
174
,
trailer_expr -> 
174
+
trailer_expr -> 
174
%
trailer_expr -> 
174
in
trailer_expr -> 
174
&
trailer_expr -> 
174
-
trailer_expr -> 
174
^
trailer_expr -> 
174
/
trailer_expr -> 
174
>>
trailer_expr -> 
174
//
trailer_expr -> 
174
**
trailer_expr -> 
174
@
trailer_expr -> 
174
*
trailer_expr -> 
174
|
trailer_expr -> 
175
factor
9
175
NAME
29
175
[
3
175
~
45
175
atom_expr
24
175
power
56
175
(
36
175
term
534
175
True
17
175
atom
54
175
False
35
175
-
49
175
None
42
175
NUMBER
27
175
STRING
28
175
{
52
175
+
55
176
factor
9
176
NAME
29
176
[
3
176
~
45
176
atom_expr
24
176
power
56
176
term
535
176
(
36
176
True
17
176
atom
54
176
False
35
176
-
49
176
None
42
176
NUMBER
27
176
STRING
28
176
{
52
176
+
55
177
factor
9
177
NAME
29
177
[
3
177
~
45
177
atom_expr
24
177
power
56
177
(
36
177
True
17
177
term
536
177
atom
54
177
False
35
177
-
49
177
None
42
177
NUMBER
27
177
STRING
28
177
{
52
177
+
55
178
factor
9
178
NAME
29
178
[
3
178
~
45
178
atom_expr
24
178
power
56
178
(
36
178
term
537
178
True
17
178
atom
54
178
False
35
178
-
49
178
None
42
178
NUMBER
27
178
STRING
28
178
{
52
178
+
55
179
factor
9
179
term
538
179
NAME
29
179
[
3
179
~
45
179
atom_expr
24
179
power
56
179
(
36
179
True
17
179
atom
54
179
False
35
179
-
49
179
None
42
179
NUMBER
27
179
STRING
28
179
{
52
179
+
55
180
(
539
180
NEWLINE
540
181
(
dotted_name -> NAME
181
.
541
181
NEWLINE
dotted_name -> NAME
182
assert
decorated -> decorators classdef
182
None
decorated -> decorators classdef
182
+
decorated -> decorators classdef
182
resetstats
decorated -> decorators classdef
182
return
decorated -> decorators classdef
182
False
decorated -> decorators classdef
182
if
decorated -> decorators classdef
182
(
decorated -> decorators classdef
182
nonlocal
decorated -> decorators classdef
182
$
decorated -> decorators classdef
182
class
decorated -> decorators classdef
182
global
decorated -> decorators classdef
182
pass
decorated -> decorators classdef
182
not
decorated -> decorators classdef
182
conf
decorated -> decorators classdef
182
break
decorated -> decorators classdef
182
yield
decorated -> decorators classdef
182
begsim
decorated -> decorators classdef
182
{
decorated -> decorators classdef
182
NUMBER
decorated -> decorators classdef
182
@
decorated -> decorators classdef
182
NEWLINE
decorated -> decorators classdef
182
with
decorated -> decorators classdef
182
lambda
decorated -> decorators classdef
182
raise
decorated -> decorators classdef
182
~
decorated -> decorators classdef
182
for
decorated -> decorators classdef
182
continue
decorated -> decorators classdef
182
endsim
decorated -> decorators classdef
182
True
decorated -> decorators classdef
182
def
decorated -> decorators classdef
182
try
decorated -> decorators classdef
182
-
decorated -> decorators classdef
182
NAME
decorated -> decorators classdef
182
[
decorated -> decorators classdef
182
STRING
decorated -> decorators classdef
182
del
decorated -> decorators classdef
182
while
decorated -> decorators classdef
183
(
decorated -> decorators funcdef
183
resetstats
decorated -> decorators funcdef
183
NAME
decorated -> decorators funcdef
183
$
decorated -> decorators funcdef
183
class
decorated -> decorators funcdef
183
~
decorated -> decorators funcdef
183
conf
decorated -> decorators funcdef
183
begsim
decorated -> decorators funcdef
183
NEWLINE
decorated -> decorators funcdef
183
endsim
decorated -> decorators funcdef
183
not
decorated -> decorators funcdef
183
assert
decorated -> decorators funcdef
183
{
decorated -> decorators funcdef
183
def
decorated -> decorators funcdef
183
continue
decorated -> decorators funcdef
183
nonlocal
decorated -> decorators funcdef
183
None
decorated -> decorators funcdef
183
while
decorated -> decorators funcdef
183
break
decorated -> decorators funcdef
183
return
decorated -> decorators funcdef
183
+
decorated -> decorators funcdef
183
STRING
decorated -> decorators funcdef
183
False
decorated -> decorators funcdef
183
-
decorated -> decorators funcdef
183
if
decorated -> decorators funcdef
183
[
decorated -> decorators funcdef
183
global
decorated -> decorators funcdef
183
NUMBER
decorated -> decorators funcdef
183
yield
decorated -> decorators funcdef
183
True
decorated -> decorators funcdef
183
try
decorated -> decorators funcdef
183
pass
decorated -> decorators funcdef
183
@
decorated -> decorators funcdef
183
lambda
decorated -> decorators funcdef
183
raise
decorated -> decorators funcdef
183
for
decorated -> decorators funcdef
183
del
decorated -> decorators funcdef
183
with
decorated -> decorators funcdef
184
//
542
184
in
term -> factor
184
-
term -> factor
184
*
543
184
%
544
184
@
545
184
>=
term -> factor
184
/
546
184
<
term -> factor
184
<=
term -> factor
184
==
term -> factor
184
!=
term -> factor
184
>>
term -> factor
184
is
term -> factor
184
or
term -> factor
184
and
term -> factor
184
NEWLINE
term -> factor
184
^
term -> factor
184
,
term -> factor
184
+
term -> factor
184
&
term -> factor
184
<<
term -> factor
184
|
term -> factor
184
>
term -> factor
184
if
term -> factor
184
not
term -> factor
185
+
547
185
-
548
185
NEWLINE
arith_expr -> term
185
|
arith_expr -> term
185
or
arith_expr -> term
185
not
arith_expr -> term
185
<=
arith_expr -> term
185
!=
arith_expr -> term
185
<
arith_expr -> term
185
&
arith_expr -> term
185
>=
arith_expr -> term
185
if
arith_expr -> term
185
==
arith_expr -> term
185
^
arith_expr -> term
185
in
arith_expr -> term
185
is
arith_expr -> term
185
<<
arith_expr -> term
185
,
arith_expr -> term
185
>
arith_expr -> term
185
and
arith_expr -> term
185
>>
arith_expr -> term
186
factor
268
186
term
270
186
(
271
186
arith_expr
272
186
NAME
273
186
[
274
186
+
275
186
test_list_comp
549
186
atom_expr
277
186
NUMBER
278
186
atom
279
186
STRING
280
186
shift_expr
281
186
-
282
186
True
283
186
not_test
284
186
lambdef
285
186
and_expr
286
186
xor_expr
287
186
False
288
186
None
289
186
expr
290
186
and_test
291
186
)
550
186
{
292
186
~
293
186
power
294
186
lambda
295
186
comparison
296
186
or_test
297
186
not
298
186
test
299
186
test_list
300
187
>>
551
187
<<
552
187
&
shift_expr -> arith_expr
187
<=
shift_expr -> arith_expr
187
>
shift_expr -> arith_expr
187
NEWLINE
shift_expr -> arith_expr
187
not
shift_expr -> arith_expr
187
!=
shift_expr -> arith_expr
187
^
shift_expr -> arith_expr
187
is
shift_expr -> arith_expr
187
|
shift_expr -> arith_expr
187
>=
shift_expr -> arith_expr
187
or
shift_expr -> arith_expr
187
,
shift_expr -> arith_expr
187
==
shift_expr -> arith_expr
187
if
shift_expr -> arith_expr
187
and
shift_expr -> arith_expr
187
<
shift_expr -> arith_expr
187
in
shift_expr -> arith_expr
188
-
atom -> NAME
188
,
atom -> NAME
188
or
atom -> NAME
188
>>
atom -> NAME
188
NEWLINE
atom -> NAME
188
&
atom -> NAME
188
[
atom -> NAME
188
<=
atom -> NAME
188
<
atom -> NAME
188
.
atom -> NAME
188
|
atom -> NAME
188
*
atom -> NAME
188
/
atom -> NAME
188
<<
atom -> NAME
188
not
atom -> NAME
188
>
atom -> NAME
188
is
atom -> NAME
188
//
atom -> NAME
188
+
atom -> NAME
188
if
atom -> NAME
188
in
atom -> NAME
188
**
atom -> NAME
188
!=
atom -> NAME
188
>=
atom -> NAME
188
^
atom -> NAME
188
@
atom -> NAME
188
(
atom -> NAME
188
==
atom -> NAME
188
and
atom -> NAME
188
%
atom -> NAME
189
factor
117
189
or_test
118
189
term
119
189
(
120
189
arith_expr
121
189
NAME
122
189
[
123
189
]
553
189
+
125
189
atom_expr
126
189
NUMBER
127
189
atom
128
189
STRING
129
189
shift_expr
130
189
-
131
189
test_list_comp
554
189
True
133
189
not_test
134
189
lambdef
135
189
and_expr
136
189
xor_expr
137
189
False
138
189
None
139
189
expr
140
189
and_test
141
189
{
142
189
~
143
189
lambda
144
189
power
145
189
comparison
146
189
test_list
147
189
test
148
189
not
149
190
(
186
190
NAME
188
190
[
189
190
+
190
190
atom_expr
191
190
NUMBER
193
190
atom
192
190
STRING
194
190
-
196
190
factor
555
190
True
197
190
None
201
190
False
203
190
{
206
190
~
207
190
power
208
191
!=
power -> atom_expr
191
**
556
191
>
power -> atom_expr
191
+
power -> atom_expr
191
not
power -> atom_expr
191
&
power -> atom_expr
191
|
power -> atom_expr
191
>>
power -> atom_expr
191
^
power -> atom_expr
191
==
power -> atom_expr
191
if
power -> atom_expr
191
in
power -> atom_expr
191
%
power -> atom_expr
191
<<
power -> atom_expr
191
or
power -> atom_expr
191
NEWLINE
power -> atom_expr
191
@
power -> atom_expr
191
*
power -> atom_expr
191
/
power -> atom_expr
191
,
power -> atom_expr
191
<
power -> atom_expr
191
//
power -> atom_expr
191
>=
power -> atom_expr
191
-
power -> atom_expr
191
is
power -> atom_expr
191
<=
power -> atom_expr
191
and
power -> atom_expr
192
trailer
557
192
.
558
192
(
559
192
[
560
192
trailer_expr
561
192
<<
trailer_expr -> 
192
%
trailer_expr -> 
192
==
trailer_expr -> 
192
-
trailer_expr -> 
192
<
trailer_expr -> 
192
NEWLINE
trailer_expr -> 
192
if
trailer_expr -> 
192
or
trailer_expr -> 
192
/
trailer_expr -> 
192
**
trailer_expr -> 
192
and
trailer_expr -> 
192
@
trailer_expr -> 
192
*
trailer_expr -> 
192
|
trailer_expr -> 
192
is
trailer_expr -> 
192
,
trailer_expr -> 
192
+
trailer_expr -> 
192
in
trailer_expr -> 
192
&
trailer_expr -> 
192
<=
trailer_expr -> 
192
>=
trailer_expr -> 
192
^
trailer_expr -> 
192
>
trailer_expr -> 
192
!=
trailer_expr -> 
192
not
trailer_expr -> 
192
>>
trailer_expr -> 
192
//
trailer_expr -> 
193
[
atom -> NUMBER
193
>=
atom -> NUMBER
193
<=
atom -> NUMBER
193
!=
atom -> NUMBER
193
//
atom -> NUMBER
193
in
atom -> NUMBER
193
/
atom -> NUMBER
193
or
atom -> NUMBER
193
>
atom -> NUMBER
193
,
atom -> NUMBER
193
not
atom -> NUMBER
193
>>
atom -> NUMBER
193
(
atom -> NUMBER
193
**
atom -> NUMBER
193
<<
atom -> NUMBER
193
and
atom -> NUMBER
193
+
atom -> NUMBER
193
%
atom -> NUMBER
193
==
atom -> NUMBER
193
if
atom -> NUMBER
193
is
atom -> NUMBER
193
*
atom -> NUMBER
193
@
atom -> NUMBER
193
|
atom -> NUMBER
193
NEWLINE
atom -> NUMBER
193
-
atom -> NUMBER
193
.
atom -> NUMBER
193
^
atom -> NUMBER
193
<
atom -> NUMBER
193
&
atom -> NUMBER
194
and
atom -> STRING
194
%
atom -> STRING
194
//
atom -> STRING
194
>>
atom -> STRING
194
*
atom -> STRING
194
<
atom -> STRING
194
.
atom -> STRING
194
in
atom -> STRING
194
NEWLINE
atom -> STRING
194
^
atom -> STRING
194
(
atom -> STRING
194
if
atom -> STRING
194
==
atom -> STRING
194
-
atom -> STRING
194
**
atom -> STRING
194
<<
atom -> STRING
194
<=
atom -> STRING
194
[
atom -> STRING
194
not
atom -> STRING
194
or
atom -> STRING
194
+
atom -> STRING
194
>=
atom -> STRING
194
@
atom -> STRING
194
&
atom -> STRING
194
>
atom -> STRING
194
is
atom -> STRING
194
,
atom -> STRING
194
|
atom -> STRING
194
!=
atom -> STRING
194
/
atom -> STRING
195
&
562
195
^
and_expr -> shift_expr
195
|
and_expr -> shift_expr
195
<=
and_expr -> shift_expr
195
NEWLINE
and_expr -> shift_expr
195
or
and_expr -> shift_expr
195
>
and_expr -> shift_expr
195
not
and_expr -> shift_expr
195
,
and_expr -> shift_expr
195
!=
and_expr -> shift_expr
195
and
and_expr -> shift_expr
195
is
and_expr -> shift_expr
195
<
and_expr -> shift_expr
195
if
and_expr -> shift_expr
195
in
and_expr -> shift_expr
195
>=
and_expr -> shift_expr
195
==
and_expr -> shift_expr
196
(
186
196
NAME
188
196
[
189
196
+
190
196
atom_expr
191
196
NUMBER
193
196
atom
192
196
STRING
194
196
-
196
196
True
197
196
None
201
196
False
203
196
{
206
196
~
207
196
power
208
196
factor
563
197
(
atom -> True
197
[
atom -> True
197
+
atom -> True
197
@
atom -> True
197
<=
atom -> True
197
&
atom -> True
197
<<
atom -> True
197
-
atom -> True
197
/
atom -> True
197
or
atom -> True
197
>
atom -> True
197
%
atom -> True
197
^
atom -> True
197
if
atom -> True
197
!=
atom -> True
197
is
atom -> True
197
*
atom -> True
197
<
atom -> True
197
,
atom -> True
197
and
atom -> True
197
.
atom -> True
197
==
atom -> True
197
**
atom -> True
197
>>
atom -> True
197
in
atom -> True
197
|
atom -> True
197
>=
atom -> True
197
//
atom -> True
197
not
atom -> True
197
NEWLINE
atom -> True
198
and
564
198
NEWLINE
and_test -> not_test
198
or
and_test -> not_test
198
,
and_test -> not_test
198
if
and_test -> not_test
199
^
565
199
not
xor_expr -> and_expr
199
if
xor_expr -> and_expr
199
<=
xor_expr -> and_expr
199
,
xor_expr -> and_expr
199
>
xor_expr -> and_expr
199
NEWLINE
xor_expr -> and_expr
199
<
xor_expr -> and_expr
199
in
xor_expr -> and_expr
199
>=
xor_expr -> and_expr
199
==
xor_expr -> and_expr
199
|
xor_expr -> and_expr
199
is
xor_expr -> and_expr
199
and
xor_expr -> and_expr
199
or
xor_expr -> and_expr
199
!=
xor_expr -> and_expr
200
|
566
200
>=
expr -> xor_expr
200
,
expr -> xor_expr
200
==
expr -> xor_expr
200
NEWLINE
expr -> xor_expr
200
is
expr -> xor_expr
200
if
expr -> xor_expr
200
or
expr -> xor_expr
200
>
expr -> xor_expr
200
and
expr -> xor_expr
200
<
expr -> xor_expr
200
in
expr -> xor_expr
200
<=
expr -> xor_expr
200
not
expr -> xor_expr
200
!=
expr -> xor_expr
201
is
atom -> None
201
.
atom -> None
201
==
atom -> None
201
^
atom -> None
201
<<
atom -> None
201
>>
atom -> None
201
(
atom -> None
201
|
atom -> None
201
+
atom -> None
201
*
atom -> None
201
//
atom -> None
201
@
atom -> None
201
in
atom -> None
201
>=
atom -> None
201
!=
atom -> None
201
%
atom -> None
201
[
atom -> None
201
and
atom -> None
201
-
atom -> None
201
NEWLINE
atom -> None
201
if
atom -> None
201
&
atom -> None
201
<=
atom -> None
201
<
atom -> None
201
>
atom -> None
201
,
atom -> None
201
**
atom -> None
201
or
atom -> None
201
/
atom -> None
201
not
atom -> None
202
is
215
202
<
217
202
!=
218
202
in
219
202
<=
220
202
not
221
202
>=
222
202
>
223
202
==
224
202
comp_op
567
202
and
comparison -> expr
202
or
comparison -> expr
202
if
comparison -> expr
202
NEWLINE
comparison -> expr
202
,
comparison -> expr
203
in
atom -> False
203
>
atom -> False
203
-
atom -> False
203
%
atom -> False
203
<
atom -> False
203
NEWLINE
atom -> False
203
|
atom -> False
203
==
atom -> False
203
&
atom -> False
203
//
atom -> False
203
and
atom -> False
203
not
atom -> False
203
+
atom -> False
203
!=
atom -> False
203
if
atom -> False
203
@
atom -> False
203
[
atom -> False
203
or
atom -> False
203
<=
atom -> False
203
*
atom -> False
203
^
atom -> False
203
is
atom -> False
203
/
atom -> False
203
.
atom -> False
203
>=
atom -> False
203
**
atom -> False
203
>>
atom -> False
203
,
atom -> False
203
<<
atom -> False
203
(
atom -> False
204
,
or_test -> and_test
204
or
568
204
NEWLINE
or_test -> and_test
204
if
or_test -> and_test
205
:
569
205
NAME
305
205
vfpdef
306
205
varargslist
570
206
}
571
207
(
186
207
NAME
188
207
[
189
207
+
190
207
factor
572
207
atom_expr
191
207
NUMBER
193
207
atom
192
207
STRING
194
207
-
196
207
True
197
207
None
201
207
False
203
207
{
206
207
~
207
207
power
208
208
&
factor -> power
208
NEWLINE
factor -> power
208
%
factor -> power
208
<<
factor -> power
208
-
factor -> power
208
<=
factor -> power
208
not
factor -> power
208
//
factor -> power
208
/
factor -> power
208
is
factor -> power
208
|
factor -> power
208
<
factor -> power
208
and
factor -> power
208
>=
factor -> power
208
>>
factor -> power
208
>
factor -> power
208
in
factor -> power
208
if
factor -> power
208
^
factor -> power
208
==
factor -> power
208
+
factor -> power
208
,
factor -> power
208
@
factor -> power
208
or
factor -> power
208
*
factor -> power
208
!=
factor -> power
209
,
573
209
NEWLINE
test_list -> test
210
factor
184
210
term
185
210
(
186
210
arith_expr
187
210
NAME
188
210
[
189
210
+
190
210
atom_expr
191
210
atom
192
210
NUMBER
193
210
STRING
194
210
shift_expr
195
210
-
196
210
not_test
574
210
True
197
210
and_expr
199
210
xor_expr
200
210
None
201
210
expr
202
210
False
203
210
{
206
210
~
207
210
power
208
210
not
210
210
comparison
212
211
if
575
211
NEWLINE
test -> or_test
211
,
test -> or_test
212
NEWLINE
not_test -> comparison
212
or
not_test -> comparison
212
and
not_test -> comparison
212
,
not_test -> comparison
212
if
not_test -> comparison
213
NEWLINE
return_stmt -> return test_list
214
NEWLINE
test -> lambdef
214
,
test -> lambdef
215
NUMBER
comp_op -> is
215
[
comp_op -> is
215
not
576
215
STRING
comp_op -> is
215
None
comp_op -> is
215
True
comp_op -> is
215
(
comp_op -> is
215
False
comp_op -> is
215
NAME
comp_op -> is
215
~
comp_op -> is
215
+
comp_op -> is
215
-
comp_op -> is
215
{
comp_op -> is
216
factor
9
216
arith_expr
2
216
NAME
29
216
term
21
216
[
3
216
~
45
216
atom_expr
24
216
expr
16
216
power
56
216
(
36
216
True
17
216
and_expr
19
216
xor_expr
22
216
atom
54
216
shift_expr
50
216
False
35
216
-
49
216
None
42
216
NUMBER
27
216
STRING
28
216
{
52
216
comparison
577
216
+
55
217
+
comp_op -> <
217
NAME
comp_op -> <
217
-
comp_op -> <
217
[
comp_op -> <
217
STRING
comp_op -> <
217
False
comp_op -> <
217
(
comp_op -> <
217
{
comp_op -> <
217
~
comp_op -> <
217
NUMBER
comp_op -> <
217
True
comp_op -> <
217
None
comp_op -> <
218
{
comp_op -> !=
218
True
comp_op -> !=
218
+
comp_op -> !=
218
NAME
comp_op -> !=
218
~
comp_op -> !=
218
[
comp_op -> !=
218
(
comp_op -> !=
218
None
comp_op -> !=
218
-
comp_op -> !=
218
False
comp_op -> !=
218
STRING
comp_op -> !=
218
NUMBER
comp_op -> !=
219
(
comp_op -> in
219
+
comp_op -> in
219
True
comp_op -> in
219
NUMBER
comp_op -> in
219
False
comp_op -> in
219
{
comp_op -> in
219
None
comp_op -> in
219
STRING
comp_op -> in
219
NAME
comp_op -> in
219
~
comp_op -> in
219
-
comp_op -> in
219
[
comp_op -> in
220
{
comp_op -> <=
220
~
comp_op -> <=
220
-
comp_op -> <=
220
NUMBER
comp_op -> <=
220
+
comp_op -> <=
220
STRING
comp_op -> <=
220
(
comp_op -> <=
220
NAME
comp_op -> <=
220
False
comp_op -> <=
220
[
comp_op -> <=
220
True
comp_op -> <=
220
None
comp_op -> <=
221
in
578
222
+
comp_op -> >=
222
[
comp_op -> >=
222
~
comp_op -> >=
222
NUMBER
comp_op -> >=
222
None
comp_op -> >=
222
True
comp_op -> >=
222
-
comp_op -> >=
222
NAME
comp_op -> >=
222
{
comp_op -> >=
222
STRING
comp_op -> >=
222
(
comp_op -> >=
222
False
comp_op -> >=
223
NUMBER
comp_op -> >
223
(
comp_op -> >
223
-
comp_op -> >
223
[
comp_op -> >
223
~
comp_op -> >
223
{
comp_op -> >
223
False
comp_op -> >
223
NAME
comp_op -> >
223
True
comp_op -> >
223
None
comp_op -> >
223
+
comp_op -> >
223
STRING
comp_op -> >
224
-
comp_op -> ==
224
(
comp_op -> ==
224
STRING
comp_op -> ==
224
False
comp_op -> ==
224
NUMBER
comp_op -> ==
224
+
comp_op -> ==
224
~
comp_op -> ==
224
NAME
comp_op -> ==
224
{
comp_op -> ==
224
None
comp_op -> ==
224
True
comp_op -> ==
224
[
comp_op -> ==
225
factor
9
225
arith_expr
2
225
NAME
29
225
term
21
225
[
3
225
~
45
225
atom_expr
24
225
expr
16
225
power
56
225
(
36
225
and_test
579
225
True
17
225
not_test
18
225
and_expr
19
225
xor_expr
22
225
atom
54
225
shift_expr
50
225
False
35
225
-
49
225
None
42
225
NUMBER
27
225
STRING
28
225
{
52
225
comparison
39
225
+
55
225
not
57
226
factor
9
226
arith_expr
2
226
NAME
29
226
term
21
226
[
3
226
~
45
226
atom_expr
24
226
power
56
226
(
36
226
True
17
226
and_expr
19
226
xor_expr
580
226
atom
54
226
shift_expr
50
226
False
35
226
-
49
226
None
42
226
NUMBER
27
226
STRING
28
226
{
52
226
+
55
227
(
581
228
factor
9
228
+
55
228
term
21
228
atom_expr
24
228
(
36
228
NAME
29
228
{
52
228
[
3
228
~
45
228
arith_expr
582
228
atom
54
228
power
56
228
NUMBER
27
228
STRING
28
228
-
49
228
True
17
228
False
35
228
None
42
229
factor
9
229
+
55
229
term
21
229
arith_expr
583
229
atom_expr
24
229
(
36
229
NAME
29
229
{
52
229
[
3
229
~
45
229
atom
54
229
power
56
229
NUMBER
27
229
STRING
28
229
-
49
229
True
17
229
False
35
229
None
42
230
factor
9
230
arith_expr
2
230
NAME
29
230
term
21
230
[
3
230
~
45
230
atom_expr
24
230
power
56
230
(
36
230
expr
584
230
True
17
230
and_expr
19
230
xor_expr
22
230
atom
54
230
shift_expr
50
230
False
35
230
-
49
230
None
42
230
NUMBER
27
230
STRING
28
230
{
52
230
+
55
231
factor
585
231
(
586
231
arith_expr
587
231
NAME
588
231
[
589
231
and_expr
590
231
+
591
231
term
592
231
atom_expr
593
231
NUMBER
594
231
atom
595
231
STRING
596
231
shift_expr
597
231
-
598
231
True
599
231
not
600
231
xor_expr
601
231
None
602
231
False
603
231
or_test
604
231
not_test
605
231
~
606
231
power
607
231
{
608
231
expr
609
231
comparison
610
231
and_test
611
232
+
55
232
atom_expr
24
232
(
36
232
NAME
29
232
{
52
232
[
3
232
~
45
232
atom
54
232
factor
612
232
power
56
232
NUMBER
27
232
STRING
28
232
-
49
232
True
17
232
False
35
232
None
42
233
NEWLINE
global_stmt -> global namelist
234
NEWLINE
namelist -> NAME
234
,
613
235
def
decorators -> decorator decorators
235
class
decorators -> decorator decorators
236
//
614
236
/
615
236
in
term -> factor
236
-
term -> factor
236
*
616
236
%
617
236
@
618
236
:
term -> factor
236
>=
term -> factor
236
<
term -> factor
236
<=
term -> factor
236
==
term -> factor
236
!=
term -> factor
236
>>
term -> factor
236
is
term -> factor
236
or
term -> factor
236
and
term -> factor
236
as
term -> factor
236
^
term -> factor
236
,
term -> factor
236
+
term -> factor
236
&
term -> factor
236
<<
term -> factor
236
|
term -> factor
236
>
term -> factor
236
if
term -> factor
236
not
term -> factor
237
+
619
237
-
620
237
|
arith_expr -> term
237
:
arith_expr -> term
237
or
arith_expr -> term
237
as
arith_expr -> term
237
not
arith_expr -> term
237
<=
arith_expr -> term
237
!=
arith_expr -> term
237
<
arith_expr -> term
237
&
arith_expr -> term
237
>=
arith_expr -> term
237
if
arith_expr -> term
237
==
arith_expr -> term
237
^
arith_expr -> term
237
in
arith_expr -> term
237
is
arith_expr -> term
237
<<
arith_expr -> term
237
,
arith_expr -> term
237
>
arith_expr -> term
237
and
arith_expr -> term
237
>>
arith_expr -> term
238
factor
268
238
term
270
238
(
271
238
arith_expr
272
238
NAME
273
238
[
274
238
+
275
238
test_list_comp
621
238
atom_expr
277
238
NUMBER
278
238
atom
279
238
STRING
280
238
shift_expr
281
238
-
282
238
True
283
238
not_test
284
238
lambdef
285
238
and_expr
286
238
xor_expr
287
238
False
288
238
None
289
238
expr
290
238
and_test
291
238
)
622
238
{
292
238
~
293
238
power
294
238
lambda
295
238
comparison
296
238
or_test
297
238
not
298
238
test
299
238
test_list
300
239
>>
623
239
<<
624
239
&
shift_expr -> arith_expr
239
<=
shift_expr -> arith_expr
239
>
shift_expr -> arith_expr
239
not
shift_expr -> arith_expr
239
!=
shift_expr -> arith_expr
239
as
shift_expr -> arith_expr
239
^
shift_expr -> arith_expr
239
is
shift_expr -> arith_expr
239
|
shift_expr -> arith_expr
239
>=
shift_expr -> arith_expr
239
or
shift_expr -> arith_expr
239
,
shift_expr -> arith_expr
239
==
shift_expr -> arith_expr
239
if
shift_expr -> arith_expr
239
and
shift_expr -> arith_expr
239
<
shift_expr -> arith_expr
239
:
shift_expr -> arith_expr
239
in
shift_expr -> arith_expr
240
:
625
241
:
atom -> NAME
241
-
atom -> NAME
241
,
atom -> NAME
241
or
atom -> NAME
241
>>
atom -> NAME
241
&
atom -> NAME
241
[
atom -> NAME
241
<=
atom -> NAME
241
<
atom -> NAME
241
.
atom -> NAME
241
as
atom -> NAME
241
|
atom -> NAME
241
*
atom -> NAME
241
/
atom -> NAME
241
<<
atom -> NAME
241
not
atom -> NAME
241
>
atom -> NAME
241
is
atom -> NAME
241
//
atom -> NAME
241
+
atom -> NAME
241
if
atom -> NAME
241
in
atom -> NAME
241
**
atom -> NAME
241
!=
atom -> NAME
241
>=
atom -> NAME
241
^
atom -> NAME
241
@
atom -> NAME
241
(
atom -> NAME
241
==
atom -> NAME
241
and
atom -> NAME
241
%
atom -> NAME
242
in
atom -> False
242
>
atom -> False
242
-
atom -> False
242
%
atom -> False
242
<
atom -> False
242
|
atom -> False
242
==
atom -> False
242
&
atom -> False
242
//
atom -> False
242
and
atom -> False
242
:
atom -> False
242
not
atom -> False
242
+
atom -> False
242
!=
atom -> False
242
if
atom -> False
242
as
atom -> False
242
@
atom -> False
242
[
atom -> False
242
or
atom -> False
242
<=
atom -> False
242
*
atom -> False
242
^
atom -> False
242
is
atom -> False
242
/
atom -> False
242
.
atom -> False
242
>=
atom -> False
242
**
atom -> False
242
>>
atom -> False
242
,
atom -> False
242
<<
atom -> False
242
(
atom -> False
243
factor
117
243
or_test
118
243
term
119
243
(
120
243
arith_expr
121
243
NAME
122
243
[
123
243
]
626
243
+
125
243
atom_expr
126
243
NUMBER
127
243
atom
128
243
STRING
129
243
shift_expr
130
243
-
131
243
test_list_comp
627
243
True
133
243
not_test
134
243
lambdef
135
243
and_expr
136
243
xor_expr
137
243
False
138
243
None
139
243
expr
140
243
and_test
141
243
{
142
243
~
143
243
lambda
144
243
power
145
243
comparison
146
243
test_list
147
243
test
148
243
not
149
244
(
238
244
NAME
241
244
[
243
244
~
244
244
+
245
244
factor
628
244
atom_expr
248
244
NUMBER
251
244
atom
250
244
STRING
252
244
-
253
244
True
254
244
False
242
244
{
258
244
None
260
244
power
264
245
(
238
245
NAME
241
245
[
243
245
~
244
245
+
245
245
factor
629
245
atom_expr
248
245
NUMBER
251
245
atom
250
245
STRING
252
245
-
253
245
True
254
245
False
242
245
{
258
245
None
260
245
power
264
246
:
630
246
varargslist
631
246
NAME
305
246
vfpdef
306
247
is
215
247
<
217
247
!=
218
247
in
219
247
<=
220
247
not
221
247
>=
222
247
as
comparison -> expr
247
>
223
247
==
224
247
comp_op
632
247
and
comparison -> expr
247
or
comparison -> expr
247
:
comparison -> expr
247
if
comparison -> expr
247
,
comparison -> expr
248
!=
power -> atom_expr
248
**
633
248
as
power -> atom_expr
248
>
power -> atom_expr
248
+
power -> atom_expr
248
not
power -> atom_expr
248
&
power -> atom_expr
248
|
power -> atom_expr
248
>>
power -> atom_expr
248
:
power -> atom_expr
248
^
power -> atom_expr
248
==
power -> atom_expr
248
if
power -> atom_expr
248
in
power -> atom_expr
248
%
power -> atom_expr
248
<<
power -> atom_expr
248
or
power -> atom_expr
248
@
power -> atom_expr
248
*
power -> atom_expr
248
/
power -> atom_expr
248
,
power -> atom_expr
248
<
power -> atom_expr
248
//
power -> atom_expr
248
>=
power -> atom_expr
248
-
power -> atom_expr
248
is
power -> atom_expr
248
<=
power -> atom_expr
248
and
power -> atom_expr
249
&
634
249
^
and_expr -> shift_expr
249
|
and_expr -> shift_expr
249
<=
and_expr -> shift_expr
249
or
and_expr -> shift_expr
249
>
and_expr -> shift_expr
249
not
and_expr -> shift_expr
249
,
and_expr -> shift_expr
249
!=
and_expr -> shift_expr
249
and
and_expr -> shift_expr
249
is
and_expr -> shift_expr
249
<
and_expr -> shift_expr
249
as
and_expr -> shift_expr
249
if
and_expr -> shift_expr
249
in
and_expr -> shift_expr
249
>=
and_expr -> shift_expr
249
:
and_expr -> shift_expr
249
==
and_expr -> shift_expr
250
trailer
635
250
.
636
250
(
637
250
[
638
250
trailer_expr
639
250
<<
trailer_expr -> 
250
%
trailer_expr -> 
250
==
trailer_expr -> 
250
-
trailer_expr -> 
250
<
trailer_expr -> 
250
if
trailer_expr -> 
250
or
trailer_expr -> 
250
/
trailer_expr -> 
250
**
trailer_expr -> 
250
and
trailer_expr -> 
250
@
trailer_expr -> 
250
*
trailer_expr -> 
250
|
trailer_expr -> 
250
is
trailer_expr -> 
250
,
trailer_expr -> 
250
+
trailer_expr -> 
250
in
trailer_expr -> 
250
&
trailer_expr -> 
250
<=
trailer_expr -> 
250
>=
trailer_expr -> 
250
^
trailer_expr -> 
250
>
trailer_expr -> 
250
!=
trailer_expr -> 
250
not
trailer_expr -> 
250
>>
trailer_expr -> 
250
//
trailer_expr -> 
250
as
trailer_expr -> 
250
:
trailer_expr -> 
251
[
atom -> NUMBER
251
>=
atom -> NUMBER
251
<=
atom -> NUMBER
251
!=
atom -> NUMBER
251
//
atom -> NUMBER
251
in
atom -> NUMBER
251
/
atom -> NUMBER
251
:
atom -> NUMBER
251
or
atom -> NUMBER
251
>
atom -> NUMBER
251
,
atom -> NUMBER
251
as
atom -> NUMBER
251
not
atom -> NUMBER
251
>>
atom -> NUMBER
251
(
atom -> NUMBER
251
**
atom -> NUMBER
251
<<
atom -> NUMBER
251
and
atom -> NUMBER
251
+
atom -> NUMBER
251
%
atom -> NUMBER
251
==
atom -> NUMBER
251
if
atom -> NUMBER
251
is
atom -> NUMBER
251
*
atom -> NUMBER
251
@
atom -> NUMBER
251
|
atom -> NUMBER
251
-
atom -> NUMBER
251
.
atom -> NUMBER
251
^
atom -> NUMBER
251
<
atom -> NUMBER
251
&
atom -> NUMBER
252
and
atom -> STRING
252
%
atom -> STRING
252
//
atom -> STRING
252
>>
atom -> STRING
252
*
atom -> STRING
252
<
atom -> STRING
252
.
atom -> STRING
252
in
atom -> STRING
252
:
atom -> STRING
252
^
atom -> STRING
252
(
atom -> STRING
252
if
atom -> STRING
252
==
atom -> STRING
252
-
atom -> STRING
252
**
atom -> STRING
252
as
atom -> STRING
252
<<
atom -> STRING
252
<=
atom -> STRING
252
[
atom -> STRING
252
not
atom -> STRING
252
or
atom -> STRING
252
+
atom -> STRING
252
>=
atom -> STRING
252
@
atom -> STRING
252
&
atom -> STRING
252
>
atom -> STRING
252
is
atom -> STRING
252
,
atom -> STRING
252
|
atom -> STRING
252
!=
atom -> STRING
252
/
atom -> STRING
253
(
238
253
NAME
241
253
[
243
253
~
244
253
+
245
253
atom_expr
248
253
NUMBER
251
253
atom
250
253
STRING
252
253
-
253
253
True
254
253
False
242
253
{
258
253
None
260
253
power
264
253
factor
640
254
(
atom -> True
254
[
atom -> True
254
+
atom -> True
254
@
atom -> True
254
not
atom -> True
254
<=
atom -> True
254
&
atom -> True
254
<<
atom -> True
254
-
atom -> True
254
/
atom -> True
254
as
atom -> True
254
or
atom -> True
254
>
atom -> True
254
%
atom -> True
254
^
atom -> True
254
if
atom -> True
254
!=
atom -> True
254
is
atom -> True
254
*
atom -> True
254
<
atom -> True
254
,
atom -> True
254
and
atom -> True
254
.
atom -> True
254
==
atom -> True
254
**
atom -> True
254
>>
atom -> True
254
in
atom -> True
254
|
atom -> True
254
>=
atom -> True
254
//
atom -> True
254
:
atom -> True
255
and
641
255
or
and_test -> not_test
255
as
and_test -> not_test
255
,
and_test -> not_test
255
if
and_test -> not_test
255
:
and_test -> not_test
256
as
xor_expr -> and_expr
256
^
642
256
not
xor_expr -> and_expr
256
if
xor_expr -> and_expr
256
<=
xor_expr -> and_expr
256
:
xor_expr -> and_expr
256
,
xor_expr -> and_expr
256
>
xor_expr -> and_expr
256
<
xor_expr -> and_expr
256
in
xor_expr -> and_expr
256
>=
xor_expr -> and_expr
256
==
xor_expr -> and_expr
256
|
xor_expr -> and_expr
256
is
xor_expr -> and_expr
256
and
xor_expr -> and_expr
256
or
xor_expr -> and_expr
256
!=
xor_expr -> and_expr
257
|
643
257
>=
expr -> xor_expr
257
,
expr -> xor_expr
257
==
expr -> xor_expr
257
is
expr -> xor_expr
257
as
expr -> xor_expr
257
:
expr -> xor_expr
257
if
expr -> xor_expr
257
or
expr -> xor_expr
257
>
expr -> xor_expr
257
and
expr -> xor_expr
257
<
expr -> xor_expr
257
in
expr -> xor_expr
257
<=
expr -> xor_expr
257
not
expr -> xor_expr
257
!=
expr -> xor_expr
258
}
644
259
:
test -> or_test
259
as
test -> or_test
259
if
645
259
,
test -> or_test
260
is
atom -> None
260
.
atom -> None
260
==
atom -> None
260
^
atom -> None
260
as
atom -> None
260
<<
atom -> None
260
>>
atom -> None
260
(
atom -> None
260
|
atom -> None
260
+
atom -> None
260
*
atom -> None
260
//
atom -> None
260
@
atom -> None
260
in
atom -> None
260
>=
atom -> None
260
!=
atom -> None
260
%
atom -> None
260
[
atom -> None
260
and
atom -> None
260
-
atom -> None
260
if
atom -> None
260
&
atom -> None
260
<=
atom -> None
260
<
atom -> None
260
>
atom -> None
260
,
atom -> None
260
**
atom -> None
260
:
atom -> None
260
or
atom -> None
260
/
atom -> None
260
not
atom -> None
261
:
not_test -> comparison
261
or
not_test -> comparison
261
as
not_test -> comparison
261
and
not_test -> comparison
261
,
not_test -> comparison
261
if
not_test -> comparison
262
,
or_test -> and_test
262
or
646
262
:
or_test -> and_test
262
as
or_test -> and_test
262
if
or_test -> and_test
263
as
test -> lambdef
263
,
test -> lambdef
263
:
test -> lambdef
264
&
factor -> power
264
%
factor -> power
264
<<
factor -> power
264
-
factor -> power
264
<=
factor -> power
264
not
factor -> power
264
//
factor -> power
264
/
factor -> power
264
is
factor -> power
264
|
factor -> power
264
<
factor -> power
264
and
factor -> power
264
>=
factor -> power
264
>>
factor -> power
264
>
factor -> power
264
in
factor -> power
264
if
factor -> power
264
^
factor -> power
264
==
factor -> power
264
as
factor -> power
264
+
factor -> power
264
,
factor -> power
264
@
factor -> power
264
or
factor -> power
264
*
factor -> power
264
:
factor -> power
264
!=
factor -> power
265
factor
236
265
term
237
265
(
238
265
arith_expr
239
265
NAME
241
265
False
242
265
[
243
265
~
244
265
+
245
265
expr
247
265
atom_expr
248
265
shift_expr
249
265
atom
250
265
NUMBER
251
265
STRING
252
265
-
253
265
not_test
647
265
True
254
265
and_expr
256
265
xor_expr
257
265
{
258
265
None
260
265
comparison
261
265
power
264
265
not
265
266
as
648
266
:
with_item -> test
266
,
with_item -> test
267
:
with_items -> with_item
267
,
649
268
//
650
268
in
term -> factor
268
-
term -> factor
268
*
651
268
%
652
268
@
653
268
>=
term -> factor
268
/
654
268
<
term -> factor
268
<=
term -> factor
268
==
term -> factor
268
!=
term -> factor
268
>>
term -> factor
268
is
term -> factor
268
or
term -> factor
268
and
term -> factor
268
for
term -> factor
268
^
term -> factor
268
,
term -> factor
268
+
term -> factor
268
&
term -> factor
268
<<
term -> factor
268
|
term -> factor
268
)
term -> factor
268
>
term -> factor
268
if
term -> factor
268
not
term -> factor
269
|=
atom -> ( )
269
or
atom -> ( )
269
<<
atom -> ( )
269
NEWLINE
atom -> ( )
269
not
atom -> ( )
269
&
atom -> ( )
269
(
atom -> ( )
269
in
atom -> ( )
269
**
atom -> ( )
269
//=
atom -> ( )
269
@
atom -> ( )
269
=
atom -> ( )
269
<=
atom -> ( )
269
%
atom -> ( )
269
[
atom -> ( )
269
>=
atom -> ( )
269
**=
atom -> ( )
269
/
atom -> ( )
269
/=
atom -> ( )
269
+
atom -> ( )
269
@=
atom -> ( )
269
<
atom -> ( )
269
^=
atom -> ( )
269
*=
atom -> ( )
269
is
atom -> ( )
269
:
atom -> ( )
269
*
atom -> ( )
269
!=
atom -> ( )
269
%=
atom -> ( )
269
-
atom -> ( )
269
>>=
atom -> ( )
269
&=
atom -> ( )
269
|
atom -> ( )
269
+=
atom -> ( )
269
//
atom -> ( )
269
^
atom -> ( )
269
and
atom -> ( )
269
==
atom -> ( )
269
if
atom -> ( )
269
>
atom -> ( )
269
,
atom -> ( )
269
-=
atom -> ( )
269
<<=
atom -> ( )
269
.
atom -> ( )
269
>>
atom -> ( )
270
+
655
270
-
656
270
for
arith_expr -> term
270
|
arith_expr -> term
270
)
arith_expr -> term
270
or
arith_expr -> term
270
not
arith_expr -> term
270
<=
arith_expr -> term
270
!=
arith_expr -> term
270
<
arith_expr -> term
270
&
arith_expr -> term
270
>=
arith_expr -> term
270
if
arith_expr -> term
270
==
arith_expr -> term
270
^
arith_expr -> term
270
in
arith_expr -> term
270
is
arith_expr -> term
270
<<
arith_expr -> term
270
,
arith_expr -> term
270
>
arith_expr -> term
270
and
arith_expr -> term
270
>>
arith_expr -> term
271
factor
268
271
term
270
271
(
271
271
arith_expr
272
271
NAME
273
271
[
274
271
+
275
271
test_list_comp
657
271
atom_expr
277
271
NUMBER
278
271
atom
279
271
STRING
280
271
shift_expr
281
271
-
282
271
True
283
271
not_test
284
271
lambdef
285
271
and_expr
286
271
xor_expr
287
271
False
288
271
None
289
271
expr
290
271
and_test
291
271
)
658
271
{
292
271
~
293
271
power
294
271
lambda
295
271
comparison
296
271
or_test
297
271
not
298
271
test
299
271
test_list
300
272
>>
659
272
<<
660
272
&
shift_expr -> arith_expr
272
<=
shift_expr -> arith_expr
272
>
shift_expr -> arith_expr
272
)
shift_expr -> arith_expr
272
not
shift_expr -> arith_expr
272
!=
shift_expr -> arith_expr
272
^
shift_expr -> arith_expr
272
is
shift_expr -> arith_expr
272
|
shift_expr -> arith_expr
272
>=
shift_expr -> arith_expr
272
or
shift_expr -> arith_expr
272
,
shift_expr -> arith_expr
272
==
shift_expr -> arith_expr
272
if
shift_expr -> arith_expr
272
and
shift_expr -> arith_expr
272
<
shift_expr -> arith_expr
272
for
shift_expr -> arith_expr
272
in
shift_expr -> arith_expr
273
-
atom -> NAME
273
,
atom -> NAME
273
for
atom -> NAME
273
or
atom -> NAME
273
>>
atom -> NAME
273
&
atom -> NAME
273
[
atom -> NAME
273
<=
atom -> NAME
273
<
atom -> NAME
273
.
atom -> NAME
273
|
atom -> NAME
273
*
atom -> NAME
273
/
atom -> NAME
273
<<
atom -> NAME
273
not
atom -> NAME
273
>
atom -> NAME
273
is
atom -> NAME
273
//
atom -> NAME
273
+
atom -> NAME
273
if
atom -> NAME
273
in
atom -> NAME
273
**
atom -> NAME
273
!=
atom -> NAME
273
>=
atom -> NAME
273
)
atom -> NAME
273
^
atom -> NAME
273
@
atom -> NAME
273
(
atom -> NAME
273
==
atom -> NAME
273
and
atom -> NAME
273
%
atom -> NAME
274
factor
117
274
or_test
118
274
term
119
274
(
120
274
test_list_comp
661
274
arith_expr
121
274
NAME
122
274
[
123
274
]
662
274
+
125
274
atom_expr
126
274
NUMBER
127
274
atom
128
274
STRING
129
274
shift_expr
130
274
-
131
274
True
133
274
not_test
134
274
lambdef
135
274
and_expr
136
274
xor_expr
137
274
False
138
274
None
139
274
expr
140
274
and_test
141
274
{
142
274
~
143
274
lambda
144
274
power
145
274
comparison
146
274
test_list
147
274
test
148
274
not
149
275
(
271
275
NAME
273
275
[
274
275
+
275
275
atom_expr
277
275
NUMBER
278
275
atom
279
275
STRING
280
275
-
282
275
factor
663
275
True
283
275
False
288
275
None
289
275
{
292
275
~
293
275
power
294
276
)
664
277
!=
power -> atom_expr
277
**
665
277
>
power -> atom_expr
277
+
power -> atom_expr
277
not
power -> atom_expr
277
&
power -> atom_expr
277
|
power -> atom_expr
277
>>
power -> atom_expr
277
^
power -> atom_expr
277
==
power -> atom_expr
277
if
power -> atom_expr
277
in
power -> atom_expr
277
%
power -> atom_expr
277
for
power -> atom_expr
277
<<
power -> atom_expr
277
or
power -> atom_expr
277
@
power -> atom_expr
277
*
power -> atom_expr
277
/
power -> atom_expr
277
)
power -> atom_expr
277
<
power -> atom_expr
277
//
power -> atom_expr
277
>=
power -> atom_expr
277
-
power -> atom_expr
277
is
power -> atom_expr
277
<=
power -> atom_expr
277
and
power -> atom_expr
277
,
power -> atom_expr
278
[
atom -> NUMBER
278
>=
atom -> NUMBER
278
<=
atom -> NUMBER
278
!=
atom -> NUMBER
278
//
atom -> NUMBER
278
in
atom -> NUMBER
278
/
atom -> NUMBER
278
or
atom -> NUMBER
278
>
atom -> NUMBER
278
,
atom -> NUMBER
278
not
atom -> NUMBER
278
>>
atom -> NUMBER
278
(
atom -> NUMBER
278
**
atom -> NUMBER
278
<<
atom -> NUMBER
278
and
atom -> NUMBER
278
+
atom -> NUMBER
278
%
atom -> NUMBER
278
)
atom -> NUMBER
278
==
atom -> NUMBER
278
for
atom -> NUMBER
278
if
atom -> NUMBER
278
is
atom -> NUMBER
278
*
atom -> NUMBER
278
@
atom -> NUMBER
278
|
atom -> NUMBER
278
-
atom -> NUMBER
278
.
atom -> NUMBER
278
^
atom -> NUMBER
278
<
atom -> NUMBER
278
&
atom -> NUMBER
279
trailer
666
279
.
667
279
(
668
279
[
669
279
trailer_expr
670
279
<<
trailer_expr -> 
279
%
trailer_expr -> 
279
==
trailer_expr -> 
279
-
trailer_expr -> 
279
<
trailer_expr -> 
279
if
trailer_expr -> 
279
or
trailer_expr -> 
279
/
trailer_expr -> 
279
**
trailer_expr -> 
279
and
trailer_expr -> 
279
@
trailer_expr -> 
279
*
trailer_expr -> 
279
|
trailer_expr -> 
279
is
trailer_expr -> 
279
,
trailer_expr -> 
279
+
trailer_expr -> 
279
in
trailer_expr -> 
279
for
trailer_expr -> 
279
&
trailer_expr -> 
279
<=
trailer_expr -> 
279
>=
trailer_expr -> 
279
^
trailer_expr -> 
279
>
trailer_expr -> 
279
!=
trailer_expr -> 
279
)
trailer_expr -> 
279
not
trailer_expr -> 
279
>>
trailer_expr -> 
279
//
trailer_expr -> 
280
and
atom -> STRING
280
for
atom -> STRING
280
%
atom -> STRING
280
//
atom -> STRING
280
>>
atom -> STRING
280
*
atom -> STRING
280
<
atom -> STRING
280
.
atom -> STRING
280
in
atom -> STRING
280
^
atom -> STRING
280
(
atom -> STRING
280
if
atom -> STRING
280
==
atom -> STRING
280
-
atom -> STRING
280
**
atom -> STRING
280
<<
atom -> STRING
280
<=
atom -> STRING
280
[
atom -> STRING
280
not
atom -> STRING
280
or
atom -> STRING
280
)
atom -> STRING
280
+
atom -> STRING
280
>=
atom -> STRING
280
@
atom -> STRING
280
&
atom -> STRING
280
,
atom -> STRING
280
>
atom -> STRING
280
is
atom -> STRING
280
|
atom -> STRING
280
!=
atom -> STRING
280
/
atom -> STRING
281
&
671
281
^
and_expr -> shift_expr
281
|
and_expr -> shift_expr
281
<=
and_expr -> shift_expr
281
)
and_expr -> shift_expr
281
for
and_expr -> shift_expr
281
or
and_expr -> shift_expr
281
>
and_expr -> shift_expr
281
not
and_expr -> shift_expr
281
,
and_expr -> shift_expr
281
!=
and_expr -> shift_expr
281
and
and_expr -> shift_expr
281
is
and_expr -> shift_expr
281
<
and_expr -> shift_expr
281
if
and_expr -> shift_expr
281
in
and_expr -> shift_expr
281
>=
and_expr -> shift_expr
281
==
and_expr -> shift_expr
282
(
271
282
NAME
273
282
[
274
282
+
275
282
atom_expr
277
282
NUMBER
278
282
atom
279
282
STRING
280
282
-
282
282
True
283
282
False
288
282
None
289
282
{
292
282
~
293
282
power
294
282
factor
672
283
(
atom -> True
283
for
atom -> True
283
[
atom -> True
283
+
atom -> True
283
@
atom -> True
283
<=
atom -> True
283
&
atom -> True
283
<<
atom -> True
283
-
atom -> True
283
/
atom -> True
283
)
atom -> True
283
or
atom -> True
283
>
atom -> True
283
%
atom -> True
283
^
atom -> True
283
if
atom -> True
283
!=
atom -> True
283
is
atom -> True
283
*
atom -> True
283
<
atom -> True
283
,
atom -> True
283
and
atom -> True
283
.
atom -> True
283
==
atom -> True
283
**
atom -> True
283
>>
atom -> True
283
in
atom -> True
283
|
atom -> True
283
>=
atom -> True
283
//
atom -> True
283
not
atom -> True
284
and
673
284
or
and_test -> not_test
284
)
and_test -> not_test
284
,
and_test -> not_test
284
if
and_test -> not_test
284
for
and_test -> not_test
285
,
test -> lambdef
285
for
test -> lambdef
285
)
test -> lambdef
286
^
674
286
not
xor_expr -> and_expr
286
if
xor_expr -> and_expr
286
<=
xor_expr -> and_expr
286
,
xor_expr -> and_expr
286
>
xor_expr -> and_expr
286
<
xor_expr -> and_expr
286
in
xor_expr -> and_expr
286
>=
xor_expr -> and_expr
286
for
xor_expr -> and_expr
286
==
xor_expr -> and_expr
286
|
xor_expr -> and_expr
286
is
xor_expr -> and_expr
286
and
xor_expr -> and_expr
286
or
xor_expr -> and_expr
286
)
xor_expr -> and_expr
286
!=
xor_expr -> and_expr
287
|
675
287
>=
expr -> xor_expr
287
,
expr -> xor_expr
287
==
expr -> xor_expr
287
)
expr -> xor_expr
287
is
expr -> xor_expr
287
if
expr -> xor_expr
287
or
expr -> xor_expr
287
for
expr -> xor_expr
287
>
expr -> xor_expr
287
and
expr -> xor_expr
287
<
expr -> xor_expr
287
in
expr -> xor_expr
287
<=
expr -> xor_expr
287
not
expr -> xor_expr
287
!=
expr -> xor_expr
288
in
atom -> False
288
>
atom -> False
288
-
atom -> False
288
%
atom -> False
288
<
atom -> False
288
|
atom -> False
288
==
atom -> False
288
&
atom -> False
288
//
atom -> False
288
and
atom -> False
288
not
atom -> False
288
+
atom -> False
288
!=
atom -> False
288
if
atom -> False
288
for
atom -> False
288
)
atom -> False
288
@
atom -> False
288
[
atom -> False
288
or
atom -> False
288
<=
atom -> False
288
*
atom -> False
288
^
atom -> False
288
is
atom -> False
288
/
atom -> False
288
.
atom -> False
288
>=
atom -> False
288
**
atom -> False
288
>>
atom -> False
288
,
atom -> False
288
<<
atom -> False
288
(
atom -> False
289
is
atom -> None
289
.
atom -> None
289
==
atom -> None
289
^
atom -> None
289
<<
atom -> None
289
>>
atom -> None
289
(
atom -> None
289
|
atom -> None
289
+
atom -> None
289
for
atom -> None
289
*
atom -> None
289
//
atom -> None
289
@
atom -> None
289
in
atom -> None
289
>=
atom -> None
289
!=
atom -> None
289
%
atom -> None
289
[
atom -> None
289
and
atom -> None
289
-
atom -> None
289
)
atom -> None
289
if
atom -> None
289
&
atom -> None
289
<=
atom -> None
289
<
atom -> None
289
>
atom -> None
289
,
atom -> None
289
**
atom -> None
289
or
atom -> None
289
/
atom -> None
289
not
atom -> None
290
is
215
290
<
217
290
!=
218
290
in
219
290
<=
220
290
not
221
290
>=
222
290
>
223
290
==
224
290
comp_op
676
290
and
comparison -> expr
290
or
comparison -> expr
290
if
comparison -> expr
290
,
comparison -> expr
290
)
comparison -> expr
290
for
comparison -> expr
291
,
or_test -> and_test
291
or
677
291
for
or_test -> and_test
291
)
or_test -> and_test
291
if
or_test -> and_test
292
}
678
293
(
271
293
NAME
273
293
[
274
293
+
275
293
factor
679
293
atom_expr
277
293
NUMBER
278
293
atom
279
293
STRING
280
293
-
282
293
True
283
293
False
288
293
None
289
293
{
292
293
~
293
293
power
294
294
&
factor -> power
294
%
factor -> power
294
<<
factor -> power
294
-
factor -> power
294
<=
factor -> power
294
not
factor -> power
294
//
factor -> power
294
/
factor -> power
294
is
factor -> power
294
for
factor -> power
294
|
factor -> power
294
<
factor -> power
294
and
factor -> power
294
>=
factor -> power
294
>>
factor -> power
294
>
factor -> power
294
)
factor -> power
294
in
factor -> power
294
if
factor -> power
294
^
factor -> power
294
==
factor -> power
294
+
factor -> power
294
,
factor -> power
294
@
factor -> power
294
or
factor -> power
294
*
factor -> power
294
!=
factor -> power
295
:
680
295
NAME
305
295
varargslist
681
295
vfpdef
306
296
or
not_test -> comparison
296
and
not_test -> comparison
296
,
not_test -> comparison
296
for
not_test -> comparison
296
if
not_test -> comparison
296
)
not_test -> comparison
297
if
682
297
,
test -> or_test
297
for
test -> or_test
297
)
test -> or_test
298
factor
268
298
term
270
298
(
271
298
arith_expr
272
298
NAME
273
298
[
274
298
+
275
298
atom_expr
277
298
NUMBER
278
298
atom
279
298
STRING
280
298
shift_expr
281
298
-
282
298
not_test
683
298
True
283
298
and_expr
286
298
xor_expr
287
298
False
288
298
None
289
298
expr
290
298
{
292
298
~
293
298
power
294
298
comparison
296
298
not
298
299
)
test_list -> test
299
comp_for
684
299
,
685
299
for
686
300
)
test_list_comp -> test_list
301
factor
9
301
arith_expr
2
301
NAME
29
301
term
21
301
[
3
301
~
45
301
or_test
687
301
atom_expr
24
301
expr
16
301
power
56
301
(
36
301
True
17
301
not_test
18
301
and_expr
19
301
xor_expr
22
301
atom
54
301
shift_expr
50
301
False
35
301
-
49
301
None
42
301
NUMBER
27
301
STRING
28
301
{
52
301
and_test
37
301
comparison
39
301
+
55
301
not
57
302
:
688
302
(
689
303
:
690
304
factor
9
304
arith_expr
2
304
NAME
29
304
term
21
304
[
3
304
~
45
304
atom_expr
24
304
expr
16
304
power
56
304
(
36
304
True
17
304
not_test
18
304
and_expr
19
304
xor_expr
22
304
lambdef
53
304
atom
54
304
or_test
23
304
shift_expr
50
304
False
35
304
-
49
304
None
42
304
lambda
40
304
NUMBER
27
304
STRING
28
304
{
52
304
and_test
37
304
test
691
304
comparison
39
304
+
55
304
not
57
305
,
vfpdef -> NAME
305
:
vfpdef -> NAME
306
:
varargslist -> vfpdef
306
,
692
307
:
693
308
or
factor -> ~ factor
308
==
factor -> ~ factor
308
%=
factor -> ~ factor
308
<=
factor -> ~ factor
308
@
factor -> ~ factor
308
**=
factor -> ~ factor
308
!=
factor -> ~ factor
308
>=
factor -> ~ factor
308
/=
factor -> ~ factor
308
|=
factor -> ~ factor
308
>
factor -> ~ factor
308
and
factor -> ~ factor
308
^=
factor -> ~ factor
308
-=
factor -> ~ factor
308
,
factor -> ~ factor
308
:
factor -> ~ factor
308
//=
factor -> ~ factor
308
@=
factor -> ~ factor
308
*
factor -> ~ factor
308
&
factor -> ~ factor
308
<<=
factor -> ~ factor
308
%
factor -> ~ factor
308
<
factor -> ~ factor
308
//
factor -> ~ factor
308
>>=
factor -> ~ factor
308
=
factor -> ~ factor
308
if
factor -> ~ factor
308
^
factor -> ~ factor
308
/
factor -> ~ factor
308
in
factor -> ~ factor
308
+
factor -> ~ factor
308
not
factor -> ~ factor
308
+=
factor -> ~ factor
308
*=
factor -> ~ factor
308
-
factor -> ~ factor
308
&=
factor -> ~ factor
308
is
factor -> ~ factor
308
>>
factor -> ~ factor
308
<<
factor -> ~ factor
308
NEWLINE
factor -> ~ factor
308
|
factor -> ~ factor
309
nonlocal
simple_stmt -> small_stmt NEWLINE
309
True
simple_stmt -> small_stmt NEWLINE
309
False
simple_stmt -> small_stmt NEWLINE
309
(
simple_stmt -> small_stmt NEWLINE
309
continue
simple_stmt -> small_stmt NEWLINE
309
begsim
simple_stmt -> small_stmt NEWLINE
309
NAME
simple_stmt -> small_stmt NEWLINE
309
endsim
simple_stmt -> small_stmt NEWLINE
309
break
simple_stmt -> small_stmt NEWLINE
309
return
simple_stmt -> small_stmt NEWLINE
309
NUMBER
simple_stmt -> small_stmt NEWLINE
309
[
simple_stmt -> small_stmt NEWLINE
309
global
simple_stmt -> small_stmt NEWLINE
309
resetstats
simple_stmt -> small_stmt NEWLINE
309
yield
simple_stmt -> small_stmt NEWLINE
309
conf
simple_stmt -> small_stmt NEWLINE
309
$
simple_stmt -> small_stmt NEWLINE
309
not
simple_stmt -> small_stmt NEWLINE
309
lambda
simple_stmt -> small_stmt NEWLINE
309
del
simple_stmt -> small_stmt NEWLINE
309
pass
simple_stmt -> small_stmt NEWLINE
309
for
simple_stmt -> small_stmt NEWLINE
309
@
simple_stmt -> small_stmt NEWLINE
309
with
simple_stmt -> small_stmt NEWLINE
309
class
simple_stmt -> small_stmt NEWLINE
309
NEWLINE
simple_stmt -> small_stmt NEWLINE
309
if
simple_stmt -> small_stmt NEWLINE
309
assert
simple_stmt -> small_stmt NEWLINE
309
None
simple_stmt -> small_stmt NEWLINE
309
+
simple_stmt -> small_stmt NEWLINE
309
-
simple_stmt -> small_stmt NEWLINE
309
STRING
simple_stmt -> small_stmt NEWLINE
309
while
simple_stmt -> small_stmt NEWLINE
309
{
simple_stmt -> small_stmt NEWLINE
309
raise
simple_stmt -> small_stmt NEWLINE
309
~
simple_stmt -> small_stmt NEWLINE
309
def
simple_stmt -> small_stmt NEWLINE
309
try
simple_stmt -> small_stmt NEWLINE
310
factor
9
310
arith_expr
2
310
NAME
29
310
term
21
310
[
3
310
~
45
310
test_list
694
310
atom_expr
24
310
expr
16
310
power
56
310
(
36
310
True
17
310
not_test
18
310
and_expr
19
310
xor_expr
22
310
{
52
310
lambdef
53
310
atom
54
310
or_test
23
310
shift_expr
50
310
False
35
310
-
49
310
None
42
310
lambda
40
310
NUMBER
27
310
STRING
28
310
test
48
310
and_test
37
310
comparison
39
310
+
55
310
not
57
311
//=
factor -> - factor
311
and
factor -> - factor
311
-=
factor -> - factor
311
|=
factor -> - factor
311
>>=
factor -> - factor
311
or
factor -> - factor
311
^=
factor -> - factor
311
if
factor -> - factor
311
*=
factor -> - factor
311
<<=
factor -> - factor
311
>=
factor -> - factor
311
<
factor -> - factor
311
!=
factor -> - factor
311
-
factor -> - factor
311
=
factor -> - factor
311
==
factor -> - factor
311
+=
factor -> - factor
311
@
factor -> - factor
311
|
factor -> - factor
311
*
factor -> - factor
311
%
factor -> - factor
311
+
factor -> - factor
311
<=
factor -> - factor
311
//
factor -> - factor
311
%=
factor -> - factor
311
not
factor -> - factor
311
&=
factor -> - factor
311
>>
factor -> - factor
311
/
factor -> - factor
311
&
factor -> - factor
311
^
factor -> - factor
311
/=
factor -> - factor
311
in
factor -> - factor
311
is
factor -> - factor
311
>
factor -> - factor
311
**=
factor -> - factor
311
NEWLINE
factor -> - factor
311
,
factor -> - factor
311
@=
factor -> - factor
311
:
factor -> - factor
311
<<
factor -> - factor
312
factor
9
312
arith_expr
2
312
NAME
29
312
term
21
312
[
3
312
~
45
312
atom_expr
24
312
power
56
312
(
36
312
True
17
312
atom
54
312
shift_expr
50
312
False
35
312
-
49
312
None
42
312
and_expr
695
312
NUMBER
27
312
STRING
28
312
{
52
312
+
55
313
>
atom -> { }
313
//=
atom -> { }
313
==
atom -> { }
313
-
atom -> { }
313
not
atom -> { }
313
(
atom -> { }
313
@
atom -> { }
313
if
atom -> { }
313
and
atom -> { }
313
,
atom -> { }
313
%=
atom -> { }
313
:
atom -> { }
313
&
atom -> { }
313
<<
atom -> { }
313
!=
atom -> { }
313
or
atom -> { }
313
>>
atom -> { }
313
<=
atom -> { }
313
>>=
atom -> { }
313
NEWLINE
atom -> { }
313
>=
atom -> { }
313
is
atom -> { }
313
^=
atom -> { }
313
/
atom -> { }
313
=
atom -> { }
313
|
atom -> { }
313
^
atom -> { }
313
[
atom -> { }
313
&=
atom -> { }
313
%
atom -> { }
313
*=
atom -> { }
313
|=
atom -> { }
313
//
atom -> { }
313
*
atom -> { }
313
<<=
atom -> { }
313
+=
atom -> { }
313
**
atom -> { }
313
.
atom -> { }
313
/=
atom -> { }
313
**=
atom -> { }
313
in
atom -> { }
313
+
atom -> { }
313
-=
atom -> { }
313
<
atom -> { }
313
@=
atom -> { }
314
trailer_expr
696
314
trailer
314
314
(
315
314
[
316
314
.
317
314
==
trailer_expr -> 
314
/
trailer_expr -> 
314
+=
trailer_expr -> 
314
**
trailer_expr -> 
314
@=
trailer_expr -> 
314
is
trailer_expr -> 
314
**=
trailer_expr -> 
314
//=
trailer_expr -> 
314
,
trailer_expr -> 
314
<=
trailer_expr -> 
314
>=
trailer_expr -> 
314
*=
trailer_expr -> 
314
|=
trailer_expr -> 
314
>
trailer_expr -> 
314
!=
trailer_expr -> 
314
&=
trailer_expr -> 
314
-=
trailer_expr -> 
314
%=
trailer_expr -> 
314
<<
trailer_expr -> 
314
%
trailer_expr -> 
314
/=
trailer_expr -> 
314
<<=
trailer_expr -> 
314
-
trailer_expr -> 
314
<
trailer_expr -> 
314
NEWLINE
trailer_expr -> 
314
if
trailer_expr -> 
314
or
trailer_expr -> 
314
and
trailer_expr -> 
314
@
trailer_expr -> 
314
=
trailer_expr -> 
314
*
trailer_expr -> 
314
|
trailer_expr -> 
314
^=
trailer_expr -> 
314
+
trailer_expr -> 
314
in
trailer_expr -> 
314
&
trailer_expr -> 
314
^
trailer_expr -> 
314
not
trailer_expr -> 
314
>>
trailer_expr -> 
314
//
trailer_expr -> 
314
>>=
trailer_expr -> 
314
:
trailer_expr -> 
315
factor
697
315
term
698
315
(
699
315
arith_expr
700
315
NAME
701
315
[
702
315
atom
703
315
+
704
315
arglist
705
315
power
706
315
atom_expr
707
315
NUMBER
708
315
STRING
709
315
*
710
315
shift_expr
711
315
-
712
315
)
713
315
argument
714
315
True
715
315
not_test
716
315
lambdef
717
315
and_expr
718
315
xor_expr
719
315
False
720
315
test
721
315
None
722
315
expr
723
315
and_test
724
315
{
725
315
~
726
315
lambda
727
315
comparison
728
315
or_test
729
315
not
730
315
**
731
316
factor
732
316
or_test
733
316
term
734
316
(
735
316
arith_expr
736
316
NAME
737
316
[
738
316
~
739
316
subscriptlist
740
316
+
741
316
maybe_test
742
316
expr
743
316
atom_expr
744
316
atom
745
316
NUMBER
746
316
STRING
747
316
shift_expr
748
316
-
749
316
True
750
316
not_test
751
316
and_expr
752
316
xor_expr
753
316
False
754
316
{
755
316
None
756
316
and_test
757
316
lambda
758
316
power
759
316
subscript
760
316
test
761
316
lambdef
762
316
:
maybe_test -> 
316
comparison
763
316
not
764
317
NAME
765
318
/=
atom_expr -> atom trailer_expr
318
>
atom_expr -> atom trailer_expr
318
not
atom_expr -> atom trailer_expr
318
=
atom_expr -> atom trailer_expr
318
//
atom_expr -> atom trailer_expr
318
%=
atom_expr -> atom trailer_expr
318
>>
atom_expr -> atom trailer_expr
318
|
atom_expr -> atom trailer_expr
318
+=
atom_expr -> atom trailer_expr
318
^=
atom_expr -> atom trailer_expr
318
>>=
atom_expr -> atom trailer_expr
318
+
atom_expr -> atom trailer_expr
318
^
atom_expr -> atom trailer_expr
318
/
atom_expr -> atom trailer_expr
318
in
atom_expr -> atom trailer_expr
318
%
atom_expr -> atom trailer_expr
318
and
atom_expr -> atom trailer_expr
318
<=
atom_expr -> atom trailer_expr
318
|=
atom_expr -> atom trailer_expr
318
is
atom_expr -> atom trailer_expr
318
<
atom_expr -> atom trailer_expr
318
*=
atom_expr -> atom trailer_expr
318
@
atom_expr -> atom trailer_expr
318
-
atom_expr -> atom trailer_expr
318
NEWLINE
atom_expr -> atom trailer_expr
318
&
atom_expr -> atom trailer_expr
318
:
atom_expr -> atom trailer_expr
318
*
atom_expr -> atom trailer_expr
318
&=
atom_expr -> atom trailer_expr
318
**
atom_expr -> atom trailer_expr
318
>=
atom_expr -> atom trailer_expr
318
@=
atom_expr -> atom trailer_expr
318
-=
atom_expr -> atom trailer_expr
318
**=
atom_expr -> atom trailer_expr
318
<<=
atom_expr -> atom trailer_expr
318
or
atom_expr -> atom trailer_expr
318
,
atom_expr -> atom trailer_expr
318
//=
atom_expr -> atom trailer_expr
318
==
atom_expr -> atom trailer_expr
318
!=
atom_expr -> atom trailer_expr
318
if
atom_expr -> atom trailer_expr
318
<<
atom_expr -> atom trailer_expr
319
%=
factor -> + factor
319
<
factor -> + factor
319
if
factor -> + factor
319
<<
factor -> + factor
319
and
factor -> + factor
319
>=
factor -> + factor
319
*=
factor -> + factor
319
>>=
factor -> + factor
319
&=
factor -> + factor
319
<<=
factor -> + factor
319
%
factor -> + factor
319
>>
factor -> + factor
319
*
factor -> + factor
319
+
factor -> + factor
319
@=
factor -> + factor
319
+=
factor -> + factor
319
/
factor -> + factor
319
>
factor -> + factor
319
<=
factor -> + factor
319
^
factor -> + factor
319
is
factor -> + factor
319
|=
factor -> + factor
319
|
factor -> + factor
319
or
factor -> + factor
319
-=
factor -> + factor
319
=
factor -> + factor
319
//=
factor -> + factor
319
-
factor -> + factor
319
in
factor -> + factor
319
NEWLINE
factor -> + factor
319
&
factor -> + factor
319
**=
factor -> + factor
319
not
factor -> + factor
319
/=
factor -> + factor
319
//
factor -> + factor
319
,
factor -> + factor
319
!=
factor -> + factor
319
:
factor -> + factor
319
^=
factor -> + factor
319
==
factor -> + factor
319
@
factor -> + factor
320
*=
not_test -> not not_test
320
+=
not_test -> not not_test
320
and
not_test -> not not_test
320
if
not_test -> not not_test
320
:
not_test -> not not_test
320
/=
not_test -> not not_test
320
^=
not_test -> not not_test
320
//=
not_test -> not not_test
320
%=
not_test -> not not_test
320
@=
not_test -> not not_test
320
or
not_test -> not not_test
320
<<=
not_test -> not not_test
320
|=
not_test -> not not_test
320
**=
not_test -> not not_test
320
NEWLINE
not_test -> not not_test
320
>>=
not_test -> not not_test
320
&=
not_test -> not not_test
320
,
not_test -> not not_test
320
-=
not_test -> not not_test
320
=
not_test -> not not_test
321
$
program -> stmt program
322
None
augassign -> //=
322
yield
augassign -> //=
322
STRING
augassign -> //=
322
~
augassign -> //=
322
NAME
augassign -> //=
322
True
augassign -> //=
322
not
augassign -> //=
322
{
augassign -> //=
322
[
augassign -> //=
322
lambda
augassign -> //=
322
(
augassign -> //=
322
False
augassign -> //=
322
-
augassign -> //=
322
NUMBER
augassign -> //=
322
+
augassign -> //=
323
{
augassign -> /=
323
-
augassign -> /=
323
NAME
augassign -> /=
323
+
augassign -> /=
323
False
augassign -> /=
323
~
augassign -> /=
323
True
augassign -> /=
323
not
augassign -> /=
323
STRING
augassign -> /=
323
None
augassign -> /=
323
[
augassign -> /=
323
(
augassign -> /=
323
lambda
augassign -> /=
323
NUMBER
augassign -> /=
323
yield
augassign -> /=
324
None
augassign -> *=
324
True
augassign -> *=
324
yield
augassign -> *=
324
lambda
augassign -> *=
324
-
augassign -> *=
324
NAME
augassign -> *=
324
False
augassign -> *=
324
~
augassign -> *=
324
+
augassign -> *=
324
(
augassign -> *=
324
STRING
augassign -> *=
324
[
augassign -> *=
324
{
augassign -> *=
324
not
augassign -> *=
324
NUMBER
augassign -> *=
325
STRING
augassign -> &=
325
lambda
augassign -> &=
325
not
augassign -> &=
325
None
augassign -> &=
325
+
augassign -> &=
325
-
augassign -> &=
325
True
augassign -> &=
325
yield
augassign -> &=
325
{
augassign -> &=
325
False
augassign -> &=
325
NAME
augassign -> &=
325
[
augassign -> &=
325
~
augassign -> &=
325
(
augassign -> &=
325
NUMBER
augassign -> &=
326
STRING
augassign -> >>=
326
None
augassign -> >>=
326
NAME
augassign -> >>=
326
+
augassign -> >>=
326
{
augassign -> >>=
326
NUMBER
augassign -> >>=
326
yield
augassign -> >>=
326
(
augassign -> >>=
326
[
augassign -> >>=
326
~
augassign -> >>=
326
-
augassign -> >>=
326
False
augassign -> >>=
326
lambda
augassign -> >>=
326
True
augassign -> >>=
326
not
augassign -> >>=
327
factor
766
327
term
767
327
(
768
327
arith_expr
769
327
NAME
770
327
[
771
327
atom
772
327
+
773
327
power
774
327
atom_expr
775
327
NUMBER
776
327
STRING
777
327
shift_expr
778
327
-
779
327
True
780
327
not_test
781
327
and_expr
782
327
xor_expr
783
327
None
784
327
expr
785
327
False
786
327
and_test
787
327
lambda
788
327
~
789
327
{
790
327
test
791
327
not
792
327
or_test
793
327
yield_expr
794
327
lambdef
795
327
yield
796
327
comparison
797
327
test_list
798
328
None
augassign -> %=
328
False
augassign -> %=
328
True
augassign -> %=
328
~
augassign -> %=
328
+
augassign -> %=
328
[
augassign -> %=
328
yield
augassign -> %=
328
NAME
augassign -> %=
328
(
augassign -> %=
328
NUMBER
augassign -> %=
328
not
augassign -> %=
328
STRING
augassign -> %=
328
{
augassign -> %=
328
-
augassign -> %=
328
lambda
augassign -> %=
329
~
augassign -> -=
329
NAME
augassign -> -=
329
None
augassign -> -=
329
not
augassign -> -=
329
[
augassign -> -=
329
False
augassign -> -=
329
yield
augassign -> -=
329
{
augassign -> -=
329
-
augassign -> -=
329
True
augassign -> -=
329
(
augassign -> -=
329
STRING
augassign -> -=
329
lambda
augassign -> -=
329
+
augassign -> -=
329
NUMBER
augassign -> -=
330
False
augassign -> ^=
330
{
augassign -> ^=
330
~
augassign -> ^=
330
None
augassign -> ^=
330
lambda
augassign -> ^=
330
STRING
augassign -> ^=
330
NAME
augassign -> ^=
330
(
augassign -> ^=
330
[
augassign -> ^=
330
True
augassign -> ^=
330
not
augassign -> ^=
330
+
augassign -> ^=
330
yield
augassign -> ^=
330
NUMBER
augassign -> ^=
330
-
augassign -> ^=
331
not
augassign -> |=
331
+
augassign -> |=
331
True
augassign -> |=
331
False
augassign -> |=
331
yield
augassign -> |=
331
None
augassign -> |=
331
lambda
augassign -> |=
331
NAME
augassign -> |=
331
NUMBER
augassign -> |=
331
[
augassign -> |=
331
(
augassign -> |=
331
~
augassign -> |=
331
{
augassign -> |=
331
-
augassign -> |=
331
STRING
augassign -> |=
332
NUMBER
augassign -> <<=
332
{
augassign -> <<=
332
None
augassign -> <<=
332
NAME
augassign -> <<=
332
~
augassign -> <<=
332
True
augassign -> <<=
332
False
augassign -> <<=
332
(
augassign -> <<=
332
[
augassign -> <<=
332
-
augassign -> <<=
332
+
augassign -> <<=
332
yield
augassign -> <<=
332
lambda
augassign -> <<=
332
STRING
augassign -> <<=
332
not
augassign -> <<=
333
(
augassign -> @=
333
not
augassign -> @=
333
None
augassign -> @=
333
False
augassign -> @=
333
STRING
augassign -> @=
333
{
augassign -> @=
333
yield
augassign -> @=
333
lambda
augassign -> @=
333
-
augassign -> @=
333
[
augassign -> @=
333
NAME
augassign -> @=
333
~
augassign -> @=
333
True
augassign -> @=
333
+
augassign -> @=
333
NUMBER
augassign -> @=
334
lambda
augassign -> **=
334
NAME
augassign -> **=
334
-
augassign -> **=
334
STRING
augassign -> **=
334
True
augassign -> **=
334
NUMBER
augassign -> **=
334
False
augassign -> **=
334
+
augassign -> **=
334
[
augassign -> **=
334
yield
augassign -> **=
334
None
augassign -> **=
334
(
augassign -> **=
334
{
augassign -> **=
334
~
augassign -> **=
334
not
augassign -> **=
335
lambda
augassign -> +=
335
False
augassign -> +=
335
{
augassign -> +=
335
None
augassign -> +=
335
(
augassign -> +=
335
-
augassign -> +=
335
NUMBER
augassign -> +=
335
+
augassign -> +=
335
True
augassign -> +=
335
~
augassign -> +=
335
[
augassign -> +=
335
STRING
augassign -> +=
335
yield
augassign -> +=
335
NAME
augassign -> +=
335
not
augassign -> +=
336
NEWLINE
expr_stmt -> test_list assign
337
NEWLINE
expr_stmt -> test_list annassign
338
factor
184
338
term
185
338
(
186
338
arith_expr
187
338
NAME
188
338
[
189
338
+
190
338
atom_expr
191
338
atom
192
338
NUMBER
193
338
STRING
194
338
yield_or_testlist
799
338
shift_expr
195
338
-
196
338
True
197
338
not_test
198
338
and_expr
199
338
xor_expr
200
338
None
201
338
expr
202
338
False
203
338
and_test
204
338
lambda
205
338
{
206
338
~
207
338
power
208
338
test
209
338
not
210
338
or_test
211
338
test_list
800
338
comparison
212
338
yield
801
338
lambdef
214
338
yield_expr
802
339
factor
803
339
(
804
339
arith_expr
805
339
NAME
806
339
[
807
339
atom
808
339
+
809
339
term
810
339
power
811
339
atom_expr
812
339
NUMBER
813
339
STRING
814
339
shift_expr
815
339
-
816
339
True
817
339
and_expr
818
339
xor_expr
819
339
None
820
339
False
821
339
and_test
822
339
{
823
339
~
824
339
not_test
825
339
expr
826
339
lambdef
827
339
lambda
828
339
or_test
829
339
not
830
339
comparison
831
339
test
832
340
//
833
340
in
term -> factor
340
-
term -> factor
340
*
834
340
%
835
340
@
836
340
from
term -> factor
340
>=
term -> factor
340
/
837
340
<
term -> factor
340
<=
term -> factor
340
==
term -> factor
340
!=
term -> factor
340
>>
term -> factor
340
is
term -> factor
340
or
term -> factor
340
and
term -> factor
340
NEWLINE
term -> factor
340
^
term -> factor
340
+
term -> factor
340
&
term -> factor
340
<<
term -> factor
340
|
term -> factor
340
>
term -> factor
340
if
term -> factor
340
not
term -> factor
341
!=
power -> atom_expr
341
**
838
341
>
power -> atom_expr
341
+
power -> atom_expr
341
not
power -> atom_expr
341
&
power -> atom_expr
341
|
power -> atom_expr
341
>>
power -> atom_expr
341
^
power -> atom_expr
341
==
power -> atom_expr
341
in
power -> atom_expr
341
if
power -> atom_expr
341
%
power -> atom_expr
341
<<
power -> atom_expr
341
or
power -> atom_expr
341
NEWLINE
power -> atom_expr
341
@
power -> atom_expr
341
*
power -> atom_expr
341
/
power -> atom_expr
341
<
power -> atom_expr
341
//
power -> atom_expr
341
>=
power -> atom_expr
341
-
power -> atom_expr
341
is
power -> atom_expr
341
from
power -> atom_expr
341
<=
power -> atom_expr
341
and
power -> atom_expr
342
factor
268
342
term
270
342
(
271
342
arith_expr
272
342
NAME
273
342
[
274
342
+
275
342
test_list_comp
839
342
atom_expr
277
342
NUMBER
278
342
atom
279
342
STRING
280
342
shift_expr
281
342
-
282
342
True
283
342
not_test
284
342
lambdef
285
342
and_expr
286
342
xor_expr
287
342
False
288
342
None
289
342
expr
290
342
and_test
291
342
)
840
342
{
292
342
~
293
342
power
294
342
lambda
295
342
comparison
296
342
or_test
297
342
not
298
342
test
299
342
test_list
300
343
>>
841
343
<<
842
343
&
shift_expr -> arith_expr
343
<=
shift_expr -> arith_expr
343
>
shift_expr -> arith_expr
343
NEWLINE
shift_expr -> arith_expr
343
not
shift_expr -> arith_expr
343
!=
shift_expr -> arith_expr
343
^
shift_expr -> arith_expr
343
is
shift_expr -> arith_expr
343
|
shift_expr -> arith_expr
343
>=
shift_expr -> arith_expr
343
or
shift_expr -> arith_expr
343
==
shift_expr -> arith_expr
343
if
shift_expr -> arith_expr
343
and
shift_expr -> arith_expr
343
from
shift_expr -> arith_expr
343
<
shift_expr -> arith_expr
343
in
shift_expr -> arith_expr
344
NAME
305
344
vfpdef
306
344
varargslist
843
344
:
844
345
-
atom -> NAME
345
or
atom -> NAME
345
>>
atom -> NAME
345
NEWLINE
atom -> NAME
345
from
atom -> NAME
345
&
atom -> NAME
345
[
atom -> NAME
345
<=
atom -> NAME
345
<
atom -> NAME
345
.
atom -> NAME
345
|
atom -> NAME
345
*
atom -> NAME
345
/
atom -> NAME
345
<<
atom -> NAME
345
not
atom -> NAME
345
>
atom -> NAME
345
is
atom -> NAME
345
//
atom -> NAME
345
+
atom -> NAME
345
if
atom -> NAME
345
in
atom -> NAME
345
**
atom -> NAME
345
!=
atom -> NAME
345
>=
atom -> NAME
345
^
atom -> NAME
345
@
atom -> NAME
345
(
atom -> NAME
345
==
atom -> NAME
345
and
atom -> NAME
345
%
atom -> NAME
346
factor
117
346
or_test
118
346
term
119
346
(
120
346
arith_expr
121
346
NAME
122
346
[
123
346
]
845
346
+
125
346
atom_expr
126
346
NUMBER
127
346
atom
128
346
STRING
129
346
shift_expr
130
346
-
131
346
test_list_comp
846
346
True
133
346
not_test
134
346
lambdef
135
346
and_expr
136
346
xor_expr
137
346
False
138
346
None
139
346
expr
140
346
and_test
141
346
{
142
346
~
143
346
lambda
144
346
power
145
346
comparison
146
346
test_list
147
346
test
148
346
not
149
347
atom_expr
341
347
(
342
347
NAME
345
347
[
346
347
+
347
347
NUMBER
350
347
atom
349
347
STRING
352
347
-
353
347
factor
847
347
True
355
347
None
359
347
False
361
347
{
363
347
~
364
347
power
365
348
+
848
348
-
849
348
NEWLINE
arith_expr -> term
348
|
arith_expr -> term
348
or
arith_expr -> term
348
not
arith_expr -> term
348
<=
arith_expr -> term
348
!=
arith_expr -> term
348
<
arith_expr -> term
348
&
arith_expr -> term
348
>=
arith_expr -> term
348
if
arith_expr -> term
348
from
arith_expr -> term
348
==
arith_expr -> term
348
^
arith_expr -> term
348
in
arith_expr -> term
348
is
arith_expr -> term
348
<<
arith_expr -> term
348
>
arith_expr -> term
348
and
arith_expr -> term
348
>>
arith_expr -> term
349
trailer
850
349
.
851
349
(
852
349
[
853
349
trailer_expr
854
349
<<
trailer_expr -> 
349
%
trailer_expr -> 
349
==
trailer_expr -> 
349
from
trailer_expr -> 
349
-
trailer_expr -> 
349
<
trailer_expr -> 
349
NEWLINE
trailer_expr -> 
349
if
trailer_expr -> 
349
or
trailer_expr -> 
349
/
trailer_expr -> 
349
**
trailer_expr -> 
349
and
trailer_expr -> 
349
@
trailer_expr -> 
349
*
trailer_expr -> 
349
|
trailer_expr -> 
349
is
trailer_expr -> 
349
+
trailer_expr -> 
349
in
trailer_expr -> 
349
&
trailer_expr -> 
349
<=
trailer_expr -> 
349
>=
trailer_expr -> 
349
^
trailer_expr -> 
349
>
trailer_expr -> 
349
!=
trailer_expr -> 
349
not
trailer_expr -> 
349
>>
trailer_expr -> 
349
//
trailer_expr -> 
350
[
atom -> NUMBER
350
>=
atom -> NUMBER
350
<=
atom -> NUMBER
350
!=
atom -> NUMBER
350
//
atom -> NUMBER
350
in
atom -> NUMBER
350
/
atom -> NUMBER
350
or
atom -> NUMBER
350
>
atom -> NUMBER
350
not
atom -> NUMBER
350
>>
atom -> NUMBER
350
(
atom -> NUMBER
350
**
atom -> NUMBER
350
<<
atom -> NUMBER
350
and
atom -> NUMBER
350
+
atom -> NUMBER
350
%
atom -> NUMBER
350
==
atom -> NUMBER
350
if
atom -> NUMBER
350
is
atom -> NUMBER
350
*
atom -> NUMBER
350
@
atom -> NUMBER
350
|
atom -> NUMBER
350
NEWLINE
atom -> NUMBER
350
-
atom -> NUMBER
350
.
atom -> NUMBER
350
^
atom -> NUMBER
350
from
atom -> NUMBER
350
<
atom -> NUMBER
350
&
atom -> NUMBER
351
&
855
351
^
and_expr -> shift_expr
351
|
and_expr -> shift_expr
351
<=
and_expr -> shift_expr
351
NEWLINE
and_expr -> shift_expr
351
or
and_expr -> shift_expr
351
>
and_expr -> shift_expr
351
not
and_expr -> shift_expr
351
!=
and_expr -> shift_expr
351
and
and_expr -> shift_expr
351
is
and_expr -> shift_expr
351
<
and_expr -> shift_expr
351
if
and_expr -> shift_expr
351
in
and_expr -> shift_expr
351
>=
and_expr -> shift_expr
351
from
and_expr -> shift_expr
351
==
and_expr -> shift_expr
352
and
atom -> STRING
352
%
atom -> STRING
352
//
atom -> STRING
352
>>
atom -> STRING
352
*
atom -> STRING
352
<
atom -> STRING
352
.
atom -> STRING
352
in
atom -> STRING
352
NEWLINE
atom -> STRING
352
^
atom -> STRING
352
(
atom -> STRING
352
if
atom -> STRING
352
==
atom -> STRING
352
from
atom -> STRING
352
-
atom -> STRING
352
**
atom -> STRING
352
<<
atom -> STRING
352
<=
atom -> STRING
352
[
atom -> STRING
352
not
atom -> STRING
352
or
atom -> STRING
352
+
atom -> STRING
352
>=
atom -> STRING
352
@
atom -> STRING
352
&
atom -> STRING
352
>
atom -> STRING
352
is
atom -> STRING
352
|
atom -> STRING
352
!=
atom -> STRING
352
/
atom -> STRING
353
atom_expr
341
353
(
342
353
NAME
345
353
[
346
353
+
347
353
NUMBER
350
353
atom
349
353
STRING
352
353
-
353
353
True
355
353
None
359
353
False
361
353
{
363
353
~
364
353
power
365
353
factor
856
354
from
test -> or_test
354
if
857
354
NEWLINE
test -> or_test
355
(
atom -> True
355
[
atom -> True
355
+
atom -> True
355
@
atom -> True
355
<=
atom -> True
355
&
atom -> True
355
<<
atom -> True
355
-
atom -> True
355
from
atom -> True
355
/
atom -> True
355
or
atom -> True
355
>
atom -> True
355
%
atom -> True
355
^
atom -> True
355
if
atom -> True
355
!=
atom -> True
355
is
atom -> True
355
*
atom -> True
355
<
atom -> True
355
and
atom -> True
355
.
atom -> True
355
==
atom -> True
355
**
atom -> True
355
>>
atom -> True
355
in
atom -> True
355
|
atom -> True
355
>=
atom -> True
355
//
atom -> True
355
not
atom -> True
355
NEWLINE
atom -> True
356
^
858
356
not
xor_expr -> and_expr
356
if
xor_expr -> and_expr
356
<=
xor_expr -> and_expr
356
>
xor_expr -> and_expr
356
NEWLINE
xor_expr -> and_expr
356
<
xor_expr -> and_expr
356
in
xor_expr -> and_expr
356
>=
xor_expr -> and_expr
356
==
xor_expr -> and_expr
356
|
xor_expr -> and_expr
356
is
xor_expr -> and_expr
356
and
xor_expr -> and_expr
356
or
xor_expr -> and_expr
356
from
xor_expr -> and_expr
356
!=
xor_expr -> and_expr
357
factor
340
357
atom_expr
341
357
(
342
357
arith_expr
343
357
NAME
345
357
[
346
357
+
347
357
term
348
357
atom
349
357
NUMBER
350
357
shift_expr
351
357
STRING
352
357
-
353
357
not_test
859
357
True
355
357
and_expr
356
357
not
357
357
xor_expr
358
357
None
359
357
expr
360
357
False
361
357
{
363
357
~
364
357
power
365
357
comparison
367
358
|
860
358
>=
expr -> xor_expr
358
==
expr -> xor_expr
358
NEWLINE
expr -> xor_expr
358
is
expr -> xor_expr
358
if
expr -> xor_expr
358
or
expr -> xor_expr
358
>
expr -> xor_expr
358
and
expr -> xor_expr
358
from
expr -> xor_expr
358
<
expr -> xor_expr
358
in
expr -> xor_expr
358
<=
expr -> xor_expr
358
not
expr -> xor_expr
358
!=
expr -> xor_expr
359
is
atom -> None
359
.
atom -> None
359
==
atom -> None
359
^
atom -> None
359
<<
atom -> None
359
>>
atom -> None
359
(
atom -> None
359
|
atom -> None
359
+
atom -> None
359
*
atom -> None
359
//
atom -> None
359
@
atom -> None
359
in
atom -> None
359
>=
atom -> None
359
!=
atom -> None
359
%
atom -> None
359
[
atom -> None
359
and
atom -> None
359
-
atom -> None
359
NEWLINE
atom -> None
359
if
atom -> None
359
&
atom -> None
359
<=
atom -> None
359
<
atom -> None
359
>
atom -> None
359
**
atom -> None
359
from
atom -> None
359
or
atom -> None
359
/
atom -> None
359
not
atom -> None
360
is
215
360
<
217
360
!=
218
360
in
219
360
<=
220
360
not
221
360
>=
222
360
>
223
360
==
224
360
comp_op
861
360
and
comparison -> expr
360
or
comparison -> expr
360
from
comparison -> expr
360
if
comparison -> expr
360
NEWLINE
comparison -> expr
361
in
atom -> False
361
>
atom -> False
361
-
atom -> False
361
%
atom -> False
361
<
atom -> False
361
NEWLINE
atom -> False
361
|
atom -> False
361
==
atom -> False
361
&
atom -> False
361
//
atom -> False
361
and
atom -> False
361
not
atom -> False
361
+
atom -> False
361
!=
atom -> False
361
if
atom -> False
361
@
atom -> False
361
[
atom -> False
361
or
atom -> False
361
<=
atom -> False
361
*
atom -> False
361
^
atom -> False
361
is
atom -> False
361
/
atom -> False
361
.
atom -> False
361
>=
atom -> False
361
from
atom -> False
361
**
atom -> False
361
>>
atom -> False
361
<<
atom -> False
361
(
atom -> False
362
from
or_test -> and_test
362
or
862
362
NEWLINE
or_test -> and_test
362
if
or_test -> and_test
363
}
863
364
atom_expr
341
364
(
342
364
NAME
345
364
[
346
364
+
347
364
factor
864
364
NUMBER
350
364
atom
349
364
STRING
352
364
-
353
364
True
355
364
None
359
364
False
361
364
{
363
364
~
364
364
power
365
365
&
factor -> power
365
NEWLINE
factor -> power
365
%
factor -> power
365
<<
factor -> power
365
from
factor -> power
365
-
factor -> power
365
<=
factor -> power
365
not
factor -> power
365
//
factor -> power
365
/
factor -> power
365
is
factor -> power
365
|
factor -> power
365
<
factor -> power
365
and
factor -> power
365
>=
factor -> power
365
>>
factor -> power
365
>
factor -> power
365
in
factor -> power
365
if
factor -> power
365
^
factor -> power
365
==
factor -> power
365
+
factor -> power
365
@
factor -> power
365
or
factor -> power
365
*
factor -> power
365
!=
factor -> power
366
and
865
366
NEWLINE
and_test -> not_test
366
from
and_test -> not_test
366
or
and_test -> not_test
366
if
and_test -> not_test
367
NEWLINE
not_test -> comparison
367
or
not_test -> comparison
367
and
not_test -> comparison
367
if
not_test -> comparison
367
from
not_test -> comparison
368
NEWLINE
test -> lambdef
368
from
test -> lambdef
369
from
866
369
NEWLINE
raise_stmt -> raise test
370
NEWLINE
nonlocal_stmt -> nonlocal namelist
371
<<
term -> factor
371
//
867
371
|
term -> factor
371
/
868
371
%
869
371
*
870
371
@
871
371
-
term -> factor
371
NEWLINE
term -> factor
371
^
term -> factor
371
,
term -> factor
371
+
term -> factor
371
&
term -> factor
371
>>
term -> factor
372
-
872
372
+
873
372
NEWLINE
arith_expr -> term
372
|
arith_expr -> term
372
&
arith_expr -> term
372
^
arith_expr -> term
372
<<
arith_expr -> term
372
,
arith_expr -> term
372
>>
arith_expr -> term
373
factor
268
373
term
270
373
(
271
373
arith_expr
272
373
NAME
273
373
[
274
373
+
275
373
test_list_comp
874
373
atom_expr
277
373
NUMBER
278
373
atom
279
373
STRING
280
373
shift_expr
281
373
-
282
373
True
283
373
not_test
284
373
lambdef
285
373
and_expr
286
373
xor_expr
287
373
False
288
373
None
289
373
expr
290
373
and_test
291
373
)
875
373
{
292
373
~
293
373
power
294
373
lambda
295
373
comparison
296
373
or_test
297
373
not
298
373
test
299
373
test_list
300
374
.
atom -> True
374
&
atom -> True
374
**
atom -> True
374
(
atom -> True
374
%
atom -> True
374
[
atom -> True
374
>>
atom -> True
374
<<
atom -> True
374
//
atom -> True
374
^
atom -> True
374
-
atom -> True
374
+
atom -> True
374
*
atom -> True
374
/
atom -> True
374
|
atom -> True
374
@
atom -> True
374
NEWLINE
atom -> True
374
,
atom -> True
375
factor
117
375
or_test
118
375
term
119
375
(
120
375
arith_expr
121
375
NAME
122
375
[
123
375
+
125
375
atom_expr
126
375
NUMBER
127
375
atom
128
375
STRING
129
375
shift_expr
130
375
-
131
375
]
876
375
True
133
375
not_test
134
375
lambdef
135
375
and_expr
136
375
xor_expr
137
375
False
138
375
None
139
375
expr
140
375
and_test
141
375
test_list_comp
877
375
{
142
375
~
143
375
lambda
144
375
power
145
375
comparison
146
375
test_list
147
375
test
148
375
not
149
376
(
373
376
True
374
376
[
375
376
+
376
376
STRING
377
376
atom_expr
378
376
NUMBER
380
376
~
381
376
NAME
382
376
factor
878
376
False
383
376
{
384
376
None
387
376
power
388
376
-
389
376
atom
393
377
-
atom -> STRING
377
^
atom -> STRING
377
**
atom -> STRING
377
+
atom -> STRING
377
%
atom -> STRING
377
<<
atom -> STRING
377
//
atom -> STRING
377
@
atom -> STRING
377
(
atom -> STRING
377
>>
atom -> STRING
377
&
atom -> STRING
377
[
atom -> STRING
377
*
atom -> STRING
377
,
atom -> STRING
377
.
atom -> STRING
377
|
atom -> STRING
377
NEWLINE
atom -> STRING
377
/
atom -> STRING
378
**
879
378
+
power -> atom_expr
378
&
power -> atom_expr
378
|
power -> atom_expr
378
>>
power -> atom_expr
378
^
power -> atom_expr
378
%
power -> atom_expr
378
<<
power -> atom_expr
378
NEWLINE
power -> atom_expr
378
@
power -> atom_expr
378
*
power -> atom_expr
378
/
power -> atom_expr
378
//
power -> atom_expr
378
-
power -> atom_expr
378
,
power -> atom_expr
379
>>
880
379
,
shift_expr -> arith_expr
379
&
shift_expr -> arith_expr
379
<<
881
379
|
shift_expr -> arith_expr
379
NEWLINE
shift_expr -> arith_expr
379
^
shift_expr -> arith_expr
380
+
atom -> NUMBER
380
%
atom -> NUMBER
380
[
atom -> NUMBER
380
,
atom -> NUMBER
380
*
atom -> NUMBER
380
-
atom -> NUMBER
380
&
atom -> NUMBER
380
.
atom -> NUMBER
380
NEWLINE
atom -> NUMBER
380
>>
atom -> NUMBER
380
^
atom -> NUMBER
380
(
atom -> NUMBER
380
@
atom -> NUMBER
380
**
atom -> NUMBER
380
<<
atom -> NUMBER
380
|
atom -> NUMBER
380
//
atom -> NUMBER
380
/
atom -> NUMBER
381
(
373
381
True
374
381
[
375
381
+
376
381
STRING
377
381
atom_expr
378
381
NUMBER
380
381
~
381
381
NAME
382
381
False
383
381
{
384
381
factor
882
381
None
387
381
power
388
381
-
389
381
atom
393
382
&
atom -> NAME
382
[
atom -> NAME
382
**
atom -> NAME
382
-
atom -> NAME
382
.
atom -> NAME
382
,
atom -> NAME
382
>>
atom -> NAME
382
//
atom -> NAME
382
^
atom -> NAME
382
|
atom -> NAME
382
@
atom -> NAME
382
(
atom -> NAME
382
NEWLINE
atom -> NAME
382
+
atom -> NAME
382
*
atom -> NAME
382
%
atom -> NAME
382
/
atom -> NAME
382
<<
atom -> NAME
383
,
atom -> False
383
*
atom -> False
383
^
atom -> False
383
@
atom -> False
383
-
atom -> False
383
[
atom -> False
383
%
atom -> False
383
/
atom -> False
383
+
atom -> False
383
.
atom -> False
383
NEWLINE
atom -> False
383
|
atom -> False
383
**
atom -> False
383
>>
atom -> False
383
&
atom -> False
383
//
atom -> False
383
<<
atom -> False
383
(
atom -> False
384
}
883
385
,
xor_expr -> and_expr
385
^
884
385
NEWLINE
xor_expr -> and_expr
385
|
xor_expr -> and_expr
386
&
885
386
^
and_expr -> shift_expr
386
,
and_expr -> shift_expr
386
NEWLINE
and_expr -> shift_expr
386
|
and_expr -> shift_expr
387
%
atom -> None
387
[
atom -> None
387
*
atom -> None
387
.
atom -> None
387
//
atom -> None
387
,
atom -> None
387
@
atom -> None
387
^
atom -> None
387
**
atom -> None
387
<<
atom -> None
387
-
atom -> None
387
>>
atom -> None
387
(
atom -> None
387
NEWLINE
atom -> None
387
&
atom -> None
387
|
atom -> None
387
+
atom -> None
387
/
atom -> None
388
&
factor -> power
388
NEWLINE
factor -> power
388
|
factor -> power
388
+
factor -> power
388
^
factor -> power
388
@
factor -> power
388
%
factor -> power
388
>>
factor -> power
388
<<
factor -> power
388
-
factor -> power
388
*
factor -> power
388
//
factor -> power
388
/
factor -> power
388
,
factor -> power
389
(
373
389
True
374
389
[
375
389
+
376
389
factor
886
389
STRING
377
389
atom_expr
378
389
NUMBER
380
389
~
381
389
NAME
382
389
False
383
389
{
384
389
None
387
389
power
388
389
-
389
389
atom
393
390
NEWLINE
expr_list -> expr
390
,
887
391
NEWLINE
yield_stmt -> yield expr_list
392
|
888
392
,
expr -> xor_expr
392
NEWLINE
expr -> xor_expr
393
trailer_expr
889
393
trailer
890
393
(
891
393
.
892
393
[
893
393
<<
trailer_expr -> 
393
,
trailer_expr -> 
393
+
trailer_expr -> 
393
%
trailer_expr -> 
393
&
trailer_expr -> 
393
-
trailer_expr -> 
393
NEWLINE
trailer_expr -> 
393
^
trailer_expr -> 
393
/
trailer_expr -> 
393
>>
trailer_expr -> 
393
//
trailer_expr -> 
393
**
trailer_expr -> 
393
@
trailer_expr -> 
393
*
trailer_expr -> 
393
|
trailer_expr -> 
394
NEWLINE
assert_stmt -> assert test_list
395
$
program -> NEWLINE program
396
//
894
396
in
term -> factor
396
-
term -> factor
396
*
895
396
%
896
396
@
897
396
>=
term -> factor
396
/
898
396
<
term -> factor
396
<=
term -> factor
396
==
term -> factor
396
!=
term -> factor
396
>>
term -> factor
396
is
term -> factor
396
or
term -> factor
396
and
term -> factor
396
NEWLINE
term -> factor
396
^
term -> factor
396
+
term -> factor
396
&
term -> factor
396
<<
term -> factor
396
|
term -> factor
396
>
term -> factor
396
if
term -> factor
396
not
term -> factor
397
factor
268
397
term
270
397
(
271
397
arith_expr
272
397
NAME
273
397
[
274
397
+
275
397
test_list_comp
899
397
atom_expr
277
397
NUMBER
278
397
atom
279
397
STRING
280
397
shift_expr
281
397
-
282
397
True
283
397
not_test
284
397
lambdef
285
397
and_expr
286
397
xor_expr
287
397
False
288
397
None
289
397
expr
290
397
and_test
291
397
)
900
397
{
292
397
~
293
397
power
294
397
lambda
295
397
comparison
296
397
or_test
297
397
not
298
397
test
299
397
test_list
300
398
>>
901
398
<<
902
398
&
shift_expr -> arith_expr
398
<=
shift_expr -> arith_expr
398
>
shift_expr -> arith_expr
398
NEWLINE
shift_expr -> arith_expr
398
not
shift_expr -> arith_expr
398
!=
shift_expr -> arith_expr
398
^
shift_expr -> arith_expr
398
is
shift_expr -> arith_expr
398
|
shift_expr -> arith_expr
398
>=
shift_expr -> arith_expr
398
or
shift_expr -> arith_expr
398
==
shift_expr -> arith_expr
398
if
shift_expr -> arith_expr
398
and
shift_expr -> arith_expr
398
<
shift_expr -> arith_expr
398
in
shift_expr -> arith_expr
399
-
atom -> NAME
399
or
atom -> NAME
399
>>
atom -> NAME
399
NEWLINE
atom -> NAME
399
&
atom -> NAME
399
[
atom -> NAME
399
<=
atom -> NAME
399
<
atom -> NAME
399
.
atom -> NAME
399
|
atom -> NAME
399
*
atom -> NAME
399
/
atom -> NAME
399
<<
atom -> NAME
399
not
atom -> NAME
399
>
atom -> NAME
399
is
atom -> NAME
399
//
atom -> NAME
399
+
atom -> NAME
399
if
atom -> NAME
399
in
atom -> NAME
399
**
atom -> NAME
399
!=
atom -> NAME
399
>=
atom -> NAME
399
^
atom -> NAME
399
@
atom -> NAME
399
(
atom -> NAME
399
==
atom -> NAME
399
and
atom -> NAME
399
%
atom -> NAME
400
factor
117
400
or_test
118
400
term
119
400
(
120
400
arith_expr
121
400
NAME
122
400
[
123
400
]
903
400
+
125
400
atom_expr
126
400
NUMBER
127
400
atom
128
400
STRING
129
400
shift_expr
130
400
-
131
400
test_list_comp
904
400
True
133
400
not_test
134
400
lambdef
135
400
and_expr
136
400
xor_expr
137
400
False
138
400
None
139
400
expr
140
400
and_test
141
400
{
142
400
~
143
400
lambda
144
400
power
145
400
comparison
146
400
test_list
147
400
test
148
400
not
149
401
(
397
401
NAME
399
401
[
400
401
+
401
401
atom_expr
403
401
NUMBER
405
401
atom
404
401
STRING
406
401
-
408
401
factor
905
401
True
409
401
None
412
401
False
414
401
{
417
401
~
418
401
power
419
402
+
906
402
-
907
402
NEWLINE
arith_expr -> term
402
|
arith_expr -> term
402
or
arith_expr -> term
402
not
arith_expr -> term
402
<=
arith_expr -> term
402
!=
arith_expr -> term
402
<
arith_expr -> term
402
&
arith_expr -> term
402
>=
arith_expr -> term
402
if
arith_expr -> term
402
==
arith_expr -> term
402
^
arith_expr -> term
402
in
arith_expr -> term
402
is
arith_expr -> term
402
<<
arith_expr -> term
402
>
arith_expr -> term
402
and
arith_expr -> term
402
>>
arith_expr -> term
403
!=
power -> atom_expr
403
**
908
403
>
power -> atom_expr
403
+
power -> atom_expr
403
not
power -> atom_expr
403
&
power -> atom_expr
403
|
power -> atom_expr
403
>>
power -> atom_expr
403
^
power -> atom_expr
403
==
power -> atom_expr
403
if
power -> atom_expr
403
in
power -> atom_expr
403
%
power -> atom_expr
403
<<
power -> atom_expr
403
or
power -> atom_expr
403
NEWLINE
power -> atom_expr
403
@
power -> atom_expr
403
*
power -> atom_expr
403
/
power -> atom_expr
403
<
power -> atom_expr
403
//
power -> atom_expr
403
>=
power -> atom_expr
403
-
power -> atom_expr
403
is
power -> atom_expr
403
<=
power -> atom_expr
403
and
power -> atom_expr
404
trailer
909
404
.
910
404
(
911
404
[
912
404
trailer_expr
913
404
<<
trailer_expr -> 
404
%
trailer_expr -> 
404
==
trailer_expr -> 
404
-
trailer_expr -> 
404
<
trailer_expr -> 
404
NEWLINE
trailer_expr -> 
404
if
trailer_expr -> 
404
or
trailer_expr -> 
404
/
trailer_expr -> 
404
**
trailer_expr -> 
404
and
trailer_expr -> 
404
@
trailer_expr -> 
404
*
trailer_expr -> 
404
|
trailer_expr -> 
404
is
trailer_expr -> 
404
+
trailer_expr -> 
404
in
trailer_expr -> 
404
&
trailer_expr -> 
404
<=
trailer_expr -> 
404
>=
trailer_expr -> 
404
^
trailer_expr -> 
404
>
trailer_expr -> 
404
!=
trailer_expr -> 
404
not
trailer_expr -> 
404
>>
trailer_expr -> 
404
//
trailer_expr -> 
405
[
atom -> NUMBER
405
>=
atom -> NUMBER
405
<=
atom -> NUMBER
405
!=
atom -> NUMBER
405
//
atom -> NUMBER
405
in
atom -> NUMBER
405
/
atom -> NUMBER
405
or
atom -> NUMBER
405
>
atom -> NUMBER
405
not
atom -> NUMBER
405
>>
atom -> NUMBER
405
(
atom -> NUMBER
405
**
atom -> NUMBER
405
<<
atom -> NUMBER
405
and
atom -> NUMBER
405
+
atom -> NUMBER
405
%
atom -> NUMBER
405
==
atom -> NUMBER
405
if
atom -> NUMBER
405
is
atom -> NUMBER
405
*
atom -> NUMBER
405
@
atom -> NUMBER
405
|
atom -> NUMBER
405
NEWLINE
atom -> NUMBER
405
-
atom -> NUMBER
405
.
atom -> NUMBER
405
^
atom -> NUMBER
405
<
atom -> NUMBER
405
&
atom -> NUMBER
406
and
atom -> STRING
406
%
atom -> STRING
406
//
atom -> STRING
406
>>
atom -> STRING
406
*
atom -> STRING
406
<
atom -> STRING
406
.
atom -> STRING
406
in
atom -> STRING
406
NEWLINE
atom -> STRING
406
^
atom -> STRING
406
(
atom -> STRING
406
if
atom -> STRING
406
==
atom -> STRING
406
-
atom -> STRING
406
**
atom -> STRING
406
<<
atom -> STRING
406
<=
atom -> STRING
406
[
atom -> STRING
406
not
atom -> STRING
406
or
atom -> STRING
406
+
atom -> STRING
406
>=
atom -> STRING
406
@
atom -> STRING
406
&
atom -> STRING
406
>
atom -> STRING
406
is
atom -> STRING
406
|
atom -> STRING
406
!=
atom -> STRING
406
/
atom -> STRING
407
&
914
407
^
and_expr -> shift_expr
407
|
and_expr -> shift_expr
407
<=
and_expr -> shift_expr
407
NEWLINE
and_expr -> shift_expr
407
or
and_expr -> shift_expr
407
>
and_expr -> shift_expr
407
not
and_expr -> shift_expr
407
!=
and_expr -> shift_expr
407
and
and_expr -> shift_expr
407
is
and_expr -> shift_expr
407
<
and_expr -> shift_expr
407
if
and_expr -> shift_expr
407
in
and_expr -> shift_expr
407
>=
and_expr -> shift_expr
407
==
and_expr -> shift_expr
408
(
397
408
NAME
399
408
[
400
408
+
401
408
atom_expr
403
408
NUMBER
405
408
atom
404
408
STRING
406
408
-
408
408
True
409
408
None
412
408
False
414
408
{
417
408
~
418
408
power
419
408
factor
915
409
(
atom -> True
409
[
atom -> True
409
+
atom -> True
409
@
atom -> True
409
<=
atom -> True
409
&
atom -> True
409
<<
atom -> True
409
-
atom -> True
409
/
atom -> True
409
or
atom -> True
409
>
atom -> True
409
%
atom -> True
409
^
atom -> True
409
if
atom -> True
409
!=
atom -> True
409
is
atom -> True
409
*
atom -> True
409
<
atom -> True
409
and
atom -> True
409
.
atom -> True
409
==
atom -> True
409
**
atom -> True
409
>>
atom -> True
409
in
atom -> True
409
|
atom -> True
409
>=
atom -> True
409
//
atom -> True
409
not
atom -> True
409
NEWLINE
atom -> True
410
^
916
410
not
xor_expr -> and_expr
410
if
xor_expr -> and_expr
410
<=
xor_expr -> and_expr
410
>
xor_expr -> and_expr
410
NEWLINE
xor_expr -> and_expr
410
<
xor_expr -> and_expr
410
in
xor_expr -> and_expr
410
>=
xor_expr -> and_expr
410
==
xor_expr -> and_expr
410
|
xor_expr -> and_expr
410
is
xor_expr -> and_expr
410
and
xor_expr -> and_expr
410
or
xor_expr -> and_expr
410
!=
xor_expr -> and_expr
411
|
917
411
>=
expr -> xor_expr
411
==
expr -> xor_expr
411
NEWLINE
expr -> xor_expr
411
is
expr -> xor_expr
411
if
expr -> xor_expr
411
or
expr -> xor_expr
411
>
expr -> xor_expr
411
and
expr -> xor_expr
411
<
expr -> xor_expr
411
in
expr -> xor_expr
411
<=
expr -> xor_expr
411
not
expr -> xor_expr
411
!=
expr -> xor_expr
412
is
atom -> None
412
.
atom -> None
412
==
atom -> None
412
^
atom -> None
412
<<
atom -> None
412
>>
atom -> None
412
(
atom -> None
412
|
atom -> None
412
+
atom -> None
412
*
atom -> None
412
//
atom -> None
412
@
atom -> None
412
in
atom -> None
412
>=
atom -> None
412
!=
atom -> None
412
%
atom -> None
412
[
atom -> None
412
and
atom -> None
412
-
atom -> None
412
NEWLINE
atom -> None
412
if
atom -> None
412
&
atom -> None
412
<=
atom -> None
412
<
atom -> None
412
>
atom -> None
412
**
atom -> None
412
or
atom -> None
412
/
atom -> None
412
not
atom -> None
413
is
215
413
<
217
413
!=
218
413
in
219
413
<=
220
413
not
221
413
>=
222
413
>
223
413
==
224
413
comp_op
918
413
and
comparison -> expr
413
or
comparison -> expr
413
if
comparison -> expr
413
NEWLINE
comparison -> expr
414
in
atom -> False
414
>
atom -> False
414
-
atom -> False
414
%
atom -> False
414
<
atom -> False
414
NEWLINE
atom -> False
414
|
atom -> False
414
==
atom -> False
414
&
atom -> False
414
//
atom -> False
414
and
atom -> False
414
not
atom -> False
414
+
atom -> False
414
!=
atom -> False
414
if
atom -> False
414
@
atom -> False
414
[
atom -> False
414
or
atom -> False
414
<=
atom -> False
414
*
atom -> False
414
^
atom -> False
414
is
atom -> False
414
/
atom -> False
414
.
atom -> False
414
>=
atom -> False
414
**
atom -> False
414
>>
atom -> False
414
<<
atom -> False
414
(
atom -> False
415
NEWLINE
or_test -> and_test
415
or
919
415
if
or_test -> and_test
416
NAME
305
416
varargslist
920
416
vfpdef
306
416
:
921
417
}
922
418
(
397
418
NAME
399
418
[
400
418
+
401
418
factor
923
418
atom_expr
403
418
NUMBER
405
418
atom
404
418
STRING
406
418
-
408
418
True
409
418
None
412
418
False
414
418
{
417
418
~
418
418
power
419
419
&
factor -> power
419
NEWLINE
factor -> power
419
%
factor -> power
419
<<
factor -> power
419
-
factor -> power
419
<=
factor -> power
419
not
factor -> power
419
//
factor -> power
419
/
factor -> power
419
is
factor -> power
419
|
factor -> power
419
<
factor -> power
419
and
factor -> power
419
>=
factor -> power
419
>>
factor -> power
419
>
factor -> power
419
in
factor -> power
419
if
factor -> power
419
^
factor -> power
419
==
factor -> power
419
+
factor -> power
419
@
factor -> power
419
or
factor -> power
419
*
factor -> power
419
!=
factor -> power
420
and
924
420
NEWLINE
and_test -> not_test
420
or
and_test -> not_test
420
if
and_test -> not_test
421
factor
396
421
(
397
421
arith_expr
398
421
NAME
399
421
[
400
421
+
401
421
term
402
421
atom_expr
403
421
atom
404
421
NUMBER
405
421
STRING
406
421
shift_expr
407
421
-
408
421
not_test
925
421
True
409
421
and_expr
410
421
xor_expr
411
421
None
412
421
expr
413
421
False
414
421
{
417
421
~
418
421
power
419
421
not
421
421
comparison
422
422
and
not_test -> comparison
422
NEWLINE
not_test -> comparison
422
or
not_test -> comparison
422
if
not_test -> comparison
423
NEWLINE
test -> or_test
423
if
926
424
NEWLINE
test -> lambdef
425
NEWLINE
sim_stmt -> begsim test
426
NEWLINE
del_stmt -> del expr_list
427
factor
85
427
(
86
427
NAME
88
427
[
90
427
~
91
427
+
92
427
atom_expr
94
427
NUMBER
96
427
atom
95
427
STRING
97
427
-
100
427
term
927
427
True
101
427
False
104
427
{
105
427
None
106
427
power
108
428
factor
85
428
(
86
428
NAME
88
428
[
90
428
~
91
428
+
92
428
atom_expr
94
428
NUMBER
96
428
atom
95
428
term
928
428
STRING
97
428
-
100
428
True
101
428
False
104
428
{
105
428
None
106
428
power
108
429
factor
85
429
(
86
429
NAME
88
429
[
90
429
~
91
429
+
92
429
atom_expr
94
429
NUMBER
96
429
atom
95
429
STRING
97
429
-
100
429
True
101
429
False
104
429
{
105
429
None
106
429
term
929
429
power
108
430
factor
85
430
(
86
430
NAME
88
430
term
930
430
[
90
430
~
91
430
+
92
430
atom_expr
94
430
NUMBER
96
430
atom
95
430
STRING
97
430
-
100
430
True
101
430
False
104
430
{
105
430
None
106
430
power
108
431
factor
85
431
(
86
431
NAME
88
431
[
90
431
~
91
431
+
92
431
atom_expr
94
431
NUMBER
96
431
atom
95
431
STRING
97
431
-
100
431
term
931
431
True
101
431
False
104
431
{
105
431
None
106
431
power
108
432
)
932
433
or
atom -> ( )
433
<<
atom -> ( )
433
not
atom -> ( )
433
&
atom -> ( )
433
(
atom -> ( )
433
in
atom -> ( )
433
**
atom -> ( )
433
@
atom -> ( )
433
<=
atom -> ( )
433
%
atom -> ( )
433
[
atom -> ( )
433
>=
atom -> ( )
433
/
atom -> ( )
433
+
atom -> ( )
433
<
atom -> ( )
433
is
atom -> ( )
433
:
atom -> ( )
433
*
atom -> ( )
433
!=
atom -> ( )
433
-
atom -> ( )
433
|
atom -> ( )
433
//
atom -> ( )
433
^
atom -> ( )
433
and
atom -> ( )
433
==
atom -> ( )
433
if
atom -> ( )
433
>
atom -> ( )
433
.
atom -> ( )
433
>>
atom -> ( )
434
factor
85
434
(
86
434
arith_expr
87
434
NAME
88
434
term
89
434
[
90
434
~
91
434
+
92
434
atom_expr
94
434
NUMBER
96
434
atom
95
434
STRING
97
434
-
100
434
shift_expr
933
434
True
101
434
False
104
434
{
105
434
None
106
434
power
108
435
factor
85
435
(
86
435
arith_expr
87
435
NAME
88
435
term
89
435
[
90
435
~
91
435
+
92
435
atom_expr
94
435
NUMBER
96
435
atom
95
435
STRING
97
435
-
100
435
True
101
435
shift_expr
934
435
False
104
435
{
105
435
None
106
435
power
108
436
factor
85
436
(
86
436
NAME
88
436
term
89
436
[
90
436
~
91
436
+
92
436
atom_expr
94
436
NUMBER
96
436
atom
95
436
STRING
97
436
-
100
436
True
101
436
arith_expr
935
436
False
104
436
{
105
436
None
106
436
power
108
437
factor
85
437
(
86
437
NAME
88
437
term
89
437
[
90
437
~
91
437
+
92
437
atom_expr
94
437
NUMBER
96
437
atom
95
437
STRING
97
437
-
100
437
True
101
437
False
104
437
{
105
437
None
106
437
arith_expr
936
437
power
108
438
<=
atom -> [ ]
438
is
atom -> [ ]
438
-
atom -> [ ]
438
**
atom -> [ ]
438
^
atom -> [ ]
438
%
atom -> [ ]
438
/
atom -> [ ]
438
>=
atom -> [ ]
438
|
atom -> [ ]
438
not
atom -> [ ]
438
@
atom -> [ ]
438
*
atom -> [ ]
438
(
atom -> [ ]
438
>>
atom -> [ ]
438
[
atom -> [ ]
438
:
atom -> [ ]
438
or
atom -> [ ]
438
!=
atom -> [ ]
438
and
atom -> [ ]
438
<<
atom -> [ ]
438
if
atom -> [ ]
438
in
atom -> [ ]
438
+
atom -> [ ]
438
.
atom -> [ ]
438
==
atom -> [ ]
438
>
atom -> [ ]
438
<
atom -> [ ]
438
&
atom -> [ ]
438
//
atom -> [ ]
439
]
937
440
or
factor -> ~ factor
440
==
factor -> ~ factor
440
<=
factor -> ~ factor
440
@
factor -> ~ factor
440
!=
factor -> ~ factor
440
>=
factor -> ~ factor
440
>
factor -> ~ factor
440
and
factor -> ~ factor
440
:
factor -> ~ factor
440
*
factor -> ~ factor
440
&
factor -> ~ factor
440
%
factor -> ~ factor
440
<
factor -> ~ factor
440
//
factor -> ~ factor
440
if
factor -> ~ factor
440
^
factor -> ~ factor
440
/
factor -> ~ factor
440
in
factor -> ~ factor
440
+
factor -> ~ factor
440
not
factor -> ~ factor
440
-
factor -> ~ factor
440
is
factor -> ~ factor
440
>>
factor -> ~ factor
440
<<
factor -> ~ factor
440
|
factor -> ~ factor
441
<
factor -> + factor
441
if
factor -> + factor
441
<<
factor -> + factor
441
and
factor -> + factor
441
>=
factor -> + factor
441
%
factor -> + factor
441
>>
factor -> + factor
441
*
factor -> + factor
441
+
factor -> + factor
441
/
factor -> + factor
441
>
factor -> + factor
441
<=
factor -> + factor
441
^
factor -> + factor
441
is
factor -> + factor
441
|
factor -> + factor
441
or
factor -> + factor
441
-
factor -> + factor
441
in
factor -> + factor
441
&
factor -> + factor
441
not
factor -> + factor
441
//
factor -> + factor
441
!=
factor -> + factor
441
:
factor -> + factor
441
==
factor -> + factor
441
@
factor -> + factor
442
factor
85
442
(
86
442
arith_expr
87
442
NAME
88
442
term
89
442
[
90
442
~
91
442
+
92
442
expr
93
442
atom_expr
94
442
atom
95
442
NUMBER
96
442
STRING
97
442
shift_expr
99
442
-
100
442
True
101
442
and_expr
102
442
comparison
938
442
xor_expr
103
442
False
104
442
{
105
442
None
106
442
power
108
443
(
86
443
NAME
88
443
[
90
443
~
91
443
+
92
443
atom_expr
94
443
NUMBER
96
443
atom
95
443
STRING
97
443
-
100
443
factor
939
443
True
101
443
False
104
443
{
105
443
None
106
443
power
108
444
trailer_expr
940
444
trailer
444
444
.
445
444
(
446
444
[
447
444
<<
trailer_expr -> 
444
%
trailer_expr -> 
444
==
trailer_expr -> 
444
-
trailer_expr -> 
444
<
trailer_expr -> 
444
if
trailer_expr -> 
444
or
trailer_expr -> 
444
/
trailer_expr -> 
444
**
trailer_expr -> 
444
and
trailer_expr -> 
444
@
trailer_expr -> 
444
*
trailer_expr -> 
444
|
trailer_expr -> 
444
is
trailer_expr -> 
444
+
trailer_expr -> 
444
in
trailer_expr -> 
444
&
trailer_expr -> 
444
<=
trailer_expr -> 
444
>=
trailer_expr -> 
444
^
trailer_expr -> 
444
>
trailer_expr -> 
444
!=
trailer_expr -> 
444
not
trailer_expr -> 
444
>>
trailer_expr -> 
444
//
trailer_expr -> 
444
:
trailer_expr -> 
445
NAME
941
446
factor
697
446
term
698
446
(
699
446
arith_expr
700
446
NAME
701
446
[
702
446
atom
703
446
+
704
446
power
706
446
atom_expr
707
446
NUMBER
708
446
STRING
709
446
*
710
446
shift_expr
711
446
-
712
446
argument
714
446
)
942
446
True
715
446
not_test
716
446
lambdef
717
446
and_expr
718
446
xor_expr
719
446
False
720
446
test
721
446
None
722
446
arglist
943
446
expr
723
446
and_test
724
446
{
725
446
~
726
446
lambda
727
446
comparison
728
446
or_test
729
446
not
730
446
**
731
447
factor
732
447
or_test
733
447
term
734
447
(
735
447
arith_expr
736
447
NAME
737
447
[
738
447
~
739
447
subscriptlist
944
447
+
741
447
maybe_test
742
447
expr
743
447
atom_expr
744
447
atom
745
447
NUMBER
746
447
STRING
747
447
shift_expr
748
447
-
749
447
True
750
447
not_test
751
447
and_expr
752
447
xor_expr
753
447
False
754
447
{
755
447
None
756
447
and_test
757
447
lambda
758
447
power
759
447
subscript
760
447
test
761
447
lambdef
762
447
:
maybe_test -> 
447
comparison
763
447
not
764
448
>
atom_expr -> atom trailer_expr
448
not
atom_expr -> atom trailer_expr
448
//
atom_expr -> atom trailer_expr
448
>>
atom_expr -> atom trailer_expr
448
|
atom_expr -> atom trailer_expr
448
^
atom_expr -> atom trailer_expr
448
/
atom_expr -> atom trailer_expr
448
+
atom_expr -> atom trailer_expr
448
in
atom_expr -> atom trailer_expr
448
%
atom_expr -> atom trailer_expr
448
and
atom_expr -> atom trailer_expr
448
<=
atom_expr -> atom trailer_expr
448
is
atom_expr -> atom trailer_expr
448
<
atom_expr -> atom trailer_expr
448
@
atom_expr -> atom trailer_expr
448
-
atom_expr -> atom trailer_expr
448
&
atom_expr -> atom trailer_expr
448
:
atom_expr -> atom trailer_expr
448
*
atom_expr -> atom trailer_expr
448
**
atom_expr -> atom trailer_expr
448
>=
atom_expr -> atom trailer_expr
448
or
atom_expr -> atom trailer_expr
448
==
atom_expr -> atom trailer_expr
448
!=
atom_expr -> atom trailer_expr
448
if
atom_expr -> atom trailer_expr
448
<<
atom_expr -> atom trailer_expr
449
factor
9
449
arith_expr
2
449
NAME
29
449
term
21
449
[
3
449
~
45
449
atom_expr
24
449
expr
16
449
power
56
449
(
36
449
return
13
449
small_stmt
945
449
flow_stmt
15
449
suite
946
449
True
17
449
not_test
18
449
and_expr
19
449
xor_expr
22
449
{
52
449
lambdef
53
449
atom
54
449
or_test
23
449
shift_expr
50
449
False
35
449
NEWLINE
947
449
-
49
449
None
42
449
lambda
40
449
global
25
449
NUMBER
27
449
STRING
28
449
test
48
449
endsim
33
449
and_test
37
449
simple_stmt
948
449
comparison
39
449
break_stmt
74
449
+
55
449
not
57
449
raise
62
449
return_stmt
75
449
continue
59
449
del_stmt
60
449
test_list
61
449
raise_stmt
63
449
resetstats
64
449
pass_stmt
65
449
nonlocal
66
449
break
76
449
sim_stmt
77
449
stat_stmt
78
449
global_stmt
67
449
yield_stmt
79
449
assert_stmt
80
449
pass
81
449
yield
68
449
continue_stmt
69
449
assert
70
449
nonlocal_stmt
71
449
expr_stmt
72
449
begsim
83
449
del
84
450
factor
85
450
(
86
450
arith_expr
87
450
NAME
88
450
term
89
450
[
90
450
~
91
450
+
92
450
atom_expr
94
450
NUMBER
96
450
atom
95
450
STRING
97
450
shift_expr
99
450
-
100
450
True
101
450
False
104
450
{
105
450
None
106
450
and_expr
949
450
power
108
451
and
factor -> - factor
451
if
factor -> - factor
451
or
factor -> - factor
451
>=
factor -> - factor
451
<
factor -> - factor
451
!=
factor -> - factor
451
-
factor -> - factor
451
==
factor -> - factor
451
@
factor -> - factor
451
|
factor -> - factor
451
*
factor -> - factor
451
%
factor -> - factor
451
+
factor -> - factor
451
<=
factor -> - factor
451
//
factor -> - factor
451
not
factor -> - factor
451
>>
factor -> - factor
451
/
factor -> - factor
451
&
factor -> - factor
451
^
factor -> - factor
451
in
factor -> - factor
451
is
factor -> - factor
451
>
factor -> - factor
451
:
factor -> - factor
451
<<
factor -> - factor
452
factor
85
452
(
86
452
arith_expr
87
452
NAME
88
452
term
89
452
[
90
452
~
91
452
+
92
452
atom_expr
94
452
NUMBER
96
452
atom
95
452
STRING
97
452
shift_expr
99
452
-
100
452
True
101
452
and_expr
102
452
False
104
452
{
105
452
None
106
452
xor_expr
950
452
power
108
453
factor
85
453
(
86
453
arith_expr
87
453
NAME
88
453
term
89
453
[
90
453
~
91
453
+
92
453
atom_expr
94
453
NUMBER
96
453
atom
95
453
STRING
97
453
shift_expr
99
453
-
100
453
True
101
453
and_expr
102
453
xor_expr
103
453
False
104
453
{
105
453
None
106
453
power
108
453
expr
951
454
>
atom -> { }
454
==
atom -> { }
454
-
atom -> { }
454
not
atom -> { }
454
(
atom -> { }
454
@
atom -> { }
454
if
atom -> { }
454
and
atom -> { }
454
:
atom -> { }
454
&
atom -> { }
454
<<
atom -> { }
454
!=
atom -> { }
454
or
atom -> { }
454
>>
atom -> { }
454
<=
atom -> { }
454
>=
atom -> { }
454
is
atom -> { }
454
/
atom -> { }
454
^
atom -> { }
454
[
atom -> { }
454
%
atom -> { }
454
//
atom -> { }
454
*
atom -> { }
454
**
atom -> { }
454
.
atom -> { }
454
in
atom -> { }
454
+
atom -> { }
454
|
atom -> { }
454
<
atom -> { }
455
factor
85
455
(
86
455
arith_expr
87
455
NAME
88
455
term
89
455
[
90
455
~
91
455
+
92
455
expr
93
455
atom_expr
94
455
atom
95
455
NUMBER
96
455
STRING
97
455
shift_expr
99
455
-
100
455
True
101
455
and_expr
102
455
xor_expr
103
455
False
104
455
{
105
455
None
106
455
and_test
107
455
power
108
455
not_test
109
455
comparison
112
455
not
113
455
or_test
952
456
factor
85
456
(
86
456
arith_expr
87
456
NAME
88
456
term
89
456
[
90
456
~
91
456
+
92
456
expr
93
456
atom_expr
94
456
atom
95
456
NUMBER
96
456
STRING
97
456
shift_expr
99
456
-
100
456
True
101
456
and_test
953
456
and_expr
102
456
xor_expr
103
456
False
104
456
{
105
456
None
106
456
power
108
456
not_test
109
456
comparison
112
456
not
113
457
factor
585
457
(
586
457
arith_expr
587
457
NAME
588
457
[
589
457
and_expr
590
457
+
591
457
term
592
457
atom_expr
593
457
NUMBER
594
457
atom
595
457
STRING
596
457
shift_expr
597
457
-
598
457
True
599
457
not
600
457
xor_expr
601
457
None
602
457
False
603
457
not_test
605
457
~
606
457
power
607
457
{
608
457
expr
609
457
comparison
610
457
and_test
611
457
or_test
954
458
:
not_test -> not not_test
458
if
not_test -> not not_test
458
or
not_test -> not not_test
458
and
not_test -> not not_test
459
factor
85
459
(
86
459
arith_expr
87
459
NAME
88
459
term
89
459
[
90
459
~
91
459
+
92
459
expr
93
459
atom_expr
94
459
atom
95
459
NUMBER
96
459
STRING
97
459
shift_expr
99
459
-
100
459
True
101
459
and_expr
102
459
xor_expr
103
459
False
104
459
{
105
459
None
106
459
and_test
107
459
test
955
459
power
108
459
not_test
109
459
lambdef
110
459
or_test
111
459
comparison
112
459
not
113
459
lambda
114
460
:
956
461
,
shift_expr -> arith_expr >> shift_expr
461
|=
shift_expr -> arith_expr >> shift_expr
461
or
shift_expr -> arith_expr >> shift_expr
461
|
shift_expr -> arith_expr >> shift_expr
461
is
shift_expr -> arith_expr >> shift_expr
461
**=
shift_expr -> arith_expr >> shift_expr
461
NEWLINE
shift_expr -> arith_expr >> shift_expr
461
in
shift_expr -> arith_expr >> shift_expr
461
%=
shift_expr -> arith_expr >> shift_expr
461
>
shift_expr -> arith_expr >> shift_expr
461
>=
shift_expr -> arith_expr >> shift_expr
461
>>=
shift_expr -> arith_expr >> shift_expr
461
<=
shift_expr -> arith_expr >> shift_expr
461
!=
shift_expr -> arith_expr >> shift_expr
461
+=
shift_expr -> arith_expr >> shift_expr
461
<<=
shift_expr -> arith_expr >> shift_expr
461
and
shift_expr -> arith_expr >> shift_expr
461
^=
shift_expr -> arith_expr >> shift_expr
461
^
shift_expr -> arith_expr >> shift_expr
461
not
shift_expr -> arith_expr >> shift_expr
461
//=
shift_expr -> arith_expr >> shift_expr
461
&
shift_expr -> arith_expr >> shift_expr
461
&=
shift_expr -> arith_expr >> shift_expr
461
*=
shift_expr -> arith_expr >> shift_expr
461
<
shift_expr -> arith_expr >> shift_expr
461
-=
shift_expr -> arith_expr >> shift_expr
461
:
shift_expr -> arith_expr >> shift_expr
461
/=
shift_expr -> arith_expr >> shift_expr
461
if
shift_expr -> arith_expr >> shift_expr
461
@=
shift_expr -> arith_expr >> shift_expr
461
==
shift_expr -> arith_expr >> shift_expr
461
=
shift_expr -> arith_expr >> shift_expr
462
&=
shift_expr -> arith_expr << shift_expr
462
not
shift_expr -> arith_expr << shift_expr
462
<
shift_expr -> arith_expr << shift_expr
462
in
shift_expr -> arith_expr << shift_expr
462
NEWLINE
shift_expr -> arith_expr << shift_expr
462
|
shift_expr -> arith_expr << shift_expr
462
-=
shift_expr -> arith_expr << shift_expr
462
/=
shift_expr -> arith_expr << shift_expr
462
>
shift_expr -> arith_expr << shift_expr
462
or
shift_expr -> arith_expr << shift_expr
462
^
shift_expr -> arith_expr << shift_expr
462
|=
shift_expr -> arith_expr << shift_expr
462
!=
shift_expr -> arith_expr << shift_expr
462
>=
shift_expr -> arith_expr << shift_expr
462
%=
shift_expr -> arith_expr << shift_expr
462
&
shift_expr -> arith_expr << shift_expr
462
=
shift_expr -> arith_expr << shift_expr
462
*=
shift_expr -> arith_expr << shift_expr
462
>>=
shift_expr -> arith_expr << shift_expr
462
//=
shift_expr -> arith_expr << shift_expr
462
if
shift_expr -> arith_expr << shift_expr
462
**=
shift_expr -> arith_expr << shift_expr
462
is
shift_expr -> arith_expr << shift_expr
462
<=
shift_expr -> arith_expr << shift_expr
462
==
shift_expr -> arith_expr << shift_expr
462
,
shift_expr -> arith_expr << shift_expr
462
and
shift_expr -> arith_expr << shift_expr
462
+=
shift_expr -> arith_expr << shift_expr
462
^=
shift_expr -> arith_expr << shift_expr
462
<<=
shift_expr -> arith_expr << shift_expr
462
:
shift_expr -> arith_expr << shift_expr
462
@=
shift_expr -> arith_expr << shift_expr
463
factor
117
463
(
120
463
NAME
122
463
[
123
463
+
125
463
atom_expr
126
463
NUMBER
127
463
atom
128
463
STRING
129
463
-
131
463
term
957
463
True
133
463
False
138
463
None
139
463
{
142
463
~
143
463
power
145
464
factor
117
464
(
120
464
NAME
122
464
[
123
464
+
125
464
atom_expr
126
464
NUMBER
127
464
atom
128
464
STRING
129
464
-
131
464
True
133
464
False
138
464
None
139
464
term
958
464
{
142
464
~
143
464
power
145
465
factor
117
465
(
120
465
NAME
122
465
term
959
465
[
123
465
+
125
465
atom_expr
126
465
NUMBER
127
465
atom
128
465
STRING
129
465
-
131
465
True
133
465
False
138
465
None
139
465
{
142
465
~
143
465
power
145
466
factor
117
466
(
120
466
NAME
122
466
[
123
466
+
125
466
atom_expr
126
466
NUMBER
127
466
atom
128
466
STRING
129
466
-
131
466
term
960
466
True
133
466
False
138
466
None
139
466
{
142
466
~
143
466
power
145
467
factor
117
467
(
120
467
NAME
122
467
[
123
467
+
125
467
atom_expr
126
467
NUMBER
127
467
atom
128
467
term
961
467
STRING
129
467
-
131
467
True
133
467
False
138
467
None
139
467
{
142
467
~
143
467
power
145
468
factor
585
468
(
586
468
arith_expr
587
468
NAME
588
468
[
589
468
and_expr
590
468
+
591
468
term
592
468
atom_expr
593
468
NUMBER
594
468
atom
595
468
STRING
596
468
shift_expr
597
468
-
598
468
True
599
468
not
600
468
xor_expr
601
468
None
602
468
False
603
468
not_test
605
468
or_test
962
468
~
606
468
power
607
468
{
608
468
expr
609
468
comparison
610
468
and_test
611
469
factor
117
469
term
119
469
(
120
469
NAME
122
469
[
123
469
arith_expr
963
469
+
125
469
atom_expr
126
469
NUMBER
127
469
atom
128
469
STRING
129
469
-
131
469
True
133
469
False
138
469
None
139
469
{
142
469
~
143
469
power
145
470
factor
117
470
term
119
470
(
120
470
NAME
122
470
[
123
470
+
125
470
atom_expr
126
470
NUMBER
127
470
atom
128
470
STRING
129
470
-
131
470
True
133
470
False
138
470
None
139
470
arith_expr
964
470
{
142
470
~
143
470
power
145
471
)
965
472
for
atom -> ( )
472
or
atom -> ( )
472
<<
atom -> ( )
472
not
atom -> ( )
472
&
atom -> ( )
472
(
atom -> ( )
472
in
atom -> ( )
472
**
atom -> ( )
472
@
atom -> ( )
472
<=
atom -> ( )
472
%
atom -> ( )
472
[
atom -> ( )
472
>=
atom -> ( )
472
/
atom -> ( )
472
+
atom -> ( )
472
<
atom -> ( )
472
]
atom -> ( )
472
is
atom -> ( )
472
*
atom -> ( )
472
!=
atom -> ( )
472
-
atom -> ( )
472
|
atom -> ( )
472
//
atom -> ( )
472
^
atom -> ( )
472
and
atom -> ( )
472
==
atom -> ( )
472
if
atom -> ( )
472
>
atom -> ( )
472
,
atom -> ( )
472
.
atom -> ( )
472
>>
atom -> ( )
473
factor
117
473
term
119
473
(
120
473
arith_expr
121
473
NAME
122
473
[
123
473
+
125
473
atom_expr
126
473
NUMBER
127
473
atom
128
473
STRING
129
473
-
131
473
shift_expr
966
473
True
133
473
False
138
473
None
139
473
{
142
473
~
143
473
power
145
474
factor
117
474
term
119
474
(
120
474
arith_expr
121
474
NAME
122
474
[
123
474
+
125
474
atom_expr
126
474
NUMBER
127
474
atom
128
474
STRING
129
474
-
131
474
shift_expr
967
474
True
133
474
False
138
474
None
139
474
{
142
474
~
143
474
power
145
475
<=
atom -> [ ]
475
is
atom -> [ ]
475
-
atom -> [ ]
475
]
atom -> [ ]
475
**
atom -> [ ]
475
^
atom -> [ ]
475
%
atom -> [ ]
475
/
atom -> [ ]
475
>=
atom -> [ ]
475
|
atom -> [ ]
475
not
atom -> [ ]
475
@
atom -> [ ]
475
*
atom -> [ ]
475
(
atom -> [ ]
475
,
atom -> [ ]
475
>>
atom -> [ ]
475
[
atom -> [ ]
475
or
atom -> [ ]
475
!=
atom -> [ ]
475
and
atom -> [ ]
475
<<
atom -> [ ]
475
if
atom -> [ ]
475
in
atom -> [ ]
475
+
atom -> [ ]
475
.
atom -> [ ]
475
==
atom -> [ ]
475
>
atom -> [ ]
475
<
atom -> [ ]
475
for
atom -> [ ]
475
&
atom -> [ ]
475
//
atom -> [ ]
476
]
968
477
<
factor -> + factor
477
if
factor -> + factor
477
<<
factor -> + factor
477
]
factor -> + factor
477
and
factor -> + factor
477
>=
factor -> + factor
477
%
factor -> + factor
477
>>
factor -> + factor
477
*
factor -> + factor
477
+
factor -> + factor
477
/
factor -> + factor
477
>
factor -> + factor
477
<=
factor -> + factor
477
^
factor -> + factor
477
is
factor -> + factor
477
|
factor -> + factor
477
or
factor -> + factor
477
-
factor -> + factor
477
in
factor -> + factor
477
for
factor -> + factor
477
&
factor -> + factor
477
not
factor -> + factor
477
//
factor -> + factor
477
,
factor -> + factor
477
!=
factor -> + factor
477
==
factor -> + factor
477
@
factor -> + factor
478
(
120
478
NAME
122
478
[
123
478
+
125
478
atom_expr
126
478
NUMBER
127
478
atom
128
478
STRING
129
478
-
131
478
factor
969
478
True
133
478
False
138
478
None
139
478
{
142
478
~
143
478
power
145
479
trailer_expr
970
479
trailer
479
479
.
480
479
(
481
479
[
482
479
<<
trailer_expr -> 
479
%
trailer_expr -> 
479
==
trailer_expr -> 
479
-
trailer_expr -> 
479
<
trailer_expr -> 
479
if
trailer_expr -> 
479
or
trailer_expr -> 
479
/
trailer_expr -> 
479
**
trailer_expr -> 
479
and
trailer_expr -> 
479
@
trailer_expr -> 
479
*
trailer_expr -> 
479
|
trailer_expr -> 
479
is
trailer_expr -> 
479
,
trailer_expr -> 
479
+
trailer_expr -> 
479
in
trailer_expr -> 
479
for
trailer_expr -> 
479
&
trailer_expr -> 
479
<=
trailer_expr -> 
479
>=
trailer_expr -> 
479
^
trailer_expr -> 
479
>
trailer_expr -> 
479
!=
trailer_expr -> 
479
not
trailer_expr -> 
479
>>
trailer_expr -> 
479
//
trailer_expr -> 
479
]
trailer_expr -> 
480
NAME
971
481
factor
697
481
term
698
481
(
699
481
arith_expr
700
481
NAME
701
481
[
702
481
atom
703
481
+
704
481
power
706
481
atom_expr
707
481
NUMBER
708
481
STRING
709
481
*
710
481
shift_expr
711
481
-
712
481
argument
714
481
)
972
481
True
715
481
not_test
716
481
lambdef
717
481
and_expr
718
481
xor_expr
719
481
False
720
481
test
721
481
None
722
481
arglist
973
481
expr
723
481
and_test
724
481
{
725
481
~
726
481
lambda
727
481
comparison
728
481
or_test
729
481
not
730
481
**
731
482
factor
732
482
or_test
733
482
term
734
482
(
735
482
arith_expr
736
482
NAME
737
482
[
738
482
~
739
482
subscriptlist
974
482
+
741
482
maybe_test
742
482
expr
743
482
atom_expr
744
482
atom
745
482
NUMBER
746
482
STRING
747
482
shift_expr
748
482
-
749
482
True
750
482
not_test
751
482
and_expr
752
482
xor_expr
753
482
False
754
482
{
755
482
None
756
482
and_test
757
482
lambda
758
482
power
759
482
subscript
760
482
test
761
482
lambdef
762
482
:
maybe_test -> 
482
comparison
763
482
not
764
483
>
atom_expr -> atom trailer_expr
483
not
atom_expr -> atom trailer_expr
483
//
atom_expr -> atom trailer_expr
483
>>
atom_expr -> atom trailer_expr
483
|
atom_expr -> atom trailer_expr
483
^
atom_expr -> atom trailer_expr
483
/
atom_expr -> atom trailer_expr
483
+
atom_expr -> atom trailer_expr
483
in
atom_expr -> atom trailer_expr
483
%
atom_expr -> atom trailer_expr
483
and
atom_expr -> atom trailer_expr
483
<=
atom_expr -> atom trailer_expr
483
is
atom_expr -> atom trailer_expr
483
<
atom_expr -> atom trailer_expr
483
@
atom_expr -> atom trailer_expr
483
-
atom_expr -> atom trailer_expr
483
]
atom_expr -> atom trailer_expr
483
&
atom_expr -> atom trailer_expr
483
*
atom_expr -> atom trailer_expr
483
**
atom_expr -> atom trailer_expr
483
>=
atom_expr -> atom trailer_expr
483
for
atom_expr -> atom trailer_expr
483
or
atom_expr -> atom trailer_expr
483
,
atom_expr -> atom trailer_expr
483
==
atom_expr -> atom trailer_expr
483
!=
atom_expr -> atom trailer_expr
483
if
atom_expr -> atom trailer_expr
483
<<
atom_expr -> atom trailer_expr
484
factor
117
484
term
119
484
(
120
484
arith_expr
121
484
NAME
122
484
[
123
484
+
125
484
atom_expr
126
484
NUMBER
127
484
atom
128
484
STRING
129
484
shift_expr
130
484
-
131
484
True
133
484
False
138
484
None
139
484
and_expr
975
484
{
142
484
~
143
484
power
145
485
for
factor -> - factor
485
and
factor -> - factor
485
if
factor -> - factor
485
or
factor -> - factor
485
>=
factor -> - factor
485
<
factor -> - factor
485
!=
factor -> - factor
485
-
factor -> - factor
485
==
factor -> - factor
485
]
factor -> - factor
485
@
factor -> - factor
485
|
factor -> - factor
485
*
factor -> - factor
485
%
factor -> - factor
485
+
factor -> - factor
485
<=
factor -> - factor
485
//
factor -> - factor
485
not
factor -> - factor
485
>>
factor -> - factor
485
/
factor -> - factor
485
&
factor -> - factor
485
^
factor -> - factor
485
in
factor -> - factor
485
is
factor -> - factor
485
>
factor -> - factor
485
,
factor -> - factor
485
<<
factor -> - factor
486
in
atom -> [ test_list_comp ]
486
/
atom -> [ test_list_comp ]
486
or
atom -> [ test_list_comp ]
486
//=
atom -> [ test_list_comp ]
486
<<
atom -> [ test_list_comp ]
486
!=
atom -> [ test_list_comp ]
486
=
atom -> [ test_list_comp ]
486
<=
atom -> [ test_list_comp ]
486
%=
atom -> [ test_list_comp ]
486
if
atom -> [ test_list_comp ]
486
>>
atom -> [ test_list_comp ]
486
*
atom -> [ test_list_comp ]
486
*=
atom -> [ test_list_comp ]
486
|=
atom -> [ test_list_comp ]
486
^
atom -> [ test_list_comp ]
486
&=
atom -> [ test_list_comp ]
486
+=
atom -> [ test_list_comp ]
486
>>=
atom -> [ test_list_comp ]
486
.
atom -> [ test_list_comp ]
486
(
atom -> [ test_list_comp ]
486
>=
atom -> [ test_list_comp ]
486
and
atom -> [ test_list_comp ]
486
**=
atom -> [ test_list_comp ]
486
<
atom -> [ test_list_comp ]
486
,
atom -> [ test_list_comp ]
486
/=
atom -> [ test_list_comp ]
486
[
atom -> [ test_list_comp ]
486
==
atom -> [ test_list_comp ]
486
@
atom -> [ test_list_comp ]
486
%
atom -> [ test_list_comp ]
486
|
atom -> [ test_list_comp ]
486
-
atom -> [ test_list_comp ]
486
&
atom -> [ test_list_comp ]
486
:
atom -> [ test_list_comp ]
486
^=
atom -> [ test_list_comp ]
486
+
atom -> [ test_list_comp ]
486
@=
atom -> [ test_list_comp ]
486
is
atom -> [ test_list_comp ]
486
//
atom -> [ test_list_comp ]
486
-=
atom -> [ test_list_comp ]
486
<<=
atom -> [ test_list_comp ]
486
**
atom -> [ test_list_comp ]
486
not
atom -> [ test_list_comp ]
486
NEWLINE
atom -> [ test_list_comp ]
486
>
atom -> [ test_list_comp ]
487
factor
117
487
term
119
487
(
120
487
arith_expr
121
487
NAME
122
487
[
123
487
+
125
487
atom_expr
126
487
NUMBER
127
487
atom
128
487
STRING
129
487
shift_expr
130
487
-
131
487
True
133
487
not_test
134
487
and_expr
136
487
xor_expr
137
487
False
138
487
None
139
487
expr
140
487
{
142
487
~
143
487
and_test
976
487
power
145
487
comparison
146
487
not
149
488
factor
117
488
term
119
488
(
120
488
arith_expr
121
488
NAME
122
488
[
123
488
+
125
488
atom_expr
126
488
NUMBER
127
488
atom
128
488
STRING
129
488
shift_expr
130
488
-
131
488
True
133
488
and_expr
136
488
False
138
488
None
139
488
xor_expr
977
488
{
142
488
~
143
488
power
145
489
factor
117
489
term
119
489
(
120
489
arith_expr
121
489
NAME
122
489
[
123
489
+
125
489
atom_expr
126
489
NUMBER
127
489
atom
128
489
STRING
129
489
shift_expr
130
489
-
131
489
True
133
489
and_expr
136
489
xor_expr
137
489
False
138
489
None
139
489
{
142
489
~
143
489
power
145
489
expr
978
490
factor
117
490
term
119
490
(
120
490
arith_expr
121
490
NAME
122
490
[
123
490
+
125
490
atom_expr
126
490
NUMBER
127
490
atom
128
490
STRING
129
490
shift_expr
130
490
-
131
490
True
133
490
and_expr
136
490
comparison
979
490
xor_expr
137
490
False
138
490
None
139
490
expr
140
490
{
142
490
~
143
490
power
145
491
factor
117
491
term
119
491
(
120
491
arith_expr
121
491
NAME
122
491
[
123
491
+
125
491
atom_expr
126
491
NUMBER
127
491
atom
128
491
STRING
129
491
shift_expr
130
491
-
131
491
True
133
491
not_test
134
491
and_expr
136
491
xor_expr
137
491
False
138
491
None
139
491
expr
140
491
and_test
141
491
{
142
491
~
143
491
power
145
491
comparison
146
491
or_test
980
491
not
149
492
>
atom -> { }
492
==
atom -> { }
492
-
atom -> { }
492
]
atom -> { }
492
not
atom -> { }
492
(
atom -> { }
492
@
atom -> { }
492
if
atom -> { }
492
and
atom -> { }
492
,
atom -> { }
492
&
atom -> { }
492
<<
atom -> { }
492
!=
atom -> { }
492
or
atom -> { }
492
>>
atom -> { }
492
<=
atom -> { }
492
>=
atom -> { }
492
is
atom -> { }
492
/
atom -> { }
492
^
atom -> { }
492
[
atom -> { }
492
%
atom -> { }
492
//
atom -> { }
492
*
atom -> { }
492
**
atom -> { }
492
.
atom -> { }
492
for
atom -> { }
492
in
atom -> { }
492
+
atom -> { }
492
|
atom -> { }
492
<
atom -> { }
493
or
factor -> ~ factor
493
==
factor -> ~ factor
493
<=
factor -> ~ factor
493
@
factor -> ~ factor
493
!=
factor -> ~ factor
493
>=
factor -> ~ factor
493
>
factor -> ~ factor
493
and
factor -> ~ factor
493
,
factor -> ~ factor
493
*
factor -> ~ factor
493
&
factor -> ~ factor
493
%
factor -> ~ factor
493
<
factor -> ~ factor
493
//
factor -> ~ factor
493
if
factor -> ~ factor
493
^
factor -> ~ factor
493
/
factor -> ~ factor
493
for
factor -> ~ factor
493
in
factor -> ~ factor
493
+
factor -> ~ factor
493
not
factor -> ~ factor
493
-
factor -> ~ factor
493
is
factor -> ~ factor
493
>>
factor -> ~ factor
493
<<
factor -> ~ factor
493
]
factor -> ~ factor
493
|
factor -> ~ factor
494
factor
117
494
or_test
118
494
term
119
494
(
120
494
arith_expr
121
494
NAME
122
494
[
123
494
+
125
494
atom_expr
126
494
NUMBER
127
494
atom
128
494
STRING
129
494
shift_expr
130
494
-
131
494
True
133
494
not_test
134
494
lambdef
135
494
and_expr
136
494
xor_expr
137
494
False
138
494
None
139
494
expr
140
494
and_test
141
494
{
142
494
~
143
494
lambda
144
494
power
145
494
comparison
146
494
test
981
494
not
149
495
:
982
496
]
test_list_comp -> test comp_for
497
factor
152
497
NUMBER
153
497
term
155
497
(
156
497
True
157
497
[
158
497
+
159
497
STRING
160
497
atom_expr
161
497
arith_expr
162
497
expr
163
497
~
164
497
NAME
165
497
False
166
497
{
167
497
and_expr
168
497
xor_expr
169
497
None
170
497
power
171
497
-
172
497
shift_expr
173
497
atom
174
497
expr_list
983
498
factor
984
498
or_test
985
498
term
986
498
(
987
498
arith_expr
988
498
NAME
989
498
test_list
990
498
[
991
498
+
992
498
atom_expr
993
498
NUMBER
994
498
atom
995
498
STRING
996
498
shift_expr
997
498
-
998
498
True
999
498
not_test
1000
498
and_expr
1001
498
xor_expr
1002
498
None
1003
498
False
1004
498
and_test
1005
498
{
1006
498
~
1007
498
lambda
1008
498
power
1009
498
expr
1010
498
lambdef
1011
498
test
1012
498
not
1013
498
comparison
1014
499
]
not_test -> not not_test
499
or
not_test -> not not_test
499
,
not_test -> not not_test
499
and
not_test -> not not_test
499
if
not_test -> not not_test
499
for
not_test -> not not_test
500
except_clause
1015
500
except
1016
501
NEWLINE
1017
502
INDENT
1018
503
except
suite -> simple_stmt
504
factor
697
504
term
698
504
(
699
504
arith_expr
700
504
NAME
701
504
[
702
504
atom
703
504
arglist
1019
504
+
704
504
power
706
504
atom_expr
707
504
NUMBER
708
504
STRING
709
504
*
710
504
shift_expr
711
504
-
712
504
argument
714
504
True
715
504
not_test
716
504
lambdef
717
504
and_expr
718
504
)
1020
504
xor_expr
719
504
False
720
504
test
721
504
None
722
504
expr
723
504
and_test
724
504
{
725
504
~
726
504
lambda
727
504
comparison
728
504
or_test
729
504
not
730
504
**
731
505
factor
9
505
arith_expr
2
505
NAME
29
505
term
21
505
[
3
505
~
45
505
atom_expr
24
505
expr
16
505
power
56
505
(
36
505
return
13
505
small_stmt
47
505
flow_stmt
15
505
True
17
505
not_test
18
505
and_expr
19
505
xor_expr
22
505
{
52
505
lambdef
53
505
atom
54
505
suite
1021
505
or_test
23
505
shift_expr
50
505
False
35
505
NEWLINE
1022
505
-
49
505
None
42
505
lambda
40
505
global
25
505
NUMBER
27
505
STRING
28
505
test
48
505
endsim
33
505
and_test
37
505
simple_stmt
1023
505
comparison
39
505
break_stmt
74
505
+
55
505
not
57
505
raise
62
505
continue
59
505
return_stmt
75
505
del_stmt
60
505
test_list
61
505
raise_stmt
63
505
resetstats
64
505
pass_stmt
65
505
nonlocal
66
505
break
76
505
sim_stmt
77
505
stat_stmt
78
505
global_stmt
67
505
yield_stmt
79
505
assert_stmt
80
505
pass
81
505
yield
68
505
continue_stmt
69
505
assert
70
505
nonlocal_stmt
71
505
expr_stmt
72
505
begsim
83
505
del
84
506
factor
152
506
NUMBER
153
506
(
156
506
True
157
506
[
158
506
+
159
506
STRING
160
506
atom_expr
161
506
~
164
506
NAME
165
506
False
166
506
{
167
506
term
1024
506
None
170
506
power
171
506
-
172
506
atom
174
507
factor
152
507
NUMBER
153
507
(
156
507
True
157
507
[
158
507
+
159
507
STRING
160
507
atom_expr
161
507
~
164
507
NAME
165
507
term
1025
507
False
166
507
{
167
507
None
170
507
power
171
507
-
172
507
atom
174
508
factor
152
508
NUMBER
153
508
(
156
508
term
1026
508
True
157
508
[
158
508
+
159
508
STRING
160
508
atom_expr
161
508
~
164
508
NAME
165
508
False
166
508
{
167
508
None
170
508
power
171
508
-
172
508
atom
174
509
factor
152
509
NUMBER
153
509
(
156
509
True
157
509
[
158
509
+
159
509
STRING
160
509
atom_expr
161
509
~
164
509
NAME
165
509
False
166
509
{
167
509
term
1027
509
None
170
509
power
171
509
-
172
509
atom
174
510
factor
152
510
NUMBER
153
510
(
156
510
True
157
510
[
158
510
+
159
510
STRING
160
510
atom_expr
161
510
~
164
510
NAME
165
510
False
166
510
{
167
510
None
170
510
term
1028
510
power
171
510
-
172
510
atom
174
511
factor
1029
511
test_list
1030
511
term
1031
511
(
1032
511
arith_expr
1033
511
NAME
1034
511
[
1035
511
~
1036
511
+
1037
511
expr
1038
511
atom_expr
1039
511
atom
1040
511
NUMBER
1041
511
STRING
1042
511
shift_expr
1043
511
-
1044
511
True
1045
511
not_test
1046
511
and_expr
1047
511
xor_expr
1048
511
False
1049
511
{
1050
511
None
1051
511
test
1052
511
and_test
1053
511
power
1054
511
lambda
1055
511
or_test
1056
511
lambdef
1057
511
comparison
1058
511
not
1059
512
factor
152
512
NUMBER
153
512
term
155
512
(
156
512
True
157
512
[
158
512
+
159
512
STRING
160
512
atom_expr
161
512
arith_expr
1060
512
~
164
512
NAME
165
512
False
166
512
{
167
512
None
170
512
power
171
512
-
172
512
atom
174
513
factor
152
513
NUMBER
153
513
term
155
513
(
156
513
True
157
513
[
158
513
+
159
513
STRING
160
513
atom_expr
161
513
~
164
513
arith_expr
1061
513
NAME
165
513
False
166
513
{
167
513
None
170
513
power
171
513
-
172
513
atom
174
514
)
1062
515
@
atom -> ( )
515
.
atom -> ( )
515
|
atom -> ( )
515
%
atom -> ( )
515
[
atom -> ( )
515
(
atom -> ( )
515
//
atom -> ( )
515
^
atom -> ( )
515
**
atom -> ( )
515
<<
atom -> ( )
515
,
atom -> ( )
515
/
atom -> ( )
515
*
atom -> ( )
515
+
atom -> ( )
515
&
atom -> ( )
515
in
atom -> ( )
515
-
atom -> ( )
515
>>
atom -> ( )
516
^
atom -> [ ]
516
%
atom -> [ ]
516
/
atom -> [ ]
516
in
atom -> [ ]
516
|
atom -> [ ]
516
+
atom -> [ ]
516
.
atom -> [ ]
516
@
atom -> [ ]
516
*
atom -> [ ]
516
-
atom -> [ ]
516
(
atom -> [ ]
516
<<
atom -> [ ]
516
>>
atom -> [ ]
516
[
atom -> [ ]
516
,
atom -> [ ]
516
**
atom -> [ ]
516
&
atom -> [ ]
516
//
atom -> [ ]
517
]
1063
518
%
factor -> + factor
518
+
factor -> + factor
518
>>
factor -> + factor
518
*
factor -> + factor
518
|
factor -> + factor
518
<<
factor -> + factor
518
-
factor -> + factor
518
in
factor -> + factor
518
/
factor -> + factor
518
&
factor -> + factor
518
,
factor -> + factor
518
^
factor -> + factor
518
@
factor -> + factor
518
//
factor -> + factor
519
NUMBER
153
519
(
156
519
True
157
519
[
158
519
factor
1064
519
+
159
519
STRING
160
519
atom_expr
161
519
~
164
519
NAME
165
519
False
166
519
{
167
519
None
170
519
power
171
519
-
172
519
atom
174
520
factor
152
520
NUMBER
153
520
term
155
520
(
156
520
True
157
520
[
158
520
+
159
520
STRING
160
520
atom_expr
161
520
arith_expr
162
520
~
164
520
NAME
165
520
False
166
520
{
167
520
None
170
520
power
171
520
shift_expr
1065
520
-
172
520
atom
174
521
factor
152
521
NUMBER
153
521
term
155
521
(
156
521
True
157
521
[
158
521
+
159
521
STRING
160
521
atom_expr
161
521
arith_expr
162
521
~
164
521
NAME
165
521
False
166
521
{
167
521
None
170
521
power
171
521
-
172
521
shift_expr
1066
521
atom
174
522
factor
152
522
NUMBER
153
522
term
155
522
(
156
522
True
157
522
[
158
522
+
159
522
STRING
160
522
atom_expr
161
522
arith_expr
162
522
expr
163
522
~
164
522
NAME
165
522
False
166
522
{
167
522
and_expr
168
522
xor_expr
169
522
None
170
522
power
171
522
-
172
522
shift_expr
173
522
atom
174
522
expr_list
1067
523
-
factor -> ~ factor
523
,
factor -> ~ factor
523
*
factor -> ~ factor
523
@
factor -> ~ factor
523
^
factor -> ~ factor
523
/
factor -> ~ factor
523
&
factor -> ~ factor
523
%
factor -> ~ factor
523
in
factor -> ~ factor
523
>>
factor -> ~ factor
523
+
factor -> ~ factor
523
<<
factor -> ~ factor
523
|
factor -> ~ factor
523
//
factor -> ~ factor
524
**
atom -> { }
524
[
atom -> { }
524
<<
atom -> { }
524
%
atom -> { }
524
//
atom -> { }
524
-
atom -> { }
524
.
atom -> { }
524
^
atom -> { }
524
>>
atom -> { }
524
(
atom -> { }
524
in
atom -> { }
524
@
atom -> { }
524
*
atom -> { }
524
+
atom -> { }
524
,
atom -> { }
524
|
atom -> { }
524
/
atom -> { }
524
&
atom -> { }
525
factor
152
525
NUMBER
153
525
term
155
525
(
156
525
True
157
525
[
158
525
+
159
525
STRING
160
525
atom_expr
161
525
arith_expr
162
525
xor_expr
1068
525
~
164
525
NAME
165
525
False
166
525
{
167
525
and_expr
168
525
None
170
525
power
171
525
-
172
525
shift_expr
173
525
atom
174
526
factor
152
526
NUMBER
153
526
term
155
526
(
156
526
True
157
526
[
158
526
+
159
526
STRING
160
526
atom_expr
161
526
arith_expr
162
526
~
164
526
NAME
165
526
False
166
526
{
167
526
and_expr
168
526
xor_expr
169
526
None
170
526
power
171
526
-
172
526
shift_expr
173
526
atom
174
526
expr
1069
527
%
factor -> - factor
527
&
factor -> - factor
527
*
factor -> - factor
527
^
factor -> - factor
527
+
factor -> - factor
527
-
factor -> - factor
527
in
factor -> - factor
527
//
factor -> - factor
527
,
factor -> - factor
527
@
factor -> - factor
527
|
factor -> - factor
527
<<
factor -> - factor
527
>>
factor -> - factor
527
/
factor -> - factor
528
factor
152
528
NUMBER
153
528
term
155
528
(
156
528
True
157
528
[
158
528
+
159
528
STRING
160
528
atom_expr
161
528
arith_expr
162
528
~
164
528
and_expr
1070
528
NAME
165
528
False
166
528
{
167
528
None
170
528
power
171
528
-
172
528
shift_expr
173
528
atom
174
529
@
atom_expr -> atom trailer_expr
529
,
atom_expr -> atom trailer_expr
529
-
atom_expr -> atom trailer_expr
529
<<
atom_expr -> atom trailer_expr
529
+
atom_expr -> atom trailer_expr
529
/
atom_expr -> atom trailer_expr
529
&
atom_expr -> atom trailer_expr
529
in
atom_expr -> atom trailer_expr
529
%
atom_expr -> atom trailer_expr
529
*
atom_expr -> atom trailer_expr
529
^
atom_expr -> atom trailer_expr
529
//
atom_expr -> atom trailer_expr
529
**
atom_expr -> atom trailer_expr
529
>>
atom_expr -> atom trailer_expr
529
|
atom_expr -> atom trailer_expr
530
trailer_expr
1071
530
trailer
530
530
(
531
530
.
532
530
[
533
530
<<
trailer_expr -> 
530
,
trailer_expr -> 
530
+
trailer_expr -> 
530
%
trailer_expr -> 
530
in
trailer_expr -> 
530
&
trailer_expr -> 
530
-
trailer_expr -> 
530
^
trailer_expr -> 
530
/
trailer_expr -> 
530
>>
trailer_expr -> 
530
//
trailer_expr -> 
530
**
trailer_expr -> 
530
@
trailer_expr -> 
530
*
trailer_expr -> 
530
|
trailer_expr -> 
531
factor
697
531
term
698
531
(
699
531
arith_expr
700
531
NAME
701
531
[
702
531
atom
703
531
+
704
531
power
706
531
atom_expr
707
531
NUMBER
708
531
STRING
709
531
*
710
531
shift_expr
711
531
-
712
531
argument
714
531
)
1072
531
True
715
531
not_test
716
531
lambdef
717
531
and_expr
718
531
xor_expr
719
531
False
720
531
test
721
531
None
722
531
arglist
1073
531
expr
723
531
and_test
724
531
{
725
531
~
726
531
lambda
727
531
comparison
728
531
or_test
729
531
not
730
531
**
731
532
NAME
1074
533
factor
732
533
or_test
733
533
term
734
533
(
735
533
arith_expr
736
533
NAME
737
533
[
738
533
~
739
533
subscriptlist
1075
533
+
741
533
maybe_test
742
533
expr
743
533
atom_expr
744
533
atom
745
533
NUMBER
746
533
STRING
747
533
shift_expr
748
533
-
749
533
True
750
533
not_test
751
533
and_expr
752
533
xor_expr
753
533
False
754
533
{
755
533
None
756
533
and_test
757
533
lambda
758
533
power
759
533
subscript
760
533
test
761
533
lambdef
762
533
:
maybe_test -> 
533
comparison
763
533
not
764
534
and
term -> factor // term
534
&=
term -> factor // term
534
if
term -> factor // term
534
>
term -> factor // term
534
<
term -> factor // term
534
/=
term -> factor // term
534
**=
term -> factor // term
534
-=
term -> factor // term
534
==
term -> factor // term
534
+
term -> factor // term
534
+=
term -> factor // term
534
-
term -> factor // term
534
in
term -> factor // term
534
&
term -> factor // term
534
:
term -> factor // term
534
*=
term -> factor // term
534
!=
term -> factor // term
534
^
term -> factor // term
534
,
term -> factor // term
534
=
term -> factor // term
534
^=
term -> factor // term
534
or
term -> factor // term
534
@=
term -> factor // term
534
NEWLINE
term -> factor // term
534
|=
term -> factor // term
534
<=
term -> factor // term
534
>=
term -> factor // term
534
<<=
term -> factor // term
534
|
term -> factor // term
534
//=
term -> factor // term
534
%=
term -> factor // term
534
>>
term -> factor // term
534
not
term -> factor // term
534
is
term -> factor // term
534
<<
term -> factor // term
534
>>=
term -> factor // term
535
or
term -> factor / term
535
<<
term -> factor / term
535
@=
term -> factor / term
535
<<=
term -> factor / term
535
%=
term -> factor / term
535
not
term -> factor / term
535
in
term -> factor / term
535
**=
term -> factor / term
535
|=
term -> factor / term
535
!=
term -> factor / term
535
<
term -> factor / term
535
,
term -> factor / term
535
-=
term -> factor / term
535
>>=
term -> factor / term
535
>>
term -> factor / term
535
and
term -> factor / term
535
^
term -> factor / term
535
==
term -> factor / term
535
<=
term -> factor / term
535
+
term -> factor / term
535
>
term -> factor / term
535
*=
term -> factor / term
535
^=
term -> factor / term
535
&
term -> factor / term
535
is
term -> factor / term
535
-
term -> factor / term
535
NEWLINE
term -> factor / term
535
:
term -> factor / term
535
//=
term -> factor / term
535
&=
term -> factor / term
535
|
term -> factor / term
535
+=
term -> factor / term
535
>=
term -> factor / term
535
/=
term -> factor / term
535
if
term -> factor / term
535
=
term -> factor / term
536
&
term -> factor % term
536
%=
term -> factor % term
536
@=
term -> factor % term
536
==
term -> factor % term
536
/=
term -> factor % term
536
**=
term -> factor % term
536
!=
term -> factor % term
536
//=
term -> factor % term
536
-=
term -> factor % term
536
<<=
term -> factor % term
536
|=
term -> factor % term
536
<
term -> factor % term
536
in
term -> factor % term
536
+=
term -> factor % term
536
=
term -> factor % term
536
>>
term -> factor % term
536
<<
term -> factor % term
536
NEWLINE
term -> factor % term
536
-
term -> factor % term
536
if
term -> factor % term
536
>
term -> factor % term
536
or
term -> factor % term
536
^
term -> factor % term
536
+
term -> factor % term
536
,
term -> factor % term
536
>>=
term -> factor % term
536
*=
term -> factor % term
536
is
term -> factor % term
536
|
term -> factor % term
536
>=
term -> factor % term
536
<=
term -> factor % term
536
and
term -> factor % term
536
not
term -> factor % term
536
&=
term -> factor % term
536
^=
term -> factor % term
536
:
term -> factor % term
537
and
term -> factor @ term
537
in
term -> factor @ term
537
>=
term -> factor @ term
537
@=
term -> factor @ term
537
<
term -> factor @ term
537
&=
term -> factor @ term
537
:
term -> factor @ term
537
+=
term -> factor @ term
537
*=
term -> factor @ term
537
,
term -> factor @ term
537
if
term -> factor @ term
537
>
term -> factor @ term
537
-
term -> factor @ term
537
^=
term -> factor @ term
537
>>=
term -> factor @ term
537
or
term -> factor @ term
537
NEWLINE
term -> factor @ term
537
<<
term -> factor @ term
537
|=
term -> factor @ term
537
<<=
term -> factor @ term
537
//=
term -> factor @ term
537
%=
term -> factor @ term
537
is
term -> factor @ term
537
!=
term -> factor @ term
537
|
term -> factor @ term
537
&
term -> factor @ term
537
-=
term -> factor @ term
537
==
term -> factor @ term
537
>>
term -> factor @ term
537
<=
term -> factor @ term
537
not
term -> factor @ term
537
+
term -> factor @ term
537
**=
term -> factor @ term
537
^
term -> factor @ term
537
=
term -> factor @ term
537
/=
term -> factor @ term
538
^
term -> factor * term
538
+
term -> factor * term
538
==
term -> factor * term
538
@=
term -> factor * term
538
*=
term -> factor * term
538
>>
term -> factor * term
538
**=
term -> factor * term
538
in
term -> factor * term
538
and
term -> factor * term
538
if
term -> factor * term
538
&=
term -> factor * term
538
>>=
term -> factor * term
538
is
term -> factor * term
538
|=
term -> factor * term
538
<<=
term -> factor * term
538
<<
term -> factor * term
538
+=
term -> factor * term
538
:
term -> factor * term
538
,
term -> factor * term
538
//=
term -> factor * term
538
-
term -> factor * term
538
!=
term -> factor * term
538
or
term -> factor * term
538
^=
term -> factor * term
538
>
term -> factor * term
538
&
term -> factor * term
538
/=
term -> factor * term
538
|
term -> factor * term
538
>=
term -> factor * term
538
NEWLINE
term -> factor * term
538
<=
term -> factor * term
538
not
term -> factor * term
538
=
term -> factor * term
538
<
term -> factor * term
538
-=
term -> factor * term
538
%=
term -> factor * term
539
factor
697
539
term
698
539
(
699
539
arith_expr
700
539
NAME
701
539
[
702
539
atom
703
539
+
704
539
power
706
539
atom_expr
707
539
NUMBER
708
539
STRING
709
539
*
710
539
shift_expr
711
539
-
712
539
)
1076
539
argument
714
539
True
715
539
not_test
716
539
lambdef
717
539
and_expr
718
539
xor_expr
719
539
False
720
539
test
721
539
None
722
539
expr
723
539
and_test
724
539
{
725
539
~
726
539
arglist
1077
539
lambda
727
539
comparison
728
539
or_test
729
539
not
730
539
**
731
540
@
decorator -> @ dotted_name NEWLINE
540
def
decorator -> @ dotted_name NEWLINE
540
class
decorator -> @ dotted_name NEWLINE
541
dotted_name
1078
541
NAME
181
542
factor
184
542
(
186
542
NAME
188
542
[
189
542
+
190
542
atom_expr
191
542
NUMBER
193
542
atom
192
542
STRING
194
542
-
196
542
term
1079
542
True
197
542
None
201
542
False
203
542
{
206
542
~
207
542
power
208
543
factor
184
543
(
186
543
NAME
188
543
[
189
543
+
190
543
atom_expr
191
543
NUMBER
193
543
atom
192
543
STRING
194
543
-
196
543
True
197
543
None
201
543
term
1080
543
False
203
543
{
206
543
~
207
543
power
208
544
factor
184
544
(
186
544
NAME
188
544
term
1081
544
[
189
544
+
190
544
atom_expr
191
544
NUMBER
193
544
atom
192
544
STRING
194
544
-
196
544
True
197
544
None
201
544
False
203
544
{
206
544
~
207
544
power
208
545
factor
184
545
(
186
545
NAME
188
545
[
189
545
+
190
545
atom_expr
191
545
NUMBER
193
545
atom
192
545
STRING
194
545
-
196
545
term
1082
545
True
197
545
None
201
545
False
203
545
{
206
545
~
207
545
power
208
546
factor
184
546
(
186
546
NAME
188
546
[
189
546
+
190
546
atom_expr
191
546
NUMBER
193
546
atom
192
546
term
1083
546
STRING
194
546
-
196
546
True
197
546
None
201
546
False
203
546
{
206
546
~
207
546
power
208
547
factor
184
547
term
185
547
(
186
547
NAME
188
547
[
189
547
+
190
547
atom_expr
191
547
NUMBER
193
547
atom
192
547
STRING
194
547
-
196
547
True
197
547
arith_expr
1084
547
None
201
547
False
203
547
{
206
547
~
207
547
power
208
548
factor
184
548
term
185
548
(
186
548
NAME
188
548
[
189
548
+
190
548
atom_expr
191
548
NUMBER
193
548
atom
192
548
STRING
194
548
-
196
548
True
197
548
None
201
548
False
203
548
arith_expr
1085
548
{
206
548
~
207
548
power
208
549
)
1086
550
or
atom -> ( )
550
<<
atom -> ( )
550
NEWLINE
atom -> ( )
550
not
atom -> ( )
550
&
atom -> ( )
550
(
atom -> ( )
550
in
atom -> ( )
550
**
atom -> ( )
550
@
atom -> ( )
550
<=
atom -> ( )
550
%
atom -> ( )
550
[
atom -> ( )
550
>=
atom -> ( )
550
/
atom -> ( )
550
+
atom -> ( )
550
<
atom -> ( )
550
is
atom -> ( )
550
*
atom -> ( )
550
!=
atom -> ( )
550
-
atom -> ( )
550
|
atom -> ( )
550
//
atom -> ( )
550
^
atom -> ( )
550
and
atom -> ( )
550
==
atom -> ( )
550
if
atom -> ( )
550
>
atom -> ( )
550
,
atom -> ( )
550
.
atom -> ( )
550
>>
atom -> ( )
551
factor
184
551
term
185
551
(
186
551
arith_expr
187
551
NAME
188
551
[
189
551
+
190
551
atom_expr
191
551
atom
192
551
NUMBER
193
551
STRING
194
551
-
196
551
shift_expr
1087
551
True
197
551
None
201
551
False
203
551
{
206
551
~
207
551
power
208
552
factor
184
552
term
185
552
(
186
552
arith_expr
187
552
NAME
188
552
[
189
552
+
190
552
atom_expr
191
552
atom
192
552
NUMBER
193
552
STRING
194
552
-
196
552
True
197
552
shift_expr
1088
552
None
201
552
False
203
552
{
206
552
~
207
552
power
208
553
<=
atom -> [ ]
553
is
atom -> [ ]
553
-
atom -> [ ]
553
**
atom -> [ ]
553
^
atom -> [ ]
553
%
atom -> [ ]
553
/
atom -> [ ]
553
>=
atom -> [ ]
553
|
atom -> [ ]
553
not
atom -> [ ]
553
@
atom -> [ ]
553
*
atom -> [ ]
553
(
atom -> [ ]
553
,
atom -> [ ]
553
>>
atom -> [ ]
553
[
atom -> [ ]
553
NEWLINE
atom -> [ ]
553
or
atom -> [ ]
553
!=
atom -> [ ]
553
and
atom -> [ ]
553
<<
atom -> [ ]
553
if
atom -> [ ]
553
in
atom -> [ ]
553
+
atom -> [ ]
553
.
atom -> [ ]
553
==
atom -> [ ]
553
>
atom -> [ ]
553
<
atom -> [ ]
553
&
atom -> [ ]
553
//
atom -> [ ]
554
]
1089
555
<
factor -> + factor
555
if
factor -> + factor
555
<<
factor -> + factor
555
and
factor -> + factor
555
>=
factor -> + factor
555
%
factor -> + factor
555
>>
factor -> + factor
555
*
factor -> + factor
555
+
factor -> + factor
555
/
factor -> + factor
555
>
factor -> + factor
555
<=
factor -> + factor
555
^
factor -> + factor
555
is
factor -> + factor
555
|
factor -> + factor
555
or
factor -> + factor
555
-
factor -> + factor
555
in
factor -> + factor
555
NEWLINE
factor -> + factor
555
&
factor -> + factor
555
not
factor -> + factor
555
//
factor -> + factor
555
,
factor -> + factor
555
!=
factor -> + factor
555
==
factor -> + factor
555
@
factor -> + factor
556
(
186
556
NAME
188
556
[
189
556
+
190
556
atom_expr
191
556
NUMBER
193
556
atom
192
556
STRING
194
556
-
196
556
factor
1090
556
True
197
556
None
201
556
False
203
556
{
206
556
~
207
556
power
208
557
trailer_expr
1091
557
trailer
557
557
.
558
557
(
559
557
[
560
557
<<
trailer_expr -> 
557
%
trailer_expr -> 
557
==
trailer_expr -> 
557
-
trailer_expr -> 
557
<
trailer_expr -> 
557
NEWLINE
trailer_expr -> 
557
if
trailer_expr -> 
557
or
trailer_expr -> 
557
/
trailer_expr -> 
557
**
trailer_expr -> 
557
and
trailer_expr -> 
557
@
trailer_expr -> 
557
*
trailer_expr -> 
557
|
trailer_expr -> 
557
is
trailer_expr -> 
557
,
trailer_expr -> 
557
+
trailer_expr -> 
557
in
trailer_expr -> 
557
&
trailer_expr -> 
557
<=
trailer_expr -> 
557
>=
trailer_expr -> 
557
^
trailer_expr -> 
557
>
trailer_expr -> 
557
!=
trailer_expr -> 
557
not
trailer_expr -> 
557
>>
trailer_expr -> 
557
//
trailer_expr -> 
558
NAME
1092
559
factor
697
559
term
698
559
(
699
559
arith_expr
700
559
NAME
701
559
[
702
559
atom
703
559
+
704
559
power
706
559
atom_expr
707
559
NUMBER
708
559
STRING
709
559
arglist
1093
559
*
710
559
shift_expr
711
559
-
712
559
argument
714
559
)
1094
559
True
715
559
not_test
716
559
lambdef
717
559
and_expr
718
559
xor_expr
719
559
False
720
559
test
721
559
None
722
559
expr
723
559
and_test
724
559
{
725
559
~
726
559
lambda
727
559
comparison
728
559
or_test
729
559
not
730
559
**
731
560
factor
732
560
or_test
733
560
term
734
560
(
735
560
arith_expr
736
560
NAME
737
560
[
738
560
~
739
560
subscriptlist
1095
560
+
741
560
maybe_test
742
560
expr
743
560
atom_expr
744
560
atom
745
560
NUMBER
746
560
STRING
747
560
shift_expr
748
560
-
749
560
True
750
560
not_test
751
560
and_expr
752
560
xor_expr
753
560
False
754
560
{
755
560
None
756
560
and_test
757
560
lambda
758
560
power
759
560
subscript
760
560
test
761
560
lambdef
762
560
:
maybe_test -> 
560
comparison
763
560
not
764
561
>
atom_expr -> atom trailer_expr
561
not
atom_expr -> atom trailer_expr
561
//
atom_expr -> atom trailer_expr
561
>>
atom_expr -> atom trailer_expr
561
|
atom_expr -> atom trailer_expr
561
^
atom_expr -> atom trailer_expr
561
/
atom_expr -> atom trailer_expr
561
+
atom_expr -> atom trailer_expr
561
in
atom_expr -> atom trailer_expr
561
%
atom_expr -> atom trailer_expr
561
and
atom_expr -> atom trailer_expr
561
<=
atom_expr -> atom trailer_expr
561
is
atom_expr -> atom trailer_expr
561
<
atom_expr -> atom trailer_expr
561
@
atom_expr -> atom trailer_expr
561
-
atom_expr -> atom trailer_expr
561
NEWLINE
atom_expr -> atom trailer_expr
561
&
atom_expr -> atom trailer_expr
561
*
atom_expr -> atom trailer_expr
561
**
atom_expr -> atom trailer_expr
561
>=
atom_expr -> atom trailer_expr
561
or
atom_expr -> atom trailer_expr
561
,
atom_expr -> atom trailer_expr
561
==
atom_expr -> atom trailer_expr
561
!=
atom_expr -> atom trailer_expr
561
if
atom_expr -> atom trailer_expr
561
<<
atom_expr -> atom trailer_expr
562
factor
184
562
term
185
562
(
186
562
arith_expr
187
562
NAME
188
562
[
189
562
+
190
562
atom_expr
191
562
atom
192
562
NUMBER
193
562
STRING
194
562
shift_expr
195
562
-
196
562
True
197
562
None
201
562
and_expr
1096
562
False
203
562
{
206
562
~
207
562
power
208
563
and
factor -> - factor
563
if
factor -> - factor
563
or
factor -> - factor
563
>=
factor -> - factor
563
<
factor -> - factor
563
!=
factor -> - factor
563
-
factor -> - factor
563
==
factor -> - factor
563
@
factor -> - factor
563
|
factor -> - factor
563
*
factor -> - factor
563
%
factor -> - factor
563
+
factor -> - factor
563
<=
factor -> - factor
563
//
factor -> - factor
563
not
factor -> - factor
563
>>
factor -> - factor
563
/
factor -> - factor
563
&
factor -> - factor
563
^
factor -> - factor
563
in
factor -> - factor
563
is
factor -> - factor
563
>
factor -> - factor
563
NEWLINE
factor -> - factor
563
,
factor -> - factor
563
<<
factor -> - factor
564
factor
184
564
term
185
564
(
186
564
arith_expr
187
564
NAME
188
564
[
189
564
+
190
564
atom_expr
191
564
atom
192
564
NUMBER
193
564
STRING
194
564
shift_expr
195
564
-
196
564
True
197
564
not_test
198
564
and_expr
199
564
xor_expr
200
564
None
201
564
expr
202
564
False
203
564
{
206
564
~
207
564
and_test
1097
564
power
208
564
not
210
564
comparison
212
565
factor
184
565
term
185
565
(
186
565
arith_expr
187
565
NAME
188
565
[
189
565
+
190
565
atom_expr
191
565
atom
192
565
NUMBER
193
565
STRING
194
565
shift_expr
195
565
-
196
565
True
197
565
and_expr
199
565
None
201
565
False
203
565
{
206
565
~
207
565
xor_expr
1098
565
power
208
566
factor
184
566
term
185
566
(
186
566
arith_expr
187
566
NAME
188
566
[
189
566
+
190
566
atom_expr
191
566
atom
192
566
NUMBER
193
566
STRING
194
566
shift_expr
195
566
-
196
566
True
197
566
and_expr
199
566
xor_expr
200
566
None
201
566
False
203
566
{
206
566
~
207
566
power
208
566
expr
1099
567
factor
184
567
term
185
567
(
186
567
arith_expr
187
567
NAME
188
567
[
189
567
+
190
567
atom_expr
191
567
atom
192
567
NUMBER
193
567
STRING
194
567
shift_expr
195
567
-
196
567
True
197
567
and_expr
199
567
comparison
1100
567
xor_expr
200
567
None
201
567
expr
202
567
False
203
567
{
206
567
~
207
567
power
208
568
factor
184
568
term
185
568
(
186
568
arith_expr
187
568
NAME
188
568
[
189
568
+
190
568
or_test
1101
568
atom_expr
191
568
atom
192
568
NUMBER
193
568
STRING
194
568
shift_expr
195
568
-
196
568
True
197
568
not_test
198
568
and_expr
199
568
xor_expr
200
568
None
201
568
expr
202
568
False
203
568
and_test
204
568
{
206
568
~
207
568
power
208
568
not
210
568
comparison
212
569
factor
184
569
term
185
569
(
186
569
arith_expr
187
569
NAME
188
569
[
189
569
+
190
569
atom_expr
191
569
atom
192
569
NUMBER
193
569
STRING
194
569
shift_expr
195
569
-
196
569
True
197
569
not_test
198
569
and_expr
199
569
xor_expr
200
569
None
201
569
expr
202
569
False
203
569
and_test
204
569
lambda
205
569
{
206
569
~
207
569
power
208
569
not
210
569
or_test
211
569
test
1102
569
comparison
212
569
lambdef
214
570
:
1103
571
>
atom -> { }
571
==
atom -> { }
571
-
atom -> { }
571
not
atom -> { }
571
(
atom -> { }
571
@
atom -> { }
571
if
atom -> { }
571
and
atom -> { }
571
,
atom -> { }
571
&
atom -> { }
571
<<
atom -> { }
571
!=
atom -> { }
571
or
atom -> { }
571
>>
atom -> { }
571
<=
atom -> { }
571
NEWLINE
atom -> { }
571
>=
atom -> { }
571
is
atom -> { }
571
/
atom -> { }
571
^
atom -> { }
571
[
atom -> { }
571
%
atom -> { }
571
//
atom -> { }
571
*
atom -> { }
571
**
atom -> { }
571
.
atom -> { }
571
in
atom -> { }
571
+
atom -> { }
571
|
atom -> { }
571
<
atom -> { }
572
or
factor -> ~ factor
572
==
factor -> ~ factor
572
<=
factor -> ~ factor
572
@
factor -> ~ factor
572
!=
factor -> ~ factor
572
>=
factor -> ~ factor
572
>
factor -> ~ factor
572
and
factor -> ~ factor
572
,
factor -> ~ factor
572
*
factor -> ~ factor
572
&
factor -> ~ factor
572
%
factor -> ~ factor
572
<
factor -> ~ factor
572
//
factor -> ~ factor
572
if
factor -> ~ factor
572
^
factor -> ~ factor
572
/
factor -> ~ factor
572
in
factor -> ~ factor
572
+
factor -> ~ factor
572
not
factor -> ~ factor
572
-
factor -> ~ factor
572
is
factor -> ~ factor
572
>>
factor -> ~ factor
572
<<
factor -> ~ factor
572
NEWLINE
factor -> ~ factor
572
|
factor -> ~ factor
573
factor
184
573
term
185
573
(
186
573
arith_expr
187
573
NAME
188
573
[
189
573
+
190
573
atom_expr
191
573
atom
192
573
NUMBER
193
573
STRING
194
573
shift_expr
195
573
-
196
573
True
197
573
not_test
198
573
and_expr
199
573
xor_expr
200
573
None
201
573
expr
202
573
False
203
573
and_test
204
573
lambda
205
573
{
206
573
~
207
573
power
208
573
test
209
573
not
210
573
or_test
211
573
comparison
212
573
lambdef
214
573
test_list
1104
574
or
not_test -> not not_test
574
,
not_test -> not not_test
574
and
not_test -> not not_test
574
if
not_test -> not not_test
574
NEWLINE
not_test -> not not_test
575
factor
585
575
(
586
575
arith_expr
587
575
NAME
588
575
[
589
575
and_expr
590
575
+
591
575
term
592
575
atom_expr
593
575
NUMBER
594
575
atom
595
575
STRING
596
575
shift_expr
597
575
-
598
575
True
599
575
not
600
575
xor_expr
601
575
None
602
575
False
603
575
not_test
605
575
~
606
575
power
607
575
{
608
575
expr
609
575
or_test
1105
575
comparison
610
575
and_test
611
576
NAME
comp_op -> is not
576
(
comp_op -> is not
576
False
comp_op -> is not
576
{
comp_op -> is not
576
None
comp_op -> is not
576
NUMBER
comp_op -> is not
576
-
comp_op -> is not
576
+
comp_op -> is not
576
STRING
comp_op -> is not
576
~
comp_op -> is not
576
[
comp_op -> is not
576
True
comp_op -> is not
577
|=
comparison -> expr comp_op comparison
577
<<=
comparison -> expr comp_op comparison
577
or
comparison -> expr comp_op comparison
577
=
comparison -> expr comp_op comparison
577
^=
comparison -> expr comp_op comparison
577
if
comparison -> expr comp_op comparison
577
NEWLINE
comparison -> expr comp_op comparison
577
-=
comparison -> expr comp_op comparison
577
%=
comparison -> expr comp_op comparison
577
and
comparison -> expr comp_op comparison
577
//=
comparison -> expr comp_op comparison
577
:
comparison -> expr comp_op comparison
577
/=
comparison -> expr comp_op comparison
577
+=
comparison -> expr comp_op comparison
577
&=
comparison -> expr comp_op comparison
577
**=
comparison -> expr comp_op comparison
577
@=
comparison -> expr comp_op comparison
577
*=
comparison -> expr comp_op comparison
577
>>=
comparison -> expr comp_op comparison
577
,
comparison -> expr comp_op comparison
578
False
comp_op -> not in
578
NUMBER
comp_op -> not in
578
-
comp_op -> not in
578
+
comp_op -> not in
578
~
comp_op -> not in
578
True
comp_op -> not in
578
None
comp_op -> not in
578
NAME
comp_op -> not in
578
STRING
comp_op -> not in
578
[
comp_op -> not in
578
(
comp_op -> not in
578
{
comp_op -> not in
579
,
and_test -> not_test and and_test
579
&=
and_test -> not_test and and_test
579
:
and_test -> not_test and and_test
579
if
and_test -> not_test and and_test
579
NEWLINE
and_test -> not_test and and_test
579
@=
and_test -> not_test and and_test
579
=
and_test -> not_test and and_test
579
/=
and_test -> not_test and and_test
579
^=
and_test -> not_test and and_test
579
//=
and_test -> not_test and and_test
579
-=
and_test -> not_test and and_test
579
>>=
and_test -> not_test and and_test
579
|=
and_test -> not_test and and_test
579
*=
and_test -> not_test and and_test
579
%=
and_test -> not_test and and_test
579
**=
and_test -> not_test and and_test
579
or
and_test -> not_test and and_test
579
<<=
and_test -> not_test and and_test
579
+=
and_test -> not_test and and_test
580
<=
xor_expr -> and_expr ^ xor_expr
580
!=
xor_expr -> and_expr ^ xor_expr
580
**=
xor_expr -> and_expr ^ xor_expr
580
not
xor_expr -> and_expr ^ xor_expr
580
>>=
xor_expr -> and_expr ^ xor_expr
580
,
xor_expr -> and_expr ^ xor_expr
580
:
xor_expr -> and_expr ^ xor_expr
580
+=
xor_expr -> and_expr ^ xor_expr
580
NEWLINE
xor_expr -> and_expr ^ xor_expr
580
/=
xor_expr -> and_expr ^ xor_expr
580
>=
xor_expr -> and_expr ^ xor_expr
580
<
xor_expr -> and_expr ^ xor_expr
580
-=
xor_expr -> and_expr ^ xor_expr
580
or
xor_expr -> and_expr ^ xor_expr
580
in
xor_expr -> and_expr ^ xor_expr
580
^=
xor_expr -> and_expr ^ xor_expr
580
=
xor_expr -> and_expr ^ xor_expr
580
<<=
xor_expr -> and_expr ^ xor_expr
580
>
xor_expr -> and_expr ^ xor_expr
580
if
xor_expr -> and_expr ^ xor_expr
580
*=
xor_expr -> and_expr ^ xor_expr
580
and
xor_expr -> and_expr ^ xor_expr
580
is
xor_expr -> and_expr ^ xor_expr
580
|=
xor_expr -> and_expr ^ xor_expr
580
@=
xor_expr -> and_expr ^ xor_expr
580
|
xor_expr -> and_expr ^ xor_expr
580
&=
xor_expr -> and_expr ^ xor_expr
580
==
xor_expr -> and_expr ^ xor_expr
580
//=
xor_expr -> and_expr ^ xor_expr
580
%=
xor_expr -> and_expr ^ xor_expr
581
)
1106
581
parameters
1107
581
tfpdef
1108
581
**
1109
581
param
1110
581
*
1111
581
NAME
1112
582
==
arith_expr -> term + arith_expr
582
!=
arith_expr -> term + arith_expr
582
//=
arith_expr -> term + arith_expr
582
<<
arith_expr -> term + arith_expr
582
&
arith_expr -> term + arith_expr
582
<
arith_expr -> term + arith_expr
582
^
arith_expr -> term + arith_expr
582
+=
arith_expr -> term + arith_expr
582
/=
arith_expr -> term + arith_expr
582
@=
arith_expr -> term + arith_expr
582
,
arith_expr -> term + arith_expr
582
>=
arith_expr -> term + arith_expr
582
^=
arith_expr -> term + arith_expr
582
NEWLINE
arith_expr -> term + arith_expr
582
**=
arith_expr -> term + arith_expr
582
in
arith_expr -> term + arith_expr
582
>>
arith_expr -> term + arith_expr
582
<<=
arith_expr -> term + arith_expr
582
not
arith_expr -> term + arith_expr
582
:
arith_expr -> term + arith_expr
582
|=
arith_expr -> term + arith_expr
582
<=
arith_expr -> term + arith_expr
582
-=
arith_expr -> term + arith_expr
582
>>=
arith_expr -> term + arith_expr
582
&=
arith_expr -> term + arith_expr
582
%=
arith_expr -> term + arith_expr
582
is
arith_expr -> term + arith_expr
582
|
arith_expr -> term + arith_expr
582
and
arith_expr -> term + arith_expr
582
=
arith_expr -> term + arith_expr
582
*=
arith_expr -> term + arith_expr
582
or
arith_expr -> term + arith_expr
582
if
arith_expr -> term + arith_expr
582
>
arith_expr -> term + arith_expr
583
if
arith_expr -> term - arith_expr
583
&
arith_expr -> term - arith_expr
583
>>
arith_expr -> term - arith_expr
583
:
arith_expr -> term - arith_expr
583
>>=
arith_expr -> term - arith_expr
583
-=
arith_expr -> term - arith_expr
583
**=
arith_expr -> term - arith_expr
583
NEWLINE
arith_expr -> term - arith_expr
583
!=
arith_expr -> term - arith_expr
583
%=
arith_expr -> term - arith_expr
583
>=
arith_expr -> term - arith_expr
583
&=
arith_expr -> term - arith_expr
583
+=
arith_expr -> term - arith_expr
583
|
arith_expr -> term - arith_expr
583
@=
arith_expr -> term - arith_expr
583
>
arith_expr -> term - arith_expr
583
//=
arith_expr -> term - arith_expr
583
/=
arith_expr -> term - arith_expr
583
<<=
arith_expr -> term - arith_expr
583
<
arith_expr -> term - arith_expr
583
==
arith_expr -> term - arith_expr
583
,
arith_expr -> term - arith_expr
583
|=
arith_expr -> term - arith_expr
583
and
arith_expr -> term - arith_expr
583
*=
arith_expr -> term - arith_expr
583
=
arith_expr -> term - arith_expr
583
is
arith_expr -> term - arith_expr
583
in
arith_expr -> term - arith_expr
583
^
arith_expr -> term - arith_expr
583
<<
arith_expr -> term - arith_expr
583
not
arith_expr -> term - arith_expr
583
or
arith_expr -> term - arith_expr
583
<=
arith_expr -> term - arith_expr
583
^=
arith_expr -> term - arith_expr
584
|=
expr -> xor_expr | expr
584
^=
expr -> xor_expr | expr
584
==
expr -> xor_expr | expr
584
=
expr -> xor_expr | expr
584
<
expr -> xor_expr | expr
584
>>=
expr -> xor_expr | expr
584
not
expr -> xor_expr | expr
584
if
expr -> xor_expr | expr
584
*=
expr -> xor_expr | expr
584
%=
expr -> xor_expr | expr
584
+=
expr -> xor_expr | expr
584
is
expr -> xor_expr | expr
584
/=
expr -> xor_expr | expr
584
@=
expr -> xor_expr | expr
584
in
expr -> xor_expr | expr
584
//=
expr -> xor_expr | expr
584
**=
expr -> xor_expr | expr
584
,
expr -> xor_expr | expr
584
&=
expr -> xor_expr | expr
584
:
expr -> xor_expr | expr
584
or
expr -> xor_expr | expr
584
<=
expr -> xor_expr | expr
584
>
expr -> xor_expr | expr
584
!=
expr -> xor_expr | expr
584
>=
expr -> xor_expr | expr
584
NEWLINE
expr -> xor_expr | expr
584
<<=
expr -> xor_expr | expr
584
and
expr -> xor_expr | expr
584
-=
expr -> xor_expr | expr
585
//
1113
585
in
term -> factor
585
@
1114
585
-
term -> factor
585
*
1115
585
%
1116
585
>=
term -> factor
585
/
1117
585
<
term -> factor
585
<=
term -> factor
585
==
term -> factor
585
!=
term -> factor
585
>>
term -> factor
585
is
term -> factor
585
or
term -> factor
585
and
term -> factor
585
^
term -> factor
585
+
term -> factor
585
&
term -> factor
585
<<
term -> factor
585
|
term -> factor
585
>
term -> factor
585
else
term -> factor
585
not
term -> factor
586
factor
268
586
term
270
586
(
271
586
arith_expr
272
586
NAME
273
586
[
274
586
+
275
586
test_list_comp
1118
586
atom_expr
277
586
NUMBER
278
586
atom
279
586
STRING
280
586
shift_expr
281
586
-
282
586
True
283
586
not_test
284
586
lambdef
285
586
and_expr
286
586
xor_expr
287
586
False
288
586
None
289
586
expr
290
586
and_test
291
586
)
1119
586
{
292
586
~
293
586
power
294
586
lambda
295
586
comparison
296
586
or_test
297
586
not
298
586
test
299
586
test_list
300
587
>>
1120
587
<<
1121
587
&
shift_expr -> arith_expr
587
<=
shift_expr -> arith_expr
587
>
shift_expr -> arith_expr
587
not
shift_expr -> arith_expr
587
!=
shift_expr -> arith_expr
587
^
shift_expr -> arith_expr
587
else
shift_expr -> arith_expr
587
is
shift_expr -> arith_expr
587
|
shift_expr -> arith_expr
587
>=
shift_expr -> arith_expr
587
or
shift_expr -> arith_expr
587
==
shift_expr -> arith_expr
587
and
shift_expr -> arith_expr
587
<
shift_expr -> arith_expr
587
in
shift_expr -> arith_expr
588
-
atom -> NAME
588
or
atom -> NAME
588
>>
atom -> NAME
588
&
atom -> NAME
588
[
atom -> NAME
588
<=
atom -> NAME
588
<
atom -> NAME
588
.
atom -> NAME
588
|
atom -> NAME
588
*
atom -> NAME
588
/
atom -> NAME
588
<<
atom -> NAME
588
not
atom -> NAME
588
>
atom -> NAME
588
is
atom -> NAME
588
else
atom -> NAME
588
//
atom -> NAME
588
+
atom -> NAME
588
in
atom -> NAME
588
**
atom -> NAME
588
!=
atom -> NAME
588
>=
atom -> NAME
588
^
atom -> NAME
588
@
atom -> NAME
588
(
atom -> NAME
588
==
atom -> NAME
588
and
atom -> NAME
588
%
atom -> NAME
589
factor
117
589
or_test
118
589
term
119
589
(
120
589
arith_expr
121
589
NAME
122
589
[
123
589
]
1122
589
+
125
589
atom_expr
126
589
NUMBER
127
589
atom
128
589
STRING
129
589
shift_expr
130
589
-
131
589
test_list_comp
1123
589
True
133
589
not_test
134
589
lambdef
135
589
and_expr
136
589
xor_expr
137
589
False
138
589
None
139
589
expr
140
589
and_test
141
589
{
142
589
~
143
589
lambda
144
589
power
145
589
comparison
146
589
test_list
147
589
test
148
589
not
149
590
^
1124
590
not
xor_expr -> and_expr
590
<=
xor_expr -> and_expr
590
else
xor_expr -> and_expr
590
>
xor_expr -> and_expr
590
<
xor_expr -> and_expr
590
in
xor_expr -> and_expr
590
>=
xor_expr -> and_expr
590
==
xor_expr -> and_expr
590
|
xor_expr -> and_expr
590
is
xor_expr -> and_expr
590
and
xor_expr -> and_expr
590
or
xor_expr -> and_expr
590
!=
xor_expr -> and_expr
591
True
599
591
NUMBER
594
591
(
586
591
NAME
588
591
~
606
591
[
589
591
atom_expr
593
591
+
591
591
factor
1125
591
None
602
591
STRING
596
591
atom
595
591
False
603
591
-
598
591
{
608
591
power
607
592
+
1126
592
-
1127
592
|
arith_expr -> term
592
or
arith_expr -> term
592
not
arith_expr -> term
592
else
arith_expr -> term
592
<=
arith_expr -> term
592
!=
arith_expr -> term
592
<
arith_expr -> term
592
&
arith_expr -> term
592
>=
arith_expr -> term
592
==
arith_expr -> term
592
^
arith_expr -> term
592
in
arith_expr -> term
592
is
arith_expr -> term
592
<<
arith_expr -> term
592
>
arith_expr -> term
592
and
arith_expr -> term
592
>>
arith_expr -> term
593
!=
power -> atom_expr
593
**
1128
593
>
power -> atom_expr
593
+
power -> atom_expr
593
not
power -> atom_expr
593
&
power -> atom_expr
593
else
power -> atom_expr
593
|
power -> atom_expr
593
>>
power -> atom_expr
593
^
power -> atom_expr
593
==
power -> atom_expr
593
in
power -> atom_expr
593
%
power -> atom_expr
593
<<
power -> atom_expr
593
or
power -> atom_expr
593
@
power -> atom_expr
593
*
power -> atom_expr
593
/
power -> atom_expr
593
<
power -> atom_expr
593
//
power -> atom_expr
593
>=
power -> atom_expr
593
-
power -> atom_expr
593
is
power -> atom_expr
593
<=
power -> atom_expr
593
and
power -> atom_expr
594
[
atom -> NUMBER
594
>=
atom -> NUMBER
594
<=
atom -> NUMBER
594
!=
atom -> NUMBER
594
//
atom -> NUMBER
594
in
atom -> NUMBER
594
/
atom -> NUMBER
594
or
atom -> NUMBER
594
>
atom -> NUMBER
594
not
atom -> NUMBER
594
>>
atom -> NUMBER
594
(
atom -> NUMBER
594
**
atom -> NUMBER
594
<<
atom -> NUMBER
594
and
atom -> NUMBER
594
+
atom -> NUMBER
594
%
atom -> NUMBER
594
==
atom -> NUMBER
594
else
atom -> NUMBER
594
is
atom -> NUMBER
594
*
atom -> NUMBER
594
@
atom -> NUMBER
594
|
atom -> NUMBER
594
-
atom -> NUMBER
594
.
atom -> NUMBER
594
^
atom -> NUMBER
594
<
atom -> NUMBER
594
&
atom -> NUMBER
595
[
1129
595
trailer
1130
595
.
1131
595
(
1132
595
trailer_expr
1133
595
<<
trailer_expr -> 
595
%
trailer_expr -> 
595
==
trailer_expr -> 
595
-
trailer_expr -> 
595
<
trailer_expr -> 
595
or
trailer_expr -> 
595
/
trailer_expr -> 
595
**
trailer_expr -> 
595
and
trailer_expr -> 
595
@
trailer_expr -> 
595
*
trailer_expr -> 
595
|
trailer_expr -> 
595
is
trailer_expr -> 
595
+
trailer_expr -> 
595
in
trailer_expr -> 
595
else
trailer_expr -> 
595
&
trailer_expr -> 
595
<=
trailer_expr -> 
595
>=
trailer_expr -> 
595
^
trailer_expr -> 
595
>
trailer_expr -> 
595
!=
trailer_expr -> 
595
not
trailer_expr -> 
595
>>
trailer_expr -> 
595
//
trailer_expr -> 
596
and
atom -> STRING
596
%
atom -> STRING
596
//
atom -> STRING
596
>>
atom -> STRING
596
*
atom -> STRING
596
<
atom -> STRING
596
.
atom -> STRING
596
in
atom -> STRING
596
^
atom -> STRING
596
else
atom -> STRING
596
(
atom -> STRING
596
==
atom -> STRING
596
-
atom -> STRING
596
**
atom -> STRING
596
<<
atom -> STRING
596
<=
atom -> STRING
596
[
atom -> STRING
596
not
atom -> STRING
596
or
atom -> STRING
596
+
atom -> STRING
596
>=
atom -> STRING
596
@
atom -> STRING
596
&
atom -> STRING
596
>
atom -> STRING
596
is
atom -> STRING
596
|
atom -> STRING
596
!=
atom -> STRING
596
/
atom -> STRING
597
&
1134
597
^
and_expr -> shift_expr
597
|
and_expr -> shift_expr
597
<=
and_expr -> shift_expr
597
else
and_expr -> shift_expr
597
or
and_expr -> shift_expr
597
>
and_expr -> shift_expr
597
not
and_expr -> shift_expr
597
!=
and_expr -> shift_expr
597
and
and_expr -> shift_expr
597
is
and_expr -> shift_expr
597
<
and_expr -> shift_expr
597
in
and_expr -> shift_expr
597
>=
and_expr -> shift_expr
597
==
and_expr -> shift_expr
598
True
599
598
NUMBER
594
598
(
586
598
NAME
588
598
~
606
598
[
589
598
factor
1135
598
atom_expr
593
598
+
591
598
None
602
598
STRING
596
598
atom
595
598
False
603
598
-
598
598
{
608
598
power
607
599
(
atom -> True
599
[
atom -> True
599
+
atom -> True
599
@
atom -> True
599
<=
atom -> True
599
&
atom -> True
599
<<
atom -> True
599
-
atom -> True
599
/
atom -> True
599
or
atom -> True
599
>
atom -> True
599
%
atom -> True
599
^
atom -> True
599
!=
atom -> True
599
is
atom -> True
599
*
atom -> True
599
<
atom -> True
599
and
atom -> True
599
.
atom -> True
599
==
atom -> True
599
else
atom -> True
599
**
atom -> True
599
>>
atom -> True
599
in
atom -> True
599
|
atom -> True
599
>=
atom -> True
599
//
atom -> True
599
not
atom -> True
600
factor
585
600
(
586
600
arith_expr
587
600
NAME
588
600
[
589
600
and_expr
590
600
+
591
600
term
592
600
atom_expr
593
600
NUMBER
594
600
atom
595
600
STRING
596
600
shift_expr
597
600
-
598
600
not_test
1136
600
True
599
600
not
600
600
xor_expr
601
600
None
602
600
False
603
600
~
606
600
power
607
600
{
608
600
expr
609
600
comparison
610
601
|
1137
601
>=
expr -> xor_expr
601
==
expr -> xor_expr
601
is
expr -> xor_expr
601
or
expr -> xor_expr
601
>
expr -> xor_expr
601
and
expr -> xor_expr
601
<
expr -> xor_expr
601
in
expr -> xor_expr
601
<=
expr -> xor_expr
601
not
expr -> xor_expr
601
else
expr -> xor_expr
601
!=
expr -> xor_expr
602
is
atom -> None
602
.
atom -> None
602
==
atom -> None
602
^
atom -> None
602
<<
atom -> None
602
>>
atom -> None
602
(
atom -> None
602
|
atom -> None
602
+
atom -> None
602
*
atom -> None
602
//
atom -> None
602
@
atom -> None
602
in
atom -> None
602
>=
atom -> None
602
!=
atom -> None
602
%
atom -> None
602
[
atom -> None
602
and
atom -> None
602
-
atom -> None
602
&
atom -> None
602
else
atom -> None
602
<=
atom -> None
602
<
atom -> None
602
>
atom -> None
602
**
atom -> None
602
or
atom -> None
602
/
atom -> None
602
not
atom -> None
603
in
atom -> False
603
>
atom -> False
603
-
atom -> False
603
%
atom -> False
603
<
atom -> False
603
|
atom -> False
603
==
atom -> False
603
&
atom -> False
603
//
atom -> False
603
and
atom -> False
603
not
atom -> False
603
+
atom -> False
603
!=
atom -> False
603
@
atom -> False
603
[
atom -> False
603
or
atom -> False
603
<=
atom -> False
603
*
atom -> False
603
^
atom -> False
603
else
atom -> False
603
is
atom -> False
603
/
atom -> False
603
.
atom -> False
603
>=
atom -> False
603
**
atom -> False
603
>>
atom -> False
603
<<
atom -> False
603
(
atom -> False
604
else
1138
605
or
and_test -> not_test
605
else
and_test -> not_test
605
and
1139
606
True
599
606
NUMBER
594
606
(
586
606
NAME
588
606
~
606
606
[
589
606
atom_expr
593
606
+
591
606
None
602
606
factor
1140
606
STRING
596
606
atom
595
606
False
603
606
-
598
606
{
608
606
power
607
607
&
factor -> power
607
%
factor -> power
607
<<
factor -> power
607
-
factor -> power
607
<=
factor -> power
607
not
factor -> power
607
//
factor -> power
607
/
factor -> power
607
is
factor -> power
607
else
factor -> power
607
|
factor -> power
607
<
factor -> power
607
and
factor -> power
607
>=
factor -> power
607
>>
factor -> power
607
>
factor -> power
607
in
factor -> power
607
^
factor -> power
607
==
factor -> power
607
+
factor -> power
607
@
factor -> power
607
or
factor -> power
607
*
factor -> power
607
!=
factor -> power
608
}
1141
609
is
215
609
not
221
609
>
223
609
==
224
609
>=
222
609
in
219
609
<
217
609
!=
218
609
<=
220
609
comp_op
1142
609
and
comparison -> expr
609
or
comparison -> expr
609
else
comparison -> expr
610
and
not_test -> comparison
610
else
not_test -> comparison
610
or
not_test -> comparison
611
or
1143
611
else
or_test -> and_test
612
-=
power -> atom_expr ** factor
612
+
power -> atom_expr ** factor
612
@=
power -> atom_expr ** factor
612
&
power -> atom_expr ** factor
612
**=
power -> atom_expr ** factor
612
>>
power -> atom_expr ** factor
612
<<
power -> atom_expr ** factor
612
not
power -> atom_expr ** factor
612
is
power -> atom_expr ** factor
612
@
power -> atom_expr ** factor
612
*=
power -> atom_expr ** factor
612
:
power -> atom_expr ** factor
612
/=
power -> atom_expr ** factor
612
==
power -> atom_expr ** factor
612
*
power -> atom_expr ** factor
612
or
power -> atom_expr ** factor
612
//=
power -> atom_expr ** factor
612
>
power -> atom_expr ** factor
612
|=
power -> atom_expr ** factor
612
&=
power -> atom_expr ** factor
612
-
power -> atom_expr ** factor
612
%=
power -> atom_expr ** factor
612
>>=
power -> atom_expr ** factor
612
if
power -> atom_expr ** factor
612
!=
power -> atom_expr ** factor
612
>=
power -> atom_expr ** factor
612
/
power -> atom_expr ** factor
612
%
power -> atom_expr ** factor
612
and
power -> atom_expr ** factor
612
=
power -> atom_expr ** factor
612
NEWLINE
power -> atom_expr ** factor
612
<=
power -> atom_expr ** factor
612
<
power -> atom_expr ** factor
612
|
power -> atom_expr ** factor
612
^
power -> atom_expr ** factor
612
in
power -> atom_expr ** factor
612
+=
power -> atom_expr ** factor
612
,
power -> atom_expr ** factor
612
<<=
power -> atom_expr ** factor
612
//
power -> atom_expr ** factor
612
^=
power -> atom_expr ** factor
613
namelist
1144
613
NAME
234
614
factor
236
614
(
238
614
NAME
241
614
[
243
614
~
244
614
+
245
614
atom_expr
248
614
NUMBER
251
614
atom
250
614
STRING
252
614
-
253
614
term
1145
614
True
254
614
False
242
614
{
258
614
None
260
614
power
264
615
factor
236
615
(
238
615
NAME
241
615
[
243
615
~
244
615
+
245
615
atom_expr
248
615
NUMBER
251
615
atom
250
615
term
1146
615
STRING
252
615
-
253
615
True
254
615
False
242
615
{
258
615
None
260
615
power
264
616
factor
236
616
(
238
616
NAME
241
616
[
243
616
~
244
616
+
245
616
atom_expr
248
616
NUMBER
251
616
atom
250
616
STRING
252
616
-
253
616
True
254
616
False
242
616
{
258
616
None
260
616
term
1147
616
power
264
617
factor
236
617
(
238
617
NAME
241
617
term
1148
617
[
243
617
~
244
617
+
245
617
atom_expr
248
617
NUMBER
251
617
atom
250
617
STRING
252
617
-
253
617
True
254
617
False
242
617
{
258
617
None
260
617
power
264
618
factor
236
618
(
238
618
NAME
241
618
[
243
618
~
244
618
+
245
618
atom_expr
248
618
NUMBER
251
618
atom
250
618
STRING
252
618
-
253
618
term
1149
618
True
254
618
False
242
618
{
258
618
None
260
618
power
264
619
factor
236
619
term
237
619
(
238
619
NAME
241
619
[
243
619
~
244
619
+
245
619
atom_expr
248
619
NUMBER
251
619
atom
250
619
STRING
252
619
-
253
619
True
254
619
arith_expr
1150
619
False
242
619
{
258
619
None
260
619
power
264
620
factor
236
620
term
237
620
(
238
620
NAME
241
620
[
243
620
~
244
620
+
245
620
atom_expr
248
620
NUMBER
251
620
atom
250
620
STRING
252
620
-
253
620
True
254
620
False
242
620
{
258
620
None
260
620
arith_expr
1151
620
power
264
621
)
1152
622
or
atom -> ( )
622
<<
atom -> ( )
622
not
atom -> ( )
622
&
atom -> ( )
622
(
atom -> ( )
622
in
atom -> ( )
622
**
atom -> ( )
622
@
atom -> ( )
622
<=
atom -> ( )
622
%
atom -> ( )
622
as
atom -> ( )
622
[
atom -> ( )
622
>=
atom -> ( )
622
/
atom -> ( )
622
+
atom -> ( )
622
<
atom -> ( )
622
is
atom -> ( )
622
:
atom -> ( )
622
*
atom -> ( )
622
!=
atom -> ( )
622
-
atom -> ( )
622
|
atom -> ( )
622
//
atom -> ( )
622
^
atom -> ( )
622
and
atom -> ( )
622
==
atom -> ( )
622
if
atom -> ( )
622
>
atom -> ( )
622
,
atom -> ( )
622
.
atom -> ( )
622
>>
atom -> ( )
623
factor
236
623
term
237
623
(
238
623
arith_expr
239
623
NAME
241
623
[
243
623
~
244
623
+
245
623
atom_expr
248
623
NUMBER
251
623
atom
250
623
STRING
252
623
-
253
623
shift_expr
1153
623
True
254
623
False
242
623
{
258
623
None
260
623
power
264
624
factor
236
624
term
237
624
(
238
624
arith_expr
239
624
NAME
241
624
[
243
624
~
244
624
+
245
624
atom_expr
248
624
NUMBER
251
624
atom
250
624
STRING
252
624
-
253
624
True
254
624
shift_expr
1154
624
False
242
624
{
258
624
None
260
624
power
264
625
factor
9
625
arith_expr
2
625
NAME
29
625
term
21
625
[
3
625
~
45
625
suite
1155
625
atom_expr
24
625
expr
16
625
power
56
625
(
36
625
return
13
625
small_stmt
47
625
flow_stmt
15
625
True
17
625
not_test
18
625
and_expr
19
625
xor_expr
22
625
{
52
625
lambdef
53
625
atom
54
625
or_test
23
625
shift_expr
50
625
False
35
625
NEWLINE
1022
625
-
49
625
None
42
625
lambda
40
625
global
25
625
NUMBER
27
625
STRING
28
625
test
48
625
endsim
33
625
and_test
37
625
simple_stmt
1023
625
comparison
39
625
break_stmt
74
625
+
55
625
not
57
625
raise
62
625
continue
59
625
return_stmt
75
625
del_stmt
60
625
test_list
61
625
raise_stmt
63
625
resetstats
64
625
pass_stmt
65
625
nonlocal
66
625
break
76
625
sim_stmt
77
625
stat_stmt
78
625
global_stmt
67
625
yield_stmt
79
625
assert_stmt
80
625
pass
81
625
yield
68
625
continue_stmt
69
625
assert
70
625
nonlocal_stmt
71
625
expr_stmt
72
625
begsim
83
625
del
84
626
<=
atom -> [ ]
626
is
atom -> [ ]
626
-
atom -> [ ]
626
**
atom -> [ ]
626
^
atom -> [ ]
626
%
atom -> [ ]
626
/
atom -> [ ]
626
>=
atom -> [ ]
626
|
atom -> [ ]
626
not
atom -> [ ]
626
@
atom -> [ ]
626
*
atom -> [ ]
626
(
atom -> [ ]
626
,
atom -> [ ]
626
>>
atom -> [ ]
626
[
atom -> [ ]
626
:
atom -> [ ]
626
or
atom -> [ ]
626
!=
atom -> [ ]
626
and
atom -> [ ]
626
<<
atom -> [ ]
626
if
atom -> [ ]
626
in
atom -> [ ]
626
as
atom -> [ ]
626
+
atom -> [ ]
626
.
atom -> [ ]
626
==
atom -> [ ]
626
>
atom -> [ ]
626
<
atom -> [ ]
626
&
atom -> [ ]
626
//
atom -> [ ]
627
]
1156
628
or
factor -> ~ factor
628
==
factor -> ~ factor
628
<=
factor -> ~ factor
628
@
factor -> ~ factor
628
!=
factor -> ~ factor
628
>=
factor -> ~ factor
628
>
factor -> ~ factor
628
and
factor -> ~ factor
628
,
factor -> ~ factor
628
:
factor -> ~ factor
628
*
factor -> ~ factor
628
as
factor -> ~ factor
628
&
factor -> ~ factor
628
%
factor -> ~ factor
628
<
factor -> ~ factor
628
//
factor -> ~ factor
628
if
factor -> ~ factor
628
^
factor -> ~ factor
628
/
factor -> ~ factor
628
in
factor -> ~ factor
628
+
factor -> ~ factor
628
not
factor -> ~ factor
628
-
factor -> ~ factor
628
is
factor -> ~ factor
628
>>
factor -> ~ factor
628
<<
factor -> ~ factor
628
|
factor -> ~ factor
629
<
factor -> + factor
629
if
factor -> + factor
629
<<
factor -> + factor
629
and
factor -> + factor
629
>=
factor -> + factor
629
%
factor -> + factor
629
>>
factor -> + factor
629
*
factor -> + factor
629
as
factor -> + factor
629
+
factor -> + factor
629
/
factor -> + factor
629
>
factor -> + factor
629
<=
factor -> + factor
629
^
factor -> + factor
629
is
factor -> + factor
629
|
factor -> + factor
629
or
factor -> + factor
629
-
factor -> + factor
629
in
factor -> + factor
629
&
factor -> + factor
629
not
factor -> + factor
629
//
factor -> + factor
629
,
factor -> + factor
629
!=
factor -> + factor
629
:
factor -> + factor
629
==
factor -> + factor
629
@
factor -> + factor
630
factor
236
630
term
237
630
(
238
630
arith_expr
239
630
NAME
241
630
False
242
630
[
243
630
~
244
630
+
245
630
lambda
246
630
expr
247
630
atom_expr
248
630
shift_expr
249
630
atom
250
630
NUMBER
251
630
STRING
252
630
-
253
630
True
254
630
not_test
255
630
and_expr
256
630
xor_expr
257
630
{
258
630
or_test
259
630
None
260
630
comparison
261
630
and_test
262
630
test
1157
630
lambdef
263
630
power
264
630
not
265
631
:
1158
632
factor
236
632
term
237
632
(
238
632
arith_expr
239
632
NAME
241
632
False
242
632
[
243
632
~
244
632
+
245
632
expr
247
632
atom_expr
248
632
shift_expr
249
632
atom
250
632
NUMBER
251
632
STRING
252
632
-
253
632
True
254
632
and_expr
256
632
comparison
1159
632
xor_expr
257
632
{
258
632
None
260
632
power
264
633
(
238
633
NAME
241
633
[
243
633
~
244
633
+
245
633
atom_expr
248
633
NUMBER
251
633
atom
250
633
STRING
252
633
-
253
633
factor
1160
633
True
254
633
False
242
633
{
258
633
None
260
633
power
264
634
factor
236
634
term
237
634
(
238
634
arith_expr
239
634
NAME
241
634
[
243
634
~
244
634
+
245
634
atom_expr
248
634
shift_expr
249
634
atom
250
634
NUMBER
251
634
STRING
252
634
-
253
634
True
254
634
False
242
634
{
258
634
None
260
634
and_expr
1161
634
power
264
635
trailer_expr
1162
635
trailer
635
635
.
636
635
(
637
635
[
638
635
<<
trailer_expr -> 
635
%
trailer_expr -> 
635
==
trailer_expr -> 
635
-
trailer_expr -> 
635
<
trailer_expr -> 
635
if
trailer_expr -> 
635
or
trailer_expr -> 
635
/
trailer_expr -> 
635
**
trailer_expr -> 
635
and
trailer_expr -> 
635
@
trailer_expr -> 
635
*
trailer_expr -> 
635
|
trailer_expr -> 
635
is
trailer_expr -> 
635
,
trailer_expr -> 
635
+
trailer_expr -> 
635
in
trailer_expr -> 
635
&
trailer_expr -> 
635
<=
trailer_expr -> 
635
>=
trailer_expr -> 
635
^
trailer_expr -> 
635
>
trailer_expr -> 
635
!=
trailer_expr -> 
635
not
trailer_expr -> 
635
>>
trailer_expr -> 
635
//
trailer_expr -> 
635
as
trailer_expr -> 
635
:
trailer_expr -> 
636
NAME
1163
637
factor
697
637
term
698
637
(
699
637
arith_expr
700
637
NAME
701
637
[
702
637
atom
703
637
+
704
637
power
706
637
atom_expr
707
637
NUMBER
708
637
STRING
709
637
*
710
637
shift_expr
711
637
-
712
637
argument
714
637
)
1164
637
True
715
637
not_test
716
637
lambdef
717
637
and_expr
718
637
xor_expr
719
637
False
720
637
test
721
637
None
722
637
arglist
1165
637
expr
723
637
and_test
724
637
{
725
637
~
726
637
lambda
727
637
comparison
728
637
or_test
729
637
not
730
637
**
731
638
factor
732
638
or_test
733
638
term
734
638
(
735
638
arith_expr
736
638
NAME
737
638
[
738
638
~
739
638
subscriptlist
1166
638
+
741
638
maybe_test
742
638
expr
743
638
atom_expr
744
638
atom
745
638
NUMBER
746
638
STRING
747
638
shift_expr
748
638
-
749
638
True
750
638
not_test
751
638
and_expr
752
638
xor_expr
753
638
False
754
638
{
755
638
None
756
638
and_test
757
638
lambda
758
638
power
759
638
subscript
760
638
test
761
638
lambdef
762
638
:
maybe_test -> 
638
comparison
763
638
not
764
639
>
atom_expr -> atom trailer_expr
639
as
atom_expr -> atom trailer_expr
639
not
atom_expr -> atom trailer_expr
639
//
atom_expr -> atom trailer_expr
639
>>
atom_expr -> atom trailer_expr
639
|
atom_expr -> atom trailer_expr
639
^
atom_expr -> atom trailer_expr
639
/
atom_expr -> atom trailer_expr
639
+
atom_expr -> atom trailer_expr
639
in
atom_expr -> atom trailer_expr
639
%
atom_expr -> atom trailer_expr
639
and
atom_expr -> atom trailer_expr
639
<=
atom_expr -> atom trailer_expr
639
is
atom_expr -> atom trailer_expr
639
<
atom_expr -> atom trailer_expr
639
@
atom_expr -> atom trailer_expr
639
-
atom_expr -> atom trailer_expr
639
&
atom_expr -> atom trailer_expr
639
:
atom_expr -> atom trailer_expr
639
*
atom_expr -> atom trailer_expr
639
**
atom_expr -> atom trailer_expr
639
>=
atom_expr -> atom trailer_expr
639
or
atom_expr -> atom trailer_expr
639
,
atom_expr -> atom trailer_expr
639
==
atom_expr -> atom trailer_expr
639
!=
atom_expr -> atom trailer_expr
639
if
atom_expr -> atom trailer_expr
639
<<
atom_expr -> atom trailer_expr
640
and
factor -> - factor
640
as
factor -> - factor
640
if
factor -> - factor
640
or
factor -> - factor
640
>=
factor -> - factor
640
<
factor -> - factor
640
!=
factor -> - factor
640
-
factor -> - factor
640
==
factor -> - factor
640
@
factor -> - factor
640
|
factor -> - factor
640
*
factor -> - factor
640
%
factor -> - factor
640
+
factor -> - factor
640
<=
factor -> - factor
640
//
factor -> - factor
640
not
factor -> - factor
640
>>
factor -> - factor
640
/
factor -> - factor
640
&
factor -> - factor
640
^
factor -> - factor
640
in
factor -> - factor
640
is
factor -> - factor
640
>
factor -> - factor
640
,
factor -> - factor
640
:
factor -> - factor
640
<<
factor -> - factor
641
factor
236
641
term
237
641
(
238
641
arith_expr
239
641
NAME
241
641
False
242
641
[
243
641
~
244
641
+
245
641
expr
247
641
atom_expr
248
641
shift_expr
249
641
atom
250
641
NUMBER
251
641
STRING
252
641
-
253
641
True
254
641
not_test
255
641
and_test
1167
641
and_expr
256
641
xor_expr
257
641
{
258
641
None
260
641
comparison
261
641
power
264
641
not
265
642
factor
236
642
term
237
642
(
238
642
arith_expr
239
642
NAME
241
642
[
243
642
~
244
642
+
245
642
atom_expr
248
642
shift_expr
249
642
atom
250
642
NUMBER
251
642
STRING
252
642
-
253
642
True
254
642
and_expr
256
642
False
242
642
{
258
642
None
260
642
xor_expr
1168
642
power
264
643
factor
236
643
term
237
643
(
238
643
arith_expr
239
643
NAME
241
643
[
243
643
~
244
643
+
245
643
atom_expr
248
643
shift_expr
249
643
atom
250
643
NUMBER
251
643
STRING
252
643
-
253
643
True
254
643
and_expr
256
643
xor_expr
257
643
False
242
643
{
258
643
None
260
643
power
264
643
expr
1169
644
>
atom -> { }
644
==
atom -> { }
644
-
atom -> { }
644
not
atom -> { }
644
(
atom -> { }
644
@
atom -> { }
644
if
atom -> { }
644
and
atom -> { }
644
,
atom -> { }
644
:
atom -> { }
644
&
atom -> { }
644
<<
atom -> { }
644
!=
atom -> { }
644
or
atom -> { }
644
>>
atom -> { }
644
<=
atom -> { }
644
>=
atom -> { }
644
is
atom -> { }
644
/
atom -> { }
644
^
atom -> { }
644
[
atom -> { }
644
%
atom -> { }
644
//
atom -> { }
644
*
atom -> { }
644
**
atom -> { }
644
.
atom -> { }
644
in
atom -> { }
644
+
atom -> { }
644
|
atom -> { }
644
<
atom -> { }
644
as
atom -> { }
645
factor
585
645
(
586
645
arith_expr
587
645
NAME
588
645
[
589
645
and_expr
590
645
+
591
645
term
592
645
atom_expr
593
645
NUMBER
594
645
atom
595
645
STRING
596
645
shift_expr
597
645
-
598
645
True
599
645
not
600
645
xor_expr
601
645
None
602
645
False
603
645
not_test
605
645
~
606
645
power
607
645
{
608
645
expr
609
645
or_test
1170
645
comparison
610
645
and_test
611
646
factor
236
646
term
237
646
(
238
646
arith_expr
239
646
NAME
241
646
False
242
646
[
243
646
~
244
646
+
245
646
expr
247
646
atom_expr
248
646
shift_expr
249
646
atom
250
646
NUMBER
251
646
STRING
252
646
-
253
646
True
254
646
not_test
255
646
and_expr
256
646
xor_expr
257
646
{
258
646
None
260
646
comparison
261
646
and_test
262
646
power
264
646
not
265
646
or_test
1171
647
or
not_test -> not not_test
647
,
not_test -> not not_test
647
and
not_test -> not not_test
647
if
not_test -> not not_test
647
as
not_test -> not not_test
647
:
not_test -> not not_test
648
factor
1172
648
term
1173
648
(
1174
648
True
1175
648
~
1176
648
[
1177
648
+
1178
648
STRING
1179
648
atom_expr
1180
648
arith_expr
1181
648
NUMBER
1182
648
NAME
1183
648
False
1184
648
and_expr
1185
648
{
1186
648
None
1187
648
power
1188
648
-
1189
648
shift_expr
1190
648
expr
1191
648
xor_expr
1192
648
atom
1193
649
factor
236
649
term
237
649
(
238
649
arith_expr
239
649
NAME
241
649
False
242
649
[
243
649
~
244
649
+
245
649
lambda
246
649
expr
247
649
atom_expr
248
649
shift_expr
249
649
atom
250
649
NUMBER
251
649
STRING
252
649
-
253
649
True
254
649
not_test
255
649
and_expr
256
649
xor_expr
257
649
{
258
649
or_test
259
649
None
260
649
comparison
261
649
and_test
262
649
lambdef
263
649
power
264
649
not
265
649
test
266
649
with_items
1194
649
with_item
267
650
factor
268
650
(
271
650
NAME
273
650
[
274
650
+
275
650
atom_expr
277
650
NUMBER
278
650
atom
279
650
STRING
280
650
-
282
650
term
1195
650
True
283
650
False
288
650
None
289
650
{
292
650
~
293
650
power
294
651
factor
268
651
(
271
651
NAME
273
651
[
274
651
+
275
651
atom_expr
277
651
NUMBER
278
651
atom
279
651
STRING
280
651
-
282
651
True
283
651
False
288
651
None
289
651
term
1196
651
{
292
651
~
293
651
power
294
652
factor
268
652
(
271
652
NAME
273
652
term
1197
652
[
274
652
+
275
652
atom_expr
277
652
NUMBER
278
652
atom
279
652
STRING
280
652
-
282
652
True
283
652
False
288
652
None
289
652
{
292
652
~
293
652
power
294
653
factor
268
653
(
271
653
NAME
273
653
[
274
653
+
275
653
atom_expr
277
653
NUMBER
278
653
atom
279
653
STRING
280
653
-
282
653
term
1198
653
True
283
653
False
288
653
None
289
653
{
292
653
~
293
653
power
294
654
factor
268
654
(
271
654
NAME
273
654
[
274
654
+
275
654
atom_expr
277
654
NUMBER
278
654
atom
279
654
term
1199
654
STRING
280
654
-
282
654
True
283
654
False
288
654
None
289
654
{
292
654
~
293
654
power
294
655
factor
268
655
term
270
655
(
271
655
NAME
273
655
[
274
655
+
275
655
atom_expr
277
655
NUMBER
278
655
atom
279
655
STRING
280
655
-
282
655
True
283
655
arith_expr
1200
655
False
288
655
None
289
655
{
292
655
~
293
655
power
294
656
factor
268
656
term
270
656
(
271
656
NAME
273
656
[
274
656
+
275
656
atom_expr
277
656
NUMBER
278
656
atom
279
656
STRING
280
656
-
282
656
True
283
656
False
288
656
None
289
656
arith_expr
1201
656
{
292
656
~
293
656
power
294
657
)
1202
658
for
atom -> ( )
658
)
atom -> ( )
658
or
atom -> ( )
658
<<
atom -> ( )
658
not
atom -> ( )
658
&
atom -> ( )
658
(
atom -> ( )
658
in
atom -> ( )
658
**
atom -> ( )
658
@
atom -> ( )
658
<=
atom -> ( )
658
%
atom -> ( )
658
[
atom -> ( )
658
>=
atom -> ( )
658
/
atom -> ( )
658
+
atom -> ( )
658
<
atom -> ( )
658
is
atom -> ( )
658
*
atom -> ( )
658
!=
atom -> ( )
658
-
atom -> ( )
658
|
atom -> ( )
658
//
atom -> ( )
658
^
atom -> ( )
658
and
atom -> ( )
658
==
atom -> ( )
658
if
atom -> ( )
658
>
atom -> ( )
658
,
atom -> ( )
658
.
atom -> ( )
658
>>
atom -> ( )
659
factor
268
659
term
270
659
(
271
659
arith_expr
272
659
NAME
273
659
[
274
659
+
275
659
atom_expr
277
659
NUMBER
278
659
atom
279
659
STRING
280
659
-
282
659
shift_expr
1203
659
True
283
659
False
288
659
None
289
659
{
292
659
~
293
659
power
294
660
factor
268
660
term
270
660
(
271
660
arith_expr
272
660
NAME
273
660
[
274
660
+
275
660
atom_expr
277
660
NUMBER
278
660
atom
279
660
STRING
280
660
-
282
660
True
283
660
shift_expr
1204
660
False
288
660
None
289
660
{
292
660
~
293
660
power
294
661
]
1205
662
<=
atom -> [ ]
662
is
atom -> [ ]
662
-
atom -> [ ]
662
**
atom -> [ ]
662
)
atom -> [ ]
662
^
atom -> [ ]
662
%
atom -> [ ]
662
/
atom -> [ ]
662
>=
atom -> [ ]
662
|
atom -> [ ]
662
not
atom -> [ ]
662
@
atom -> [ ]
662
*
atom -> [ ]
662
(
atom -> [ ]
662
,
atom -> [ ]
662
>>
atom -> [ ]
662
[
atom -> [ ]
662
or
atom -> [ ]
662
!=
atom -> [ ]
662
and
atom -> [ ]
662
<<
atom -> [ ]
662
if
atom -> [ ]
662
in
atom -> [ ]
662
+
atom -> [ ]
662
.
atom -> [ ]
662
==
atom -> [ ]
662
>
atom -> [ ]
662
<
atom -> [ ]
662
for
atom -> [ ]
662
&
atom -> [ ]
662
//
atom -> [ ]
663
<
factor -> + factor
663
if
factor -> + factor
663
<<
factor -> + factor
663
and
factor -> + factor
663
>=
factor -> + factor
663
%
factor -> + factor
663
>>
factor -> + factor
663
*
factor -> + factor
663
+
factor -> + factor
663
)
factor -> + factor
663
/
factor -> + factor
663
>
factor -> + factor
663
<=
factor -> + factor
663
^
factor -> + factor
663
is
factor -> + factor
663
|
factor -> + factor
663
or
factor -> + factor
663
-
factor -> + factor
663
in
factor -> + factor
663
for
factor -> + factor
663
&
factor -> + factor
663
not
factor -> + factor
663
//
factor -> + factor
663
,
factor -> + factor
663
!=
factor -> + factor
663
==
factor -> + factor
663
@
factor -> + factor
664
+
atom -> ( test_list_comp )
664
/
atom -> ( test_list_comp )
664
%=
atom -> ( test_list_comp )
664
*
atom -> ( test_list_comp )
664
[
atom -> ( test_list_comp )
664
&
atom -> ( test_list_comp )
664
,
atom -> ( test_list_comp )
664
**
atom -> ( test_list_comp )
664
>>=
atom -> ( test_list_comp )
664
^
atom -> ( test_list_comp )
664
(
atom -> ( test_list_comp )
664
and
atom -> ( test_list_comp )
664
:
atom -> ( test_list_comp )
664
>
atom -> ( test_list_comp )
664
=
atom -> ( test_list_comp )
664
|=
atom -> ( test_list_comp )
664
-
atom -> ( test_list_comp )
664
/=
atom -> ( test_list_comp )
664
//=
atom -> ( test_list_comp )
664
^=
atom -> ( test_list_comp )
664
%
atom -> ( test_list_comp )
664
*=
atom -> ( test_list_comp )
664
//
atom -> ( test_list_comp )
664
in
atom -> ( test_list_comp )
664
**=
atom -> ( test_list_comp )
664
>>
atom -> ( test_list_comp )
664
not
atom -> ( test_list_comp )
664
>=
atom -> ( test_list_comp )
664
or
atom -> ( test_list_comp )
664
<
atom -> ( test_list_comp )
664
@=
atom -> ( test_list_comp )
664
if
atom -> ( test_list_comp )
664
|
atom -> ( test_list_comp )
664
<<
atom -> ( test_list_comp )
664
@
atom -> ( test_list_comp )
664
!=
atom -> ( test_list_comp )
664
+=
atom -> ( test_list_comp )
664
NEWLINE
atom -> ( test_list_comp )
664
<<=
atom -> ( test_list_comp )
664
is
atom -> ( test_list_comp )
664
.
atom -> ( test_list_comp )
664
<=
atom -> ( test_list_comp )
664
&=
atom -> ( test_list_comp )
664
-=
atom -> ( test_list_comp )
664
==
atom -> ( test_list_comp )
665
(
271
665
NAME
273
665
[
274
665
+
275
665
atom_expr
277
665
NUMBER
278
665
atom
279
665
STRING
280
665
-
282
665
factor
1206
665
True
283
665
False
288
665
None
289
665
{
292
665
~
293
665
power
294
666
trailer_expr
1207
666
trailer
666
666
.
667
666
(
668
666
[
669
666
<<
trailer_expr -> 
666
%
trailer_expr -> 
666
==
trailer_expr -> 
666
-
trailer_expr -> 
666
<
trailer_expr -> 
666
if
trailer_expr -> 
666
or
trailer_expr -> 
666
/
trailer_expr -> 
666
**
trailer_expr -> 
666
and
trailer_expr -> 
666
@
trailer_expr -> 
666
*
trailer_expr -> 
666
|
trailer_expr -> 
666
is
trailer_expr -> 
666
,
trailer_expr -> 
666
+
trailer_expr -> 
666
in
trailer_expr -> 
666
for
trailer_expr -> 
666
&
trailer_expr -> 
666
<=
trailer_expr -> 
666
>=
trailer_expr -> 
666
^
trailer_expr -> 
666
>
trailer_expr -> 
666
!=
trailer_expr -> 
666
)
trailer_expr -> 
666
not
trailer_expr -> 
666
>>
trailer_expr -> 
666
//
trailer_expr -> 
667
NAME
1208
668
factor
697
668
term
698
668
(
699
668
arith_expr
700
668
NAME
701
668
[
702
668
atom
703
668
+
704
668
power
706
668
atom_expr
707
668
NUMBER
708
668
STRING
709
668
*
710
668
shift_expr
711
668
-
712
668
argument
714
668
)
1209
668
True
715
668
not_test
716
668
lambdef
717
668
and_expr
718
668
xor_expr
719
668
False
720
668
test
721
668
None
722
668
arglist
1210
668
expr
723
668
and_test
724
668
{
725
668
~
726
668
lambda
727
668
comparison
728
668
or_test
729
668
not
730
668
**
731
669
factor
732
669
or_test
733
669
term
734
669
(
735
669
arith_expr
736
669
NAME
737
669
[
738
669
~
739
669
subscriptlist
1211
669
+
741
669
maybe_test
742
669
expr
743
669
atom_expr
744
669
atom
745
669
NUMBER
746
669
STRING
747
669
shift_expr
748
669
-
749
669
True
750
669
not_test
751
669
and_expr
752
669
xor_expr
753
669
False
754
669
{
755
669
None
756
669
and_test
757
669
lambda
758
669
power
759
669
subscript
760
669
test
761
669
lambdef
762
669
:
maybe_test -> 
669
comparison
763
669
not
764
670
>
atom_expr -> atom trailer_expr
670
not
atom_expr -> atom trailer_expr
670
//
atom_expr -> atom trailer_expr
670
>>
atom_expr -> atom trailer_expr
670
|
atom_expr -> atom trailer_expr
670
^
atom_expr -> atom trailer_expr
670
/
atom_expr -> atom trailer_expr
670
+
atom_expr -> atom trailer_expr
670
in
atom_expr -> atom trailer_expr
670
%
atom_expr -> atom trailer_expr
670
and
atom_expr -> atom trailer_expr
670
<=
atom_expr -> atom trailer_expr
670
is
atom_expr -> atom trailer_expr
670
<
atom_expr -> atom trailer_expr
670
@
atom_expr -> atom trailer_expr
670
-
atom_expr -> atom trailer_expr
670
&
atom_expr -> atom trailer_expr
670
*
atom_expr -> atom trailer_expr
670
**
atom_expr -> atom trailer_expr
670
>=
atom_expr -> atom trailer_expr
670
)
atom_expr -> atom trailer_expr
670
for
atom_expr -> atom trailer_expr
670
or
atom_expr -> atom trailer_expr
670
,
atom_expr -> atom trailer_expr
670
==
atom_expr -> atom trailer_expr
670
!=
atom_expr -> atom trailer_expr
670
if
atom_expr -> atom trailer_expr
670
<<
atom_expr -> atom trailer_expr
671
factor
268
671
term
270
671
(
271
671
arith_expr
272
671
NAME
273
671
[
274
671
+
275
671
atom_expr
277
671
NUMBER
278
671
atom
279
671
STRING
280
671
shift_expr
281
671
-
282
671
True
283
671
False
288
671
None
289
671
and_expr
1212
671
{
292
671
~
293
671
power
294
672
for
factor -> - factor
672
and
factor -> - factor
672
if
factor -> - factor
672
or
factor -> - factor
672
>=
factor -> - factor
672
<
factor -> - factor
672
!=
factor -> - factor
672
-
factor -> - factor
672
==
factor -> - factor
672
@
factor -> - factor
672
|
factor -> - factor
672
*
factor -> - factor
672
%
factor -> - factor
672
+
factor -> - factor
672
<=
factor -> - factor
672
//
factor -> - factor
672
not
factor -> - factor
672
>>
factor -> - factor
672
/
factor -> - factor
672
&
factor -> - factor
672
^
factor -> - factor
672
)
factor -> - factor
672
in
factor -> - factor
672
is
factor -> - factor
672
>
factor -> - factor
672
,
factor -> - factor
672
<<
factor -> - factor
673
factor
268
673
term
270
673
(
271
673
arith_expr
272
673
NAME
273
673
[
274
673
+
275
673
atom_expr
277
673
NUMBER
278
673
atom
279
673
STRING
280
673
shift_expr
281
673
-
282
673
True
283
673
not_test
284
673
and_expr
286
673
xor_expr
287
673
False
288
673
None
289
673
expr
290
673
{
292
673
~
293
673
and_test
1213
673
power
294
673
comparison
296
673
not
298
674
factor
268
674
term
270
674
(
271
674
arith_expr
272
674
NAME
273
674
[
274
674
+
275
674
atom_expr
277
674
NUMBER
278
674
atom
279
674
STRING
280
674
shift_expr
281
674
-
282
674
True
283
674
and_expr
286
674
False
288
674
None
289
674
xor_expr
1214
674
{
292
674
~
293
674
power
294
675
factor
268
675
term
270
675
(
271
675
arith_expr
272
675
NAME
273
675
[
274
675
+
275
675
atom_expr
277
675
NUMBER
278
675
atom
279
675
STRING
280
675
shift_expr
281
675
-
282
675
True
283
675
and_expr
286
675
xor_expr
287
675
False
288
675
None
289
675
{
292
675
~
293
675
power
294
675
expr
1215
676
factor
268
676
term
270
676
(
271
676
arith_expr
272
676
NAME
273
676
[
274
676
+
275
676
atom_expr
277
676
NUMBER
278
676
atom
279
676
STRING
280
676
shift_expr
281
676
-
282
676
True
283
676
and_expr
286
676
comparison
1216
676
xor_expr
287
676
False
288
676
None
289
676
expr
290
676
{
292
676
~
293
676
power
294
677
factor
268
677
term
270
677
(
271
677
arith_expr
272
677
NAME
273
677
[
274
677
+
275
677
atom_expr
277
677
NUMBER
278
677
atom
279
677
STRING
280
677
shift_expr
281
677
-
282
677
True
283
677
not_test
284
677
and_expr
286
677
xor_expr
287
677
False
288
677
None
289
677
expr
290
677
and_test
291
677
{
292
677
~
293
677
power
294
677
comparison
296
677
or_test
1217
677
not
298
678
>
atom -> { }
678
==
atom -> { }
678
)
atom -> { }
678
-
atom -> { }
678
not
atom -> { }
678
(
atom -> { }
678
@
atom -> { }
678
if
atom -> { }
678
and
atom -> { }
678
,
atom -> { }
678
&
atom -> { }
678
<<
atom -> { }
678
!=
atom -> { }
678
or
atom -> { }
678
>>
atom -> { }
678
<=
atom -> { }
678
>=
atom -> { }
678
is
atom -> { }
678
/
atom -> { }
678
^
atom -> { }
678
[
atom -> { }
678
%
atom -> { }
678
//
atom -> { }
678
*
atom -> { }
678
**
atom -> { }
678
.
atom -> { }
678
for
atom -> { }
678
in
atom -> { }
678
+
atom -> { }
678
|
atom -> { }
678
<
atom -> { }
679
or
factor -> ~ factor
679
==
factor -> ~ factor
679
<=
factor -> ~ factor
679
@
factor -> ~ factor
679
!=
factor -> ~ factor
679
>=
factor -> ~ factor
679
>
factor -> ~ factor
679
and
factor -> ~ factor
679
,
factor -> ~ factor
679
*
factor -> ~ factor
679
&
factor -> ~ factor
679
%
factor -> ~ factor
679
<
factor -> ~ factor
679
//
factor -> ~ factor
679
if
factor -> ~ factor
679
^
factor -> ~ factor
679
/
factor -> ~ factor
679
for
factor -> ~ factor
679
in
factor -> ~ factor
679
+
factor -> ~ factor
679
not
factor -> ~ factor
679
-
factor -> ~ factor
679
is
factor -> ~ factor
679
)
factor -> ~ factor
679
>>
factor -> ~ factor
679
<<
factor -> ~ factor
679
|
factor -> ~ factor
680
factor
268
680
term
270
680
(
271
680
arith_expr
272
680
NAME
273
680
[
274
680
+
275
680
atom_expr
277
680
NUMBER
278
680
atom
279
680
STRING
280
680
shift_expr
281
680
-
282
680
True
283
680
not_test
284
680
lambdef
285
680
and_expr
286
680
xor_expr
287
680
False
288
680
None
289
680
expr
290
680
and_test
291
680
{
292
680
~
293
680
power
294
680
lambda
295
680
test
1218
680
comparison
296
680
or_test
297
680
not
298
681
:
1219
682
factor
585
682
(
586
682
arith_expr
587
682
NAME
588
682
[
589
682
and_expr
590
682
+
591
682
term
592
682
atom_expr
593
682
NUMBER
594
682
atom
595
682
STRING
596
682
shift_expr
597
682
-
598
682
True
599
682
not
600
682
xor_expr
601
682
None
602
682
False
603
682
not_test
605
682
or_test
1220
682
~
606
682
power
607
682
{
608
682
expr
609
682
comparison
610
682
and_test
611
683
)
not_test -> not not_test
683
or
not_test -> not not_test
683
,
not_test -> not not_test
683
and
not_test -> not not_test
683
if
not_test -> not not_test
683
for
not_test -> not not_test
684
)
test_list_comp -> test comp_for
685
factor
1221
685
term
1222
685
(
1223
685
arith_expr
1224
685
NAME
1225
685
[
1226
685
+
1227
685
atom_expr
1228
685
NUMBER
1229
685
atom
1230
685
STRING
1231
685
shift_expr
1232
685
-
1233
685
True
1234
685
not_test
1235
685
and_expr
1236
685
xor_expr
1237
685
None
1238
685
False
1239
685
and_test
1240
685
{
1241
685
~
1242
685
power
1243
685
expr
1244
685
lambda
1245
685
comparison
1246
685
or_test
1247
685
test_list
1248
685
not
1249
685
test
1250
685
lambdef
1251
686
factor
152
686
NUMBER
153
686
term
155
686
(
156
686
True
157
686
[
158
686
+
159
686
STRING
160
686
atom_expr
161
686
arith_expr
162
686
expr
163
686
~
164
686
NAME
165
686
False
166
686
{
167
686
and_expr
168
686
xor_expr
169
686
expr_list
1252
686
None
170
686
power
171
686
-
172
686
shift_expr
173
686
atom
174
687
NEWLINE
or_test -> and_test or or_test
687
,
or_test -> and_test or or_test
687
-=
or_test -> and_test or or_test
687
*=
or_test -> and_test or or_test
687
^=
or_test -> and_test or or_test
687
>>=
or_test -> and_test or or_test
687
**=
or_test -> and_test or or_test
687
@=
or_test -> and_test or or_test
687
%=
or_test -> and_test or or_test
687
&=
or_test -> and_test or or_test
687
if
or_test -> and_test or or_test
687
//=
or_test -> and_test or or_test
687
=
or_test -> and_test or or_test
687
|=
or_test -> and_test or or_test
687
<<=
or_test -> and_test or or_test
687
/=
or_test -> and_test or or_test
687
+=
or_test -> and_test or or_test
687
:
or_test -> and_test or or_test
688
NEWLINE
1253
689
NAME
1254
690
factor
9
690
arith_expr
2
690
NAME
29
690
term
21
690
[
3
690
~
45
690
atom_expr
24
690
expr
16
690
power
56
690
(
36
690
True
17
690
not_test
18
690
and_expr
19
690
xor_expr
22
690
lambdef
53
690
atom
54
690
or_test
23
690
shift_expr
50
690
False
35
690
-
49
690
None
42
690
lambda
40
690
NUMBER
27
690
STRING
28
690
{
52
690
and_test
37
690
comparison
39
690
test
1255
690
+
55
690
not
57
691
*=
lambdef -> lambda : test
691
^=
lambdef -> lambda : test
691
:
lambdef -> lambda : test
691
/=
lambdef -> lambda : test
691
NEWLINE
lambdef -> lambda : test
691
**=
lambdef -> lambda : test
691
,
lambdef -> lambda : test
691
<<=
lambdef -> lambda : test
691
@=
lambdef -> lambda : test
691
>>=
lambdef -> lambda : test
691
-=
lambdef -> lambda : test
691
%=
lambdef -> lambda : test
691
&=
lambdef -> lambda : test
691
//=
lambdef -> lambda : test
691
+=
lambdef -> lambda : test
691
=
lambdef -> lambda : test
691
|=
lambdef -> lambda : test
692
NAME
305
692
vfpdef
306
692
varargslist
1256
693
factor
9
693
arith_expr
2
693
NAME
29
693
term
21
693
[
3
693
~
45
693
suite
1257
693
atom_expr
24
693
expr
16
693
power
56
693
(
36
693
return
13
693
small_stmt
1258
693
flow_stmt
15
693
True
17
693
not_test
18
693
and_expr
19
693
xor_expr
22
693
{
52
693
lambdef
53
693
atom
54
693
or_test
23
693
shift_expr
50
693
False
35
693
NEWLINE
1259
693
-
49
693
None
42
693
lambda
40
693
global
25
693
NUMBER
27
693
STRING
28
693
test
48
693
endsim
33
693
and_test
37
693
simple_stmt
1260
693
comparison
39
693
break_stmt
74
693
+
55
693
not
57
693
raise
62
693
continue
59
693
return_stmt
75
693
del_stmt
60
693
test_list
61
693
raise_stmt
63
693
resetstats
64
693
pass_stmt
65
693
nonlocal
66
693
break
76
693
sim_stmt
77
693
stat_stmt
78
693
global_stmt
67
693
yield_stmt
79
693
assert_stmt
80
693
pass
81
693
yield
68
693
continue_stmt
69
693
assert
70
693
nonlocal_stmt
71
693
expr_stmt
72
693
begsim
83
693
del
84
694
//=
test_list -> test , test_list
694
**=
test_list -> test , test_list
694
^=
test_list -> test , test_list
694
:
test_list -> test , test_list
694
-=
test_list -> test , test_list
694
>>=
test_list -> test , test_list
694
=
test_list -> test , test_list
694
*=
test_list -> test , test_list
694
/=
test_list -> test , test_list
694
+=
test_list -> test , test_list
694
@=
test_list -> test , test_list
694
<<=
test_list -> test , test_list
694
NEWLINE
test_list -> test , test_list
694
&=
test_list -> test , test_list
694
|=
test_list -> test , test_list
694
%=
test_list -> test , test_list
695
<<=
and_expr -> shift_expr & and_expr
695
/=
and_expr -> shift_expr & and_expr
695
,
and_expr -> shift_expr & and_expr
695
>
and_expr -> shift_expr & and_expr
695
or
and_expr -> shift_expr & and_expr
695
<=
and_expr -> shift_expr & and_expr
695
**=
and_expr -> shift_expr & and_expr
695
@=
and_expr -> shift_expr & and_expr
695
and
and_expr -> shift_expr & and_expr
695
NEWLINE
and_expr -> shift_expr & and_expr
695
is
and_expr -> shift_expr & and_expr
695
>>=
and_expr -> shift_expr & and_expr
695
+=
and_expr -> shift_expr & and_expr
695
if
and_expr -> shift_expr & and_expr
695
==
and_expr -> shift_expr & and_expr
695
&=
and_expr -> shift_expr & and_expr
695
*=
and_expr -> shift_expr & and_expr
695
-=
and_expr -> shift_expr & and_expr
695
^=
and_expr -> shift_expr & and_expr
695
//=
and_expr -> shift_expr & and_expr
695
|
and_expr -> shift_expr & and_expr
695
|=
and_expr -> shift_expr & and_expr
695
>=
and_expr -> shift_expr & and_expr
695
<
and_expr -> shift_expr & and_expr
695
%=
and_expr -> shift_expr & and_expr
695
=
and_expr -> shift_expr & and_expr
695
!=
and_expr -> shift_expr & and_expr
695
:
and_expr -> shift_expr & and_expr
695
^
and_expr -> shift_expr & and_expr
695
in
and_expr -> shift_expr & and_expr
695
not
and_expr -> shift_expr & and_expr
696
+
trailer_expr -> trailer trailer_expr
696
,
trailer_expr -> trailer trailer_expr
696
*
trailer_expr -> trailer trailer_expr
696
/
trailer_expr -> trailer trailer_expr
696
not
trailer_expr -> trailer trailer_expr
696
<<
trailer_expr -> trailer trailer_expr
696
!=
trailer_expr -> trailer trailer_expr
696
>>=
trailer_expr -> trailer trailer_expr
696
*=
trailer_expr -> trailer trailer_expr
696
=
trailer_expr -> trailer trailer_expr
696
>=
trailer_expr -> trailer trailer_expr
696
@=
trailer_expr -> trailer trailer_expr
696
>>
trailer_expr -> trailer trailer_expr
696
|
trailer_expr -> trailer trailer_expr
696
%
trailer_expr -> trailer trailer_expr
696
>
trailer_expr -> trailer trailer_expr
696
-
trailer_expr -> trailer trailer_expr
696
**=
trailer_expr -> trailer trailer_expr
696
&
trailer_expr -> trailer trailer_expr
696
<=
trailer_expr -> trailer trailer_expr
696
:
trailer_expr -> trailer trailer_expr
696
|=
trailer_expr -> trailer trailer_expr
696
**
trailer_expr -> trailer trailer_expr
696
@
trailer_expr -> trailer trailer_expr
696
if
trailer_expr -> trailer trailer_expr
696
&=
trailer_expr -> trailer trailer_expr
696
NEWLINE
trailer_expr -> trailer trailer_expr
696
/=
trailer_expr -> trailer trailer_expr
696
<<=
trailer_expr -> trailer trailer_expr
696
==
trailer_expr -> trailer trailer_expr
696
-=
trailer_expr -> trailer trailer_expr
696
or
trailer_expr -> trailer trailer_expr
696
%=
trailer_expr -> trailer trailer_expr
696
<
trailer_expr -> trailer trailer_expr
696
and
trailer_expr -> trailer trailer_expr
696
//=
trailer_expr -> trailer trailer_expr
696
+=
trailer_expr -> trailer trailer_expr
696
in
trailer_expr -> trailer trailer_expr
696
is
trailer_expr -> trailer trailer_expr
696
^=
trailer_expr -> trailer trailer_expr
696
^
trailer_expr -> trailer trailer_expr
696
//
trailer_expr -> trailer trailer_expr
697
//
1261
697
in
term -> factor
697
-
term -> factor
697
*
1262
697
%
1263
697
@
1264
697
>=
term -> factor
697
/
1265
697
=
term -> factor
697
<
term -> factor
697
<=
term -> factor
697
==
term -> factor
697
!=
term -> factor
697
>>
term -> factor
697
is
term -> factor
697
or
term -> factor
697
and
term -> factor
697
for
term -> factor
697
^
term -> factor
697
,
term -> factor
697
+
term -> factor
697
&
term -> factor
697
<<
term -> factor
697
|
term -> factor
697
)
term -> factor
697
>
term -> factor
697
if
term -> factor
697
not
term -> factor
698
+
1266
698
-
1267
698
for
arith_expr -> term
698
|
arith_expr -> term
698
)
arith_expr -> term
698
or
arith_expr -> term
698
not
arith_expr -> term
698
<=
arith_expr -> term
698
!=
arith_expr -> term
698
<
arith_expr -> term
698
=
arith_expr -> term
698
&
arith_expr -> term
698
>=
arith_expr -> term
698
if
arith_expr -> term
698
==
arith_expr -> term
698
^
arith_expr -> term
698
in
arith_expr -> term
698
is
arith_expr -> term
698
<<
arith_expr -> term
698
,
arith_expr -> term
698
>
arith_expr -> term
698
and
arith_expr -> term
698
>>
arith_expr -> term
699
factor
268
699
term
270
699
(
271
699
arith_expr
272
699
NAME
273
699
[
274
699
+
275
699
test_list_comp
1268
699
atom_expr
277
699
NUMBER
278
699
atom
279
699
STRING
280
699
shift_expr
281
699
-
282
699
True
283
699
not_test
284
699
lambdef
285
699
and_expr
286
699
xor_expr
287
699
False
288
699
None
289
699
expr
290
699
and_test
291
699
)
1269
699
{
292
699
~
293
699
power
294
699
lambda
295
699
comparison
296
699
or_test
297
699
not
298
699
test
299
699
test_list
300
700
>>
1270
700
<<
1271
700
&
shift_expr -> arith_expr
700
<=
shift_expr -> arith_expr
700
>
shift_expr -> arith_expr
700
)
shift_expr -> arith_expr
700
not
shift_expr -> arith_expr
700
!=
shift_expr -> arith_expr
700
^
shift_expr -> arith_expr
700
is
shift_expr -> arith_expr
700
|
shift_expr -> arith_expr
700
=
shift_expr -> arith_expr
700
>=
shift_expr -> arith_expr
700
or
shift_expr -> arith_expr
700
,
shift_expr -> arith_expr
700
==
shift_expr -> arith_expr
700
if
shift_expr -> arith_expr
700
and
shift_expr -> arith_expr
700
<
shift_expr -> arith_expr
700
for
shift_expr -> arith_expr
700
in
shift_expr -> arith_expr
701
-
atom -> NAME
701
,
atom -> NAME
701
for
atom -> NAME
701
or
atom -> NAME
701
>>
atom -> NAME
701
&
atom -> NAME
701
[
atom -> NAME
701
<=
atom -> NAME
701
<
atom -> NAME
701
.
atom -> NAME
701
|
atom -> NAME
701
*
atom -> NAME
701
/
atom -> NAME
701
<<
atom -> NAME
701
not
atom -> NAME
701
>
atom -> NAME
701
=
atom -> NAME
701
is
atom -> NAME
701
//
atom -> NAME
701
+
atom -> NAME
701
if
atom -> NAME
701
in
atom -> NAME
701
**
atom -> NAME
701
!=
atom -> NAME
701
>=
atom -> NAME
701
)
atom -> NAME
701
^
atom -> NAME
701
@
atom -> NAME
701
(
atom -> NAME
701
==
atom -> NAME
701
and
atom -> NAME
701
%
atom -> NAME
702
factor
117
702
or_test
118
702
term
119
702
(
120
702
test_list_comp
1272
702
arith_expr
121
702
NAME
122
702
[
123
702
]
1273
702
+
125
702
atom_expr
126
702
NUMBER
127
702
atom
128
702
STRING
129
702
shift_expr
130
702
-
131
702
True
133
702
not_test
134
702
lambdef
135
702
and_expr
136
702
xor_expr
137
702
False
138
702
None
139
702
expr
140
702
and_test
141
702
{
142
702
~
143
702
lambda
144
702
power
145
702
comparison
146
702
test_list
147
702
test
148
702
not
149
703
trailer
1274
703
.
1275
703
(
1276
703
[
1277
703
trailer_expr
1278
703
<<
trailer_expr -> 
703
%
trailer_expr -> 
703
==
trailer_expr -> 
703
-
trailer_expr -> 
703
<
trailer_expr -> 
703
if
trailer_expr -> 
703
or
trailer_expr -> 
703
/
trailer_expr -> 
703
**
trailer_expr -> 
703
and
trailer_expr -> 
703
@
trailer_expr -> 
703
=
trailer_expr -> 
703
*
trailer_expr -> 
703
|
trailer_expr -> 
703
is
trailer_expr -> 
703
,
trailer_expr -> 
703
+
trailer_expr -> 
703
in
trailer_expr -> 
703
for
trailer_expr -> 
703
&
trailer_expr -> 
703
<=
trailer_expr -> 
703
>=
trailer_expr -> 
703
^
trailer_expr -> 
703
>
trailer_expr -> 
703
!=
trailer_expr -> 
703
)
trailer_expr -> 
703
not
trailer_expr -> 
703
>>
trailer_expr -> 
703
//
trailer_expr -> 
704
(
699
704
NAME
701
704
[
702
704
atom
703
704
+
704
704
atom_expr
707
704
power
706
704
NUMBER
708
704
STRING
709
704
-
712
704
factor
1279
704
True
715
704
False
720
704
None
722
704
{
725
704
~
726
705
)
1280
706
&
factor -> power
706
%
factor -> power
706
<<
factor -> power
706
-
factor -> power
706
<=
factor -> power
706
not
factor -> power
706
//
factor -> power
706
/
factor -> power
706
is
factor -> power
706
for
factor -> power
706
|
factor -> power
706
<
factor -> power
706
and
factor -> power
706
>=
factor -> power
706
>>
factor -> power
706
>
factor -> power
706
)
factor -> power
706
in
factor -> power
706
=
factor -> power
706
if
factor -> power
706
^
factor -> power
706
==
factor -> power
706
+
factor -> power
706
,
factor -> power
706
@
factor -> power
706
or
factor -> power
706
*
factor -> power
706
!=
factor -> power
707
!=
power -> atom_expr
707
**
1281
707
>
power -> atom_expr
707
+
power -> atom_expr
707
not
power -> atom_expr
707
&
power -> atom_expr
707
|
power -> atom_expr
707
>>
power -> atom_expr
707
^
power -> atom_expr
707
==
power -> atom_expr
707
if
power -> atom_expr
707
in
power -> atom_expr
707
%
power -> atom_expr
707
for
power -> atom_expr
707
<<
power -> atom_expr
707
or
power -> atom_expr
707
@
power -> atom_expr
707
=
power -> atom_expr
707
*
power -> atom_expr
707
/
power -> atom_expr
707
)
power -> atom_expr
707
<
power -> atom_expr
707
//
power -> atom_expr
707
>=
power -> atom_expr
707
-
power -> atom_expr
707
is
power -> atom_expr
707
<=
power -> atom_expr
707
and
power -> atom_expr
707
,
power -> atom_expr
708
[
atom -> NUMBER
708
=
atom -> NUMBER
708
>=
atom -> NUMBER
708
<=
atom -> NUMBER
708
!=
atom -> NUMBER
708
//
atom -> NUMBER
708
in
atom -> NUMBER
708
/
atom -> NUMBER
708
or
atom -> NUMBER
708
>
atom -> NUMBER
708
,
atom -> NUMBER
708
not
atom -> NUMBER
708
>>
atom -> NUMBER
708
(
atom -> NUMBER
708
**
atom -> NUMBER
708
<<
atom -> NUMBER
708
and
atom -> NUMBER
708
+
atom -> NUMBER
708
%
atom -> NUMBER
708
)
atom -> NUMBER
708
==
atom -> NUMBER
708
for
atom -> NUMBER
708
if
atom -> NUMBER
708
is
atom -> NUMBER
708
*
atom -> NUMBER
708
@
atom -> NUMBER
708
|
atom -> NUMBER
708
-
atom -> NUMBER
708
.
atom -> NUMBER
708
^
atom -> NUMBER
708
<
atom -> NUMBER
708
&
atom -> NUMBER
709
and
atom -> STRING
709
for
atom -> STRING
709
%
atom -> STRING
709
//
atom -> STRING
709
>>
atom -> STRING
709
*
atom -> STRING
709
<
atom -> STRING
709
.
atom -> STRING
709
in
atom -> STRING
709
^
atom -> STRING
709
=
atom -> STRING
709
(
atom -> STRING
709
if
atom -> STRING
709
==
atom -> STRING
709
-
atom -> STRING
709
**
atom -> STRING
709
<<
atom -> STRING
709
<=
atom -> STRING
709
[
atom -> STRING
709
not
atom -> STRING
709
or
atom -> STRING
709
)
atom -> STRING
709
+
atom -> STRING
709
>=
atom -> STRING
709
@
atom -> STRING
709
&
atom -> STRING
709
>
atom -> STRING
709
is
atom -> STRING
709
,
atom -> STRING
709
|
atom -> STRING
709
!=
atom -> STRING
709
/
atom -> STRING
710
factor
1221
710
term
1222
710
(
1223
710
arith_expr
1224
710
NAME
1225
710
[
1226
710
+
1227
710
atom_expr
1228
710
NUMBER
1229
710
atom
1230
710
STRING
1231
710
shift_expr
1232
710
-
1233
710
True
1234
710
not_test
1235
710
and_expr
1236
710
xor_expr
1237
710
None
1238
710
False
1239
710
test
1282
710
and_test
1240
710
{
1241
710
~
1242
710
power
1243
710
expr
1244
710
lambda
1245
710
comparison
1246
710
or_test
1247
710
not
1249
710
lambdef
1251
711
&
1283
711
^
and_expr -> shift_expr
711
|
and_expr -> shift_expr
711
<=
and_expr -> shift_expr
711
=
and_expr -> shift_expr
711
)
and_expr -> shift_expr
711
for
and_expr -> shift_expr
711
or
and_expr -> shift_expr
711
>
and_expr -> shift_expr
711
not
and_expr -> shift_expr
711
,
and_expr -> shift_expr
711
!=
and_expr -> shift_expr
711
and
and_expr -> shift_expr
711
is
and_expr -> shift_expr
711
<
and_expr -> shift_expr
711
if
and_expr -> shift_expr
711
in
and_expr -> shift_expr
711
>=
and_expr -> shift_expr
711
==
and_expr -> shift_expr
712
(
699
712
NAME
701
712
[
702
712
atom
703
712
+
704
712
atom_expr
707
712
power
706
712
NUMBER
708
712
STRING
709
712
-
712
712
True
715
712
False
720
712
None
722
712
{
725
712
~
726
712
factor
1284
713
%
trailer -> ( )
713
<=
trailer -> ( )
713
and
trailer -> ( )
713
//
trailer -> ( )
713
not
trailer -> ( )
713
&=
trailer -> ( )
713
**=
trailer -> ( )
713
or
trailer -> ( )
713
NEWLINE
trailer -> ( )
713
|=
trailer -> ( )
713
>>
trailer -> ( )
713
^=
trailer -> ( )
713
>
trailer -> ( )
713
*=
trailer -> ( )
713
<<
trailer -> ( )
713
[
trailer -> ( )
713
is
trailer -> ( )
713
<<=
trailer -> ( )
713
:
trailer -> ( )
713
%=
trailer -> ( )
713
-
trailer -> ( )
713
**
trailer -> ( )
713
/
trailer -> ( )
713
@=
trailer -> ( )
713
+=
trailer -> ( )
713
,
trailer -> ( )
713
&
trailer -> ( )
713
in
trailer -> ( )
713
+
trailer -> ( )
713
!=
trailer -> ( )
713
^
trailer -> ( )
713
//=
trailer -> ( )
713
-=
trailer -> ( )
713
*
trailer -> ( )
713
/=
trailer -> ( )
713
if
trailer -> ( )
713
>>=
trailer -> ( )
713
>=
trailer -> ( )
713
(
trailer -> ( )
713
@
trailer -> ( )
713
=
trailer -> ( )
713
==
trailer -> ( )
713
|
trailer -> ( )
713
.
trailer -> ( )
713
<
trailer -> ( )
714
,
1285
714
)
arglist -> argument
715
(
atom -> True
715
for
atom -> True
715
[
atom -> True
715
+
atom -> True
715
@
atom -> True
715
<=
atom -> True
715
&
atom -> True
715
=
atom -> True
715
<<
atom -> True
715
-
atom -> True
715
/
atom -> True
715
)
atom -> True
715
or
atom -> True
715
>
atom -> True
715
%
atom -> True
715
^
atom -> True
715
if
atom -> True
715
!=
atom -> True
715
is
atom -> True
715
*
atom -> True
715
<
atom -> True
715
,
atom -> True
715
and
atom -> True
715
.
atom -> True
715
==
atom -> True
715
**
atom -> True
715
>>
atom -> True
715
in
atom -> True
715
|
atom -> True
715
>=
atom -> True
715
//
atom -> True
715
not
atom -> True
716
and
1286
716
=
and_test -> not_test
716
or
and_test -> not_test
716
)
and_test -> not_test
716
,
and_test -> not_test
716
if
and_test -> not_test
716
for
and_test -> not_test
717
,
test -> lambdef
717
=
test -> lambdef
717
for
test -> lambdef
717
)
test -> lambdef
718
^
1287
718
=
xor_expr -> and_expr
718
not
xor_expr -> and_expr
718
if
xor_expr -> and_expr
718
<=
xor_expr -> and_expr
718
,
xor_expr -> and_expr
718
>
xor_expr -> and_expr
718
<
xor_expr -> and_expr
718
in
xor_expr -> and_expr
718
>=
xor_expr -> and_expr
718
for
xor_expr -> and_expr
718
==
xor_expr -> and_expr
718
|
xor_expr -> and_expr
718
is
xor_expr -> and_expr
718
and
xor_expr -> and_expr
718
or
xor_expr -> and_expr
718
)
xor_expr -> and_expr
718
!=
xor_expr -> and_expr
719
|
1288
719
>=
expr -> xor_expr
719
,
expr -> xor_expr
719
==
expr -> xor_expr
719
)
expr -> xor_expr
719
is
expr -> xor_expr
719
if
expr -> xor_expr
719
or
expr -> xor_expr
719
for
expr -> xor_expr
719
>
expr -> xor_expr
719
and
expr -> xor_expr
719
<
expr -> xor_expr
719
in
expr -> xor_expr
719
<=
expr -> xor_expr
719
=
expr -> xor_expr
719
not
expr -> xor_expr
719
!=
expr -> xor_expr
720
in
atom -> False
720
>
atom -> False
720
-
atom -> False
720
%
atom -> False
720
<
atom -> False
720
|
atom -> False
720
==
atom -> False
720
&
atom -> False
720
//
atom -> False
720
and
atom -> False
720
not
atom -> False
720
+
atom -> False
720
!=
atom -> False
720
if
atom -> False
720
for
atom -> False
720
)
atom -> False
720
@
atom -> False
720
[
atom -> False
720
or
atom -> False
720
<=
atom -> False
720
=
atom -> False
720
*
atom -> False
720
^
atom -> False
720
is
atom -> False
720
/
atom -> False
720
.
atom -> False
720
>=
atom -> False
720
**
atom -> False
720
>>
atom -> False
720
,
atom -> False
720
<<
atom -> False
720
(
atom -> False
721
for
1289
721
comp_for
1290
721
=
1291
721
,
argument -> test
721
)
argument -> test
722
is
atom -> None
722
.
atom -> None
722
==
atom -> None
722
^
atom -> None
722
<<
atom -> None
722
>>
atom -> None
722
(
atom -> None
722
|
atom -> None
722
=
atom -> None
722
+
atom -> None
722
for
atom -> None
722
*
atom -> None
722
//
atom -> None
722
@
atom -> None
722
in
atom -> None
722
>=
atom -> None
722
!=
atom -> None
722
%
atom -> None
722
[
atom -> None
722
and
atom -> None
722
-
atom -> None
722
)
atom -> None
722
if
atom -> None
722
&
atom -> None
722
<=
atom -> None
722
<
atom -> None
722
>
atom -> None
722
,
atom -> None
722
**
atom -> None
722
or
atom -> None
722
/
atom -> None
722
not
atom -> None
723
is
215
723
<
217
723
!=
218
723
in
219
723
<=
220
723
not
221
723
>=
222
723
>
223
723
==
224
723
comp_op
1292
723
and
comparison -> expr
723
or
comparison -> expr
723
=
comparison -> expr
723
if
comparison -> expr
723
,
comparison -> expr
723
)
comparison -> expr
723
for
comparison -> expr
724
,
or_test -> and_test
724
or
1293
724
=
or_test -> and_test
724
for
or_test -> and_test
724
)
or_test -> and_test
724
if
or_test -> and_test
725
}
1294
726
(
699
726
NAME
701
726
[
702
726
atom
703
726
+
704
726
factor
1295
726
atom_expr
707
726
power
706
726
NUMBER
708
726
STRING
709
726
-
712
726
True
715
726
False
720
726
None
722
726
{
725
726
~
726
727
:
1296
727
varargslist
1297
727
NAME
305
727
vfpdef
306
728
=
not_test -> comparison
728
or
not_test -> comparison
728
and
not_test -> comparison
728
,
not_test -> comparison
728
for
not_test -> comparison
728
if
not_test -> comparison
728
)
not_test -> comparison
729
if
1298
729
,
test -> or_test
729
for
test -> or_test
729
=
test -> or_test
729
)
test -> or_test
730
factor
697
730
term
698
730
(
699
730
arith_expr
700
730
NAME
701
730
[
702
730
atom
703
730
+
704
730
power
706
730
atom_expr
707
730
NUMBER
708
730
STRING
709
730
shift_expr
711
730
-
712
730
not_test
1299
730
True
715
730
and_expr
718
730
xor_expr
719
730
False
720
730
None
722
730
expr
723
730
{
725
730
~
726
730
comparison
728
730
not
730
731
factor
1221
731
term
1222
731
(
1223
731
arith_expr
1224
731
NAME
1225
731
[
1226
731
+
1227
731
atom_expr
1228
731
NUMBER
1229
731
atom
1230
731
STRING
1231
731
shift_expr
1232
731
-
1233
731
True
1234
731
not_test
1235
731
and_expr
1236
731
xor_expr
1237
731
None
1238
731
False
1239
731
and_test
1240
731
{
1241
731
~
1242
731
power
1243
731
test
1300
731
expr
1244
731
lambda
1245
731
comparison
1246
731
or_test
1247
731
not
1249
731
lambdef
1251
732
//
1301
732
/
1302
732
in
term -> factor
732
-
term -> factor
732
*
1303
732
%
1304
732
@
1305
732
:
term -> factor
732
]
term -> factor
732
>=
term -> factor
732
<
term -> factor
732
<=
term -> factor
732
==
term -> factor
732
!=
term -> factor
732
>>
term -> factor
732
is
term -> factor
732
or
term -> factor
732
and
term -> factor
732
^
term -> factor
732
,
term -> factor
732
+
term -> factor
732
&
term -> factor
732
<<
term -> factor
732
|
term -> factor
732
>
term -> factor
732
if
term -> factor
732
not
term -> factor
733
:
test -> or_test
733
]
test -> or_test
733
if
1306
733
,
test -> or_test
734
+
1307
734
-
1308
734
|
arith_expr -> term
734
:
arith_expr -> term
734
or
arith_expr -> term
734
not
arith_expr -> term
734
<=
arith_expr -> term
734
!=
arith_expr -> term
734
<
arith_expr -> term
734
&
arith_expr -> term
734
>=
arith_expr -> term
734
if
arith_expr -> term
734
==
arith_expr -> term
734
^
arith_expr -> term
734
in
arith_expr -> term
734
is
arith_expr -> term
734
<<
arith_expr -> term
734
,
arith_expr -> term
734
>
arith_expr -> term
734
and
arith_expr -> term
734
>>
arith_expr -> term
734
]
arith_expr -> term
735
factor
268
735
term
270
735
(
271
735
arith_expr
272
735
NAME
273
735
[
274
735
+
275
735
test_list_comp
1309
735
atom_expr
277
735
NUMBER
278
735
atom
279
735
STRING
280
735
shift_expr
281
735
-
282
735
)
1310
735
True
283
735
not_test
284
735
lambdef
285
735
and_expr
286
735
xor_expr
287
735
False
288
735
None
289
735
expr
290
735
and_test
291
735
{
292
735
~
293
735
power
294
735
lambda
295
735
comparison
296
735
or_test
297
735
not
298
735
test
299
735
test_list
300
736
>>
1311
736
<<
1312
736
&
shift_expr -> arith_expr
736
<=
shift_expr -> arith_expr
736
>
shift_expr -> arith_expr
736
not
shift_expr -> arith_expr
736
!=
shift_expr -> arith_expr
736
^
shift_expr -> arith_expr
736
is
shift_expr -> arith_expr
736
|
shift_expr -> arith_expr
736
>=
shift_expr -> arith_expr
736
or
shift_expr -> arith_expr
736
]
shift_expr -> arith_expr
736
,
shift_expr -> arith_expr
736
==
shift_expr -> arith_expr
736
if
shift_expr -> arith_expr
736
and
shift_expr -> arith_expr
736
<
shift_expr -> arith_expr
736
:
shift_expr -> arith_expr
736
in
shift_expr -> arith_expr
737
]
atom -> NAME
737
:
atom -> NAME
737
-
atom -> NAME
737
,
atom -> NAME
737
or
atom -> NAME
737
>>
atom -> NAME
737
&
atom -> NAME
737
[
atom -> NAME
737
<=
atom -> NAME
737
<
atom -> NAME
737
.
atom -> NAME
737
|
atom -> NAME
737
*
atom -> NAME
737
/
atom -> NAME
737
<<
atom -> NAME
737
not
atom -> NAME
737
>
atom -> NAME
737
is
atom -> NAME
737
//
atom -> NAME
737
+
atom -> NAME
737
if
atom -> NAME
737
in
atom -> NAME
737
**
atom -> NAME
737
!=
atom -> NAME
737
>=
atom -> NAME
737
^
atom -> NAME
737
@
atom -> NAME
737
(
atom -> NAME
737
==
atom -> NAME
737
and
atom -> NAME
737
%
atom -> NAME
738
factor
117
738
or_test
118
738
term
119
738
(
120
738
arith_expr
121
738
NAME
122
738
[
123
738
]
1313
738
+
125
738
atom_expr
126
738
NUMBER
127
738
atom
128
738
STRING
129
738
shift_expr
130
738
-
131
738
test_list_comp
1314
738
True
133
738
not_test
134
738
lambdef
135
738
and_expr
136
738
xor_expr
137
738
False
138
738
None
139
738
expr
140
738
and_test
141
738
{
142
738
~
143
738
lambda
144
738
power
145
738
comparison
146
738
test_list
147
738
test
148
738
not
149
739
(
735
739
NAME
737
739
[
738
739
~
739
739
+
741
739
factor
1315
739
atom_expr
744
739
NUMBER
746
739
atom
745
739
STRING
747
739
-
749
739
True
750
739
False
754
739
{
755
739
None
756
739
power
759
740
]
1316
741
(
735
741
NAME
737
741
[
738
741
~
739
741
+
741
741
atom_expr
744
741
NUMBER
746
741
atom
745
741
STRING
747
741
-
749
741
factor
1317
741
True
750
741
False
754
741
{
755
741
None
756
741
power
759
742
:
1318
743
is
215
743
<
217
743
!=
218
743
in
219
743
<=
220
743
comp_op
1319
743
not
221
743
>=
222
743
>
223
743
==
224
743
]
comparison -> expr
743
and
comparison -> expr
743
or
comparison -> expr
743
:
comparison -> expr
743
if
comparison -> expr
743
,
comparison -> expr
744
!=
power -> atom_expr
744
**
1320
744
>
power -> atom_expr
744
]
power -> atom_expr
744
+
power -> atom_expr
744
not
power -> atom_expr
744
&
power -> atom_expr
744
|
power -> atom_expr
744
>>
power -> atom_expr
744
:
power -> atom_expr
744
^
power -> atom_expr
744
==
power -> atom_expr
744
if
power -> atom_expr
744
in
power -> atom_expr
744
%
power -> atom_expr
744
<<
power -> atom_expr
744
or
power -> atom_expr
744
@
power -> atom_expr
744
*
power -> atom_expr
744
/
power -> atom_expr
744
,
power -> atom_expr
744
<
power -> atom_expr
744
//
power -> atom_expr
744
>=
power -> atom_expr
744
-
power -> atom_expr
744
is
power -> atom_expr
744
<=
power -> atom_expr
744
and
power -> atom_expr
745
trailer
1321
745
.
1322
745
(
1323
745
[
1324
745
trailer_expr
1325
745
<<
trailer_expr -> 
745
%
trailer_expr -> 
745
==
trailer_expr -> 
745
-
trailer_expr -> 
745
<
trailer_expr -> 
745
if
trailer_expr -> 
745
or
trailer_expr -> 
745
/
trailer_expr -> 
745
**
trailer_expr -> 
745
and
trailer_expr -> 
745
@
trailer_expr -> 
745
*
trailer_expr -> 
745
|
trailer_expr -> 
745
is
trailer_expr -> 
745
,
trailer_expr -> 
745
+
trailer_expr -> 
745
in
trailer_expr -> 
745
&
trailer_expr -> 
745
<=
trailer_expr -> 
745
>=
trailer_expr -> 
745
^
trailer_expr -> 
745
>
trailer_expr -> 
745
!=
trailer_expr -> 
745
not
trailer_expr -> 
745
>>
trailer_expr -> 
745
//
trailer_expr -> 
745
]
trailer_expr -> 
745
:
trailer_expr -> 
746
[
atom -> NUMBER
746
>=
atom -> NUMBER
746
<=
atom -> NUMBER
746
!=
atom -> NUMBER
746
//
atom -> NUMBER
746
in
atom -> NUMBER
746
/
atom -> NUMBER
746
:
atom -> NUMBER
746
or
atom -> NUMBER
746
>
atom -> NUMBER
746
,
atom -> NUMBER
746
not
atom -> NUMBER
746
>>
atom -> NUMBER
746
(
atom -> NUMBER
746
**
atom -> NUMBER
746
<<
atom -> NUMBER
746
and
atom -> NUMBER
746
+
atom -> NUMBER
746
%
atom -> NUMBER
746
==
atom -> NUMBER
746
]
atom -> NUMBER
746
if
atom -> NUMBER
746
is
atom -> NUMBER
746
*
atom -> NUMBER
746
@
atom -> NUMBER
746
|
atom -> NUMBER
746
-
atom -> NUMBER
746
.
atom -> NUMBER
746
^
atom -> NUMBER
746
<
atom -> NUMBER
746
&
atom -> NUMBER
747
and
atom -> STRING
747
%
atom -> STRING
747
//
atom -> STRING
747
>>
atom -> STRING
747
*
atom -> STRING
747
<
atom -> STRING
747
.
atom -> STRING
747
in
atom -> STRING
747
]
atom -> STRING
747
:
atom -> STRING
747
^
atom -> STRING
747
(
atom -> STRING
747
if
atom -> STRING
747
==
atom -> STRING
747
-
atom -> STRING
747
**
atom -> STRING
747
<<
atom -> STRING
747
<=
atom -> STRING
747
[
atom -> STRING
747
not
atom -> STRING
747
or
atom -> STRING
747
+
atom -> STRING
747
>=
atom -> STRING
747
@
atom -> STRING
747
&
atom -> STRING
747
>
atom -> STRING
747
is
atom -> STRING
747
,
atom -> STRING
747
|
atom -> STRING
747
!=
atom -> STRING
747
/
atom -> STRING
748
&
1326
748
^
and_expr -> shift_expr
748
|
and_expr -> shift_expr
748
<=
and_expr -> shift_expr
748
or
and_expr -> shift_expr
748
>
and_expr -> shift_expr
748
]
and_expr -> shift_expr
748
not
and_expr -> shift_expr
748
,
and_expr -> shift_expr
748
!=
and_expr -> shift_expr
748
and
and_expr -> shift_expr
748
is
and_expr -> shift_expr
748
<
and_expr -> shift_expr
748
if
and_expr -> shift_expr
748
in
and_expr -> shift_expr
748
>=
and_expr -> shift_expr
748
:
and_expr -> shift_expr
748
==
and_expr -> shift_expr
749
(
735
749
NAME
737
749
[
738
749
~
739
749
+
741
749
atom_expr
744
749
NUMBER
746
749
atom
745
749
STRING
747
749
-
749
749
True
750
749
False
754
749
{
755
749
None
756
749
power
759
749
factor
1327
750
(
atom -> True
750
[
atom -> True
750
+
atom -> True
750
@
atom -> True
750
not
atom -> True
750
<=
atom -> True
750
&
atom -> True
750
<<
atom -> True
750
-
atom -> True
750
/
atom -> True
750
or
atom -> True
750
>
atom -> True
750
%
atom -> True
750
^
atom -> True
750
if
atom -> True
750
!=
atom -> True
750
is
atom -> True
750
*
atom -> True
750
<
atom -> True
750
,
atom -> True
750
and
atom -> True
750
.
atom -> True
750
==
atom -> True
750
]
atom -> True
750
**
atom -> True
750
>>
atom -> True
750
in
atom -> True
750
|
atom -> True
750
>=
atom -> True
750
//
atom -> True
750
:
atom -> True
751
and
1328
751
]
and_test -> not_test
751
or
and_test -> not_test
751
,
and_test -> not_test
751
if
and_test -> not_test
751
:
and_test -> not_test
752
^
1329
752
not
xor_expr -> and_expr
752
if
xor_expr -> and_expr
752
<=
xor_expr -> and_expr
752
:
xor_expr -> and_expr
752
,
xor_expr -> and_expr
752
>
xor_expr -> and_expr
752
]
xor_expr -> and_expr
752
<
xor_expr -> and_expr
752
in
xor_expr -> and_expr
752
>=
xor_expr -> and_expr
752
==
xor_expr -> and_expr
752
|
xor_expr -> and_expr
752
is
xor_expr -> and_expr
752
and
xor_expr -> and_expr
752
or
xor_expr -> and_expr
752
!=
xor_expr -> and_expr
753
|
1330
753
>=
expr -> xor_expr
753
,
expr -> xor_expr
753
==
expr -> xor_expr
753
is
expr -> xor_expr
753
:
expr -> xor_expr
753
if
expr -> xor_expr
753
or
expr -> xor_expr
753
>
expr -> xor_expr
753
and
expr -> xor_expr
753
<
expr -> xor_expr
753
]
expr -> xor_expr
753
in
expr -> xor_expr
753
<=
expr -> xor_expr
753
not
expr -> xor_expr
753
!=
expr -> xor_expr
754
in
atom -> False
754
>
atom -> False
754
-
atom -> False
754
%
atom -> False
754
<
atom -> False
754
|
atom -> False
754
==
atom -> False
754
&
atom -> False
754
//
atom -> False
754
and
atom -> False
754
:
atom -> False
754
not
atom -> False
754
+
atom -> False
754
!=
atom -> False
754
if
atom -> False
754
@
atom -> False
754
]
atom -> False
754
[
atom -> False
754
or
atom -> False
754
<=
atom -> False
754
*
atom -> False
754
^
atom -> False
754
is
atom -> False
754
/
atom -> False
754
.
atom -> False
754
>=
atom -> False
754
**
atom -> False
754
>>
atom -> False
754
,
atom -> False
754
<<
atom -> False
754
(
atom -> False
755
}
1331
756
is
atom -> None
756
.
atom -> None
756
==
atom -> None
756
^
atom -> None
756
<<
atom -> None
756
>>
atom -> None
756
(
atom -> None
756
|
atom -> None
756
+
atom -> None
756
*
atom -> None
756
//
atom -> None
756
@
atom -> None
756
in
atom -> None
756
>=
atom -> None
756
!=
atom -> None
756
%
atom -> None
756
]
atom -> None
756
[
atom -> None
756
and
atom -> None
756
-
atom -> None
756
if
atom -> None
756
&
atom -> None
756
<=
atom -> None
756
<
atom -> None
756
>
atom -> None
756
,
atom -> None
756
**
atom -> None
756
:
atom -> None
756
or
atom -> None
756
/
atom -> None
756
not
atom -> None
757
,
or_test -> and_test
757
or
1332
757
:
or_test -> and_test
757
if
or_test -> and_test
757
]
or_test -> and_test
758
:
1333
758
NAME
305
758
varargslist
1334
758
vfpdef
306
759
&
factor -> power
759
%
factor -> power
759
<<
factor -> power
759
-
factor -> power
759
<=
factor -> power
759
not
factor -> power
759
//
factor -> power
759
/
factor -> power
759
is
factor -> power
759
|
factor -> power
759
<
factor -> power
759
and
factor -> power
759
>=
factor -> power
759
>>
factor -> power
759
>
factor -> power
759
in
factor -> power
759
if
factor -> power
759
^
factor -> power
759
==
factor -> power
759
+
factor -> power
759
,
factor -> power
759
@
factor -> power
759
or
factor -> power
759
*
factor -> power
759
:
factor -> power
759
]
factor -> power
759
!=
factor -> power
760
]
subscriptlist -> subscript
760
,
1335
761
:
maybe_test -> test
761
]
subscript -> test
761
,
subscript -> test
762
]
test -> lambdef
762
,
test -> lambdef
762
:
test -> lambdef
763
:
not_test -> comparison
763
or
not_test -> comparison
763
and
not_test -> comparison
763
,
not_test -> comparison
763
if
not_test -> comparison
763
]
not_test -> comparison
764
factor
732
764
term
734
764
(
735
764
arith_expr
736
764
NAME
737
764
[
738
764
~
739
764
+
741
764
expr
743
764
atom_expr
744
764
atom
745
764
NUMBER
746
764
STRING
747
764
shift_expr
748
764
-
749
764
not_test
1336
764
True
750
764
and_expr
752
764
xor_expr
753
764
False
754
764
{
755
764
None
756
764
power
759
764
comparison
763
764
not
764
765
%=
trailer -> . NAME
765
<=
trailer -> . NAME
765
<<
trailer -> . NAME
765
**
trailer -> . NAME
765
!=
trailer -> . NAME
765
:
trailer -> . NAME
765
/
trailer -> . NAME
765
&
trailer -> . NAME
765
//
trailer -> . NAME
765
<
trailer -> . NAME
765
is
trailer -> . NAME
765
-
trailer -> . NAME
765
if
trailer -> . NAME
765
[
trailer -> . NAME
765
or
trailer -> . NAME
765
//=
trailer -> . NAME
765
>
trailer -> . NAME
765
*
trailer -> . NAME
765
|=
trailer -> . NAME
765
@=
trailer -> . NAME
765
+
trailer -> . NAME
765
&=
trailer -> . NAME
765
>>=
trailer -> . NAME
765
%
trailer -> . NAME
765
.
trailer -> . NAME
765
<<=
trailer -> . NAME
765
^=
trailer -> . NAME
765
>=
trailer -> . NAME
765
|
trailer -> . NAME
765
**=
trailer -> . NAME
765
and
trailer -> . NAME
765
(
trailer -> . NAME
765
,
trailer -> . NAME
765
*=
trailer -> . NAME
765
NEWLINE
trailer -> . NAME
765
-=
trailer -> . NAME
765
/=
trailer -> . NAME
765
^
trailer -> . NAME
765
in
trailer -> . NAME
765
@
trailer -> . NAME
765
==
trailer -> . NAME
765
not
trailer -> . NAME
765
=
trailer -> . NAME
765
+=
trailer -> . NAME
765
>>
trailer -> . NAME
766
//
1337
766
in
term -> factor
766
-
term -> factor
766
*
1338
766
%
1339
766
@
1340
766
>=
term -> factor
766
/
1341
766
=
term -> factor
766
<
term -> factor
766
<=
term -> factor
766
==
term -> factor
766
!=
term -> factor
766
>>
term -> factor
766
is
term -> factor
766
or
term -> factor
766
and
term -> factor
766
NEWLINE
term -> factor
766
^
term -> factor
766
,
term -> factor
766
+
term -> factor
766
&
term -> factor
766
<<
term -> factor
766
|
term -> factor
766
>
term -> factor
766
if
term -> factor
766
not
term -> factor
767
+
1342
767
-
1343
767
NEWLINE
arith_expr -> term
767
|
arith_expr -> term
767
or
arith_expr -> term
767
not
arith_expr -> term
767
<=
arith_expr -> term
767
!=
arith_expr -> term
767
<
arith_expr -> term
767
=
arith_expr -> term
767
&
arith_expr -> term
767
>=
arith_expr -> term
767
if
arith_expr -> term
767
==
arith_expr -> term
767
^
arith_expr -> term
767
in
arith_expr -> term
767
is
arith_expr -> term
767
<<
arith_expr -> term
767
,
arith_expr -> term
767
>
arith_expr -> term
767
and
arith_expr -> term
767
>>
arith_expr -> term
768
factor
268
768
term
270
768
(
271
768
arith_expr
272
768
NAME
273
768
[
274
768
+
275
768
test_list_comp
1344
768
atom_expr
277
768
NUMBER
278
768
atom
279
768
STRING
280
768
shift_expr
281
768
-
282
768
True
283
768
not_test
284
768
lambdef
285
768
and_expr
286
768
xor_expr
287
768
False
288
768
None
289
768
expr
290
768
and_test
291
768
)
1345
768
{
292
768
~
293
768
power
294
768
lambda
295
768
comparison
296
768
or_test
297
768
not
298
768
test
299
768
test_list
300
769
>>
1346
769
<<
1347
769
&
shift_expr -> arith_expr
769
<=
shift_expr -> arith_expr
769
>
shift_expr -> arith_expr
769
NEWLINE
shift_expr -> arith_expr
769
not
shift_expr -> arith_expr
769
!=
shift_expr -> arith_expr
769
^
shift_expr -> arith_expr
769
is
shift_expr -> arith_expr
769
|
shift_expr -> arith_expr
769
=
shift_expr -> arith_expr
769
>=
shift_expr -> arith_expr
769
or
shift_expr -> arith_expr
769
,
shift_expr -> arith_expr
769
==
shift_expr -> arith_expr
769
if
shift_expr -> arith_expr
769
and
shift_expr -> arith_expr
769
<
shift_expr -> arith_expr
769
in
shift_expr -> arith_expr
770
-
atom -> NAME
770
,
atom -> NAME
770
or
atom -> NAME
770
>>
atom -> NAME
770
NEWLINE
atom -> NAME
770
&
atom -> NAME
770
[
atom -> NAME
770
<=
atom -> NAME
770
<
atom -> NAME
770
.
atom -> NAME
770
|
atom -> NAME
770
*
atom -> NAME
770
/
atom -> NAME
770
<<
atom -> NAME
770
not
atom -> NAME
770
>
atom -> NAME
770
=
atom -> NAME
770
is
atom -> NAME
770
//
atom -> NAME
770
+
atom -> NAME
770
if
atom -> NAME
770
in
atom -> NAME
770
**
atom -> NAME
770
!=
atom -> NAME
770
>=
atom -> NAME
770
^
atom -> NAME
770
@
atom -> NAME
770
(
atom -> NAME
770
==
atom -> NAME
770
and
atom -> NAME
770
%
atom -> NAME
771
factor
117
771
or_test
118
771
term
119
771
(
120
771
arith_expr
121
771
NAME
122
771
[
123
771
]
1348
771
+
125
771
atom_expr
126
771
NUMBER
127
771
atom
128
771
STRING
129
771
shift_expr
130
771
-
131
771
test_list_comp
1349
771
True
133
771
not_test
134
771
lambdef
135
771
and_expr
136
771
xor_expr
137
771
False
138
771
None
139
771
expr
140
771
and_test
141
771
{
142
771
~
143
771
lambda
144
771
power
145
771
comparison
146
771
test_list
147
771
test
148
771
not
149
772
trailer
1350
772
.
1351
772
(
1352
772
[
1353
772
trailer_expr
1354
772
<<
trailer_expr -> 
772
%
trailer_expr -> 
772
==
trailer_expr -> 
772
-
trailer_expr -> 
772
<
trailer_expr -> 
772
NEWLINE
trailer_expr -> 
772
if
trailer_expr -> 
772
or
trailer_expr -> 
772
/
trailer_expr -> 
772
**
trailer_expr -> 
772
and
trailer_expr -> 
772
@
trailer_expr -> 
772
=
trailer_expr -> 
772
*
trailer_expr -> 
772
|
trailer_expr -> 
772
is
trailer_expr -> 
772
,
trailer_expr -> 
772
+
trailer_expr -> 
772
in
trailer_expr -> 
772
&
trailer_expr -> 
772
<=
trailer_expr -> 
772
>=
trailer_expr -> 
772
^
trailer_expr -> 
772
>
trailer_expr -> 
772
!=
trailer_expr -> 
772
not
trailer_expr -> 
772
>>
trailer_expr -> 
772
//
trailer_expr -> 
773
(
768
773
NAME
770
773
[
771
773
atom
772
773
+
773
773
atom_expr
775
773
power
774
773
NUMBER
776
773
STRING
777
773
-
779
773
factor
1355
773
True
780
773
None
784
773
False
786
773
{
790
773
~
789
774
&
factor -> power
774
NEWLINE
factor -> power
774
%
factor -> power
774
<<
factor -> power
774
-
factor -> power
774
<=
factor -> power
774
not
factor -> power
774
//
factor -> power
774
/
factor -> power
774
is
factor -> power
774
|
factor -> power
774
<
factor -> power
774
and
factor -> power
774
>=
factor -> power
774
>>
factor -> power
774
>
factor -> power
774
in
factor -> power
774
=
factor -> power
774
if
factor -> power
774
^
factor -> power
774
==
factor -> power
774
+
factor -> power
774
,
factor -> power
774
@
factor -> power
774
or
factor -> power
774
*
factor -> power
774
!=
factor -> power
775
!=
power -> atom_expr
775
**
1356
775
>
power -> atom_expr
775
+
power -> atom_expr
775
not
power -> atom_expr
775
&
power -> atom_expr
775
|
power -> atom_expr
775
>>
power -> atom_expr
775
^
power -> atom_expr
775
==
power -> atom_expr
775
if
power -> atom_expr
775
in
power -> atom_expr
775
%
power -> atom_expr
775
<<
power -> atom_expr
775
or
power -> atom_expr
775
NEWLINE
power -> atom_expr
775
@
power -> atom_expr
775
=
power -> atom_expr
775
*
power -> atom_expr
775
/
power -> atom_expr
775
,
power -> atom_expr
775
<
power -> atom_expr
775
//
power -> atom_expr
775
>=
power -> atom_expr
775
-
power -> atom_expr
775
is
power -> atom_expr
775
<=
power -> atom_expr
775
and
power -> atom_expr
776
[
atom -> NUMBER
776
=
atom -> NUMBER
776
>=
atom -> NUMBER
776
<=
atom -> NUMBER
776
!=
atom -> NUMBER
776
//
atom -> NUMBER
776
in
atom -> NUMBER
776
/
atom -> NUMBER
776
or
atom -> NUMBER
776
>
atom -> NUMBER
776
,
atom -> NUMBER
776
not
atom -> NUMBER
776
>>
atom -> NUMBER
776
(
atom -> NUMBER
776
**
atom -> NUMBER
776
<<
atom -> NUMBER
776
and
atom -> NUMBER
776
+
atom -> NUMBER
776
%
atom -> NUMBER
776
==
atom -> NUMBER
776
if
atom -> NUMBER
776
is
atom -> NUMBER
776
*
atom -> NUMBER
776
@
atom -> NUMBER
776
|
atom -> NUMBER
776
NEWLINE
atom -> NUMBER
776
-
atom -> NUMBER
776
.
atom -> NUMBER
776
^
atom -> NUMBER
776
<
atom -> NUMBER
776
&
atom -> NUMBER
777
and
atom -> STRING
777
%
atom -> STRING
777
//
atom -> STRING
777
>>
atom -> STRING
777
*
atom -> STRING
777
<
atom -> STRING
777
.
atom -> STRING
777
in
atom -> STRING
777
NEWLINE
atom -> STRING
777
^
atom -> STRING
777
=
atom -> STRING
777
(
atom -> STRING
777
if
atom -> STRING
777
==
atom -> STRING
777
-
atom -> STRING
777
**
atom -> STRING
777
<<
atom -> STRING
777
<=
atom -> STRING
777
[
atom -> STRING
777
not
atom -> STRING
777
or
atom -> STRING
777
+
atom -> STRING
777
>=
atom -> STRING
777
@
atom -> STRING
777
&
atom -> STRING
777
>
atom -> STRING
777
is
atom -> STRING
777
,
atom -> STRING
777
|
atom -> STRING
777
!=
atom -> STRING
777
/
atom -> STRING
778
&
1357
778
^
and_expr -> shift_expr
778
|
and_expr -> shift_expr
778
<=
and_expr -> shift_expr
778
=
and_expr -> shift_expr
778
NEWLINE
and_expr -> shift_expr
778
or
and_expr -> shift_expr
778
>
and_expr -> shift_expr
778
not
and_expr -> shift_expr
778
,
and_expr -> shift_expr
778
!=
and_expr -> shift_expr
778
and
and_expr -> shift_expr
778
is
and_expr -> shift_expr
778
<
and_expr -> shift_expr
778
if
and_expr -> shift_expr
778
in
and_expr -> shift_expr
778
>=
and_expr -> shift_expr
778
==
and_expr -> shift_expr
779
(
768
779
NAME
770
779
[
771
779
atom
772
779
+
773
779
atom_expr
775
779
power
774
779
NUMBER
776
779
STRING
777
779
-
779
779
True
780
779
None
784
779
False
786
779
{
790
779
~
789
779
factor
1358
780
(
atom -> True
780
[
atom -> True
780
+
atom -> True
780
@
atom -> True
780
<=
atom -> True
780
&
atom -> True
780
=
atom -> True
780
<<
atom -> True
780
-
atom -> True
780
/
atom -> True
780
or
atom -> True
780
>
atom -> True
780
%
atom -> True
780
^
atom -> True
780
if
atom -> True
780
!=
atom -> True
780
is
atom -> True
780
*
atom -> True
780
<
atom -> True
780
,
atom -> True
780
and
atom -> True
780
.
atom -> True
780
==
atom -> True
780
**
atom -> True
780
>>
atom -> True
780
in
atom -> True
780
|
atom -> True
780
>=
atom -> True
780
//
atom -> True
780
not
atom -> True
780
NEWLINE
atom -> True
781
and
1359
781
=
and_test -> not_test
781
NEWLINE
and_test -> not_test
781
or
and_test -> not_test
781
,
and_test -> not_test
781
if
and_test -> not_test
782
^
1360
782
=
xor_expr -> and_expr
782
not
xor_expr -> and_expr
782
if
xor_expr -> and_expr
782
<=
xor_expr -> and_expr
782
,
xor_expr -> and_expr
782
>
xor_expr -> and_expr
782
NEWLINE
xor_expr -> and_expr
782
<
xor_expr -> and_expr
782
in
xor_expr -> and_expr
782
>=
xor_expr -> and_expr
782
==
xor_expr -> and_expr
782
|
xor_expr -> and_expr
782
is
xor_expr -> and_expr
782
and
xor_expr -> and_expr
782
or
xor_expr -> and_expr
782
!=
xor_expr -> and_expr
783
|
1361
783
>=
expr -> xor_expr
783
,
expr -> xor_expr
783
==
expr -> xor_expr
783
NEWLINE
expr -> xor_expr
783
is
expr -> xor_expr
783
if
expr -> xor_expr
783
or
expr -> xor_expr
783
>
expr -> xor_expr
783
and
expr -> xor_expr
783
<
expr -> xor_expr
783
in
expr -> xor_expr
783
<=
expr -> xor_expr
783
=
expr -> xor_expr
783
not
expr -> xor_expr
783
!=
expr -> xor_expr
784
is
atom -> None
784
.
atom -> None
784
==
atom -> None
784
^
atom -> None
784
<<
atom -> None
784
>>
atom -> None
784
(
atom -> None
784
|
atom -> None
784
=
atom -> None
784
+
atom -> None
784
*
atom -> None
784
//
atom -> None
784
@
atom -> None
784
in
atom -> None
784
>=
atom -> None
784
!=
atom -> None
784
%
atom -> None
784
[
atom -> None
784
and
atom -> None
784
-
atom -> None
784
NEWLINE
atom -> None
784
if
atom -> None
784
&
atom -> None
784
<=
atom -> None
784
<
atom -> None
784
>
atom -> None
784
,
atom -> None
784
**
atom -> None
784
or
atom -> None
784
/
atom -> None
784
not
atom -> None
785
is
215
785
<
217
785
!=
218
785
in
219
785
<=
220
785
not
221
785
>=
222
785
>
223
785
==
224
785
comp_op
1362
785
and
comparison -> expr
785
or
comparison -> expr
785
=
comparison -> expr
785
if
comparison -> expr
785
NEWLINE
comparison -> expr
785
,
comparison -> expr
786
in
atom -> False
786
>
atom -> False
786
-
atom -> False
786
%
atom -> False
786
<
atom -> False
786
NEWLINE
atom -> False
786
|
atom -> False
786
==
atom -> False
786
&
atom -> False
786
//
atom -> False
786
and
atom -> False
786
not
atom -> False
786
+
atom -> False
786
!=
atom -> False
786
if
atom -> False
786
@
atom -> False
786
[
atom -> False
786
or
atom -> False
786
<=
atom -> False
786
=
atom -> False
786
*
atom -> False
786
^
atom -> False
786
is
atom -> False
786
/
atom -> False
786
.
atom -> False
786
>=
atom -> False
786
**
atom -> False
786
>>
atom -> False
786
,
atom -> False
786
<<
atom -> False
786
(
atom -> False
787
,
or_test -> and_test
787
or
1363
787
=
or_test -> and_test
787
NEWLINE
or_test -> and_test
787
if
or_test -> and_test
788
:
1364
788
varargslist
1365
788
NAME
305
788
vfpdef
306
789
(
768
789
NAME
770
789
[
771
789
atom
772
789
+
773
789
factor
1366
789
atom_expr
775
789
power
774
789
NUMBER
776
789
STRING
777
789
-
779
789
True
780
789
None
784
789
False
786
789
{
790
789
~
789
790
}
1367
791
=
test_list -> test
791
,
1368
791
NEWLINE
test_list -> test
792
factor
766
792
term
767
792
(
768
792
arith_expr
769
792
NAME
770
792
[
771
792
atom
772
792
+
773
792
power
774
792
atom_expr
775
792
NUMBER
776
792
STRING
777
792
shift_expr
778
792
-
779
792
not_test
1369
792
True
780
792
and_expr
782
792
xor_expr
783
792
None
784
792
expr
785
792
False
786
792
~
789
792
{
790
792
not
792
792
comparison
797
793
NEWLINE
test -> or_test
793
if
1370
793
,
test -> or_test
793
=
test -> or_test
794
=
327
794
assign
1371
794
NEWLINE
assign -> 
795
NEWLINE
test -> lambdef
795
,
test -> lambdef
795
=
test -> lambdef
796
factor
766
796
term
767
796
(
768
796
arith_expr
769
796
NAME
770
796
[
771
796
atom
772
796
+
773
796
power
774
796
atom_expr
775
796
NUMBER
776
796
STRING
777
796
shift_expr
778
796
-
779
796
True
780
796
not_test
781
796
and_expr
782
796
xor_expr
783
796
None
784
796
test_list
1372
796
expr
785
796
False
786
796
and_test
787
796
lambda
788
796
~
789
796
{
790
796
test
791
796
yield_arg
1373
796
not
792
796
or_test
793
796
from
1374
796
lambdef
795
796
comparison
797
796
NEWLINE
yield_expr -> yield
796
=
yield_expr -> yield
797
=
not_test -> comparison
797
or
not_test -> comparison
797
NEWLINE
not_test -> comparison
797
and
not_test -> comparison
797
,
not_test -> comparison
797
if
not_test -> comparison
798
=
327
798
assign
1375
798
NEWLINE
assign -> 
799
NEWLINE
expr_stmt -> test_list augassign yield_or_testlist
800
NEWLINE
yield_or_testlist -> test_list
801
factor
184
801
term
185
801
(
186
801
arith_expr
187
801
NAME
188
801
[
189
801
+
190
801
atom_expr
191
801
atom
192
801
NUMBER
193
801
STRING
194
801
shift_expr
195
801
-
196
801
True
197
801
not_test
198
801
and_expr
199
801
xor_expr
200
801
None
201
801
test_list
1376
801
expr
202
801
False
203
801
and_test
204
801
lambda
205
801
{
206
801
~
207
801
power
208
801
test
209
801
not
210
801
or_test
211
801
comparison
212
801
lambdef
214
801
from
1377
801
NEWLINE
yield_expr -> yield
801
yield_arg
1378
802
NEWLINE
yield_or_testlist -> yield_expr
803
//
1379
803
in
term -> factor
803
-
term -> factor
803
*
1380
803
%
1381
803
@
1382
803
>=
term -> factor
803
/
1383
803
=
term -> factor
803
<
term -> factor
803
<=
term -> factor
803
==
term -> factor
803
!=
term -> factor
803
>>
term -> factor
803
is
term -> factor
803
or
term -> factor
803
and
term -> factor
803
^
term -> factor
803
+
term -> factor
803
&
term -> factor
803
<<
term -> factor
803
|
term -> factor
803
>
term -> factor
803
if
term -> factor
803
not
term -> factor
804
factor
268
804
term
270
804
(
271
804
arith_expr
272
804
NAME
273
804
[
274
804
+
275
804
test_list_comp
1384
804
atom_expr
277
804
NUMBER
278
804
atom
279
804
STRING
280
804
shift_expr
281
804
-
282
804
True
283
804
not_test
284
804
lambdef
285
804
and_expr
286
804
xor_expr
287
804
False
288
804
None
289
804
expr
290
804
and_test
291
804
)
1385
804
{
292
804
~
293
804
power
294
804
lambda
295
804
comparison
296
804
or_test
297
804
not
298
804
test
299
804
test_list
300
805
>>
1386
805
<<
1387
805
&
shift_expr -> arith_expr
805
<=
shift_expr -> arith_expr
805
>
shift_expr -> arith_expr
805
not
shift_expr -> arith_expr
805
!=
shift_expr -> arith_expr
805
^
shift_expr -> arith_expr
805
is
shift_expr -> arith_expr
805
|
shift_expr -> arith_expr
805
=
shift_expr -> arith_expr
805
>=
shift_expr -> arith_expr
805
or
shift_expr -> arith_expr
805
==
shift_expr -> arith_expr
805
if
shift_expr -> arith_expr
805
and
shift_expr -> arith_expr
805
<
shift_expr -> arith_expr
805
in
shift_expr -> arith_expr
806
-
atom -> NAME
806
or
atom -> NAME
806
>>
atom -> NAME
806
&
atom -> NAME
806
[
atom -> NAME
806
<=
atom -> NAME
806
<
atom -> NAME
806
.
atom -> NAME
806
|
atom -> NAME
806
*
atom -> NAME
806
/
atom -> NAME
806
<<
atom -> NAME
806
not
atom -> NAME
806
>
atom -> NAME
806
=
atom -> NAME
806
is
atom -> NAME
806
//
atom -> NAME
806
+
atom -> NAME
806
if
atom -> NAME
806
in
atom -> NAME
806
**
atom -> NAME
806
!=
atom -> NAME
806
>=
atom -> NAME
806
^
atom -> NAME
806
@
atom -> NAME
806
(
atom -> NAME
806
==
atom -> NAME
806
and
atom -> NAME
806
%
atom -> NAME
807
factor
117
807
or_test
118
807
term
119
807
(
120
807
arith_expr
121
807
NAME
122
807
[
123
807
]
1388
807
+
125
807
atom_expr
126
807
NUMBER
127
807
atom
128
807
STRING
129
807
shift_expr
130
807
-
131
807
test_list_comp
1389
807
True
133
807
not_test
134
807
lambdef
135
807
and_expr
136
807
xor_expr
137
807
False
138
807
None
139
807
expr
140
807
and_test
141
807
{
142
807
~
143
807
lambda
144
807
power
145
807
comparison
146
807
test_list
147
807
test
148
807
not
149
808
trailer
1390
808
.
1391
808
(
1392
808
[
1393
808
trailer_expr
1394
808
<<
trailer_expr -> 
808
%
trailer_expr -> 
808
==
trailer_expr -> 
808
-
trailer_expr -> 
808
<
trailer_expr -> 
808
if
trailer_expr -> 
808
or
trailer_expr -> 
808
/
trailer_expr -> 
808
**
trailer_expr -> 
808
and
trailer_expr -> 
808
@
trailer_expr -> 
808
=
trailer_expr -> 
808
*
trailer_expr -> 
808
|
trailer_expr -> 
808
is
trailer_expr -> 
808
+
trailer_expr -> 
808
in
trailer_expr -> 
808
&
trailer_expr -> 
808
<=
trailer_expr -> 
808
>=
trailer_expr -> 
808
^
trailer_expr -> 
808
>
trailer_expr -> 
808
!=
trailer_expr -> 
808
not
trailer_expr -> 
808
>>
trailer_expr -> 
808
//
trailer_expr -> 
809
(
804
809
NAME
806
809
[
807
809
atom
808
809
+
809
809
atom_expr
812
809
power
811
809
NUMBER
813
809
STRING
814
809
-
816
809
factor
1395
809
True
817
809
None
820
809
False
821
809
{
823
809
~
824
810
+
1396
810
-
1397
810
|
arith_expr -> term
810
or
arith_expr -> term
810
not
arith_expr -> term
810
<=
arith_expr -> term
810
!=
arith_expr -> term
810
<
arith_expr -> term
810
=
arith_expr -> term
810
&
arith_expr -> term
810
>=
arith_expr -> term
810
if
arith_expr -> term
810
==
arith_expr -> term
810
^
arith_expr -> term
810
in
arith_expr -> term
810
is
arith_expr -> term
810
<<
arith_expr -> term
810
>
arith_expr -> term
810
and
arith_expr -> term
810
>>
arith_expr -> term
811
&
factor -> power
811
%
factor -> power
811
<<
factor -> power
811
-
factor -> power
811
<=
factor -> power
811
not
factor -> power
811
//
factor -> power
811
/
factor -> power
811
is
factor -> power
811
|
factor -> power
811
<
factor -> power
811
and
factor -> power
811
>=
factor -> power
811
>>
factor -> power
811
>
factor -> power
811
in
factor -> power
811
=
factor -> power
811
if
factor -> power
811
^
factor -> power
811
==
factor -> power
811
+
factor -> power
811
@
factor -> power
811
or
factor -> power
811
*
factor -> power
811
!=
factor -> power
812
!=
power -> atom_expr
812
**
1398
812
>
power -> atom_expr
812
+
power -> atom_expr
812
not
power -> atom_expr
812
&
power -> atom_expr
812
|
power -> atom_expr
812
>>
power -> atom_expr
812
^
power -> atom_expr
812
==
power -> atom_expr
812
if
power -> atom_expr
812
in
power -> atom_expr
812
%
power -> atom_expr
812
<<
power -> atom_expr
812
or
power -> atom_expr
812
@
power -> atom_expr
812
=
power -> atom_expr
812
*
power -> atom_expr
812
/
power -> atom_expr
812
<
power -> atom_expr
812
//
power -> atom_expr
812
>=
power -> atom_expr
812
-
power -> atom_expr
812
is
power -> atom_expr
812
<=
power -> atom_expr
812
and
power -> atom_expr
813
[
atom -> NUMBER
813
=
atom -> NUMBER
813
>=
atom -> NUMBER
813
<=
atom -> NUMBER
813
!=
atom -> NUMBER
813
//
atom -> NUMBER
813
in
atom -> NUMBER
813
/
atom -> NUMBER
813
or
atom -> NUMBER
813
>
atom -> NUMBER
813
not
atom -> NUMBER
813
>>
atom -> NUMBER
813
(
atom -> NUMBER
813
**
atom -> NUMBER
813
<<
atom -> NUMBER
813
and
atom -> NUMBER
813
+
atom -> NUMBER
813
%
atom -> NUMBER
813
==
atom -> NUMBER
813
if
atom -> NUMBER
813
is
atom -> NUMBER
813
*
atom -> NUMBER
813
@
atom -> NUMBER
813
|
atom -> NUMBER
813
-
atom -> NUMBER
813
.
atom -> NUMBER
813
^
atom -> NUMBER
813
<
atom -> NUMBER
813
&
atom -> NUMBER
814
and
atom -> STRING
814
%
atom -> STRING
814
//
atom -> STRING
814
>>
atom -> STRING
814
*
atom -> STRING
814
<
atom -> STRING
814
.
atom -> STRING
814
in
atom -> STRING
814
^
atom -> STRING
814
=
atom -> STRING
814
(
atom -> STRING
814
if
atom -> STRING
814
==
atom -> STRING
814
-
atom -> STRING
814
**
atom -> STRING
814
<<
atom -> STRING
814
<=
atom -> STRING
814
[
atom -> STRING
814
not
atom -> STRING
814
or
atom -> STRING
814
+
atom -> STRING
814
>=
atom -> STRING
814
@
atom -> STRING
814
&
atom -> STRING
814
>
atom -> STRING
814
is
atom -> STRING
814
|
atom -> STRING
814
!=
atom -> STRING
814
/
atom -> STRING
815
&
1399
815
^
and_expr -> shift_expr
815
|
and_expr -> shift_expr
815
<=
and_expr -> shift_expr
815
=
and_expr -> shift_expr
815
or
and_expr -> shift_expr
815
>
and_expr -> shift_expr
815
not
and_expr -> shift_expr
815
!=
and_expr -> shift_expr
815
and
and_expr -> shift_expr
815
is
and_expr -> shift_expr
815
<
and_expr -> shift_expr
815
if
and_expr -> shift_expr
815
in
and_expr -> shift_expr
815
>=
and_expr -> shift_expr
815
==
and_expr -> shift_expr
816
(
804
816
NAME
806
816
[
807
816
atom
808
816
+
809
816
atom_expr
812
816
power
811
816
NUMBER
813
816
STRING
814
816
-
816
816
True
817
816
None
820
816
False
821
816
{
823
816
~
824
816
factor
1400
817
(
atom -> True
817
[
atom -> True
817
+
atom -> True
817
@
atom -> True
817
<=
atom -> True
817
&
atom -> True
817
=
atom -> True
817
<<
atom -> True
817
-
atom -> True
817
/
atom -> True
817
or
atom -> True
817
>
atom -> True
817
%
atom -> True
817
^
atom -> True
817
if
atom -> True
817
!=
atom -> True
817
is
atom -> True
817
*
atom -> True
817
<
atom -> True
817
and
atom -> True
817
.
atom -> True
817
==
atom -> True
817
**
atom -> True
817
>>
atom -> True
817
in
atom -> True
817
|
atom -> True
817
>=
atom -> True
817
//
atom -> True
817
not
atom -> True
818
^
1401
818
=
xor_expr -> and_expr
818
not
xor_expr -> and_expr
818
if
xor_expr -> and_expr
818
<=
xor_expr -> and_expr
818
>
xor_expr -> and_expr
818
<
xor_expr -> and_expr
818
in
xor_expr -> and_expr
818
>=
xor_expr -> and_expr
818
==
xor_expr -> and_expr
818
|
xor_expr -> and_expr
818
is
xor_expr -> and_expr
818
and
xor_expr -> and_expr
818
or
xor_expr -> and_expr
818
!=
xor_expr -> and_expr
819
|
1402
819
>=
expr -> xor_expr
819
==
expr -> xor_expr
819
is
expr -> xor_expr
819
if
expr -> xor_expr
819
or
expr -> xor_expr
819
>
expr -> xor_expr
819
and
expr -> xor_expr
819
<
expr -> xor_expr
819
in
expr -> xor_expr
819
<=
expr -> xor_expr
819
=
expr -> xor_expr
819
not
expr -> xor_expr
819
!=
expr -> xor_expr
820
is
atom -> None
820
.
atom -> None
820
==
atom -> None
820
^
atom -> None
820
<<
atom -> None
820
>>
atom -> None
820
(
atom -> None
820
|
atom -> None
820
=
atom -> None
820
+
atom -> None
820
*
atom -> None
820
//
atom -> None
820
@
atom -> None
820
in
atom -> None
820
>=
atom -> None
820
!=
atom -> None
820
%
atom -> None
820
[
atom -> None
820
and
atom -> None
820
-
atom -> None
820
if
atom -> None
820
&
atom -> None
820
<=
atom -> None
820
<
atom -> None
820
>
atom -> None
820
**
atom -> None
820
or
atom -> None
820
/
atom -> None
820
not
atom -> None
821
in
atom -> False
821
>
atom -> False
821
-
atom -> False
821
%
atom -> False
821
<
atom -> False
821
|
atom -> False
821
==
atom -> False
821
&
atom -> False
821
//
atom -> False
821
and
atom -> False
821
not
atom -> False
821
+
atom -> False
821
!=
atom -> False
821
if
atom -> False
821
@
atom -> False
821
[
atom -> False
821
or
atom -> False
821
<=
atom -> False
821
=
atom -> False
821
*
atom -> False
821
^
atom -> False
821
is
atom -> False
821
/
atom -> False
821
.
atom -> False
821
>=
atom -> False
821
**
atom -> False
821
>>
atom -> False
821
<<
atom -> False
821
(
atom -> False
822
or
1403
822
=
or_test -> and_test
822
if
or_test -> and_test
823
}
1404
824
(
804
824
NAME
806
824
[
807
824
atom
808
824
+
809
824
factor
1405
824
atom_expr
812
824
power
811
824
NUMBER
813
824
STRING
814
824
-
816
824
True
817
824
None
820
824
False
821
824
{
823
824
~
824
825
and
1406
825
=
and_test -> not_test
825
or
and_test -> not_test
825
if
and_test -> not_test
826
is
215
826
<
217
826
!=
218
826
in
219
826
<=
220
826
not
221
826
>=
222
826
>
223
826
==
224
826
comp_op
1407
826
and
comparison -> expr
826
or
comparison -> expr
826
=
comparison -> expr
826
if
comparison -> expr
827
=
test -> lambdef
828
:
1408
828
varargslist
1409
828
NAME
305
828
vfpdef
306
829
=
test -> or_test
829
if
1410
830
factor
803
830
(
804
830
arith_expr
805
830
NAME
806
830
[
807
830
atom
808
830
+
809
830
term
810
830
power
811
830
atom_expr
812
830
NUMBER
813
830
STRING
814
830
shift_expr
815
830
-
816
830
not_test
1411
830
True
817
830
and_expr
818
830
xor_expr
819
830
None
820
830
False
821
830
{
823
830
~
824
830
expr
826
830
not
830
830
comparison
831
831
=
not_test -> comparison
831
and
not_test -> comparison
831
or
not_test -> comparison
831
if
not_test -> comparison
832
=
1412
833
factor
340
833
atom_expr
341
833
(
342
833
NAME
345
833
[
346
833
+
347
833
NUMBER
350
833
atom
349
833
STRING
352
833
-
353
833
term
1413
833
True
355
833
None
359
833
False
361
833
{
363
833
~
364
833
power
365
834
factor
340
834
atom_expr
341
834
(
342
834
NAME
345
834
[
346
834
+
347
834
NUMBER
350
834
atom
349
834
STRING
352
834
-
353
834
True
355
834
None
359
834
term
1414
834
False
361
834
{
363
834
~
364
834
power
365
835
factor
340
835
atom_expr
341
835
(
342
835
NAME
345
835
term
1415
835
[
346
835
+
347
835
NUMBER
350
835
atom
349
835
STRING
352
835
-
353
835
True
355
835
None
359
835
False
361
835
{
363
835
~
364
835
power
365
836
factor
340
836
atom_expr
341
836
(
342
836
NAME
345
836
[
346
836
+
347
836
NUMBER
350
836
atom
349
836
STRING
352
836
-
353
836
term
1416
836
True
355
836
None
359
836
False
361
836
{
363
836
~
364
836
power
365
837
factor
340
837
atom_expr
341
837
(
342
837
NAME
345
837
[
346
837
+
347
837
NUMBER
350
837
atom
349
837
term
1417
837
STRING
352
837
-
353
837
True
355
837
None
359
837
False
361
837
{
363
837
~
364
837
power
365
838
atom_expr
341
838
(
342
838
NAME
345
838
[
346
838
+
347
838
NUMBER
350
838
atom
349
838
STRING
352
838
-
353
838
factor
1418
838
True
355
838
None
359
838
False
361
838
{
363
838
~
364
838
power
365
839
)
1419
840
or
atom -> ( )
840
<<
atom -> ( )
840
NEWLINE
atom -> ( )
840
not
atom -> ( )
840
&
atom -> ( )
840
(
atom -> ( )
840
in
atom -> ( )
840
**
atom -> ( )
840
@
atom -> ( )
840
<=
atom -> ( )
840
%
atom -> ( )
840
[
atom -> ( )
840
>=
atom -> ( )
840
/
atom -> ( )
840
+
atom -> ( )
840
<
atom -> ( )
840
is
atom -> ( )
840
*
atom -> ( )
840
!=
atom -> ( )
840
-
atom -> ( )
840
from
atom -> ( )
840
|
atom -> ( )
840
//
atom -> ( )
840
^
atom -> ( )
840
and
atom -> ( )
840
==
atom -> ( )
840
if
atom -> ( )
840
>
atom -> ( )
840
.
atom -> ( )
840
>>
atom -> ( )
841
factor
340
841
atom_expr
341
841
(
342
841
arith_expr
343
841
NAME
345
841
[
346
841
+
347
841
term
348
841
atom
349
841
NUMBER
350
841
STRING
352
841
-
353
841
shift_expr
1420
841
True
355
841
None
359
841
False
361
841
{
363
841
~
364
841
power
365
842
factor
340
842
atom_expr
341
842
(
342
842
arith_expr
343
842
NAME
345
842
[
346
842
+
347
842
term
348
842
atom
349
842
NUMBER
350
842
STRING
352
842
-
353
842
True
355
842
shift_expr
1421
842
None
359
842
False
361
842
{
363
842
~
364
842
power
365
843
:
1422
844
factor
340
844
atom_expr
341
844
(
342
844
arith_expr
343
844
lambda
344
844
NAME
345
844
[
346
844
+
347
844
term
348
844
atom
349
844
NUMBER
350
844
shift_expr
351
844
STRING
352
844
-
353
844
or_test
354
844
True
355
844
and_expr
356
844
not
357
844
xor_expr
358
844
None
359
844
expr
360
844
False
361
844
and_test
362
844
{
363
844
~
364
844
power
365
844
not_test
366
844
comparison
367
844
test
1423
844
lambdef
368
845
<=
atom -> [ ]
845
is
atom -> [ ]
845
-
atom -> [ ]
845
**
atom -> [ ]
845
^
atom -> [ ]
845
%
atom -> [ ]
845
/
atom -> [ ]
845
>=
atom -> [ ]
845
|
atom -> [ ]
845
not
atom -> [ ]
845
@
atom -> [ ]
845
*
atom -> [ ]
845
(
atom -> [ ]
845
>>
atom -> [ ]
845
[
atom -> [ ]
845
NEWLINE
atom -> [ ]
845
from
atom -> [ ]
845
or
atom -> [ ]
845
!=
atom -> [ ]
845
and
atom -> [ ]
845
<<
atom -> [ ]
845
if
atom -> [ ]
845
in
atom -> [ ]
845
+
atom -> [ ]
845
.
atom -> [ ]
845
==
atom -> [ ]
845
>
atom -> [ ]
845
<
atom -> [ ]
845
&
atom -> [ ]
845
//
atom -> [ ]
846
]
1424
847
<
factor -> + factor
847
if
factor -> + factor
847
<<
factor -> + factor
847
and
factor -> + factor
847
>=
factor -> + factor
847
%
factor -> + factor
847
>>
factor -> + factor
847
*
factor -> + factor
847
+
factor -> + factor
847
from
factor -> + factor
847
/
factor -> + factor
847
>
factor -> + factor
847
<=
factor -> + factor
847
^
factor -> + factor
847
is
factor -> + factor
847
|
factor -> + factor
847
or
factor -> + factor
847
-
factor -> + factor
847
in
factor -> + factor
847
NEWLINE
factor -> + factor
847
&
factor -> + factor
847
not
factor -> + factor
847
//
factor -> + factor
847
!=
factor -> + factor
847
==
factor -> + factor
847
@
factor -> + factor
848
factor
340
848
atom_expr
341
848
(
342
848
NAME
345
848
[
346
848
+
347
848
term
348
848
NUMBER
350
848
atom
349
848
STRING
352
848
-
353
848
True
355
848
arith_expr
1425
848
None
359
848
False
361
848
{
363
848
~
364
848
power
365
849
factor
340
849
atom_expr
341
849
(
342
849
NAME
345
849
[
346
849
+
347
849
term
348
849
NUMBER
350
849
atom
349
849
STRING
352
849
-
353
849
True
355
849
None
359
849
False
361
849
arith_expr
1426
849
{
363
849
~
364
849
power
365
850
trailer_expr
1427
850
trailer
850
850
.
851
850
(
852
850
[
853
850
<<
trailer_expr -> 
850
%
trailer_expr -> 
850
==
trailer_expr -> 
850
from
trailer_expr -> 
850
-
trailer_expr -> 
850
<
trailer_expr -> 
850
NEWLINE
trailer_expr -> 
850
if
trailer_expr -> 
850
or
trailer_expr -> 
850
/
trailer_expr -> 
850
**
trailer_expr -> 
850
and
trailer_expr -> 
850
@
trailer_expr -> 
850
*
trailer_expr -> 
850
|
trailer_expr -> 
850
is
trailer_expr -> 
850
+
trailer_expr -> 
850
in
trailer_expr -> 
850
&
trailer_expr -> 
850
<=
trailer_expr -> 
850
>=
trailer_expr -> 
850
^
trailer_expr -> 
850
>
trailer_expr -> 
850
!=
trailer_expr -> 
850
not
trailer_expr -> 
850
>>
trailer_expr -> 
850
//
trailer_expr -> 
851
NAME
1428
852
factor
697
852
term
698
852
(
699
852
arith_expr
700
852
NAME
701
852
[
702
852
atom
703
852
+
704
852
power
706
852
atom_expr
707
852
NUMBER
708
852
STRING
709
852
arglist
1429
852
*
710
852
shift_expr
711
852
-
712
852
argument
714
852
)
1430
852
True
715
852
not_test
716
852
lambdef
717
852
and_expr
718
852
xor_expr
719
852
False
720
852
test
721
852
None
722
852
expr
723
852
and_test
724
852
{
725
852
~
726
852
lambda
727
852
comparison
728
852
or_test
729
852
not
730
852
**
731
853
factor
732
853
or_test
733
853
term
734
853
(
735
853
arith_expr
736
853
NAME
737
853
[
738
853
~
739
853
subscriptlist
1431
853
+
741
853
maybe_test
742
853
expr
743
853
atom_expr
744
853
atom
745
853
NUMBER
746
853
STRING
747
853
shift_expr
748
853
-
749
853
True
750
853
not_test
751
853
and_expr
752
853
xor_expr
753
853
False
754
853
{
755
853
None
756
853
and_test
757
853
lambda
758
853
power
759
853
subscript
760
853
test
761
853
lambdef
762
853
:
maybe_test -> 
853
comparison
763
853
not
764
854
>
atom_expr -> atom trailer_expr
854
from
atom_expr -> atom trailer_expr
854
not
atom_expr -> atom trailer_expr
854
//
atom_expr -> atom trailer_expr
854
>>
atom_expr -> atom trailer_expr
854
|
atom_expr -> atom trailer_expr
854
^
atom_expr -> atom trailer_expr
854
/
atom_expr -> atom trailer_expr
854
+
atom_expr -> atom trailer_expr
854
in
atom_expr -> atom trailer_expr
854
%
atom_expr -> atom trailer_expr
854
and
atom_expr -> atom trailer_expr
854
<=
atom_expr -> atom trailer_expr
854
is
atom_expr -> atom trailer_expr
854
<
atom_expr -> atom trailer_expr
854
@
atom_expr -> atom trailer_expr
854
-
atom_expr -> atom trailer_expr
854
NEWLINE
atom_expr -> atom trailer_expr
854
&
atom_expr -> atom trailer_expr
854
*
atom_expr -> atom trailer_expr
854
**
atom_expr -> atom trailer_expr
854
>=
atom_expr -> atom trailer_expr
854
or
atom_expr -> atom trailer_expr
854
==
atom_expr -> atom trailer_expr
854
!=
atom_expr -> atom trailer_expr
854
if
atom_expr -> atom trailer_expr
854
<<
atom_expr -> atom trailer_expr
855
factor
340
855
atom_expr
341
855
(
342
855
arith_expr
343
855
NAME
345
855
[
346
855
+
347
855
term
348
855
atom
349
855
NUMBER
350
855
shift_expr
351
855
STRING
352
855
-
353
855
True
355
855
None
359
855
and_expr
1432
855
False
361
855
{
363
855
~
364
855
power
365
856
and
factor -> - factor
856
from
factor -> - factor
856
if
factor -> - factor
856
or
factor -> - factor
856
>=
factor -> - factor
856
<
factor -> - factor
856
!=
factor -> - factor
856
-
factor -> - factor
856
==
factor -> - factor
856
@
factor -> - factor
856
|
factor -> - factor
856
*
factor -> - factor
856
%
factor -> - factor
856
+
factor -> - factor
856
<=
factor -> - factor
856
//
factor -> - factor
856
not
factor -> - factor
856
>>
factor -> - factor
856
/
factor -> - factor
856
&
factor -> - factor
856
^
factor -> - factor
856
in
factor -> - factor
856
is
factor -> - factor
856
>
factor -> - factor
856
NEWLINE
factor -> - factor
856
<<
factor -> - factor
857
factor
585
857
(
586
857
arith_expr
587
857
NAME
588
857
or_test
1433
857
[
589
857
and_expr
590
857
+
591
857
term
592
857
atom_expr
593
857
NUMBER
594
857
atom
595
857
STRING
596
857
shift_expr
597
857
-
598
857
True
599
857
not
600
857
xor_expr
601
857
None
602
857
False
603
857
not_test
605
857
~
606
857
power
607
857
{
608
857
expr
609
857
comparison
610
857
and_test
611
858
factor
340
858
atom_expr
341
858
(
342
858
arith_expr
343
858
NAME
345
858
[
346
858
+
347
858
term
348
858
atom
349
858
NUMBER
350
858
shift_expr
351
858
STRING
352
858
-
353
858
True
355
858
and_expr
356
858
None
359
858
False
361
858
{
363
858
~
364
858
xor_expr
1434
858
power
365
859
or
not_test -> not not_test
859
and
not_test -> not not_test
859
if
not_test -> not not_test
859
NEWLINE
not_test -> not not_test
859
from
not_test -> not not_test
860
factor
340
860
atom_expr
341
860
(
342
860
arith_expr
343
860
NAME
345
860
[
346
860
+
347
860
term
348
860
atom
349
860
NUMBER
350
860
shift_expr
351
860
STRING
352
860
-
353
860
True
355
860
and_expr
356
860
xor_expr
358
860
None
359
860
False
361
860
{
363
860
~
364
860
power
365
860
expr
1435
861
factor
340
861
atom_expr
341
861
(
342
861
arith_expr
343
861
NAME
345
861
[
346
861
+
347
861
term
348
861
atom
349
861
NUMBER
350
861
shift_expr
351
861
STRING
352
861
-
353
861
True
355
861
and_expr
356
861
comparison
1436
861
xor_expr
358
861
None
359
861
expr
360
861
False
361
861
{
363
861
~
364
861
power
365
862
factor
340
862
atom_expr
341
862
(
342
862
arith_expr
343
862
NAME
345
862
[
346
862
+
347
862
or_test
1437
862
term
348
862
atom
349
862
NUMBER
350
862
shift_expr
351
862
STRING
352
862
-
353
862
True
355
862
and_expr
356
862
not
357
862
xor_expr
358
862
None
359
862
expr
360
862
False
361
862
and_test
362
862
{
363
862
~
364
862
power
365
862
not_test
366
862
comparison
367
863
>
atom -> { }
863
==
atom -> { }
863
-
atom -> { }
863
not
atom -> { }
863
(
atom -> { }
863
@
atom -> { }
863
if
atom -> { }
863
and
atom -> { }
863
&
atom -> { }
863
<<
atom -> { }
863
!=
atom -> { }
863
or
atom -> { }
863
>>
atom -> { }
863
<=
atom -> { }
863
NEWLINE
atom -> { }
863
>=
atom -> { }
863
is
atom -> { }
863
from
atom -> { }
863
/
atom -> { }
863
^
atom -> { }
863
[
atom -> { }
863
%
atom -> { }
863
//
atom -> { }
863
*
atom -> { }
863
**
atom -> { }
863
.
atom -> { }
863
in
atom -> { }
863
+
atom -> { }
863
|
atom -> { }
863
<
atom -> { }
864
or
factor -> ~ factor
864
==
factor -> ~ factor
864
<=
factor -> ~ factor
864
@
factor -> ~ factor
864
!=
factor -> ~ factor
864
>=
factor -> ~ factor
864
>
factor -> ~ factor
864
and
factor -> ~ factor
864
*
factor -> ~ factor
864
&
factor -> ~ factor
864
%
factor -> ~ factor
864
<
factor -> ~ factor
864
from
factor -> ~ factor
864
//
factor -> ~ factor
864
if
factor -> ~ factor
864
^
factor -> ~ factor
864
/
factor -> ~ factor
864
in
factor -> ~ factor
864
+
factor -> ~ factor
864
not
factor -> ~ factor
864
-
factor -> ~ factor
864
is
factor -> ~ factor
864
>>
factor -> ~ factor
864
<<
factor -> ~ factor
864
NEWLINE
factor -> ~ factor
864
|
factor -> ~ factor
865
factor
340
865
atom_expr
341
865
(
342
865
arith_expr
343
865
NAME
345
865
[
346
865
+
347
865
term
348
865
atom
349
865
NUMBER
350
865
shift_expr
351
865
STRING
352
865
-
353
865
True
355
865
and_expr
356
865
not
357
865
xor_expr
358
865
None
359
865
expr
360
865
False
361
865
{
363
865
~
364
865
and_test
1438
865
power
365
865
not_test
366
865
comparison
367
866
factor
396
866
(
397
866
arith_expr
398
866
NAME
399
866
[
400
866
+
401
866
term
402
866
atom_expr
403
866
atom
404
866
NUMBER
405
866
STRING
406
866
shift_expr
407
866
-
408
866
True
409
866
and_expr
410
866
xor_expr
411
866
None
412
866
expr
413
866
False
414
866
and_test
415
866
lambda
416
866
{
417
866
~
418
866
power
419
866
not_test
420
866
not
421
866
comparison
422
866
test
1439
866
or_test
423
866
lambdef
424
867
factor
371
867
(
373
867
True
374
867
[
375
867
+
376
867
STRING
377
867
atom_expr
378
867
NUMBER
380
867
~
381
867
NAME
382
867
False
383
867
{
384
867
term
1440
867
None
387
867
power
388
867
-
389
867
atom
393
868
factor
371
868
(
373
868
True
374
868
[
375
868
+
376
868
STRING
377
868
atom_expr
378
868
NUMBER
380
868
~
381
868
NAME
382
868
term
1441
868
False
383
868
{
384
868
None
387
868
power
388
868
-
389
868
atom
393
869
factor
371
869
(
373
869
term
1442
869
True
374
869
[
375
869
+
376
869
STRING
377
869
atom_expr
378
869
NUMBER
380
869
~
381
869
NAME
382
869
False
383
869
{
384
869
None
387
869
power
388
869
-
389
869
atom
393
870
factor
371
870
(
373
870
True
374
870
term
1443
870
[
375
870
+
376
870
STRING
377
870
atom_expr
378
870
NUMBER
380
870
~
381
870
NAME
382
870
False
383
870
{
384
870
None
387
870
power
388
870
-
389
870
atom
393
871
factor
371
871
(
373
871
True
374
871
[
375
871
+
376
871
STRING
377
871
atom_expr
378
871
NUMBER
380
871
~
381
871
NAME
382
871
False
383
871
{
384
871
None
387
871
term
1444
871
power
388
871
-
389
871
atom
393
872
factor
371
872
term
372
872
(
373
872
True
374
872
[
375
872
+
376
872
STRING
377
872
atom_expr
378
872
NUMBER
380
872
arith_expr
1445
872
~
381
872
NAME
382
872
False
383
872
{
384
872
None
387
872
power
388
872
-
389
872
atom
393
873
factor
371
873
term
372
873
(
373
873
True
374
873
[
375
873
+
376
873
STRING
377
873
atom_expr
378
873
NUMBER
380
873
~
381
873
arith_expr
1446
873
NAME
382
873
False
383
873
{
384
873
None
387
873
power
388
873
-
389
873
atom
393
874
)
1447
875
@
atom -> ( )
875
.
atom -> ( )
875
|
atom -> ( )
875
%
atom -> ( )
875
[
atom -> ( )
875
(
atom -> ( )
875
//
atom -> ( )
875
^
atom -> ( )
875
**
atom -> ( )
875
<<
atom -> ( )
875
NEWLINE
atom -> ( )
875
,
atom -> ( )
875
/
atom -> ( )
875
+
atom -> ( )
875
&
atom -> ( )
875
*
atom -> ( )
875
-
atom -> ( )
875
>>
atom -> ( )
876
^
atom -> [ ]
876
%
atom -> [ ]
876
NEWLINE
atom -> [ ]
876
/
atom -> [ ]
876
|
atom -> [ ]
876
+
atom -> [ ]
876
.
atom -> [ ]
876
@
atom -> [ ]
876
*
atom -> [ ]
876
-
atom -> [ ]
876
(
atom -> [ ]
876
<<
atom -> [ ]
876
>>
atom -> [ ]
876
[
atom -> [ ]
876
,
atom -> [ ]
876
**
atom -> [ ]
876
&
atom -> [ ]
876
//
atom -> [ ]
877
]
1448
878
%
factor -> + factor
878
+
factor -> + factor
878
>>
factor -> + factor
878
*
factor -> + factor
878
|
factor -> + factor
878
<<
factor -> + factor
878
-
factor -> + factor
878
NEWLINE
factor -> + factor
878
/
factor -> + factor
878
&
factor -> + factor
878
,
factor -> + factor
878
^
factor -> + factor
878
@
factor -> + factor
878
//
factor -> + factor
879
(
373
879
True
374
879
[
375
879
factor
1449
879
+
376
879
STRING
377
879
atom_expr
378
879
NUMBER
380
879
~
381
879
NAME
382
879
False
383
879
{
384
879
None
387
879
power
388
879
-
389
879
atom
393
880
factor
371
880
term
372
880
(
373
880
True
374
880
[
375
880
+
376
880
STRING
377
880
atom_expr
378
880
arith_expr
379
880
NUMBER
380
880
~
381
880
NAME
382
880
False
383
880
{
384
880
None
387
880
power
388
880
-
389
880
shift_expr
1450
880
atom
393
881
factor
371
881
term
372
881
(
373
881
True
374
881
[
375
881
+
376
881
STRING
377
881
atom_expr
378
881
arith_expr
379
881
NUMBER
380
881
~
381
881
NAME
382
881
False
383
881
{
384
881
None
387
881
power
388
881
-
389
881
atom
393
881
shift_expr
1451
882
-
factor -> ~ factor
882
,
factor -> ~ factor
882
*
factor -> ~ factor
882
@
factor -> ~ factor
882
^
factor -> ~ factor
882
/
factor -> ~ factor
882
&
factor -> ~ factor
882
%
factor -> ~ factor
882
>>
factor -> ~ factor
882
+
factor -> ~ factor
882
<<
factor -> ~ factor
882
NEWLINE
factor -> ~ factor
882
|
factor -> ~ factor
882
//
factor -> ~ factor
883
**
atom -> { }
883
[
atom -> { }
883
<<
atom -> { }
883
%
atom -> { }
883
//
atom -> { }
883
-
atom -> { }
883
.
atom -> { }
883
^
atom -> { }
883
>>
atom -> { }
883
NEWLINE
atom -> { }
883
(
atom -> { }
883
@
atom -> { }
883
*
atom -> { }
883
+
atom -> { }
883
,
atom -> { }
883
|
atom -> { }
883
/
atom -> { }
883
&
atom -> { }
884
factor
371
884
term
372
884
(
373
884
True
374
884
[
375
884
+
376
884
STRING
377
884
atom_expr
378
884
arith_expr
379
884
NUMBER
380
884
~
381
884
NAME
382
884
False
383
884
{
384
884
and_expr
385
884
shift_expr
386
884
None
387
884
power
388
884
-
389
884
atom
393
884
xor_expr
1452
885
factor
371
885
term
372
885
(
373
885
True
374
885
[
375
885
+
376
885
STRING
377
885
atom_expr
378
885
arith_expr
379
885
NUMBER
380
885
~
381
885
and_expr
1453
885
NAME
382
885
False
383
885
{
384
885
shift_expr
386
885
None
387
885
power
388
885
-
389
885
atom
393
886
%
factor -> - factor
886
&
factor -> - factor
886
*
factor -> - factor
886
^
factor -> - factor
886
+
factor -> - factor
886
-
factor -> - factor
886
NEWLINE
factor -> - factor
886
//
factor -> - factor
886
,
factor -> - factor
886
@
factor -> - factor
886
|
factor -> - factor
886
<<
factor -> - factor
886
>>
factor -> - factor
886
/
factor -> - factor
887
factor
371
887
term
372
887
(
373
887
True
374
887
[
375
887
+
376
887
STRING
377
887
atom_expr
378
887
arith_expr
379
887
NUMBER
380
887
~
381
887
NAME
382
887
False
383
887
{
384
887
and_expr
385
887
shift_expr
386
887
None
387
887
power
388
887
-
389
887
expr
390
887
expr_list
1454
887
xor_expr
392
887
atom
393
888
factor
371
888
term
372
888
(
373
888
True
374
888
[
375
888
+
376
888
STRING
377
888
atom_expr
378
888
arith_expr
379
888
NUMBER
380
888
~
381
888
NAME
382
888
False
383
888
{
384
888
and_expr
385
888
shift_expr
386
888
None
387
888
power
388
888
-
389
888
xor_expr
392
888
atom
393
888
expr
1455
889
@
atom_expr -> atom trailer_expr
889
,
atom_expr -> atom trailer_expr
889
-
atom_expr -> atom trailer_expr
889
<<
atom_expr -> atom trailer_expr
889
NEWLINE
atom_expr -> atom trailer_expr
889
/
atom_expr -> atom trailer_expr
889
&
atom_expr -> atom trailer_expr
889
+
atom_expr -> atom trailer_expr
889
%
atom_expr -> atom trailer_expr
889
*
atom_expr -> atom trailer_expr
889
^
atom_expr -> atom trailer_expr
889
//
atom_expr -> atom trailer_expr
889
**
atom_expr -> atom trailer_expr
889
>>
atom_expr -> atom trailer_expr
889
|
atom_expr -> atom trailer_expr
890
trailer_expr
1456
890
trailer
890
890
(
891
890
.
892
890
[
893
890
<<
trailer_expr -> 
890
,
trailer_expr -> 
890
+
trailer_expr -> 
890
%
trailer_expr -> 
890
&
trailer_expr -> 
890
-
trailer_expr -> 
890
NEWLINE
trailer_expr -> 
890
^
trailer_expr -> 
890
/
trailer_expr -> 
890
>>
trailer_expr -> 
890
//
trailer_expr -> 
890
**
trailer_expr -> 
890
@
trailer_expr -> 
890
*
trailer_expr -> 
890
|
trailer_expr -> 
891
factor
697
891
term
698
891
(
699
891
arith_expr
700
891
NAME
701
891
[
702
891
atom
703
891
+
704
891
power
706
891
atom_expr
707
891
NUMBER
708
891
STRING
709
891
arglist
1457
891
*
710
891
shift_expr
711
891
-
712
891
argument
714
891
True
715
891
not_test
716
891
lambdef
717
891
and_expr
718
891
xor_expr
719
891
False
720
891
test
721
891
None
722
891
expr
723
891
)
1458
891
and_test
724
891
{
725
891
~
726
891
lambda
727
891
comparison
728
891
or_test
729
891
not
730
891
**
731
892
NAME
1459
893
factor
732
893
or_test
733
893
term
734
893
(
735
893
arith_expr
736
893
NAME
737
893
[
738
893
~
739
893
subscriptlist
1460
893
+
741
893
maybe_test
742
893
expr
743
893
atom_expr
744
893
atom
745
893
NUMBER
746
893
STRING
747
893
shift_expr
748
893
-
749
893
True
750
893
not_test
751
893
and_expr
752
893
xor_expr
753
893
False
754
893
{
755
893
None
756
893
and_test
757
893
lambda
758
893
power
759
893
subscript
760
893
test
761
893
lambdef
762
893
:
maybe_test -> 
893
comparison
763
893
not
764
894
factor
396
894
(
397
894
NAME
399
894
[
400
894
+
401
894
atom_expr
403
894
NUMBER
405
894
atom
404
894
STRING
406
894
-
408
894
term
1461
894
True
409
894
None
412
894
False
414
894
{
417
894
~
418
894
power
419
895
factor
396
895
(
397
895
NAME
399
895
[
400
895
+
401
895
atom_expr
403
895
NUMBER
405
895
atom
404
895
STRING
406
895
-
408
895
True
409
895
None
412
895
term
1462
895
False
414
895
{
417
895
~
418
895
power
419
896
factor
396
896
(
397
896
NAME
399
896
term
1463
896
[
400
896
+
401
896
atom_expr
403
896
NUMBER
405
896
atom
404
896
STRING
406
896
-
408
896
True
409
896
None
412
896
False
414
896
{
417
896
~
418
896
power
419
897
factor
396
897
(
397
897
NAME
399
897
[
400
897
+
401
897
atom_expr
403
897
NUMBER
405
897
atom
404
897
STRING
406
897
-
408
897
term
1464
897
True
409
897
None
412
897
False
414
897
{
417
897
~
418
897
power
419
898
factor
396
898
(
397
898
NAME
399
898
[
400
898
+
401
898
atom_expr
403
898
NUMBER
405
898
atom
404
898
term
1465
898
STRING
406
898
-
408
898
True
409
898
None
412
898
False
414
898
{
417
898
~
418
898
power
419
899
)
1466
900
or
atom -> ( )
900
<<
atom -> ( )
900
NEWLINE
atom -> ( )
900
not
atom -> ( )
900
&
atom -> ( )
900
(
atom -> ( )
900
in
atom -> ( )
900
**
atom -> ( )
900
@
atom -> ( )
900
<=
atom -> ( )
900
%
atom -> ( )
900
[
atom -> ( )
900
>=
atom -> ( )
900
/
atom -> ( )
900
+
atom -> ( )
900
<
atom -> ( )
900
is
atom -> ( )
900
*
atom -> ( )
900
!=
atom -> ( )
900
-
atom -> ( )
900
|
atom -> ( )
900
//
atom -> ( )
900
^
atom -> ( )
900
and
atom -> ( )
900
==
atom -> ( )
900
if
atom -> ( )
900
>
atom -> ( )
900
.
atom -> ( )
900
>>
atom -> ( )
901
factor
396
901
(
397
901
arith_expr
398
901
NAME
399
901
[
400
901
+
401
901
term
402
901
atom_expr
403
901
atom
404
901
NUMBER
405
901
STRING
406
901
-
408
901
shift_expr
1467
901
True
409
901
None
412
901
False
414
901
{
417
901
~
418
901
power
419
902
factor
396
902
(
397
902
arith_expr
398
902
NAME
399
902
[
400
902
+
401
902
term
402
902
atom_expr
403
902
atom
404
902
NUMBER
405
902
STRING
406
902
-
408
902
True
409
902
shift_expr
1468
902
None
412
902
False
414
902
{
417
902
~
418
902
power
419
903
<=
atom -> [ ]
903
is
atom -> [ ]
903
-
atom -> [ ]
903
**
atom -> [ ]
903
^
atom -> [ ]
903
%
atom -> [ ]
903
/
atom -> [ ]
903
>=
atom -> [ ]
903
|
atom -> [ ]
903
not
atom -> [ ]
903
@
atom -> [ ]
903
*
atom -> [ ]
903
(
atom -> [ ]
903
>>
atom -> [ ]
903
[
atom -> [ ]
903
NEWLINE
atom -> [ ]
903
or
atom -> [ ]
903
!=
atom -> [ ]
903
and
atom -> [ ]
903
<<
atom -> [ ]
903
if
atom -> [ ]
903
in
atom -> [ ]
903
+
atom -> [ ]
903
.
atom -> [ ]
903
==
atom -> [ ]
903
>
atom -> [ ]
903
<
atom -> [ ]
903
&
atom -> [ ]
903
//
atom -> [ ]
904
]
1469
905
<
factor -> + factor
905
if
factor -> + factor
905
<<
factor -> + factor
905
and
factor -> + factor
905
>=
factor -> + factor
905
%
factor -> + factor
905
>>
factor -> + factor
905
*
factor -> + factor
905
+
factor -> + factor
905
/
factor -> + factor
905
>
factor -> + factor
905
<=
factor -> + factor
905
^
factor -> + factor
905
is
factor -> + factor
905
|
factor -> + factor
905
or
factor -> + factor
905
-
factor -> + factor
905
in
factor -> + factor
905
NEWLINE
factor -> + factor
905
&
factor -> + factor
905
not
factor -> + factor
905
//
factor -> + factor
905
!=
factor -> + factor
905
==
factor -> + factor
905
@
factor -> + factor
906
factor
396
906
(
397
906
NAME
399
906
[
400
906
+
401
906
term
402
906
atom_expr
403
906
NUMBER
405
906
atom
404
906
STRING
406
906
-
408
906
True
409
906
arith_expr
1470
906
None
412
906
False
414
906
{
417
906
~
418
906
power
419
907
factor
396
907
(
397
907
NAME
399
907
[
400
907
+
401
907
term
402
907
atom_expr
403
907
NUMBER
405
907
atom
404
907
STRING
406
907
-
408
907
True
409
907
None
412
907
False
414
907
arith_expr
1471
907
{
417
907
~
418
907
power
419
908
(
397
908
NAME
399
908
[
400
908
+
401
908
atom_expr
403
908
NUMBER
405
908
atom
404
908
STRING
406
908
-
408
908
factor
1472
908
True
409
908
None
412
908
False
414
908
{
417
908
~
418
908
power
419
909
trailer_expr
1473
909
trailer
909
909
.
910
909
(
911
909
[
912
909
<<
trailer_expr -> 
909
%
trailer_expr -> 
909
==
trailer_expr -> 
909
-
trailer_expr -> 
909
<
trailer_expr -> 
909
NEWLINE
trailer_expr -> 
909
if
trailer_expr -> 
909
or
trailer_expr -> 
909
/
trailer_expr -> 
909
**
trailer_expr -> 
909
and
trailer_expr -> 
909
@
trailer_expr -> 
909
*
trailer_expr -> 
909
|
trailer_expr -> 
909
is
trailer_expr -> 
909
+
trailer_expr -> 
909
in
trailer_expr -> 
909
&
trailer_expr -> 
909
<=
trailer_expr -> 
909
>=
trailer_expr -> 
909
^
trailer_expr -> 
909
>
trailer_expr -> 
909
!=
trailer_expr -> 
909
not
trailer_expr -> 
909
>>
trailer_expr -> 
909
//
trailer_expr -> 
910
NAME
1474
911
factor
697
911
term
698
911
(
699
911
arith_expr
700
911
NAME
701
911
[
702
911
atom
703
911
+
704
911
power
706
911
atom_expr
707
911
NUMBER
708
911
STRING
709
911
arglist
1475
911
*
710
911
shift_expr
711
911
-
712
911
argument
714
911
)
1476
911
True
715
911
not_test
716
911
lambdef
717
911
and_expr
718
911
xor_expr
719
911
False
720
911
test
721
911
None
722
911
expr
723
911
and_test
724
911
{
725
911
~
726
911
lambda
727
911
comparison
728
911
or_test
729
911
not
730
911
**
731
912
factor
732
912
or_test
733
912
term
734
912
(
735
912
arith_expr
736
912
NAME
737
912
[
738
912
~
739
912
subscriptlist
1477
912
+
741
912
maybe_test
742
912
expr
743
912
atom_expr
744
912
atom
745
912
NUMBER
746
912
STRING
747
912
shift_expr
748
912
-
749
912
True
750
912
not_test
751
912
and_expr
752
912
xor_expr
753
912
False
754
912
{
755
912
None
756
912
and_test
757
912
lambda
758
912
power
759
912
subscript
760
912
test
761
912
lambdef
762
912
:
maybe_test -> 
912
comparison
763
912
not
764
913
>
atom_expr -> atom trailer_expr
913
not
atom_expr -> atom trailer_expr
913
//
atom_expr -> atom trailer_expr
913
>>
atom_expr -> atom trailer_expr
913
|
atom_expr -> atom trailer_expr
913
^
atom_expr -> atom trailer_expr
913
/
atom_expr -> atom trailer_expr
913
+
atom_expr -> atom trailer_expr
913
in
atom_expr -> atom trailer_expr
913
%
atom_expr -> atom trailer_expr
913
and
atom_expr -> atom trailer_expr
913
<=
atom_expr -> atom trailer_expr
913
is
atom_expr -> atom trailer_expr
913
<
atom_expr -> atom trailer_expr
913
@
atom_expr -> atom trailer_expr
913
-
atom_expr -> atom trailer_expr
913
NEWLINE
atom_expr -> atom trailer_expr
913
&
atom_expr -> atom trailer_expr
913
*
atom_expr -> atom trailer_expr
913
**
atom_expr -> atom trailer_expr
913
>=
atom_expr -> atom trailer_expr
913
or
atom_expr -> atom trailer_expr
913
==
atom_expr -> atom trailer_expr
913
!=
atom_expr -> atom trailer_expr
913
if
atom_expr -> atom trailer_expr
913
<<
atom_expr -> atom trailer_expr
914
factor
396
914
(
397
914
arith_expr
398
914
NAME
399
914
[
400
914
+
401
914
term
402
914
atom_expr
403
914
atom
404
914
NUMBER
405
914
STRING
406
914
shift_expr
407
914
-
408
914
True
409
914
None
412
914
and_expr
1478
914
False
414
914
{
417
914
~
418
914
power
419
915
and
factor -> - factor
915
if
factor -> - factor
915
or
factor -> - factor
915
>=
factor -> - factor
915
<
factor -> - factor
915
!=
factor -> - factor
915
-
factor -> - factor
915
==
factor -> - factor
915
@
factor -> - factor
915
|
factor -> - factor
915
*
factor -> - factor
915
%
factor -> - factor
915
+
factor -> - factor
915
<=
factor -> - factor
915
//
factor -> - factor
915
not
factor -> - factor
915
>>
factor -> - factor
915
/
factor -> - factor
915
&
factor -> - factor
915
^
factor -> - factor
915
in
factor -> - factor
915
is
factor -> - factor
915
>
factor -> - factor
915
NEWLINE
factor -> - factor
915
<<
factor -> - factor
916
factor
396
916
(
397
916
arith_expr
398
916
NAME
399
916
[
400
916
+
401
916
term
402
916
atom_expr
403
916
atom
404
916
NUMBER
405
916
STRING
406
916
shift_expr
407
916
-
408
916
True
409
916
and_expr
410
916
None
412
916
False
414
916
{
417
916
~
418
916
xor_expr
1479
916
power
419
917
factor
396
917
(
397
917
arith_expr
398
917
NAME
399
917
[
400
917
+
401
917
term
402
917
atom_expr
403
917
atom
404
917
NUMBER
405
917
STRING
406
917
shift_expr
407
917
-
408
917
True
409
917
and_expr
410
917
xor_expr
411
917
None
412
917
False
414
917
{
417
917
~
418
917
power
419
917
expr
1480
918
factor
396
918
(
397
918
arith_expr
398
918
NAME
399
918
[
400
918
+
401
918
term
402
918
atom_expr
403
918
atom
404
918
NUMBER
405
918
STRING
406
918
shift_expr
407
918
-
408
918
True
409
918
and_expr
410
918
comparison
1481
918
xor_expr
411
918
None
412
918
expr
413
918
False
414
918
{
417
918
~
418
918
power
419
919
factor
396
919
(
397
919
arith_expr
398
919
NAME
399
919
[
400
919
+
401
919
or_test
1482
919
term
402
919
atom_expr
403
919
atom
404
919
NUMBER
405
919
STRING
406
919
shift_expr
407
919
-
408
919
True
409
919
and_expr
410
919
xor_expr
411
919
None
412
919
expr
413
919
False
414
919
and_test
415
919
{
417
919
~
418
919
power
419
919
not_test
420
919
not
421
919
comparison
422
920
:
1483
921
factor
396
921
(
397
921
arith_expr
398
921
NAME
399
921
[
400
921
+
401
921
term
402
921
atom_expr
403
921
atom
404
921
NUMBER
405
921
STRING
406
921
shift_expr
407
921
-
408
921
True
409
921
and_expr
410
921
xor_expr
411
921
None
412
921
expr
413
921
False
414
921
and_test
415
921
lambda
416
921
{
417
921
~
418
921
power
419
921
not_test
420
921
not
421
921
comparison
422
921
or_test
423
921
lambdef
424
921
test
1484
922
>
atom -> { }
922
==
atom -> { }
922
-
atom -> { }
922
not
atom -> { }
922
(
atom -> { }
922
@
atom -> { }
922
if
atom -> { }
922
and
atom -> { }
922
&
atom -> { }
922
<<
atom -> { }
922
!=
atom -> { }
922
or
atom -> { }
922
>>
atom -> { }
922
<=
atom -> { }
922
NEWLINE
atom -> { }
922
>=
atom -> { }
922
is
atom -> { }
922
/
atom -> { }
922
^
atom -> { }
922
[
atom -> { }
922
%
atom -> { }
922
//
atom -> { }
922
*
atom -> { }
922
**
atom -> { }
922
.
atom -> { }
922
in
atom -> { }
922
+
atom -> { }
922
|
atom -> { }
922
<
atom -> { }
923
or
factor -> ~ factor
923
==
factor -> ~ factor
923
<=
factor -> ~ factor
923
@
factor -> ~ factor
923
!=
factor -> ~ factor
923
>=
factor -> ~ factor
923
>
factor -> ~ factor
923
and
factor -> ~ factor
923
*
factor -> ~ factor
923
&
factor -> ~ factor
923
%
factor -> ~ factor
923
<
factor -> ~ factor
923
//
factor -> ~ factor
923
if
factor -> ~ factor
923
^
factor -> ~ factor
923
/
factor -> ~ factor
923
in
factor -> ~ factor
923
+
factor -> ~ factor
923
not
factor -> ~ factor
923
-
factor -> ~ factor
923
is
factor -> ~ factor
923
>>
factor -> ~ factor
923
<<
factor -> ~ factor
923
NEWLINE
factor -> ~ factor
923
|
factor -> ~ factor
924
factor
396
924
(
397
924
arith_expr
398
924
NAME
399
924
[
400
924
+
401
924
term
402
924
atom_expr
403
924
atom
404
924
NUMBER
405
924
STRING
406
924
shift_expr
407
924
-
408
924
True
409
924
and_expr
410
924
xor_expr
411
924
None
412
924
expr
413
924
False
414
924
{
417
924
~
418
924
and_test
1485
924
power
419
924
not_test
420
924
not
421
924
comparison
422
925
if
not_test -> not not_test
925
NEWLINE
not_test -> not not_test
925
or
not_test -> not not_test
925
and
not_test -> not not_test
926
factor
585
926
(
586
926
arith_expr
587
926
NAME
588
926
[
589
926
and_expr
590
926
+
591
926
term
592
926
atom_expr
593
926
NUMBER
594
926
atom
595
926
STRING
596
926
shift_expr
597
926
-
598
926
True
599
926
not
600
926
xor_expr
601
926
None
602
926
False
603
926
not_test
605
926
~
606
926
power
607
926
{
608
926
expr
609
926
comparison
610
926
and_test
611
926
or_test
1486
927
and
term -> factor // term
927
if
term -> factor // term
927
>
term -> factor // term
927
<
term -> factor // term
927
==
term -> factor // term
927
+
term -> factor // term
927
-
term -> factor // term
927
&
term -> factor // term
927
in
term -> factor // term
927
:
term -> factor // term
927
!=
term -> factor // term
927
^
term -> factor // term
927
or
term -> factor // term
927
<=
term -> factor // term
927
>=
term -> factor // term
927
|
term -> factor // term
927
>>
term -> factor // term
927
not
term -> factor // term
927
is
term -> factor // term
927
<<
term -> factor // term
928
or
term -> factor / term
928
<<
term -> factor / term
928
not
term -> factor / term
928
in
term -> factor / term
928
!=
term -> factor / term
928
<
term -> factor / term
928
+
term -> factor / term
928
and
term -> factor / term
928
>>
term -> factor / term
928
^
term -> factor / term
928
<=
term -> factor / term
928
==
term -> factor / term
928
>
term -> factor / term
928
&
term -> factor / term
928
is
term -> factor / term
928
-
term -> factor / term
928
:
term -> factor / term
928
|
term -> factor / term
928
>=
term -> factor / term
928
if
term -> factor / term
929
^
term -> factor * term
929
+
term -> factor * term
929
==
term -> factor * term
929
>>
term -> factor * term
929
in
term -> factor * term
929
and
term -> factor * term
929
if
term -> factor * term
929
is
term -> factor * term
929
<<
term -> factor * term
929
:
term -> factor * term
929
-
term -> factor * term
929
!=
term -> factor * term
929
or
term -> factor * term
929
>
term -> factor * term
929
&
term -> factor * term
929
|
term -> factor * term
929
>=
term -> factor * term
929
<=
term -> factor * term
929
not
term -> factor * term
929
<
term -> factor * term
930
&
term -> factor % term
930
==
term -> factor % term
930
!=
term -> factor % term
930
<
term -> factor % term
930
in
term -> factor % term
930
>>
term -> factor % term
930
<<
term -> factor % term
930
-
term -> factor % term
930
if
term -> factor % term
930
>
term -> factor % term
930
or
term -> factor % term
930
^
term -> factor % term
930
+
term -> factor % term
930
is
term -> factor % term
930
|
term -> factor % term
930
>=
term -> factor % term
930
<=
term -> factor % term
930
and
term -> factor % term
930
not
term -> factor % term
930
:
term -> factor % term
931
and
term -> factor @ term
931
in
term -> factor @ term
931
>=
term -> factor @ term
931
<
term -> factor @ term
931
:
term -> factor @ term
931
>
term -> factor @ term
931
-
term -> factor @ term
931
or
term -> factor @ term
931
<<
term -> factor @ term
931
is
term -> factor @ term
931
!=
term -> factor @ term
931
|
term -> factor @ term
931
&
term -> factor @ term
931
==
term -> factor @ term
931
>>
term -> factor @ term
931
<=
term -> factor @ term
931
not
term -> factor @ term
931
+
term -> factor @ term
931
^
term -> factor @ term
931
if
term -> factor @ term
932
+
atom -> ( test_list_comp )
932
/
atom -> ( test_list_comp )
932
*
atom -> ( test_list_comp )
932
[
atom -> ( test_list_comp )
932
&
atom -> ( test_list_comp )
932
**
atom -> ( test_list_comp )
932
^
atom -> ( test_list_comp )
932
(
atom -> ( test_list_comp )
932
and
atom -> ( test_list_comp )
932
:
atom -> ( test_list_comp )
932
>
atom -> ( test_list_comp )
932
-
atom -> ( test_list_comp )
932
%
atom -> ( test_list_comp )
932
//
atom -> ( test_list_comp )
932
in
atom -> ( test_list_comp )
932
>>
atom -> ( test_list_comp )
932
not
atom -> ( test_list_comp )
932
>=
atom -> ( test_list_comp )
932
or
atom -> ( test_list_comp )
932
<
atom -> ( test_list_comp )
932
if
atom -> ( test_list_comp )
932
|
atom -> ( test_list_comp )
932
<<
atom -> ( test_list_comp )
932
@
atom -> ( test_list_comp )
932
!=
atom -> ( test_list_comp )
932
is
atom -> ( test_list_comp )
932
.
atom -> ( test_list_comp )
932
<=
atom -> ( test_list_comp )
932
==
atom -> ( test_list_comp )
933
>=
shift_expr -> arith_expr >> shift_expr
933
if
shift_expr -> arith_expr >> shift_expr
933
<=
shift_expr -> arith_expr >> shift_expr
933
!=
shift_expr -> arith_expr >> shift_expr
933
or
shift_expr -> arith_expr >> shift_expr
933
|
shift_expr -> arith_expr >> shift_expr
933
is
shift_expr -> arith_expr >> shift_expr
933
and
shift_expr -> arith_expr >> shift_expr
933
in
shift_expr -> arith_expr >> shift_expr
933
^
shift_expr -> arith_expr >> shift_expr
933
not
shift_expr -> arith_expr >> shift_expr
933
<
shift_expr -> arith_expr >> shift_expr
933
==
shift_expr -> arith_expr >> shift_expr
933
:
shift_expr -> arith_expr >> shift_expr
933
&
shift_expr -> arith_expr >> shift_expr
933
>
shift_expr -> arith_expr >> shift_expr
934
>
shift_expr -> arith_expr << shift_expr
934
or
shift_expr -> arith_expr << shift_expr
934
^
shift_expr -> arith_expr << shift_expr
934
not
shift_expr -> arith_expr << shift_expr
934
<
shift_expr -> arith_expr << shift_expr
934
if
shift_expr -> arith_expr << shift_expr
934
in
shift_expr -> arith_expr << shift_expr
934
!=
shift_expr -> arith_expr << shift_expr
934
==
shift_expr -> arith_expr << shift_expr
934
|
shift_expr -> arith_expr << shift_expr
934
>=
shift_expr -> arith_expr << shift_expr
934
and
shift_expr -> arith_expr << shift_expr
934
&
shift_expr -> arith_expr << shift_expr
934
<=
shift_expr -> arith_expr << shift_expr
934
is
shift_expr -> arith_expr << shift_expr
934
:
shift_expr -> arith_expr << shift_expr
935
==
arith_expr -> term + arith_expr
935
if
arith_expr -> term + arith_expr
935
>=
arith_expr -> term + arith_expr
935
>
arith_expr -> term + arith_expr
935
!=
arith_expr -> term + arith_expr
935
is
arith_expr -> term + arith_expr
935
<<
arith_expr -> term + arith_expr
935
|
arith_expr -> term + arith_expr
935
and
arith_expr -> term + arith_expr
935
^
arith_expr -> term + arith_expr
935
>>
arith_expr -> term + arith_expr
935
in
arith_expr -> term + arith_expr
935
or
arith_expr -> term + arith_expr
935
:
arith_expr -> term + arith_expr
935
<
arith_expr -> term + arith_expr
935
&
arith_expr -> term + arith_expr
935
not
arith_expr -> term + arith_expr
935
<=
arith_expr -> term + arith_expr
936
if
arith_expr -> term - arith_expr
936
>
arith_expr -> term - arith_expr
936
>>
arith_expr -> term - arith_expr
936
&
arith_expr -> term - arith_expr
936
and
arith_expr -> term - arith_expr
936
:
arith_expr -> term - arith_expr
936
>=
arith_expr -> term - arith_expr
936
is
arith_expr -> term - arith_expr
936
in
arith_expr -> term - arith_expr
936
!=
arith_expr -> term - arith_expr
936
^
arith_expr -> term - arith_expr
936
<
arith_expr -> term - arith_expr
936
<<
arith_expr -> term - arith_expr
936
not
arith_expr -> term - arith_expr
936
==
arith_expr -> term - arith_expr
936
|
arith_expr -> term - arith_expr
936
or
arith_expr -> term - arith_expr
936
<=
arith_expr -> term - arith_expr
937
in
atom -> [ test_list_comp ]
937
/
atom -> [ test_list_comp ]
937
or
atom -> [ test_list_comp ]
937
if
atom -> [ test_list_comp ]
937
<<
atom -> [ test_list_comp ]
937
!=
atom -> [ test_list_comp ]
937
<=
atom -> [ test_list_comp ]
937
>>
atom -> [ test_list_comp ]
937
*
atom -> [ test_list_comp ]
937
^
atom -> [ test_list_comp ]
937
.
atom -> [ test_list_comp ]
937
(
atom -> [ test_list_comp ]
937
>=
atom -> [ test_list_comp ]
937
and
atom -> [ test_list_comp ]
937
<
atom -> [ test_list_comp ]
937
[
atom -> [ test_list_comp ]
937
==
atom -> [ test_list_comp ]
937
@
atom -> [ test_list_comp ]
937
%
atom -> [ test_list_comp ]
937
-
atom -> [ test_list_comp ]
937
|
atom -> [ test_list_comp ]
937
&
atom -> [ test_list_comp ]
937
:
atom -> [ test_list_comp ]
937
+
atom -> [ test_list_comp ]
937
is
atom -> [ test_list_comp ]
937
//
atom -> [ test_list_comp ]
937
**
atom -> [ test_list_comp ]
937
not
atom -> [ test_list_comp ]
937
>
atom -> [ test_list_comp ]
938
or
comparison -> expr comp_op comparison
938
and
comparison -> expr comp_op comparison
938
:
comparison -> expr comp_op comparison
938
if
comparison -> expr comp_op comparison
939
+
power -> atom_expr ** factor
939
&
power -> atom_expr ** factor
939
>>
power -> atom_expr ** factor
939
<<
power -> atom_expr ** factor
939
not
power -> atom_expr ** factor
939
is
power -> atom_expr ** factor
939
@
power -> atom_expr ** factor
939
:
power -> atom_expr ** factor
939
==
power -> atom_expr ** factor
939
*
power -> atom_expr ** factor
939
or
power -> atom_expr ** factor
939
>
power -> atom_expr ** factor
939
-
power -> atom_expr ** factor
939
if
power -> atom_expr ** factor
939
!=
power -> atom_expr ** factor
939
>=
power -> atom_expr ** factor
939
/
power -> atom_expr ** factor
939
%
power -> atom_expr ** factor
939
and
power -> atom_expr ** factor
939
<=
power -> atom_expr ** factor
939
<
power -> atom_expr ** factor
939
|
power -> atom_expr ** factor
939
^
power -> atom_expr ** factor
939
in
power -> atom_expr ** factor
939
//
power -> atom_expr ** factor
940
+
trailer_expr -> trailer trailer_expr
940
*
trailer_expr -> trailer trailer_expr
940
/
trailer_expr -> trailer trailer_expr
940
not
trailer_expr -> trailer trailer_expr
940
<<
trailer_expr -> trailer trailer_expr
940
!=
trailer_expr -> trailer trailer_expr
940
>=
trailer_expr -> trailer trailer_expr
940
>>
trailer_expr -> trailer trailer_expr
940
|
trailer_expr -> trailer trailer_expr
940
%
trailer_expr -> trailer trailer_expr
940
>
trailer_expr -> trailer trailer_expr
940
&
trailer_expr -> trailer trailer_expr
940
-
trailer_expr -> trailer trailer_expr
940
<=
trailer_expr -> trailer trailer_expr
940
:
trailer_expr -> trailer trailer_expr
940
**
trailer_expr -> trailer trailer_expr
940
@
trailer_expr -> trailer trailer_expr
940
if
trailer_expr -> trailer trailer_expr
940
==
trailer_expr -> trailer trailer_expr
940
or
trailer_expr -> trailer trailer_expr
940
<
trailer_expr -> trailer trailer_expr
940
and
trailer_expr -> trailer trailer_expr
940
in
trailer_expr -> trailer trailer_expr
940
is
trailer_expr -> trailer trailer_expr
940
^
trailer_expr -> trailer trailer_expr
940
//
trailer_expr -> trailer trailer_expr
941
<=
trailer -> . NAME
941
<<
trailer -> . NAME
941
**
trailer -> . NAME
941
!=
trailer -> . NAME
941
:
trailer -> . NAME
941
/
trailer -> . NAME
941
&
trailer -> . NAME
941
//
trailer -> . NAME
941
<
trailer -> . NAME
941
is
trailer -> . NAME
941
-
trailer -> . NAME
941
if
trailer -> . NAME
941
[
trailer -> . NAME
941
or
trailer -> . NAME
941
>
trailer -> . NAME
941
*
trailer -> . NAME
941
+
trailer -> . NAME
941
%
trailer -> . NAME
941
.
trailer -> . NAME
941
>=
trailer -> . NAME
941
|
trailer -> . NAME
941
and
trailer -> . NAME
941
(
trailer -> . NAME
941
==
trailer -> . NAME
941
^
trailer -> . NAME
941
in
trailer -> . NAME
941
@
trailer -> . NAME
941
not
trailer -> . NAME
941
>>
trailer -> . NAME
942
%
trailer -> ( )
942
<=
trailer -> ( )
942
and
trailer -> ( )
942
//
trailer -> ( )
942
not
trailer -> ( )
942
or
trailer -> ( )
942
>>
trailer -> ( )
942
>
trailer -> ( )
942
<<
trailer -> ( )
942
[
trailer -> ( )
942
is
trailer -> ( )
942
:
trailer -> ( )
942
-
trailer -> ( )
942
**
trailer -> ( )
942
/
trailer -> ( )
942
+
trailer -> ( )
942
&
trailer -> ( )
942
in
trailer -> ( )
942
^
trailer -> ( )
942
!=
trailer -> ( )
942
*
trailer -> ( )
942
if
trailer -> ( )
942
>=
trailer -> ( )
942
(
trailer -> ( )
942
@
trailer -> ( )
942
==
trailer -> ( )
942
|
trailer -> ( )
942
.
trailer -> ( )
942
<
trailer -> ( )
943
)
1487
944
]
1488
945
NEWLINE
1489
946
NEWLINE
elif_clause -> 
946
-
elif_clause -> 
946
elif
1490
946
elif_clause
1491
946
NUMBER
elif_clause -> 
946
conf
elif_clause -> 
946
class
elif_clause -> 
946
(
elif_clause -> 
946
NAME
elif_clause -> 
946
else
elif_clause -> 
946
pass
elif_clause -> 
946
~
elif_clause -> 
946
not
elif_clause -> 
946
endsim
elif_clause -> 
946
{
elif_clause -> 
946
yield
elif_clause -> 
946
def
elif_clause -> 
946
lambda
elif_clause -> 
946
@
elif_clause -> 
946
[
elif_clause -> 
946
+
elif_clause -> 
946
raise
elif_clause -> 
946
True
elif_clause -> 
946
del
elif_clause -> 
946
None
elif_clause -> 
946
nonlocal
elif_clause -> 
946
while
elif_clause -> 
946
return
elif_clause -> 
946
try
elif_clause -> 
946
False
elif_clause -> 
946
begsim
elif_clause -> 
946
global
elif_clause -> 
946
continue
elif_clause -> 
946
with
elif_clause -> 
946
if
elif_clause -> 
946
break
elif_clause -> 
946
STRING
elif_clause -> 
946
assert
elif_clause -> 
946
$
elif_clause -> 
946
resetstats
elif_clause -> 
946
for
elif_clause -> 
947
INDENT
1492
948
resetstats
suite -> simple_stmt
948
+
suite -> simple_stmt
948
lambda
suite -> simple_stmt
948
try
suite -> simple_stmt
948
begsim
suite -> simple_stmt
948
None
suite -> simple_stmt
948
not
suite -> simple_stmt
948
@
suite -> simple_stmt
948
[
suite -> simple_stmt
948
class
suite -> simple_stmt
948
return
suite -> simple_stmt
948
else
suite -> simple_stmt
948
nonlocal
suite -> simple_stmt
948
NUMBER
suite -> simple_stmt
948
yield
suite -> simple_stmt
948
STRING
suite -> simple_stmt
948
NEWLINE
suite -> simple_stmt
948
-
suite -> simple_stmt
948
False
suite -> simple_stmt
948
def
suite -> simple_stmt
948
conf
suite -> simple_stmt
948
elif
suite -> simple_stmt
948
True
suite -> simple_stmt
948
raise
suite -> simple_stmt
948
endsim
suite -> simple_stmt
948
with
suite -> simple_stmt
948
global
suite -> simple_stmt
948
{
suite -> simple_stmt
948
~
suite -> simple_stmt
948
assert
suite -> simple_stmt
948
(
suite -> simple_stmt
948
$
suite -> simple_stmt
948
while
suite -> simple_stmt
948
del
suite -> simple_stmt
948
pass
suite -> simple_stmt
948
break
suite -> simple_stmt
948
for
suite -> simple_stmt
948
continue
suite -> simple_stmt
948
NAME
suite -> simple_stmt
948
if
suite -> simple_stmt
949
==
and_expr -> shift_expr & and_expr
949
in
and_expr -> shift_expr & and_expr
949
!=
and_expr -> shift_expr & and_expr
949
or
and_expr -> shift_expr & and_expr
949
>
and_expr -> shift_expr & and_expr
949
not
and_expr -> shift_expr & and_expr
949
:
and_expr -> shift_expr & and_expr
949
|
and_expr -> shift_expr & and_expr
949
<=
and_expr -> shift_expr & and_expr
949
and
and_expr -> shift_expr & and_expr
949
^
and_expr -> shift_expr & and_expr
949
is
and_expr -> shift_expr & and_expr
949
>=
and_expr -> shift_expr & and_expr
949
<
and_expr -> shift_expr & and_expr
949
if
and_expr -> shift_expr & and_expr
950
<=
xor_expr -> and_expr ^ xor_expr
950
!=
xor_expr -> and_expr ^ xor_expr
950
and
xor_expr -> and_expr ^ xor_expr
950
is
xor_expr -> and_expr ^ xor_expr
950
>=
xor_expr -> and_expr ^ xor_expr
950
not
xor_expr -> and_expr ^ xor_expr
950
<
xor_expr -> and_expr ^ xor_expr
950
:
xor_expr -> and_expr ^ xor_expr
950
|
xor_expr -> and_expr ^ xor_expr
950
in
xor_expr -> and_expr ^ xor_expr
950
==
xor_expr -> and_expr ^ xor_expr
950
or
xor_expr -> and_expr ^ xor_expr
950
if
xor_expr -> and_expr ^ xor_expr
950
>
xor_expr -> and_expr ^ xor_expr
951
not
expr -> xor_expr | expr
951
in
expr -> xor_expr | expr
951
if
expr -> xor_expr | expr
951
:
expr -> xor_expr | expr
951
or
expr -> xor_expr | expr
951
<=
expr -> xor_expr | expr
951
>
expr -> xor_expr | expr
951
!=
expr -> xor_expr | expr
951
==
expr -> xor_expr | expr
951
>=
expr -> xor_expr | expr
951
is
expr -> xor_expr | expr
951
<
expr -> xor_expr | expr
951
and
expr -> xor_expr | expr
952
if
or_test -> and_test or or_test
952
:
or_test -> and_test or or_test
953
:
and_test -> not_test and and_test
953
if
and_test -> not_test and and_test
953
or
and_test -> not_test and and_test
954
else
1493
955
:
lambdef -> lambda : test
956
factor
85
956
(
86
956
arith_expr
87
956
NAME
88
956
term
89
956
[
90
956
~
91
956
+
92
956
expr
93
956
atom_expr
94
956
atom
95
956
NUMBER
96
956
STRING
97
956
shift_expr
99
956
-
100
956
True
101
956
and_expr
102
956
xor_expr
103
956
False
104
956
{
105
956
None
106
956
and_test
107
956
power
108
956
not_test
109
956
lambdef
110
956
or_test
111
956
comparison
112
956
not
113
956
lambda
114
956
test
1494
957
and
term -> factor // term
957
if
term -> factor // term
957
>
term -> factor // term
957
<
term -> factor // term
957
for
term -> factor // term
957
==
term -> factor // term
957
]
term -> factor // term
957
+
term -> factor // term
957
-
term -> factor // term
957
&
term -> factor // term
957
in
term -> factor // term
957
!=
term -> factor // term
957
^
term -> factor // term
957
,
term -> factor // term
957
or
term -> factor // term
957
<=
term -> factor // term
957
>=
term -> factor // term
957
|
term -> factor // term
957
>>
term -> factor // term
957
not
term -> factor // term
957
is
term -> factor // term
957
<<
term -> factor // term
958
^
term -> factor * term
958
+
term -> factor * term
958
==
term -> factor * term
958
>>
term -> factor * term
958
in
term -> factor * term
958
and
term -> factor * term
958
if
term -> factor * term
958
for
term -> factor * term
958
is
term -> factor * term
958
]
term -> factor * term
958
<<
term -> factor * term
958
,
term -> factor * term
958
-
term -> factor * term
958
!=
term -> factor * term
958
or
term -> factor * term
958
>
term -> factor * term
958
&
term -> factor * term
958
>=
term -> factor * term
958
|
term -> factor * term
958
<=
term -> factor * term
958
not
term -> factor * term
958
<
term -> factor * term
959
&
term -> factor % term
959
]
term -> factor % term
959
==
term -> factor % term
959
!=
term -> factor % term
959
<
term -> factor % term
959
in
term -> factor % term
959
>>
term -> factor % term
959
<<
term -> factor % term
959
-
term -> factor % term
959
if
term -> factor % term
959
>
term -> factor % term
959
or
term -> factor % term
959
^
term -> factor % term
959
+
term -> factor % term
959
,
term -> factor % term
959
is
term -> factor % term
959
|
term -> factor % term
959
>=
term -> factor % term
959
<=
term -> factor % term
959
and
term -> factor % term
959
not
term -> factor % term
959
for
term -> factor % term
960
for
term -> factor @ term
960
and
term -> factor @ term
960
in
term -> factor @ term
960
>=
term -> factor @ term
960
<
term -> factor @ term
960
,
term -> factor @ term
960
>
term -> factor @ term
960
-
term -> factor @ term
960
or
term -> factor @ term
960
<<
term -> factor @ term
960
is
term -> factor @ term
960
!=
term -> factor @ term
960
|
term -> factor @ term
960
&
term -> factor @ term
960
==
term -> factor @ term
960
>>
term -> factor @ term
960
]
term -> factor @ term
960
not
term -> factor @ term
960
<=
term -> factor @ term
960
+
term -> factor @ term
960
^
term -> factor @ term
960
if
term -> factor @ term
961
or
term -> factor / term
961
<<
term -> factor / term
961
not
term -> factor / term
961
in
term -> factor / term
961
!=
term -> factor / term
961
<
term -> factor / term
961
,
term -> factor / term
961
]
term -> factor / term
961
+
term -> factor / term
961
and
term -> factor / term
961
>>
term -> factor / term
961
^
term -> factor / term
961
<=
term -> factor / term
961
==
term -> factor / term
961
>
term -> factor / term
961
&
term -> factor / term
961
is
term -> factor / term
961
-
term -> factor / term
961
for
term -> factor / term
961
|
term -> factor / term
961
>=
term -> factor / term
961
if
term -> factor / term
962
else
1495
963
for
arith_expr -> term + arith_expr
963
==
arith_expr -> term + arith_expr
963
]
arith_expr -> term + arith_expr
963
!=
arith_expr -> term + arith_expr
963
<<
arith_expr -> term + arith_expr
963
&
arith_expr -> term + arith_expr
963
<
arith_expr -> term + arith_expr
963
^
arith_expr -> term + arith_expr
963
,
arith_expr -> term + arith_expr
963
>=
arith_expr -> term + arith_expr
963
in
arith_expr -> term + arith_expr
963
>>
arith_expr -> term + arith_expr
963
not
arith_expr -> term + arith_expr
963
<=
arith_expr -> term + arith_expr
963
is
arith_expr -> term + arith_expr
963
|
arith_expr -> term + arith_expr
963
and
arith_expr -> term + arith_expr
963
or
arith_expr -> term + arith_expr
963
if
arith_expr -> term + arith_expr
963
>
arith_expr -> term + arith_expr
964
if
arith_expr -> term - arith_expr
964
&
arith_expr -> term - arith_expr
964
>>
arith_expr -> term - arith_expr
964
!=
arith_expr -> term - arith_expr
964
>=
arith_expr -> term - arith_expr
964
|
arith_expr -> term - arith_expr
964
>
arith_expr -> term - arith_expr
964
for
arith_expr -> term - arith_expr
964
<
arith_expr -> term - arith_expr
964
==
arith_expr -> term - arith_expr
964
,
arith_expr -> term - arith_expr
964
and
arith_expr -> term - arith_expr
964
]
arith_expr -> term - arith_expr
964
is
arith_expr -> term - arith_expr
964
in
arith_expr -> term - arith_expr
964
^
arith_expr -> term - arith_expr
964
<<
arith_expr -> term - arith_expr
964
not
arith_expr -> term - arith_expr
964
or
arith_expr -> term - arith_expr
964
<=
arith_expr -> term - arith_expr
965
+
atom -> ( test_list_comp )
965
/
atom -> ( test_list_comp )
965
*
atom -> ( test_list_comp )
965
[
atom -> ( test_list_comp )
965
&
atom -> ( test_list_comp )
965
,
atom -> ( test_list_comp )
965
**
atom -> ( test_list_comp )
965
^
atom -> ( test_list_comp )
965
(
atom -> ( test_list_comp )
965
and
atom -> ( test_list_comp )
965
>
atom -> ( test_list_comp )
965
-
atom -> ( test_list_comp )
965
%
atom -> ( test_list_comp )
965
//
atom -> ( test_list_comp )
965
]
atom -> ( test_list_comp )
965
in
atom -> ( test_list_comp )
965
>>
atom -> ( test_list_comp )
965
for
atom -> ( test_list_comp )
965
not
atom -> ( test_list_comp )
965
>=
atom -> ( test_list_comp )
965
or
atom -> ( test_list_comp )
965
<
atom -> ( test_list_comp )
965
if
atom -> ( test_list_comp )
965
|
atom -> ( test_list_comp )
965
<<
atom -> ( test_list_comp )
965
@
atom -> ( test_list_comp )
965
!=
atom -> ( test_list_comp )
965
is
atom -> ( test_list_comp )
965
.
atom -> ( test_list_comp )
965
<=
atom -> ( test_list_comp )
965
==
atom -> ( test_list_comp )
966
]
shift_expr -> arith_expr >> shift_expr
966
>=
shift_expr -> arith_expr >> shift_expr
966
,
shift_expr -> arith_expr >> shift_expr
966
if
shift_expr -> arith_expr >> shift_expr
966
<=
shift_expr -> arith_expr >> shift_expr
966
!=
shift_expr -> arith_expr >> shift_expr
966
or
shift_expr -> arith_expr >> shift_expr
966
|
shift_expr -> arith_expr >> shift_expr
966
is
shift_expr -> arith_expr >> shift_expr
966
and
shift_expr -> arith_expr >> shift_expr
966
in
shift_expr -> arith_expr >> shift_expr
966
^
shift_expr -> arith_expr >> shift_expr
966
not
shift_expr -> arith_expr >> shift_expr
966
<
shift_expr -> arith_expr >> shift_expr
966
==
shift_expr -> arith_expr >> shift_expr
966
for
shift_expr -> arith_expr >> shift_expr
966
&
shift_expr -> arith_expr >> shift_expr
966
>
shift_expr -> arith_expr >> shift_expr
967
>
shift_expr -> arith_expr << shift_expr
967
or
shift_expr -> arith_expr << shift_expr
967
^
shift_expr -> arith_expr << shift_expr
967
for
shift_expr -> arith_expr << shift_expr
967
not
shift_expr -> arith_expr << shift_expr
967
<
shift_expr -> arith_expr << shift_expr
967
if
shift_expr -> arith_expr << shift_expr
967
in
shift_expr -> arith_expr << shift_expr
967
!=
shift_expr -> arith_expr << shift_expr
967
,
shift_expr -> arith_expr << shift_expr
967
|
shift_expr -> arith_expr << shift_expr
967
>=
shift_expr -> arith_expr << shift_expr
967
and
shift_expr -> arith_expr << shift_expr
967
==
shift_expr -> arith_expr << shift_expr
967
]
shift_expr -> arith_expr << shift_expr
967
&
shift_expr -> arith_expr << shift_expr
967
<=
shift_expr -> arith_expr << shift_expr
967
is
shift_expr -> arith_expr << shift_expr
968
in
atom -> [ test_list_comp ]
968
/
atom -> [ test_list_comp ]
968
or
atom -> [ test_list_comp ]
968
if
atom -> [ test_list_comp ]
968
<<
atom -> [ test_list_comp ]
968
!=
atom -> [ test_list_comp ]
968
<=
atom -> [ test_list_comp ]
968
>>
atom -> [ test_list_comp ]
968
*
atom -> [ test_list_comp ]
968
^
atom -> [ test_list_comp ]
968
.
atom -> [ test_list_comp ]
968
(
atom -> [ test_list_comp ]
968
>=
atom -> [ test_list_comp ]
968
and
atom -> [ test_list_comp ]
968
<
atom -> [ test_list_comp ]
968
]
atom -> [ test_list_comp ]
968
,
atom -> [ test_list_comp ]
968
[
atom -> [ test_list_comp ]
968
==
atom -> [ test_list_comp ]
968
@
atom -> [ test_list_comp ]
968
%
atom -> [ test_list_comp ]
968
-
atom -> [ test_list_comp ]
968
|
atom -> [ test_list_comp ]
968
&
atom -> [ test_list_comp ]
968
+
atom -> [ test_list_comp ]
968
for
atom -> [ test_list_comp ]
968
is
atom -> [ test_list_comp ]
968
//
atom -> [ test_list_comp ]
968
**
atom -> [ test_list_comp ]
968
not
atom -> [ test_list_comp ]
968
>
atom -> [ test_list_comp ]
969
+
power -> atom_expr ** factor
969
&
power -> atom_expr ** factor
969
>>
power -> atom_expr ** factor
969
<<
power -> atom_expr ** factor
969
not
power -> atom_expr ** factor
969
is
power -> atom_expr ** factor
969
@
power -> atom_expr ** factor
969
==
power -> atom_expr ** factor
969
*
power -> atom_expr ** factor
969
or
power -> atom_expr ** factor
969
>
power -> atom_expr ** factor
969
-
power -> atom_expr ** factor
969
if
power -> atom_expr ** factor
969
!=
power -> atom_expr ** factor
969
>=
power -> atom_expr ** factor
969
for
power -> atom_expr ** factor
969
/
power -> atom_expr ** factor
969
%
power -> atom_expr ** factor
969
and
power -> atom_expr ** factor
969
<=
power -> atom_expr ** factor
969
]
power -> atom_expr ** factor
969
<
power -> atom_expr ** factor
969
|
power -> atom_expr ** factor
969
^
power -> atom_expr ** factor
969
in
power -> atom_expr ** factor
969
,
power -> atom_expr ** factor
969
//
power -> atom_expr ** factor
970
+
trailer_expr -> trailer trailer_expr
970
,
trailer_expr -> trailer trailer_expr
970
*
trailer_expr -> trailer trailer_expr
970
for
trailer_expr -> trailer trailer_expr
970
/
trailer_expr -> trailer trailer_expr
970
not
trailer_expr -> trailer trailer_expr
970
<<
trailer_expr -> trailer trailer_expr
970
!=
trailer_expr -> trailer trailer_expr
970
>=
trailer_expr -> trailer trailer_expr
970
>>
trailer_expr -> trailer trailer_expr
970
|
trailer_expr -> trailer trailer_expr
970
%
trailer_expr -> trailer trailer_expr
970
>
trailer_expr -> trailer trailer_expr
970
&
trailer_expr -> trailer trailer_expr
970
-
trailer_expr -> trailer trailer_expr
970
<=
trailer_expr -> trailer trailer_expr
970
**
trailer_expr -> trailer trailer_expr
970
@
trailer_expr -> trailer trailer_expr
970
if
trailer_expr -> trailer trailer_expr
970
==
trailer_expr -> trailer trailer_expr
970
or
trailer_expr -> trailer trailer_expr
970
<
trailer_expr -> trailer trailer_expr
970
and
trailer_expr -> trailer trailer_expr
970
in
trailer_expr -> trailer trailer_expr
970
is
trailer_expr -> trailer trailer_expr
970
]
trailer_expr -> trailer trailer_expr
970
^
trailer_expr -> trailer trailer_expr
970
//
trailer_expr -> trailer trailer_expr
971
<<
trailer -> . NAME
971
<=
trailer -> . NAME
971
**
trailer -> . NAME
971
!=
trailer -> . NAME
971
/
trailer -> . NAME
971
&
trailer -> . NAME
971
//
trailer -> . NAME
971
<
trailer -> . NAME
971
is
trailer -> . NAME
971
-
trailer -> . NAME
971
if
trailer -> . NAME
971
[
trailer -> . NAME
971
or
trailer -> . NAME
971
>
trailer -> . NAME
971
*
trailer -> . NAME
971
+
trailer -> . NAME
971
for
trailer -> . NAME
971
%
trailer -> . NAME
971
.
trailer -> . NAME
971
>=
trailer -> . NAME
971
|
trailer -> . NAME
971
and
trailer -> . NAME
971
(
trailer -> . NAME
971
]
trailer -> . NAME
971
,
trailer -> . NAME
971
==
trailer -> . NAME
971
^
trailer -> . NAME
971
in
trailer -> . NAME
971
@
trailer -> . NAME
971
not
trailer -> . NAME
971
>>
trailer -> . NAME
972
%
trailer -> ( )
972
<=
trailer -> ( )
972
and
trailer -> ( )
972
//
trailer -> ( )
972
not
trailer -> ( )
972
or
trailer -> ( )
972
for
trailer -> ( )
972
]
trailer -> ( )
972
>>
trailer -> ( )
972
>
trailer -> ( )
972
<<
trailer -> ( )
972
[
trailer -> ( )
972
is
trailer -> ( )
972
-
trailer -> ( )
972
**
trailer -> ( )
972
/
trailer -> ( )
972
,
trailer -> ( )
972
+
trailer -> ( )
972
&
trailer -> ( )
972
in
trailer -> ( )
972
^
trailer -> ( )
972
!=
trailer -> ( )
972
*
trailer -> ( )
972
if
trailer -> ( )
972
>=
trailer -> ( )
972
(
trailer -> ( )
972
@
trailer -> ( )
972
==
trailer -> ( )
972
|
trailer -> ( )
972
.
trailer -> ( )
972
<
trailer -> ( )
973
)
1496
974
]
1497
975
==
and_expr -> shift_expr & and_expr
975
in
and_expr -> shift_expr & and_expr
975
!=
and_expr -> shift_expr & and_expr
975
,
and_expr -> shift_expr & and_expr
975
or
and_expr -> shift_expr & and_expr
975
>
and_expr -> shift_expr & and_expr
975
not
and_expr -> shift_expr & and_expr
975
<=
and_expr -> shift_expr & and_expr
975
|
and_expr -> shift_expr & and_expr
975
and
and_expr -> shift_expr & and_expr
975
for
and_expr -> shift_expr & and_expr
975
^
and_expr -> shift_expr & and_expr
975
is
and_expr -> shift_expr & and_expr
975
]
and_expr -> shift_expr & and_expr
975
>=
and_expr -> shift_expr & and_expr
975
<
and_expr -> shift_expr & and_expr
975
if
and_expr -> shift_expr & and_expr
976
,
and_test -> not_test and and_test
976
]
and_test -> not_test and and_test
976
for
and_test -> not_test and and_test
976
if
and_test -> not_test and and_test
976
or
and_test -> not_test and and_test
977
<=
xor_expr -> and_expr ^ xor_expr
977
!=
xor_expr -> and_expr ^ xor_expr
977
for
xor_expr -> and_expr ^ xor_expr
977
and
xor_expr -> and_expr ^ xor_expr
977
is
xor_expr -> and_expr ^ xor_expr
977
>=
xor_expr -> and_expr ^ xor_expr
977
not
xor_expr -> and_expr ^ xor_expr
977
<
xor_expr -> and_expr ^ xor_expr
977
|
xor_expr -> and_expr ^ xor_expr
977
in
xor_expr -> and_expr ^ xor_expr
977
==
xor_expr -> and_expr ^ xor_expr
977
or
xor_expr -> and_expr ^ xor_expr
977
,
xor_expr -> and_expr ^ xor_expr
977
if
xor_expr -> and_expr ^ xor_expr
977
>
xor_expr -> and_expr ^ xor_expr
977
]
xor_expr -> and_expr ^ xor_expr
978
not
expr -> xor_expr | expr
978
,
expr -> xor_expr | expr
978
for
expr -> xor_expr | expr
978
in
expr -> xor_expr | expr
978
if
expr -> xor_expr | expr
978
or
expr -> xor_expr | expr
978
<=
expr -> xor_expr | expr
978
>
expr -> xor_expr | expr
978
!=
expr -> xor_expr | expr
978
]
expr -> xor_expr | expr
978
==
expr -> xor_expr | expr
978
>=
expr -> xor_expr | expr
978
is
expr -> xor_expr | expr
978
<
expr -> xor_expr | expr
978
and
expr -> xor_expr | expr
979
and
comparison -> expr comp_op comparison
979
]
comparison -> expr comp_op comparison
979
if
comparison -> expr comp_op comparison
979
for
comparison -> expr comp_op comparison
979
or
comparison -> expr comp_op comparison
979
,
comparison -> expr comp_op comparison
980
,
or_test -> and_test or or_test
980
for
or_test -> and_test or or_test
980
if
or_test -> and_test or or_test
980
]
or_test -> and_test or or_test
981
,
lambdef -> lambda : test
981
]
lambdef -> lambda : test
981
for
lambdef -> lambda : test
982
factor
117
982
or_test
118
982
term
119
982
(
120
982
arith_expr
121
982
NAME
122
982
[
123
982
+
125
982
atom_expr
126
982
NUMBER
127
982
atom
128
982
STRING
129
982
shift_expr
130
982
-
131
982
True
133
982
not_test
134
982
lambdef
135
982
and_expr
136
982
xor_expr
137
982
False
138
982
None
139
982
expr
140
982
and_test
141
982
{
142
982
~
143
982
lambda
144
982
power
145
982
comparison
146
982
test
1498
982
not
149
983
in
1499
984
//
1500
984
in
term -> factor
984
-
term -> factor
984
*
1501
984
%
1502
984
@
1503
984
]
term -> factor
984
>=
term -> factor
984
/
1504
984
<
term -> factor
984
<=
term -> factor
984
==
term -> factor
984
!=
term -> factor
984
>>
term -> factor
984
is
term -> factor
984
or
term -> factor
984
and
term -> factor
984
^
term -> factor
984
,
term -> factor
984
+
term -> factor
984
&
term -> factor
984
<<
term -> factor
984
|
term -> factor
984
>
term -> factor
984
if
term -> factor
984
not
term -> factor
985
if
1505
985
]
test -> or_test
985
,
test -> or_test
986
+
1506
986
-
1507
986
|
arith_expr -> term
986
or
arith_expr -> term
986
not
arith_expr -> term
986
<=
arith_expr -> term
986
!=
arith_expr -> term
986
<
arith_expr -> term
986
&
arith_expr -> term
986
>=
arith_expr -> term
986
if
arith_expr -> term
986
==
arith_expr -> term
986
^
arith_expr -> term
986
in
arith_expr -> term
986
is
arith_expr -> term
986
<<
arith_expr -> term
986
,
arith_expr -> term
986
>
arith_expr -> term
986
and
arith_expr -> term
986
>>
arith_expr -> term
986
]
arith_expr -> term
987
factor
268
987
term
270
987
(
271
987
arith_expr
272
987
NAME
273
987
[
274
987
+
275
987
test_list_comp
1508
987
atom_expr
277
987
NUMBER
278
987
atom
279
987
STRING
280
987
shift_expr
281
987
-
282
987
)
1509
987
True
283
987
not_test
284
987
lambdef
285
987
and_expr
286
987
xor_expr
287
987
False
288
987
None
289
987
expr
290
987
and_test
291
987
{
292
987
~
293
987
power
294
987
lambda
295
987
comparison
296
987
or_test
297
987
not
298
987
test
299
987
test_list
300
988
>>
1510
988
<<
1511
988
&
shift_expr -> arith_expr
988
<=
shift_expr -> arith_expr
988
>
shift_expr -> arith_expr
988
not
shift_expr -> arith_expr
988
!=
shift_expr -> arith_expr
988
^
shift_expr -> arith_expr
988
is
shift_expr -> arith_expr
988
|
shift_expr -> arith_expr
988
>=
shift_expr -> arith_expr
988
or
shift_expr -> arith_expr
988
]
shift_expr -> arith_expr
988
,
shift_expr -> arith_expr
988
==
shift_expr -> arith_expr
988
if
shift_expr -> arith_expr
988
and
shift_expr -> arith_expr
988
<
shift_expr -> arith_expr
988
in
shift_expr -> arith_expr
989
]
atom -> NAME
989
-
atom -> NAME
989
,
atom -> NAME
989
or
atom -> NAME
989
>>
atom -> NAME
989
&
atom -> NAME
989
[
atom -> NAME
989
<=
atom -> NAME
989
<
atom -> NAME
989
.
atom -> NAME
989
|
atom -> NAME
989
*
atom -> NAME
989
/
atom -> NAME
989
<<
atom -> NAME
989
not
atom -> NAME
989
>
atom -> NAME
989
is
atom -> NAME
989
//
atom -> NAME
989
+
atom -> NAME
989
if
atom -> NAME
989
in
atom -> NAME
989
**
atom -> NAME
989
!=
atom -> NAME
989
>=
atom -> NAME
989
^
atom -> NAME
989
@
atom -> NAME
989
(
atom -> NAME
989
==
atom -> NAME
989
and
atom -> NAME
989
%
atom -> NAME
990
]
test_list -> test , test_list
991
factor
117
991
or_test
118
991
term
119
991
(
120
991
arith_expr
121
991
NAME
122
991
[
123
991
]
1512
991
+
125
991
atom_expr
126
991
NUMBER
127
991
atom
128
991
STRING
129
991
shift_expr
130
991
-
131
991
test_list_comp
1513
991
True
133
991
not_test
134
991
lambdef
135
991
and_expr
136
991
xor_expr
137
991
False
138
991
None
139
991
expr
140
991
and_test
141
991
{
142
991
~
143
991
lambda
144
991
power
145
991
comparison
146
991
test_list
147
991
test
148
991
not
149
992
(
987
992
NAME
989
992
[
991
992
+
992
992
atom_expr
993
992
NUMBER
994
992
atom
995
992
STRING
996
992
-
998
992
factor
1514
992
True
999
992
None
1003
992
False
1004
992
{
1006
992
~
1007
992
power
1009
993
!=
power -> atom_expr
993
**
1515
993
>
power -> atom_expr
993
]
power -> atom_expr
993
+
power -> atom_expr
993
not
power -> atom_expr
993
&
power -> atom_expr
993
|
power -> atom_expr
993
>>
power -> atom_expr
993
^
power -> atom_expr
993
==
power -> atom_expr
993
if
power -> atom_expr
993
in
power -> atom_expr
993
%
power -> atom_expr
993
<<
power -> atom_expr
993
or
power -> atom_expr
993
@
power -> atom_expr
993
*
power -> atom_expr
993
/
power -> atom_expr
993
,
power -> atom_expr
993
<
power -> atom_expr
993
//
power -> atom_expr
993
>=
power -> atom_expr
993
-
power -> atom_expr
993
is
power -> atom_expr
993
<=
power -> atom_expr
993
and
power -> atom_expr
994
[
atom -> NUMBER
994
>=
atom -> NUMBER
994
<=
atom -> NUMBER
994
!=
atom -> NUMBER
994
//
atom -> NUMBER
994
in
atom -> NUMBER
994
/
atom -> NUMBER
994
or
atom -> NUMBER
994
>
atom -> NUMBER
994
,
atom -> NUMBER
994
not
atom -> NUMBER
994
>>
atom -> NUMBER
994
(
atom -> NUMBER
994
**
atom -> NUMBER
994
<<
atom -> NUMBER
994
and
atom -> NUMBER
994
+
atom -> NUMBER
994
%
atom -> NUMBER
994
==
atom -> NUMBER
994
]
atom -> NUMBER
994
if
atom -> NUMBER
994
is
atom -> NUMBER
994
*
atom -> NUMBER
994
@
atom -> NUMBER
994
|
atom -> NUMBER
994
-
atom -> NUMBER
994
.
atom -> NUMBER
994
^
atom -> NUMBER
994
<
atom -> NUMBER
994
&
atom -> NUMBER
995
trailer
1516
995
.
1517
995
(
1518
995
[
1519
995
trailer_expr
1520
995
<<
trailer_expr -> 
995
%
trailer_expr -> 
995
==
trailer_expr -> 
995
-
trailer_expr -> 
995
<
trailer_expr -> 
995
if
trailer_expr -> 
995
or
trailer_expr -> 
995
/
trailer_expr -> 
995
**
trailer_expr -> 
995
and
trailer_expr -> 
995
@
trailer_expr -> 
995
*
trailer_expr -> 
995
|
trailer_expr -> 
995
is
trailer_expr -> 
995
,
trailer_expr -> 
995
+
trailer_expr -> 
995
in
trailer_expr -> 
995
&
trailer_expr -> 
995
<=
trailer_expr -> 
995
>=
trailer_expr -> 
995
^
trailer_expr -> 
995
>
trailer_expr -> 
995
!=
trailer_expr -> 
995
not
trailer_expr -> 
995
>>
trailer_expr -> 
995
//
trailer_expr -> 
995
]
trailer_expr -> 
996
and
atom -> STRING
996
%
atom -> STRING
996
//
atom -> STRING
996
>>
atom -> STRING
996
*
atom -> STRING
996
<
atom -> STRING
996
.
atom -> STRING
996
in
atom -> STRING
996
]
atom -> STRING
996
^
atom -> STRING
996
(
atom -> STRING
996
if
atom -> STRING
996
==
atom -> STRING
996
-
atom -> STRING
996
**
atom -> STRING
996
<<
atom -> STRING
996
<=
atom -> STRING
996
[
atom -> STRING
996
not
atom -> STRING
996
or
atom -> STRING
996
+
atom -> STRING
996
>=
atom -> STRING
996
@
atom -> STRING
996
&
atom -> STRING
996
>
atom -> STRING
996
is
atom -> STRING
996
,
atom -> STRING
996
|
atom -> STRING
996
!=
atom -> STRING
996
/
atom -> STRING
997
&
1521
997
^
and_expr -> shift_expr
997
|
and_expr -> shift_expr
997
<=
and_expr -> shift_expr
997
or
and_expr -> shift_expr
997
>
and_expr -> shift_expr
997
]
and_expr -> shift_expr
997
not
and_expr -> shift_expr
997
,
and_expr -> shift_expr
997
!=
and_expr -> shift_expr
997
and
and_expr -> shift_expr
997
is
and_expr -> shift_expr
997
<
and_expr -> shift_expr
997
if
and_expr -> shift_expr
997
in
and_expr -> shift_expr
997
>=
and_expr -> shift_expr
997
==
and_expr -> shift_expr
998
(
987
998
NAME
989
998
[
991
998
+
992
998
atom_expr
993
998
NUMBER
994
998
atom
995
998
STRING
996
998
-
998
998
True
999
998
None
1003
998
False
1004
998
{
1006
998
~
1007
998
power
1009
998
factor
1522
999
(
atom -> True
999
[
atom -> True
999
+
atom -> True
999
@
atom -> True
999
<=
atom -> True
999
&
atom -> True
999
<<
atom -> True
999
-
atom -> True
999
/
atom -> True
999
or
atom -> True
999
>
atom -> True
999
%
atom -> True
999
^
atom -> True
999
if
atom -> True
999
!=
atom -> True
999
is
atom -> True
999
*
atom -> True
999
<
atom -> True
999
,
atom -> True
999
and
atom -> True
999
.
atom -> True
999
==
atom -> True
999
]
atom -> True
999
**
atom -> True
999
>>
atom -> True
999
in
atom -> True
999
|
atom -> True
999
>=
atom -> True
999
//
atom -> True
999
not
atom -> True
1000
and
1523
1000
]
and_test -> not_test
1000
or
and_test -> not_test
1000
,
and_test -> not_test
1000
if
and_test -> not_test
1001
^
1524
1001
not
xor_expr -> and_expr
1001
if
xor_expr -> and_expr
1001
<=
xor_expr -> and_expr
1001
,
xor_expr -> and_expr
1001
>
xor_expr -> and_expr
1001
]
xor_expr -> and_expr
1001
<
xor_expr -> and_expr
1001
in
xor_expr -> and_expr
1001
>=
xor_expr -> and_expr
1001
==
xor_expr -> and_expr
1001
|
xor_expr -> and_expr
1001
is
xor_expr -> and_expr
1001
and
xor_expr -> and_expr
1001
or
xor_expr -> and_expr
1001
!=
xor_expr -> and_expr
1002
|
1525
1002
>=
expr -> xor_expr
1002
,
expr -> xor_expr
1002
==
expr -> xor_expr
1002
is
expr -> xor_expr
1002
if
expr -> xor_expr
1002
or
expr -> xor_expr
1002
>
expr -> xor_expr
1002
and
expr -> xor_expr
1002
<
expr -> xor_expr
1002
]
expr -> xor_expr
1002
in
expr -> xor_expr
1002
<=
expr -> xor_expr
1002
not
expr -> xor_expr
1002
!=
expr -> xor_expr
1003
is
atom -> None
1003
.
atom -> None
1003
==
atom -> None
1003
^
atom -> None
1003
<<
atom -> None
1003
>>
atom -> None
1003
(
atom -> None
1003
|
atom -> None
1003
+
atom -> None
1003
*
atom -> None
1003
//
atom -> None
1003
@
atom -> None
1003
in
atom -> None
1003
>=
atom -> None
1003
!=
atom -> None
1003
%
atom -> None
1003
]
atom -> None
1003
[
atom -> None
1003
and
atom -> None
1003
-
atom -> None
1003
if
atom -> None
1003
&
atom -> None
1003
<=
atom -> None
1003
<
atom -> None
1003
>
atom -> None
1003
,
atom -> None
1003
**
atom -> None
1003
or
atom -> None
1003
/
atom -> None
1003
not
atom -> None
1004
in
atom -> False
1004
>
atom -> False
1004
-
atom -> False
1004
%
atom -> False
1004
<
atom -> False
1004
|
atom -> False
1004
==
atom -> False
1004
&
atom -> False
1004
//
atom -> False
1004
and
atom -> False
1004
not
atom -> False
1004
+
atom -> False
1004
!=
atom -> False
1004
if
atom -> False
1004
@
atom -> False
1004
]
atom -> False
1004
[
atom -> False
1004
or
atom -> False
1004
<=
atom -> False
1004
*
atom -> False
1004
^
atom -> False
1004
is
atom -> False
1004
/
atom -> False
1004
.
atom -> False
1004
>=
atom -> False
1004
**
atom -> False
1004
>>
atom -> False
1004
,
atom -> False
1004
<<
atom -> False
1004
(
atom -> False
1005
,
or_test -> and_test
1005
or
1526
1005
if
or_test -> and_test
1005
]
or_test -> and_test
1006
}
1527
1007
(
987
1007
NAME
989
1007
[
991
1007
+
992
1007
factor
1528
1007
atom_expr
993
1007
NUMBER
994
1007
atom
995
1007
STRING
996
1007
-
998
1007
True
999
1007
None
1003
1007
False
1004
1007
{
1006
1007
~
1007
1007
power
1009
1008
NAME
305
1008
vfpdef
306
1008
:
1529
1008
varargslist
1530
1009
&
factor -> power
1009
%
factor -> power
1009
<<
factor -> power
1009
-
factor -> power
1009
<=
factor -> power
1009
not
factor -> power
1009
//
factor -> power
1009
/
factor -> power
1009
is
factor -> power
1009
|
factor -> power
1009
<
factor -> power
1009
and
factor -> power
1009
>=
factor -> power
1009
>>
factor -> power
1009
>
factor -> power
1009
in
factor -> power
1009
if
factor -> power
1009
^
factor -> power
1009
==
factor -> power
1009
+
factor -> power
1009
,
factor -> power
1009
@
factor -> power
1009
or
factor -> power
1009
*
factor -> power
1009
]
factor -> power
1009
!=
factor -> power
1010
is
215
1010
<
217
1010
!=
218
1010
in
219
1010
<=
220
1010
comp_op
1531
1010
not
221
1010
>=
222
1010
>
223
1010
==
224
1010
]
comparison -> expr
1010
and
comparison -> expr
1010
or
comparison -> expr
1010
if
comparison -> expr
1010
,
comparison -> expr
1011
]
test -> lambdef
1011
,
test -> lambdef
1012
]
test_list -> test
1012
,
498
1013
factor
984
1013
term
986
1013
(
987
1013
arith_expr
988
1013
NAME
989
1013
[
991
1013
+
992
1013
atom_expr
993
1013
NUMBER
994
1013
atom
995
1013
STRING
996
1013
shift_expr
997
1013
-
998
1013
not_test
1532
1013
True
999
1013
and_expr
1001
1013
xor_expr
1002
1013
None
1003
1013
False
1004
1013
{
1006
1013
~
1007
1013
power
1009
1013
expr
1010
1013
not
1013
1013
comparison
1014
1014
or
not_test -> comparison
1014
and
not_test -> comparison
1014
,
not_test -> comparison
1014
if
not_test -> comparison
1014
]
not_test -> comparison
1015
else
1533
1015
finally
1534
1015
pass
try_stmt -> try : suite except_clause
1015
if
try_stmt -> try : suite except_clause
1015
resetstats
try_stmt -> try : suite except_clause
1015
raise
try_stmt -> try : suite except_clause
1015
with
try_stmt -> try : suite except_clause
1015
yield
try_stmt -> try : suite except_clause
1015
conf
try_stmt -> try : suite except_clause
1015
NAME
try_stmt -> try : suite except_clause
1015
return
try_stmt -> try : suite except_clause
1015
del
try_stmt -> try : suite except_clause
1015
def
try_stmt -> try : suite except_clause
1015
(
try_stmt -> try : suite except_clause
1015
not
try_stmt -> try : suite except_clause
1015
break
try_stmt -> try : suite except_clause
1015
class
try_stmt -> try : suite except_clause
1015
[
try_stmt -> try : suite except_clause
1015
~
try_stmt -> try : suite except_clause
1015
endsim
try_stmt -> try : suite except_clause
1015
nonlocal
try_stmt -> try : suite except_clause
1015
for
try_stmt -> try : suite except_clause
1015
try
try_stmt -> try : suite except_clause
1015
@
try_stmt -> try : suite except_clause
1015
NUMBER
try_stmt -> try : suite except_clause
1015
STRING
try_stmt -> try : suite except_clause
1015
begsim
try_stmt -> try : suite except_clause
1015
assert
try_stmt -> try : suite except_clause
1015
continue
try_stmt -> try : suite except_clause
1015
False
try_stmt -> try : suite except_clause
1015
$
try_stmt -> try : suite except_clause
1015
None
try_stmt -> try : suite except_clause
1015
global
try_stmt -> try : suite except_clause
1015
+
try_stmt -> try : suite except_clause
1015
lambda
try_stmt -> try : suite except_clause
1015
while
try_stmt -> try : suite except_clause
1015
NEWLINE
try_stmt -> try : suite except_clause
1015
-
try_stmt -> try : suite except_clause
1015
{
try_stmt -> try : suite except_clause
1015
True
try_stmt -> try : suite except_clause
1016
test
1535
1016
factor
1536
1016
(
1537
1016
arith_expr
1538
1016
NAME
1539
1016
term
1540
1016
[
1541
1016
~
1542
1016
+
1543
1016
lambda
1544
1016
expr
1545
1016
atom_expr
1546
1016
shift_expr
1547
1016
atom
1548
1016
NUMBER
1549
1016
STRING
1550
1016
:
1551
1016
-
1552
1016
True
1553
1016
not_test
1554
1016
and_expr
1555
1016
xor_expr
1556
1016
False
1557
1016
{
1558
1016
or_test
1559
1016
None
1560
1016
comparison
1561
1016
and_test
1562
1016
lambdef
1563
1016
power
1564
1016
not
1565
1017
except
simple_stmt -> small_stmt NEWLINE
1018
if
1566
1018
arith_expr
2
1018
try
1567
1018
[
3
1018
class
1568
1018
for
1569
1018
with_stmt
1570
1018
while_stmt
1571
1018
factor
9
1018
@
10
1018
simple_stmt
1572
1018
decorators
1573
1018
return
13
1018
confdef
1574
1018
flow_stmt
15
1018
expr
16
1018
True
17
1018
not_test
18
1018
and_expr
19
1018
def
1575
1018
term
21
1018
xor_expr
22
1018
or_test
23
1018
atom_expr
24
1018
global
25
1018
for_stmt
1576
1018
NUMBER
27
1018
STRING
28
1018
NAME
29
1018
decorator
30
1018
if_stmt
1577
1018
with
1578
1018
endsim
33
1018
classdef
1579
1018
False
35
1018
(
36
1018
and_test
37
1018
conf
1580
1018
comparison
39
1018
lambda
40
1018
while
1581
1018
None
42
1018
try_stmt
1582
1018
funcdef
1583
1018
~
45
1018
decorated
1584
1018
small_stmt
1585
1018
test
48
1018
-
49
1018
shift_expr
50
1018
{
52
1018
lambdef
53
1018
atom
54
1018
+
55
1018
power
56
1018
stmt_list
1586
1018
not
57
1018
compound_stmt
1587
1018
continue
59
1018
del_stmt
60
1018
test_list
61
1018
raise
62
1018
raise_stmt
63
1018
resetstats
64
1018
pass_stmt
65
1018
stmt
1588
1018
nonlocal
66
1018
global_stmt
67
1018
yield
68
1018
continue_stmt
69
1018
assert
70
1018
nonlocal_stmt
71
1018
expr_stmt
72
1018
break_stmt
74
1018
return_stmt
75
1018
break
76
1018
sim_stmt
77
1018
stat_stmt
78
1018
yield_stmt
79
1018
assert_stmt
80
1018
pass
81
1018
begsim
83
1018
del
84
1019
)
1589
1020
:
1590
1021
[
classdef -> class NAME : suite
1021
with
classdef -> class NAME : suite
1021
pass
classdef -> class NAME : suite
1021
-
classdef -> class NAME : suite
1021
lambda
classdef -> class NAME : suite
1021
assert
classdef -> class NAME : suite
1021
STRING
classdef -> class NAME : suite
1021
global
classdef -> class NAME : suite
1021
return
classdef -> class NAME : suite
1021
NUMBER
classdef -> class NAME : suite
1021
$
classdef -> class NAME : suite
1021
@
classdef -> class NAME : suite
1021
begsim
classdef -> class NAME : suite
1021
+
classdef -> class NAME : suite
1021
while
classdef -> class NAME : suite
1021
True
classdef -> class NAME : suite
1021
break
classdef -> class NAME : suite
1021
yield
classdef -> class NAME : suite
1021
continue
classdef -> class NAME : suite
1021
resetstats
classdef -> class NAME : suite
1021
{
classdef -> class NAME : suite
1021
def
classdef -> class NAME : suite
1021
NEWLINE
classdef -> class NAME : suite
1021
try
classdef -> class NAME : suite
1021
raise
classdef -> class NAME : suite
1021
endsim
classdef -> class NAME : suite
1021
del
classdef -> class NAME : suite
1021
for
classdef -> class NAME : suite
1021
None
classdef -> class NAME : suite
1021
nonlocal
classdef -> class NAME : suite
1021
~
classdef -> class NAME : suite
1021
not
classdef -> class NAME : suite
1021
NAME
classdef -> class NAME : suite
1021
if
classdef -> class NAME : suite
1021
(
classdef -> class NAME : suite
1021
conf
classdef -> class NAME : suite
1021
class
classdef -> class NAME : suite
1021
False
classdef -> class NAME : suite
1022
INDENT
1591
1023
resetstats
suite -> simple_stmt
1023
+
suite -> simple_stmt
1023
lambda
suite -> simple_stmt
1023
try
suite -> simple_stmt
1023
begsim
suite -> simple_stmt
1023
None
suite -> simple_stmt
1023
not
suite -> simple_stmt
1023
@
suite -> simple_stmt
1023
[
suite -> simple_stmt
1023
class
suite -> simple_stmt
1023
return
suite -> simple_stmt
1023
nonlocal
suite -> simple_stmt
1023
NUMBER
suite -> simple_stmt
1023
yield
suite -> simple_stmt
1023
STRING
suite -> simple_stmt
1023
NEWLINE
suite -> simple_stmt
1023
-
suite -> simple_stmt
1023
False
suite -> simple_stmt
1023
def
suite -> simple_stmt
1023
conf
suite -> simple_stmt
1023
True
suite -> simple_stmt
1023
raise
suite -> simple_stmt
1023
endsim
suite -> simple_stmt
1023
with
suite -> simple_stmt
1023
global
suite -> simple_stmt
1023
{
suite -> simple_stmt
1023
~
suite -> simple_stmt
1023
assert
suite -> simple_stmt
1023
(
suite -> simple_stmt
1023
$
suite -> simple_stmt
1023
while
suite -> simple_stmt
1023
del
suite -> simple_stmt
1023
pass
suite -> simple_stmt
1023
break
suite -> simple_stmt
1023
for
suite -> simple_stmt
1023
continue
suite -> simple_stmt
1023
NAME
suite -> simple_stmt
1023
if
suite -> simple_stmt
1024
+
term -> factor // term
1024
,
term -> factor // term
1024
>>
term -> factor // term
1024
&
term -> factor // term
1024
-
term -> factor // term
1024
in
term -> factor // term
1024
^
term -> factor // term
1024
<<
term -> factor // term
1024
|
term -> factor // term
1025
>>
term -> factor / term
1025
+
term -> factor / term
1025
^
term -> factor / term
1025
in
term -> factor / term
1025
|
term -> factor / term
1025
<<
term -> factor / term
1025
&
term -> factor / term
1025
-
term -> factor / term
1025
,
term -> factor / term
1026
<<
term -> factor % term
1026
|
term -> factor % term
1026
&
term -> factor % term
1026
-
term -> factor % term
1026
^
term -> factor % term
1026
+
term -> factor % term
1026
,
term -> factor % term
1026
in
term -> factor % term
1026
>>
term -> factor % term
1027
,
term -> factor * term
1027
-
term -> factor * term
1027
|
term -> factor * term
1027
^
term -> factor * term
1027
+
term -> factor * term
1027
>>
term -> factor * term
1027
<<
term -> factor * term
1027
in
term -> factor * term
1027
&
term -> factor * term
1028
in
term -> factor @ term
1028
,
term -> factor @ term
1028
>>
term -> factor @ term
1028
-
term -> factor @ term
1028
|
term -> factor @ term
1028
+
term -> factor @ term
1028
<<
term -> factor @ term
1028
&
term -> factor @ term
1028
^
term -> factor @ term
1029
//
1592
1029
/
1593
1029
in
term -> factor
1029
-
term -> factor
1029
*
1594
1029
%
1595
1029
@
1596
1029
:
term -> factor
1029
>=
term -> factor
1029
<
term -> factor
1029
<=
term -> factor
1029
==
term -> factor
1029
!=
term -> factor
1029
>>
term -> factor
1029
is
term -> factor
1029
or
term -> factor
1029
and
term -> factor
1029
^
term -> factor
1029
,
term -> factor
1029
+
term -> factor
1029
&
term -> factor
1029
<<
term -> factor
1029
|
term -> factor
1029
>
term -> factor
1029
if
term -> factor
1029
not
term -> factor
1030
:
1597
1031
+
1598
1031
-
1599
1031
|
arith_expr -> term
1031
:
arith_expr -> term
1031
or
arith_expr -> term
1031
not
arith_expr -> term
1031
<=
arith_expr -> term
1031
!=
arith_expr -> term
1031
<
arith_expr -> term
1031
&
arith_expr -> term
1031
>=
arith_expr -> term
1031
if
arith_expr -> term
1031
==
arith_expr -> term
1031
^
arith_expr -> term
1031
in
arith_expr -> term
1031
is
arith_expr -> term
1031
<<
arith_expr -> term
1031
,
arith_expr -> term
1031
>
arith_expr -> term
1031
and
arith_expr -> term
1031
>>
arith_expr -> term
1032
factor
268
1032
term
270
1032
(
271
1032
arith_expr
272
1032
NAME
273
1032
[
274
1032
+
275
1032
test_list_comp
1600
1032
atom_expr
277
1032
NUMBER
278
1032
atom
279
1032
STRING
280
1032
shift_expr
281
1032
-
282
1032
True
283
1032
not_test
284
1032
lambdef
285
1032
and_expr
286
1032
xor_expr
287
1032
False
288
1032
None
289
1032
expr
290
1032
and_test
291
1032
)
1601
1032
{
292
1032
~
293
1032
power
294
1032
lambda
295
1032
comparison
296
1032
or_test
297
1032
not
298
1032
test
299
1032
test_list
300
1033
>>
1602
1033
<<
1603
1033
&
shift_expr -> arith_expr
1033
<=
shift_expr -> arith_expr
1033
>
shift_expr -> arith_expr
1033
not
shift_expr -> arith_expr
1033
!=
shift_expr -> arith_expr
1033
^
shift_expr -> arith_expr
1033
is
shift_expr -> arith_expr
1033
|
shift_expr -> arith_expr
1033
>=
shift_expr -> arith_expr
1033
or
shift_expr -> arith_expr
1033
,
shift_expr -> arith_expr
1033
==
shift_expr -> arith_expr
1033
if
shift_expr -> arith_expr
1033
and
shift_expr -> arith_expr
1033
<
shift_expr -> arith_expr
1033
:
shift_expr -> arith_expr
1033
in
shift_expr -> arith_expr
1034
:
atom -> NAME
1034
-
atom -> NAME
1034
,
atom -> NAME
1034
or
atom -> NAME
1034
>>
atom -> NAME
1034
&
atom -> NAME
1034
[
atom -> NAME
1034
<=
atom -> NAME
1034
<
atom -> NAME
1034
.
atom -> NAME
1034
|
atom -> NAME
1034
*
atom -> NAME
1034
/
atom -> NAME
1034
<<
atom -> NAME
1034
not
atom -> NAME
1034
>
atom -> NAME
1034
is
atom -> NAME
1034
//
atom -> NAME
1034
+
atom -> NAME
1034
if
atom -> NAME
1034
in
atom -> NAME
1034
**
atom -> NAME
1034
!=
atom -> NAME
1034
>=
atom -> NAME
1034
^
atom -> NAME
1034
@
atom -> NAME
1034
(
atom -> NAME
1034
==
atom -> NAME
1034
and
atom -> NAME
1034
%
atom -> NAME
1035
factor
117
1035
or_test
118
1035
term
119
1035
(
120
1035
arith_expr
121
1035
NAME
122
1035
[
123
1035
]
1604
1035
+
125
1035
atom_expr
126
1035
NUMBER
127
1035
atom
128
1035
STRING
129
1035
shift_expr
130
1035
-
131
1035
test_list_comp
1605
1035
True
133
1035
not_test
134
1035
lambdef
135
1035
and_expr
136
1035
xor_expr
137
1035
False
138
1035
None
139
1035
expr
140
1035
and_test
141
1035
{
142
1035
~
143
1035
lambda
144
1035
power
145
1035
comparison
146
1035
test_list
147
1035
test
148
1035
not
149
1036
(
1032
1036
NAME
1034
1036
[
1035
1036
~
1036
1036
+
1037
1036
factor
1606
1036
atom_expr
1039
1036
NUMBER
1041
1036
atom
1040
1036
STRING
1042
1036
-
1044
1036
True
1045
1036
False
1049
1036
{
1050
1036
None
1051
1036
power
1054
1037
(
1032
1037
NAME
1034
1037
[
1035
1037
~
1036
1037
+
1037
1037
atom_expr
1039
1037
NUMBER
1041
1037
atom
1040
1037
STRING
1042
1037
-
1044
1037
factor
1607
1037
True
1045
1037
False
1049
1037
{
1050
1037
None
1051
1037
power
1054
1038
is
215
1038
<
217
1038
!=
218
1038
in
219
1038
<=
220
1038
not
221
1038
>=
222
1038
>
223
1038
==
224
1038
comp_op
1608
1038
and
comparison -> expr
1038
or
comparison -> expr
1038
:
comparison -> expr
1038
if
comparison -> expr
1038
,
comparison -> expr
1039
!=
power -> atom_expr
1039
**
1609
1039
>
power -> atom_expr
1039
+
power -> atom_expr
1039
not
power -> atom_expr
1039
&
power -> atom_expr
1039
|
power -> atom_expr
1039
>>
power -> atom_expr
1039
:
power -> atom_expr
1039
^
power -> atom_expr
1039
==
power -> atom_expr
1039
if
power -> atom_expr
1039
in
power -> atom_expr
1039
%
power -> atom_expr
1039
<<
power -> atom_expr
1039
or
power -> atom_expr
1039
@
power -> atom_expr
1039
*
power -> atom_expr
1039
/
power -> atom_expr
1039
,
power -> atom_expr
1039
<
power -> atom_expr
1039
//
power -> atom_expr
1039
>=
power -> atom_expr
1039
-
power -> atom_expr
1039
is
power -> atom_expr
1039
<=
power -> atom_expr
1039
and
power -> atom_expr
1040
trailer
1610
1040
.
1611
1040
(
1612
1040
[
1613
1040
trailer_expr
1614
1040
<<
trailer_expr -> 
1040
%
trailer_expr -> 
1040
==
trailer_expr -> 
1040
-
trailer_expr -> 
1040
<
trailer_expr -> 
1040
if
trailer_expr -> 
1040
or
trailer_expr -> 
1040
/
trailer_expr -> 
1040
**
trailer_expr -> 
1040
and
trailer_expr -> 
1040
@
trailer_expr -> 
1040
*
trailer_expr -> 
1040
|
trailer_expr -> 
1040
is
trailer_expr -> 
1040
,
trailer_expr -> 
1040
+
trailer_expr -> 
1040
in
trailer_expr -> 
1040
&
trailer_expr -> 
1040
<=
trailer_expr -> 
1040
>=
trailer_expr -> 
1040
^
trailer_expr -> 
1040
>
trailer_expr -> 
1040
!=
trailer_expr -> 
1040
not
trailer_expr -> 
1040
>>
trailer_expr -> 
1040
//
trailer_expr -> 
1040
:
trailer_expr -> 
1041
[
atom -> NUMBER
1041
>=
atom -> NUMBER
1041
<=
atom -> NUMBER
1041
!=
atom -> NUMBER
1041
//
atom -> NUMBER
1041
in
atom -> NUMBER
1041
/
atom -> NUMBER
1041
:
atom -> NUMBER
1041
or
atom -> NUMBER
1041
>
atom -> NUMBER
1041
,
atom -> NUMBER
1041
not
atom -> NUMBER
1041
>>
atom -> NUMBER
1041
(
atom -> NUMBER
1041
**
atom -> NUMBER
1041
<<
atom -> NUMBER
1041
and
atom -> NUMBER
1041
+
atom -> NUMBER
1041
%
atom -> NUMBER
1041
==
atom -> NUMBER
1041
if
atom -> NUMBER
1041
is
atom -> NUMBER
1041
*
atom -> NUMBER
1041
@
atom -> NUMBER
1041
|
atom -> NUMBER
1041
-
atom -> NUMBER
1041
.
atom -> NUMBER
1041
^
atom -> NUMBER
1041
<
atom -> NUMBER
1041
&
atom -> NUMBER
1042
and
atom -> STRING
1042
%
atom -> STRING
1042
//
atom -> STRING
1042
>>
atom -> STRING
1042
*
atom -> STRING
1042
<
atom -> STRING
1042
.
atom -> STRING
1042
in
atom -> STRING
1042
:
atom -> STRING
1042
^
atom -> STRING
1042
(
atom -> STRING
1042
if
atom -> STRING
1042
==
atom -> STRING
1042
-
atom -> STRING
1042
**
atom -> STRING
1042
<<
atom -> STRING
1042
<=
atom -> STRING
1042
[
atom -> STRING
1042
not
atom -> STRING
1042
or
atom -> STRING
1042
+
atom -> STRING
1042
>=
atom -> STRING
1042
@
atom -> STRING
1042
&
atom -> STRING
1042
>
atom -> STRING
1042
is
atom -> STRING
1042
,
atom -> STRING
1042
|
atom -> STRING
1042
!=
atom -> STRING
1042
/
atom -> STRING
1043
&
1615
1043
^
and_expr -> shift_expr
1043
|
and_expr -> shift_expr
1043
<=
and_expr -> shift_expr
1043
or
and_expr -> shift_expr
1043
>
and_expr -> shift_expr
1043
not
and_expr -> shift_expr
1043
,
and_expr -> shift_expr
1043
!=
and_expr -> shift_expr
1043
and
and_expr -> shift_expr
1043
is
and_expr -> shift_expr
1043
<
and_expr -> shift_expr
1043
if
and_expr -> shift_expr
1043
in
and_expr -> shift_expr
1043
>=
and_expr -> shift_expr
1043
:
and_expr -> shift_expr
1043
==
and_expr -> shift_expr
1044
(
1032
1044
NAME
1034
1044
[
1035
1044
~
1036
1044
+
1037
1044
atom_expr
1039
1044
NUMBER
1041
1044
atom
1040
1044
STRING
1042
1044
-
1044
1044
True
1045
1044
False
1049
1044
{
1050
1044
None
1051
1044
power
1054
1044
factor
1616
1045
(
atom -> True
1045
[
atom -> True
1045
+
atom -> True
1045
@
atom -> True
1045
not
atom -> True
1045
<=
atom -> True
1045
&
atom -> True
1045
<<
atom -> True
1045
-
atom -> True
1045
/
atom -> True
1045
or
atom -> True
1045
>
atom -> True
1045
%
atom -> True
1045
^
atom -> True
1045
if
atom -> True
1045
!=
atom -> True
1045
is
atom -> True
1045
*
atom -> True
1045
<
atom -> True
1045
,
atom -> True
1045
and
atom -> True
1045
.
atom -> True
1045
==
atom -> True
1045
**
atom -> True
1045
>>
atom -> True
1045
in
atom -> True
1045
|
atom -> True
1045
>=
atom -> True
1045
//
atom -> True
1045
:
atom -> True
1046
and
1617
1046
or
and_test -> not_test
1046
,
and_test -> not_test
1046
if
and_test -> not_test
1046
:
and_test -> not_test
1047
^
1618
1047
not
xor_expr -> and_expr
1047
if
xor_expr -> and_expr
1047
<=
xor_expr -> and_expr
1047
:
xor_expr -> and_expr
1047
,
xor_expr -> and_expr
1047
>
xor_expr -> and_expr
1047
<
xor_expr -> and_expr
1047
in
xor_expr -> and_expr
1047
>=
xor_expr -> and_expr
1047
==
xor_expr -> and_expr
1047
|
xor_expr -> and_expr
1047
is
xor_expr -> and_expr
1047
and
xor_expr -> and_expr
1047
or
xor_expr -> and_expr
1047
!=
xor_expr -> and_expr
1048
|
1619
1048
>=
expr -> xor_expr
1048
,
expr -> xor_expr
1048
==
expr -> xor_expr
1048
is
expr -> xor_expr
1048
:
expr -> xor_expr
1048
if
expr -> xor_expr
1048
or
expr -> xor_expr
1048
>
expr -> xor_expr
1048
and
expr -> xor_expr
1048
<
expr -> xor_expr
1048
in
expr -> xor_expr
1048
<=
expr -> xor_expr
1048
not
expr -> xor_expr
1048
!=
expr -> xor_expr
1049
in
atom -> False
1049
>
atom -> False
1049
-
atom -> False
1049
%
atom -> False
1049
<
atom -> False
1049
|
atom -> False
1049
==
atom -> False
1049
&
atom -> False
1049
//
atom -> False
1049
and
atom -> False
1049
:
atom -> False
1049
not
atom -> False
1049
+
atom -> False
1049
!=
atom -> False
1049
if
atom -> False
1049
@
atom -> False
1049
[
atom -> False
1049
or
atom -> False
1049
<=
atom -> False
1049
*
atom -> False
1049
^
atom -> False
1049
is
atom -> False
1049
/
atom -> False
1049
.
atom -> False
1049
>=
atom -> False
1049
**
atom -> False
1049
>>
atom -> False
1049
,
atom -> False
1049
<<
atom -> False
1049
(
atom -> False
1050
}
1620
1051
is
atom -> None
1051
.
atom -> None
1051
==
atom -> None
1051
^
atom -> None
1051
<<
atom -> None
1051
>>
atom -> None
1051
(
atom -> None
1051
|
atom -> None
1051
+
atom -> None
1051
*
atom -> None
1051
//
atom -> None
1051
@
atom -> None
1051
in
atom -> None
1051
>=
atom -> None
1051
!=
atom -> None
1051
%
atom -> None
1051
[
atom -> None
1051
and
atom -> None
1051
-
atom -> None
1051
if
atom -> None
1051
&
atom -> None
1051
<=
atom -> None
1051
<
atom -> None
1051
>
atom -> None
1051
,
atom -> None
1051
**
atom -> None
1051
:
atom -> None
1051
or
atom -> None
1051
/
atom -> None
1051
not
atom -> None
1052
:
test_list -> test
1052
,
1621
1053
,
or_test -> and_test
1053
or
1622
1053
:
or_test -> and_test
1053
if
or_test -> and_test
1054
&
factor -> power
1054
%
factor -> power
1054
<<
factor -> power
1054
-
factor -> power
1054
<=
factor -> power
1054
not
factor -> power
1054
//
factor -> power
1054
/
factor -> power
1054
is
factor -> power
1054
|
factor -> power
1054
<
factor -> power
1054
and
factor -> power
1054
>=
factor -> power
1054
>>
factor -> power
1054
>
factor -> power
1054
in
factor -> power
1054
if
factor -> power
1054
^
factor -> power
1054
==
factor -> power
1054
+
factor -> power
1054
,
factor -> power
1054
@
factor -> power
1054
or
factor -> power
1054
*
factor -> power
1054
:
factor -> power
1054
!=
factor -> power
1055
:
1623
1055
NAME
305
1055
varargslist
1624
1055
vfpdef
306
1056
:
test -> or_test
1056
if
1625
1056
,
test -> or_test
1057
,
test -> lambdef
1057
:
test -> lambdef
1058
:
not_test -> comparison
1058
or
not_test -> comparison
1058
and
not_test -> comparison
1058
,
not_test -> comparison
1058
if
not_test -> comparison
1059
factor
1029
1059
term
1031
1059
(
1032
1059
arith_expr
1033
1059
NAME
1034
1059
[
1035
1059
~
1036
1059
+
1037
1059
expr
1038
1059
atom_expr
1039
1059
atom
1040
1059
NUMBER
1041
1059
STRING
1042
1059
shift_expr
1043
1059
-
1044
1059
not_test
1626
1059
True
1045
1059
and_expr
1047
1059
xor_expr
1048
1059
False
1049
1059
{
1050
1059
None
1051
1059
power
1054
1059
comparison
1058
1059
not
1059
1060
&
arith_expr -> term - arith_expr
1060
>>
arith_expr -> term - arith_expr
1060
in
arith_expr -> term - arith_expr
1060
^
arith_expr -> term - arith_expr
1060
<<
arith_expr -> term - arith_expr
1060
,
arith_expr -> term - arith_expr
1060
|
arith_expr -> term - arith_expr
1061
,
arith_expr -> term + arith_expr
1061
|
arith_expr -> term + arith_expr
1061
>>
arith_expr -> term + arith_expr
1061
&
arith_expr -> term + arith_expr
1061
<<
arith_expr -> term + arith_expr
1061
^
arith_expr -> term + arith_expr
1061
in
arith_expr -> term + arith_expr
1062
(
atom -> ( test_list_comp )
1062
+
atom -> ( test_list_comp )
1062
**
atom -> ( test_list_comp )
1062
>>
atom -> ( test_list_comp )
1062
.
atom -> ( test_list_comp )
1062
/
atom -> ( test_list_comp )
1062
*
atom -> ( test_list_comp )
1062
-
atom -> ( test_list_comp )
1062
[
atom -> ( test_list_comp )
1062
&
atom -> ( test_list_comp )
1062
,
atom -> ( test_list_comp )
1062
|
atom -> ( test_list_comp )
1062
@
atom -> ( test_list_comp )
1062
<<
atom -> ( test_list_comp )
1062
%
atom -> ( test_list_comp )
1062
^
atom -> ( test_list_comp )
1062
//
atom -> ( test_list_comp )
1062
in
atom -> ( test_list_comp )
1063
in
atom -> [ test_list_comp ]
1063
/
atom -> [ test_list_comp ]
1063
,
atom -> [ test_list_comp ]
1063
.
atom -> [ test_list_comp ]
1063
[
atom -> [ test_list_comp ]
1063
//
atom -> [ test_list_comp ]
1063
<<
atom -> [ test_list_comp ]
1063
(
atom -> [ test_list_comp ]
1063
-
atom -> [ test_list_comp ]
1063
%
atom -> [ test_list_comp ]
1063
**
atom -> [ test_list_comp ]
1063
*
atom -> [ test_list_comp ]
1063
>>
atom -> [ test_list_comp ]
1063
@
atom -> [ test_list_comp ]
1063
|
atom -> [ test_list_comp ]
1063
&
atom -> [ test_list_comp ]
1063
^
atom -> [ test_list_comp ]
1063
+
atom -> [ test_list_comp ]
1064
+
power -> atom_expr ** factor
1064
&
power -> atom_expr ** factor
1064
*
power -> atom_expr ** factor
1064
|
power -> atom_expr ** factor
1064
^
power -> atom_expr ** factor
1064
@
power -> atom_expr ** factor
1064
>>
power -> atom_expr ** factor
1064
in
power -> atom_expr ** factor
1064
<<
power -> atom_expr ** factor
1064
,
power -> atom_expr ** factor
1064
/
power -> atom_expr ** factor
1064
%
power -> atom_expr ** factor
1064
//
power -> atom_expr ** factor
1064
-
power -> atom_expr ** factor
1065
^
shift_expr -> arith_expr << shift_expr
1065
in
shift_expr -> arith_expr << shift_expr
1065
,
shift_expr -> arith_expr << shift_expr
1065
|
shift_expr -> arith_expr << shift_expr
1065
&
shift_expr -> arith_expr << shift_expr
1066
,
shift_expr -> arith_expr >> shift_expr
1066
|
shift_expr -> arith_expr >> shift_expr
1066
in
shift_expr -> arith_expr >> shift_expr
1066
^
shift_expr -> arith_expr >> shift_expr
1066
&
shift_expr -> arith_expr >> shift_expr
1067
in
expr_list -> expr , expr_list
1068
,
xor_expr -> and_expr ^ xor_expr
1068
|
xor_expr -> and_expr ^ xor_expr
1068
in
xor_expr -> and_expr ^ xor_expr
1069
,
expr -> xor_expr | expr
1069
in
expr -> xor_expr | expr
1070
,
and_expr -> shift_expr & and_expr
1070
^
and_expr -> shift_expr & and_expr
1070
in
and_expr -> shift_expr & and_expr
1070
|
and_expr -> shift_expr & and_expr
1071
**
trailer_expr -> trailer trailer_expr
1071
,
trailer_expr -> trailer trailer_expr
1071
*
trailer_expr -> trailer trailer_expr
1071
+
trailer_expr -> trailer trailer_expr
1071
%
trailer_expr -> trailer trailer_expr
1071
//
trailer_expr -> trailer trailer_expr
1071
&
trailer_expr -> trailer trailer_expr
1071
-
trailer_expr -> trailer trailer_expr
1071
@
trailer_expr -> trailer trailer_expr
1071
in
trailer_expr -> trailer trailer_expr
1071
/
trailer_expr -> trailer trailer_expr
1071
<<
trailer_expr -> trailer trailer_expr
1071
^
trailer_expr -> trailer trailer_expr
1071
>>
trailer_expr -> trailer trailer_expr
1071
|
trailer_expr -> trailer trailer_expr
1072
-
trailer -> ( )
1072
%
trailer -> ( )
1072
**
trailer -> ( )
1072
/
trailer -> ( )
1072
,
trailer -> ( )
1072
+
trailer -> ( )
1072
&
trailer -> ( )
1072
in
trailer -> ( )
1072
^
trailer -> ( )
1072
<<
trailer -> ( )
1072
//
trailer -> ( )
1072
(
trailer -> ( )
1072
>>
trailer -> ( )
1072
@
trailer -> ( )
1072
[
trailer -> ( )
1072
|
trailer -> ( )
1072
.
trailer -> ( )
1072
*
trailer -> ( )
1073
)
1627
1074
-
trailer -> . NAME
1074
,
trailer -> . NAME
1074
/
trailer -> . NAME
1074
[
trailer -> . NAME
1074
+
trailer -> . NAME
1074
^
trailer -> . NAME
1074
in
trailer -> . NAME
1074
@
trailer -> . NAME
1074
.
trailer -> . NAME
1074
%
trailer -> . NAME
1074
<<
trailer -> . NAME
1074
|
trailer -> . NAME
1074
*
trailer -> . NAME
1074
**
trailer -> . NAME
1074
(
trailer -> . NAME
1074
&
trailer -> . NAME
1074
//
trailer -> . NAME
1074
>>
trailer -> . NAME
1075
]
1628
1076
NEWLINE
1629
1077
)
1630
1078
NEWLINE
dotted_name -> NAME . dotted_name
1078
(
dotted_name -> NAME . dotted_name
1079
and
term -> factor // term
1079
if
term -> factor // term
1079
>
term -> factor // term
1079
<
term -> factor // term
1079
==
term -> factor // term
1079
+
term -> factor // term
1079
-
term -> factor // term
1079
&
term -> factor // term
1079
in
term -> factor // term
1079
!=
term -> factor // term
1079
^
term -> factor // term
1079
,
term -> factor // term
1079
or
term -> factor // term
1079
NEWLINE
term -> factor // term
1079
<=
term -> factor // term
1079
>=
term -> factor // term
1079
|
term -> factor // term
1079
>>
term -> factor // term
1079
not
term -> factor // term
1079
is
term -> factor // term
1079
<<
term -> factor // term
1080
^
term -> factor * term
1080
+
term -> factor * term
1080
==
term -> factor * term
1080
>>
term -> factor * term
1080
in
term -> factor * term
1080
and
term -> factor * term
1080
if
term -> factor * term
1080
is
term -> factor * term
1080
<<
term -> factor * term
1080
,
term -> factor * term
1080
-
term -> factor * term
1080
!=
term -> factor * term
1080
or
term -> factor * term
1080
>
term -> factor * term
1080
&
term -> factor * term
1080
NEWLINE
term -> factor * term
1080
>=
term -> factor * term
1080
|
term -> factor * term
1080
<=
term -> factor * term
1080
not
term -> factor * term
1080
<
term -> factor * term
1081
&
term -> factor % term
1081
==
term -> factor % term
1081
!=
term -> factor % term
1081
<
term -> factor % term
1081
in
term -> factor % term
1081
>>
term -> factor % term
1081
<<
term -> factor % term
1081
NEWLINE
term -> factor % term
1081
-
term -> factor % term
1081
if
term -> factor % term
1081
>
term -> factor % term
1081
or
term -> factor % term
1081
^
term -> factor % term
1081
+
term -> factor % term
1081
,
term -> factor % term
1081
is
term -> factor % term
1081
|
term -> factor % term
1081
>=
term -> factor % term
1081
<=
term -> factor % term
1081
and
term -> factor % term
1081
not
term -> factor % term
1082
and
term -> factor @ term
1082
in
term -> factor @ term
1082
>=
term -> factor @ term
1082
<
term -> factor @ term
1082
,
term -> factor @ term
1082
>
term -> factor @ term
1082
-
term -> factor @ term
1082
NEWLINE
term -> factor @ term
1082
or
term -> factor @ term
1082
<<
term -> factor @ term
1082
is
term -> factor @ term
1082
!=
term -> factor @ term
1082
|
term -> factor @ term
1082
&
term -> factor @ term
1082
==
term -> factor @ term
1082
>>
term -> factor @ term
1082
<=
term -> factor @ term
1082
not
term -> factor @ term
1082
+
term -> factor @ term
1082
^
term -> factor @ term
1082
if
term -> factor @ term
1083
or
term -> factor / term
1083
<<
term -> factor / term
1083
not
term -> factor / term
1083
in
term -> factor / term
1083
!=
term -> factor / term
1083
<
term -> factor / term
1083
,
term -> factor / term
1083
+
term -> factor / term
1083
and
term -> factor / term
1083
>>
term -> factor / term
1083
^
term -> factor / term
1083
<=
term -> factor / term
1083
==
term -> factor / term
1083
>
term -> factor / term
1083
&
term -> factor / term
1083
is
term -> factor / term
1083
-
term -> factor / term
1083
NEWLINE
term -> factor / term
1083
|
term -> factor / term
1083
>=
term -> factor / term
1083
if
term -> factor / term
1084
==
arith_expr -> term + arith_expr
1084
!=
arith_expr -> term + arith_expr
1084
<<
arith_expr -> term + arith_expr
1084
&
arith_expr -> term + arith_expr
1084
<
arith_expr -> term + arith_expr
1084
^
arith_expr -> term + arith_expr
1084
,
arith_expr -> term + arith_expr
1084
>=
arith_expr -> term + arith_expr
1084
NEWLINE
arith_expr -> term + arith_expr
1084
in
arith_expr -> term + arith_expr
1084
>>
arith_expr -> term + arith_expr
1084
not
arith_expr -> term + arith_expr
1084
<=
arith_expr -> term + arith_expr
1084
is
arith_expr -> term + arith_expr
1084
|
arith_expr -> term + arith_expr
1084
and
arith_expr -> term + arith_expr
1084
or
arith_expr -> term + arith_expr
1084
if
arith_expr -> term + arith_expr
1084
>
arith_expr -> term + arith_expr
1085
if
arith_expr -> term - arith_expr
1085
&
arith_expr -> term - arith_expr
1085
>>
arith_expr -> term - arith_expr
1085
NEWLINE
arith_expr -> term - arith_expr
1085
!=
arith_expr -> term - arith_expr
1085
>=
arith_expr -> term - arith_expr
1085
|
arith_expr -> term - arith_expr
1085
>
arith_expr -> term - arith_expr
1085
<
arith_expr -> term - arith_expr
1085
==
arith_expr -> term - arith_expr
1085
,
arith_expr -> term - arith_expr
1085
and
arith_expr -> term - arith_expr
1085
is
arith_expr -> term - arith_expr
1085
in
arith_expr -> term - arith_expr
1085
^
arith_expr -> term - arith_expr
1085
<<
arith_expr -> term - arith_expr
1085
not
arith_expr -> term - arith_expr
1085
or
arith_expr -> term - arith_expr
1085
<=
arith_expr -> term - arith_expr
1086
+
atom -> ( test_list_comp )
1086
/
atom -> ( test_list_comp )
1086
*
atom -> ( test_list_comp )
1086
[
atom -> ( test_list_comp )
1086
&
atom -> ( test_list_comp )
1086
,
atom -> ( test_list_comp )
1086
**
atom -> ( test_list_comp )
1086
^
atom -> ( test_list_comp )
1086
(
atom -> ( test_list_comp )
1086
and
atom -> ( test_list_comp )
1086
>
atom -> ( test_list_comp )
1086
-
atom -> ( test_list_comp )
1086
%
atom -> ( test_list_comp )
1086
//
atom -> ( test_list_comp )
1086
in
atom -> ( test_list_comp )
1086
>>
atom -> ( test_list_comp )
1086
not
atom -> ( test_list_comp )
1086
>=
atom -> ( test_list_comp )
1086
or
atom -> ( test_list_comp )
1086
<
atom -> ( test_list_comp )
1086
if
atom -> ( test_list_comp )
1086
|
atom -> ( test_list_comp )
1086
<<
atom -> ( test_list_comp )
1086
@
atom -> ( test_list_comp )
1086
!=
atom -> ( test_list_comp )
1086
is
atom -> ( test_list_comp )
1086
NEWLINE
atom -> ( test_list_comp )
1086
.
atom -> ( test_list_comp )
1086
<=
atom -> ( test_list_comp )
1086
==
atom -> ( test_list_comp )
1087
>=
shift_expr -> arith_expr >> shift_expr
1087
,
shift_expr -> arith_expr >> shift_expr
1087
if
shift_expr -> arith_expr >> shift_expr
1087
<=
shift_expr -> arith_expr >> shift_expr
1087
!=
shift_expr -> arith_expr >> shift_expr
1087
or
shift_expr -> arith_expr >> shift_expr
1087
|
shift_expr -> arith_expr >> shift_expr
1087
is
shift_expr -> arith_expr >> shift_expr
1087
and
shift_expr -> arith_expr >> shift_expr
1087
NEWLINE
shift_expr -> arith_expr >> shift_expr
1087
in
shift_expr -> arith_expr >> shift_expr
1087
^
shift_expr -> arith_expr >> shift_expr
1087
not
shift_expr -> arith_expr >> shift_expr
1087
<
shift_expr -> arith_expr >> shift_expr
1087
==
shift_expr -> arith_expr >> shift_expr
1087
&
shift_expr -> arith_expr >> shift_expr
1087
>
shift_expr -> arith_expr >> shift_expr
1088
>
shift_expr -> arith_expr << shift_expr
1088
or
shift_expr -> arith_expr << shift_expr
1088
^
shift_expr -> arith_expr << shift_expr
1088
not
shift_expr -> arith_expr << shift_expr
1088
<
shift_expr -> arith_expr << shift_expr
1088
if
shift_expr -> arith_expr << shift_expr
1088
in
shift_expr -> arith_expr << shift_expr
1088
!=
shift_expr -> arith_expr << shift_expr
1088
,
shift_expr -> arith_expr << shift_expr
1088
|
shift_expr -> arith_expr << shift_expr
1088
>=
shift_expr -> arith_expr << shift_expr
1088
and
shift_expr -> arith_expr << shift_expr
1088
NEWLINE
shift_expr -> arith_expr << shift_expr
1088
==
shift_expr -> arith_expr << shift_expr
1088
&
shift_expr -> arith_expr << shift_expr
1088
<=
shift_expr -> arith_expr << shift_expr
1088
is
shift_expr -> arith_expr << shift_expr
1089
in
atom -> [ test_list_comp ]
1089
/
atom -> [ test_list_comp ]
1089
or
atom -> [ test_list_comp ]
1089
if
atom -> [ test_list_comp ]
1089
<<
atom -> [ test_list_comp ]
1089
!=
atom -> [ test_list_comp ]
1089
<=
atom -> [ test_list_comp ]
1089
>>
atom -> [ test_list_comp ]
1089
*
atom -> [ test_list_comp ]
1089
^
atom -> [ test_list_comp ]
1089
.
atom -> [ test_list_comp ]
1089
(
atom -> [ test_list_comp ]
1089
>=
atom -> [ test_list_comp ]
1089
and
atom -> [ test_list_comp ]
1089
<
atom -> [ test_list_comp ]
1089
,
atom -> [ test_list_comp ]
1089
[
atom -> [ test_list_comp ]
1089
==
atom -> [ test_list_comp ]
1089
@
atom -> [ test_list_comp ]
1089
%
atom -> [ test_list_comp ]
1089
-
atom -> [ test_list_comp ]
1089
|
atom -> [ test_list_comp ]
1089
&
atom -> [ test_list_comp ]
1089
+
atom -> [ test_list_comp ]
1089
is
atom -> [ test_list_comp ]
1089
//
atom -> [ test_list_comp ]
1089
**
atom -> [ test_list_comp ]
1089
not
atom -> [ test_list_comp ]
1089
NEWLINE
atom -> [ test_list_comp ]
1089
>
atom -> [ test_list_comp ]
1090
+
power -> atom_expr ** factor
1090
&
power -> atom_expr ** factor
1090
>>
power -> atom_expr ** factor
1090
<<
power -> atom_expr ** factor
1090
not
power -> atom_expr ** factor
1090
is
power -> atom_expr ** factor
1090
@
power -> atom_expr ** factor
1090
==
power -> atom_expr ** factor
1090
*
power -> atom_expr ** factor
1090
or
power -> atom_expr ** factor
1090
>
power -> atom_expr ** factor
1090
-
power -> atom_expr ** factor
1090
if
power -> atom_expr ** factor
1090
!=
power -> atom_expr ** factor
1090
>=
power -> atom_expr ** factor
1090
/
power -> atom_expr ** factor
1090
%
power -> atom_expr ** factor
1090
and
power -> atom_expr ** factor
1090
<=
power -> atom_expr ** factor
1090
NEWLINE
power -> atom_expr ** factor
1090
<
power -> atom_expr ** factor
1090
|
power -> atom_expr ** factor
1090
^
power -> atom_expr ** factor
1090
in
power -> atom_expr ** factor
1090
,
power -> atom_expr ** factor
1090
//
power -> atom_expr ** factor
1091
+
trailer_expr -> trailer trailer_expr
1091
,
trailer_expr -> trailer trailer_expr
1091
*
trailer_expr -> trailer trailer_expr
1091
/
trailer_expr -> trailer trailer_expr
1091
not
trailer_expr -> trailer trailer_expr
1091
<<
trailer_expr -> trailer trailer_expr
1091
!=
trailer_expr -> trailer trailer_expr
1091
>=
trailer_expr -> trailer trailer_expr
1091
>>
trailer_expr -> trailer trailer_expr
1091
|
trailer_expr -> trailer trailer_expr
1091
%
trailer_expr -> trailer trailer_expr
1091
>
trailer_expr -> trailer trailer_expr
1091
&
trailer_expr -> trailer trailer_expr
1091
-
trailer_expr -> trailer trailer_expr
1091
<=
trailer_expr -> trailer trailer_expr
1091
**
trailer_expr -> trailer trailer_expr
1091
@
trailer_expr -> trailer trailer_expr
1091
if
trailer_expr -> trailer trailer_expr
1091
NEWLINE
trailer_expr -> trailer trailer_expr
1091
==
trailer_expr -> trailer trailer_expr
1091
or
trailer_expr -> trailer trailer_expr
1091
<
trailer_expr -> trailer trailer_expr
1091
and
trailer_expr -> trailer trailer_expr
1091
in
trailer_expr -> trailer trailer_expr
1091
is
trailer_expr -> trailer trailer_expr
1091
^
trailer_expr -> trailer trailer_expr
1091
//
trailer_expr -> trailer trailer_expr
1092
<<
trailer -> . NAME
1092
<=
trailer -> . NAME
1092
**
trailer -> . NAME
1092
!=
trailer -> . NAME
1092
/
trailer -> . NAME
1092
&
trailer -> . NAME
1092
//
trailer -> . NAME
1092
<
trailer -> . NAME
1092
is
trailer -> . NAME
1092
-
trailer -> . NAME
1092
if
trailer -> . NAME
1092
[
trailer -> . NAME
1092
or
trailer -> . NAME
1092
>
trailer -> . NAME
1092
*
trailer -> . NAME
1092
+
trailer -> . NAME
1092
%
trailer -> . NAME
1092
.
trailer -> . NAME
1092
>=
trailer -> . NAME
1092
|
trailer -> . NAME
1092
and
trailer -> . NAME
1092
(
trailer -> . NAME
1092
,
trailer -> . NAME
1092
NEWLINE
trailer -> . NAME
1092
==
trailer -> . NAME
1092
^
trailer -> . NAME
1092
in
trailer -> . NAME
1092
@
trailer -> . NAME
1092
not
trailer -> . NAME
1092
>>
trailer -> . NAME
1093
)
1631
1094
%
trailer -> ( )
1094
<=
trailer -> ( )
1094
and
trailer -> ( )
1094
//
trailer -> ( )
1094
not
trailer -> ( )
1094
or
trailer -> ( )
1094
NEWLINE
trailer -> ( )
1094
>>
trailer -> ( )
1094
>
trailer -> ( )
1094
<<
trailer -> ( )
1094
[
trailer -> ( )
1094
is
trailer -> ( )
1094
-
trailer -> ( )
1094
**
trailer -> ( )
1094
/
trailer -> ( )
1094
,
trailer -> ( )
1094
+
trailer -> ( )
1094
&
trailer -> ( )
1094
in
trailer -> ( )
1094
^
trailer -> ( )
1094
!=
trailer -> ( )
1094
*
trailer -> ( )
1094
if
trailer -> ( )
1094
>=
trailer -> ( )
1094
(
trailer -> ( )
1094
@
trailer -> ( )
1094
==
trailer -> ( )
1094
|
trailer -> ( )
1094
.
trailer -> ( )
1094
<
trailer -> ( )
1095
]
1632
1096
==
and_expr -> shift_expr & and_expr
1096
in
and_expr -> shift_expr & and_expr
1096
!=
and_expr -> shift_expr & and_expr
1096
,
and_expr -> shift_expr & and_expr
1096
or
and_expr -> shift_expr & and_expr
1096
>
and_expr -> shift_expr & and_expr
1096
not
and_expr -> shift_expr & and_expr
1096
<=
and_expr -> shift_expr & and_expr
1096
|
and_expr -> shift_expr & and_expr
1096
and
and_expr -> shift_expr & and_expr
1096
NEWLINE
and_expr -> shift_expr & and_expr
1096
^
and_expr -> shift_expr & and_expr
1096
is
and_expr -> shift_expr & and_expr
1096
>=
and_expr -> shift_expr & and_expr
1096
<
and_expr -> shift_expr & and_expr
1096
if
and_expr -> shift_expr & and_expr
1097
NEWLINE
and_test -> not_test and and_test
1097
,
and_test -> not_test and and_test
1097
if
and_test -> not_test and and_test
1097
or
and_test -> not_test and and_test
1098
<=
xor_expr -> and_expr ^ xor_expr
1098
!=
xor_expr -> and_expr ^ xor_expr
1098
and
xor_expr -> and_expr ^ xor_expr
1098
is
xor_expr -> and_expr ^ xor_expr
1098
>=
xor_expr -> and_expr ^ xor_expr
1098
not
xor_expr -> and_expr ^ xor_expr
1098
<
xor_expr -> and_expr ^ xor_expr
1098
|
xor_expr -> and_expr ^ xor_expr
1098
in
xor_expr -> and_expr ^ xor_expr
1098
==
xor_expr -> and_expr ^ xor_expr
1098
or
xor_expr -> and_expr ^ xor_expr
1098
,
xor_expr -> and_expr ^ xor_expr
1098
if
xor_expr -> and_expr ^ xor_expr
1098
>
xor_expr -> and_expr ^ xor_expr
1098
NEWLINE
xor_expr -> and_expr ^ xor_expr
1099
not
expr -> xor_expr | expr
1099
,
expr -> xor_expr | expr
1099
in
expr -> xor_expr | expr
1099
if
expr -> xor_expr | expr
1099
or
expr -> xor_expr | expr
1099
<=
expr -> xor_expr | expr
1099
>
expr -> xor_expr | expr
1099
!=
expr -> xor_expr | expr
1099
==
expr -> xor_expr | expr
1099
NEWLINE
expr -> xor_expr | expr
1099
>=
expr -> xor_expr | expr
1099
is
expr -> xor_expr | expr
1099
<
expr -> xor_expr | expr
1099
and
expr -> xor_expr | expr
1100
and
comparison -> expr comp_op comparison
1100
if
comparison -> expr comp_op comparison
1100
or
comparison -> expr comp_op comparison
1100
NEWLINE
comparison -> expr comp_op comparison
1100
,
comparison -> expr comp_op comparison
1101
NEWLINE
or_test -> and_test or or_test
1101
,
or_test -> and_test or or_test
1101
if
or_test -> and_test or or_test
1102
,
lambdef -> lambda : test
1102
NEWLINE
lambdef -> lambda : test
1103
factor
184
1103
term
185
1103
(
186
1103
arith_expr
187
1103
NAME
188
1103
[
189
1103
+
190
1103
atom_expr
191
1103
atom
192
1103
NUMBER
193
1103
STRING
194
1103
shift_expr
195
1103
-
196
1103
True
197
1103
not_test
198
1103
and_expr
199
1103
xor_expr
200
1103
None
201
1103
expr
202
1103
False
203
1103
and_test
204
1103
lambda
205
1103
{
206
1103
~
207
1103
power
208
1103
not
210
1103
or_test
211
1103
comparison
212
1103
lambdef
214
1103
test
1633
1104
NEWLINE
test_list -> test , test_list
1105
else
1634
1106
:
1635
1107
)
1636
1108
)
param -> tfpdef
1108
,
param -> tfpdef
1108
=
1637
1109
NAME
1638
1109
tfpdef
1639
1110
)
parameters -> param
1110
,
1640
1111
NAME
1638
1111
tfpdef
1641
1112
)
tfpdef -> NAME
1112
:
1642
1112
=
tfpdef -> NAME
1112
,
tfpdef -> NAME
1113
factor
585
1113
(
586
1113
NAME
588
1113
[
589
1113
+
591
1113
atom_expr
593
1113
NUMBER
594
1113
atom
595
1113
STRING
596
1113
-
598
1113
term
1643
1113
True
599
1113
None
602
1113
False
603
1113
~
606
1113
power
607
1113
{
608
1114
factor
585
1114
(
586
1114
NAME
588
1114
[
589
1114
+
591
1114
atom_expr
593
1114
NUMBER
594
1114
atom
595
1114
STRING
596
1114
-
598
1114
term
1644
1114
True
599
1114
None
602
1114
False
603
1114
~
606
1114
power
607
1114
{
608
1115
factor
585
1115
(
586
1115
NAME
588
1115
[
589
1115
+
591
1115
atom_expr
593
1115
NUMBER
594
1115
atom
595
1115
STRING
596
1115
-
598
1115
True
599
1115
None
602
1115
False
603
1115
term
1645
1115
~
606
1115
power
607
1115
{
608
1116
factor
585
1116
(
586
1116
NAME
588
1116
term
1646
1116
[
589
1116
+
591
1116
atom_expr
593
1116
NUMBER
594
1116
atom
595
1116
STRING
596
1116
-
598
1116
True
599
1116
None
602
1116
False
603
1116
~
606
1116
power
607
1116
{
608
1117
factor
585
1117
(
586
1117
NAME
588
1117
[
589
1117
+
591
1117
atom_expr
593
1117
NUMBER
594
1117
atom
595
1117
term
1647
1117
STRING
596
1117
-
598
1117
True
599
1117
None
602
1117
False
603
1117
~
606
1117
power
607
1117
{
608
1118
)
1648
1119
or
atom -> ( )
1119
<<
atom -> ( )
1119
not
atom -> ( )
1119
&
atom -> ( )
1119
(
atom -> ( )
1119
in
atom -> ( )
1119
**
atom -> ( )
1119
@
atom -> ( )
1119
<=
atom -> ( )
1119
%
atom -> ( )
1119
[
atom -> ( )
1119
>=
atom -> ( )
1119
/
atom -> ( )
1119
else
atom -> ( )
1119
+
atom -> ( )
1119
<
atom -> ( )
1119
is
atom -> ( )
1119
*
atom -> ( )
1119
!=
atom -> ( )
1119
-
atom -> ( )
1119
|
atom -> ( )
1119
//
atom -> ( )
1119
^
atom -> ( )
1119
and
atom -> ( )
1119
==
atom -> ( )
1119
>
atom -> ( )
1119
.
atom -> ( )
1119
>>
atom -> ( )
1120
factor
585
1120
(
586
1120
arith_expr
587
1120
NAME
588
1120
[
589
1120
+
591
1120
term
592
1120
atom_expr
593
1120
NUMBER
594
1120
atom
595
1120
STRING
596
1120
-
598
1120
shift_expr
1649
1120
True
599
1120
None
602
1120
False
603
1120
~
606
1120
power
607
1120
{
608
1121
factor
585
1121
(
586
1121
arith_expr
587
1121
NAME
588
1121
[
589
1121
+
591
1121
term
592
1121
atom_expr
593
1121
NUMBER
594
1121
atom
595
1121
STRING
596
1121
-
598
1121
True
599
1121
shift_expr
1650
1121
None
602
1121
False
603
1121
~
606
1121
power
607
1121
{
608
1122
<=
atom -> [ ]
1122
is
atom -> [ ]
1122
-
atom -> [ ]
1122
**
atom -> [ ]
1122
^
atom -> [ ]
1122
%
atom -> [ ]
1122
/
atom -> [ ]
1122
>=
atom -> [ ]
1122
|
atom -> [ ]
1122
not
atom -> [ ]
1122
@
atom -> [ ]
1122
*
atom -> [ ]
1122
(
atom -> [ ]
1122
>>
atom -> [ ]
1122
[
atom -> [ ]
1122
or
atom -> [ ]
1122
!=
atom -> [ ]
1122
and
atom -> [ ]
1122
<<
atom -> [ ]
1122
in
atom -> [ ]
1122
+
atom -> [ ]
1122
.
atom -> [ ]
1122
==
atom -> [ ]
1122
>
atom -> [ ]
1122
<
atom -> [ ]
1122
&
atom -> [ ]
1122
else
atom -> [ ]
1122
//
atom -> [ ]
1123
]
1651
1124
factor
585
1124
(
586
1124
arith_expr
587
1124
NAME
588
1124
[
589
1124
and_expr
590
1124
+
591
1124
term
592
1124
atom_expr
593
1124
NUMBER
594
1124
atom
595
1124
STRING
596
1124
shift_expr
597
1124
-
598
1124
True
599
1124
None
602
1124
False
603
1124
~
606
1124
power
607
1124
xor_expr
1652
1124
{
608
1125
<
factor -> + factor
1125
<<
factor -> + factor
1125
and
factor -> + factor
1125
>=
factor -> + factor
1125
%
factor -> + factor
1125
+
factor -> + factor
1125
>>
factor -> + factor
1125
*
factor -> + factor
1125
/
factor -> + factor
1125
>
factor -> + factor
1125
<=
factor -> + factor
1125
^
factor -> + factor
1125
is
factor -> + factor
1125
|
factor -> + factor
1125
or
factor -> + factor
1125
-
factor -> + factor
1125
in
factor -> + factor
1125
&
factor -> + factor
1125
not
factor -> + factor
1125
//
factor -> + factor
1125
!=
factor -> + factor
1125
else
factor -> + factor
1125
==
factor -> + factor
1125
@
factor -> + factor
1126
factor
585
1126
(
586
1126
NAME
588
1126
[
589
1126
+
591
1126
term
592
1126
atom_expr
593
1126
NUMBER
594
1126
atom
595
1126
STRING
596
1126
-
598
1126
True
599
1126
arith_expr
1653
1126
None
602
1126
False
603
1126
~
606
1126
power
607
1126
{
608
1127
factor
585
1127
(
586
1127
NAME
588
1127
[
589
1127
+
591
1127
term
592
1127
atom_expr
593
1127
NUMBER
594
1127
atom
595
1127
STRING
596
1127
-
598
1127
True
599
1127
None
602
1127
False
603
1127
arith_expr
1654
1127
~
606
1127
power
607
1127
{
608
1128
True
599
1128
NUMBER
594
1128
(
586
1128
NAME
588
1128
~
606
1128
[
589
1128
atom_expr
593
1128
factor
1655
1128
+
591
1128
None
602
1128
STRING
596
1128
atom
595
1128
False
603
1128
-
598
1128
{
608
1128
power
607
1129
factor
732
1129
or_test
733
1129
term
734
1129
(
735
1129
arith_expr
736
1129
NAME
737
1129
[
738
1129
~
739
1129
subscriptlist
1656
1129
+
741
1129
maybe_test
742
1129
expr
743
1129
atom_expr
744
1129
atom
745
1129
NUMBER
746
1129
STRING
747
1129
shift_expr
748
1129
-
749
1129
True
750
1129
not_test
751
1129
and_expr
752
1129
xor_expr
753
1129
False
754
1129
{
755
1129
None
756
1129
and_test
757
1129
lambda
758
1129
power
759
1129
subscript
760
1129
test
761
1129
lambdef
762
1129
:
maybe_test -> 
1129
comparison
763
1129
not
764
1130
trailer_expr
1657
1130
[
1129
1130
trailer
1130
1130
.
1131
1130
(
1132
1130
<<
trailer_expr -> 
1130
%
trailer_expr -> 
1130
==
trailer_expr -> 
1130
-
trailer_expr -> 
1130
<
trailer_expr -> 
1130
or
trailer_expr -> 
1130
/
trailer_expr -> 
1130
**
trailer_expr -> 
1130
and
trailer_expr -> 
1130
@
trailer_expr -> 
1130
*
trailer_expr -> 
1130
|
trailer_expr -> 
1130
is
trailer_expr -> 
1130
+
trailer_expr -> 
1130
in
trailer_expr -> 
1130
else
trailer_expr -> 
1130
&
trailer_expr -> 
1130
<=
trailer_expr -> 
1130
>=
trailer_expr -> 
1130
^
trailer_expr -> 
1130
>
trailer_expr -> 
1130
!=
trailer_expr -> 
1130
not
trailer_expr -> 
1130
>>
trailer_expr -> 
1130
//
trailer_expr -> 
1131
NAME
1658
1132
factor
697
1132
term
698
1132
(
699
1132
arith_expr
700
1132
NAME
701
1132
[
702
1132
atom
703
1132
+
704
1132
power
706
1132
atom_expr
707
1132
NUMBER
708
1132
STRING
709
1132
*
710
1132
shift_expr
711
1132
-
712
1132
argument
714
1132
)
1659
1132
True
715
1132
not_test
716
1132
lambdef
717
1132
and_expr
718
1132
xor_expr
719
1132
False
720
1132
test
721
1132
None
722
1132
arglist
1660
1132
expr
723
1132
and_test
724
1132
{
725
1132
~
726
1132
lambda
727
1132
comparison
728
1132
or_test
729
1132
not
730
1132
**
731
1133
>
atom_expr -> atom trailer_expr
1133
not
atom_expr -> atom trailer_expr
1133
//
atom_expr -> atom trailer_expr
1133
>>
atom_expr -> atom trailer_expr
1133
|
atom_expr -> atom trailer_expr
1133
^
atom_expr -> atom trailer_expr
1133
/
atom_expr -> atom trailer_expr
1133
+
atom_expr -> atom trailer_expr
1133
in
atom_expr -> atom trailer_expr
1133
%
atom_expr -> atom trailer_expr
1133
and
atom_expr -> atom trailer_expr
1133
<=
atom_expr -> atom trailer_expr
1133
is
atom_expr -> atom trailer_expr
1133
<
atom_expr -> atom trailer_expr
1133
@
atom_expr -> atom trailer_expr
1133
-
atom_expr -> atom trailer_expr
1133
&
atom_expr -> atom trailer_expr
1133
*
atom_expr -> atom trailer_expr
1133
**
atom_expr -> atom trailer_expr
1133
>=
atom_expr -> atom trailer_expr
1133
or
atom_expr -> atom trailer_expr
1133
else
atom_expr -> atom trailer_expr
1133
==
atom_expr -> atom trailer_expr
1133
!=
atom_expr -> atom trailer_expr
1133
<<
atom_expr -> atom trailer_expr
1134
factor
585
1134
(
586
1134
arith_expr
587
1134
NAME
588
1134
[
589
1134
+
591
1134
term
592
1134
atom_expr
593
1134
NUMBER
594
1134
atom
595
1134
STRING
596
1134
shift_expr
597
1134
-
598
1134
True
599
1134
None
602
1134
and_expr
1661
1134
False
603
1134
~
606
1134
power
607
1134
{
608
1135
and
factor -> - factor
1135
or
factor -> - factor
1135
<
factor -> - factor
1135
>=
factor -> - factor
1135
!=
factor -> - factor
1135
-
factor -> - factor
1135
==
factor -> - factor
1135
@
factor -> - factor
1135
|
factor -> - factor
1135
*
factor -> - factor
1135
%
factor -> - factor
1135
+
factor -> - factor
1135
//
factor -> - factor
1135
<=
factor -> - factor
1135
not
factor -> - factor
1135
>>
factor -> - factor
1135
/
factor -> - factor
1135
else
factor -> - factor
1135
&
factor -> - factor
1135
^
factor -> - factor
1135
in
factor -> - factor
1135
is
factor -> - factor
1135
>
factor -> - factor
1135
<<
factor -> - factor
1136
or
not_test -> not not_test
1136
else
not_test -> not not_test
1136
and
not_test -> not not_test
1137
factor
585
1137
(
586
1137
arith_expr
587
1137
NAME
588
1137
[
589
1137
and_expr
590
1137
+
591
1137
term
592
1137
atom_expr
593
1137
NUMBER
594
1137
atom
595
1137
STRING
596
1137
shift_expr
597
1137
-
598
1137
True
599
1137
xor_expr
601
1137
None
602
1137
False
603
1137
~
606
1137
power
607
1137
{
608
1137
expr
1662
1138
factor
9
1138
arith_expr
2
1138
NAME
29
1138
term
21
1138
[
3
1138
~
45
1138
atom_expr
24
1138
expr
16
1138
power
56
1138
(
36
1138
True
17
1138
not_test
18
1138
and_expr
19
1138
xor_expr
22
1138
lambdef
53
1138
atom
54
1138
or_test
23
1138
shift_expr
50
1138
False
35
1138
-
49
1138
None
42
1138
lambda
40
1138
NUMBER
27
1138
STRING
28
1138
test
1663
1138
{
52
1138
and_test
37
1138
comparison
39
1138
+
55
1138
not
57
1139
factor
585
1139
(
586
1139
arith_expr
587
1139
NAME
588
1139
[
589
1139
and_expr
590
1139
+
591
1139
term
592
1139
atom_expr
593
1139
NUMBER
594
1139
atom
595
1139
STRING
596
1139
shift_expr
597
1139
-
598
1139
True
599
1139
not
600
1139
xor_expr
601
1139
None
602
1139
False
603
1139
not_test
605
1139
~
606
1139
power
607
1139
and_test
1664
1139
{
608
1139
expr
609
1139
comparison
610
1140
or
factor -> ~ factor
1140
==
factor -> ~ factor
1140
<=
factor -> ~ factor
1140
@
factor -> ~ factor
1140
!=
factor -> ~ factor
1140
>=
factor -> ~ factor
1140
>
factor -> ~ factor
1140
and
factor -> ~ factor
1140
else
factor -> ~ factor
1140
*
factor -> ~ factor
1140
&
factor -> ~ factor
1140
%
factor -> ~ factor
1140
<
factor -> ~ factor
1140
//
factor -> ~ factor
1140
^
factor -> ~ factor
1140
/
factor -> ~ factor
1140
in
factor -> ~ factor
1140
+
factor -> ~ factor
1140
not
factor -> ~ factor
1140
-
factor -> ~ factor
1140
is
factor -> ~ factor
1140
>>
factor -> ~ factor
1140
<<
factor -> ~ factor
1140
|
factor -> ~ factor
1141
>
atom -> { }
1141
==
atom -> { }
1141
-
atom -> { }
1141
not
atom -> { }
1141
(
atom -> { }
1141
@
atom -> { }
1141
and
atom -> { }
1141
&
atom -> { }
1141
<<
atom -> { }
1141
!=
atom -> { }
1141
or
atom -> { }
1141
>>
atom -> { }
1141
<=
atom -> { }
1141
>=
atom -> { }
1141
is
atom -> { }
1141
/
atom -> { }
1141
^
atom -> { }
1141
[
atom -> { }
1141
%
atom -> { }
1141
//
atom -> { }
1141
else
atom -> { }
1141
*
atom -> { }
1141
**
atom -> { }
1141
.
atom -> { }
1141
in
atom -> { }
1141
+
atom -> { }
1141
|
atom -> { }
1141
<
atom -> { }
1142
factor
585
1142
(
586
1142
arith_expr
587
1142
NAME
588
1142
[
589
1142
and_expr
590
1142
+
591
1142
comparison
1665
1142
term
592
1142
atom_expr
593
1142
NUMBER
594
1142
atom
595
1142
STRING
596
1142
shift_expr
597
1142
-
598
1142
True
599
1142
xor_expr
601
1142
None
602
1142
False
603
1142
~
606
1142
power
607
1142
{
608
1142
expr
609
1143
factor
585
1143
(
586
1143
arith_expr
587
1143
NAME
588
1143
[
589
1143
and_expr
590
1143
+
591
1143
term
592
1143
atom_expr
593
1143
NUMBER
594
1143
atom
595
1143
STRING
596
1143
shift_expr
597
1143
-
598
1143
True
599
1143
not
600
1143
xor_expr
601
1143
None
602
1143
False
603
1143
not_test
605
1143
~
606
1143
power
607
1143
{
608
1143
expr
609
1143
or_test
1666
1143
comparison
610
1143
and_test
611
1144
NEWLINE
namelist -> NAME , namelist
1145
and
term -> factor // term
1145
if
term -> factor // term
1145
>
term -> factor // term
1145
<
term -> factor // term
1145
==
term -> factor // term
1145
+
term -> factor // term
1145
-
term -> factor // term
1145
&
term -> factor // term
1145
in
term -> factor // term
1145
:
term -> factor // term
1145
!=
term -> factor // term
1145
^
term -> factor // term
1145
,
term -> factor // term
1145
or
term -> factor // term
1145
<=
term -> factor // term
1145
>=
term -> factor // term
1145
|
term -> factor // term
1145
>>
term -> factor // term
1145
not
term -> factor // term
1145
is
term -> factor // term
1145
as
term -> factor // term
1145
<<
term -> factor // term
1146
or
term -> factor / term
1146
<<
term -> factor / term
1146
not
term -> factor / term
1146
in
term -> factor / term
1146
!=
term -> factor / term
1146
<
term -> factor / term
1146
as
term -> factor / term
1146
,
term -> factor / term
1146
+
term -> factor / term
1146
and
term -> factor / term
1146
>>
term -> factor / term
1146
^
term -> factor / term
1146
<=
term -> factor / term
1146
==
term -> factor / term
1146
>
term -> factor / term
1146
&
term -> factor / term
1146
is
term -> factor / term
1146
-
term -> factor / term
1146
:
term -> factor / term
1146
|
term -> factor / term
1146
>=
term -> factor / term
1146
if
term -> factor / term
1147
^
term -> factor * term
1147
+
term -> factor * term
1147
==
term -> factor * term
1147
>>
term -> factor * term
1147
in
term -> factor * term
1147
and
term -> factor * term
1147
if
term -> factor * term
1147
is
term -> factor * term
1147
<<
term -> factor * term
1147
:
term -> factor * term
1147
,
term -> factor * term
1147
-
term -> factor * term
1147
as
term -> factor * term
1147
!=
term -> factor * term
1147
or
term -> factor * term
1147
>
term -> factor * term
1147
&
term -> factor * term
1147
>=
term -> factor * term
1147
|
term -> factor * term
1147
<=
term -> factor * term
1147
not
term -> factor * term
1147
<
term -> factor * term
1148
&
term -> factor % term
1148
==
term -> factor % term
1148
!=
term -> factor % term
1148
<
term -> factor % term
1148
in
term -> factor % term
1148
>>
term -> factor % term
1148
<<
term -> factor % term
1148
-
term -> factor % term
1148
if
term -> factor % term
1148
>
term -> factor % term
1148
as
term -> factor % term
1148
or
term -> factor % term
1148
^
term -> factor % term
1148
+
term -> factor % term
1148
,
term -> factor % term
1148
is
term -> factor % term
1148
|
term -> factor % term
1148
>=
term -> factor % term
1148
<=
term -> factor % term
1148
and
term -> factor % term
1148
not
term -> factor % term
1148
:
term -> factor % term
1149
and
term -> factor @ term
1149
in
term -> factor @ term
1149
>=
term -> factor @ term
1149
<
term -> factor @ term
1149
:
term -> factor @ term
1149
,
term -> factor @ term
1149
>
term -> factor @ term
1149
-
term -> factor @ term
1149
or
term -> factor @ term
1149
<<
term -> factor @ term
1149
is
term -> factor @ term
1149
!=
term -> factor @ term
1149
|
term -> factor @ term
1149
&
term -> factor @ term
1149
==
term -> factor @ term
1149
>>
term -> factor @ term
1149
<=
term -> factor @ term
1149
not
term -> factor @ term
1149
+
term -> factor @ term
1149
^
term -> factor @ term
1149
as
term -> factor @ term
1149
if
term -> factor @ term
1150
==
arith_expr -> term + arith_expr
1150
!=
arith_expr -> term + arith_expr
1150
<<
arith_expr -> term + arith_expr
1150
&
arith_expr -> term + arith_expr
1150
<
arith_expr -> term + arith_expr
1150
^
arith_expr -> term + arith_expr
1150
,
arith_expr -> term + arith_expr
1150
>=
arith_expr -> term + arith_expr
1150
as
arith_expr -> term + arith_expr
1150
in
arith_expr -> term + arith_expr
1150
>>
arith_expr -> term + arith_expr
1150
not
arith_expr -> term + arith_expr
1150
:
arith_expr -> term + arith_expr
1150
<=
arith_expr -> term + arith_expr
1150
is
arith_expr -> term + arith_expr
1150
|
arith_expr -> term + arith_expr
1150
and
arith_expr -> term + arith_expr
1150
or
arith_expr -> term + arith_expr
1150
if
arith_expr -> term + arith_expr
1150
>
arith_expr -> term + arith_expr
1151
if
arith_expr -> term - arith_expr
1151
&
arith_expr -> term - arith_expr
1151
>>
arith_expr -> term - arith_expr
1151
:
arith_expr -> term - arith_expr
1151
!=
arith_expr -> term - arith_expr
1151
>=
arith_expr -> term - arith_expr
1151
|
arith_expr -> term - arith_expr
1151
as
arith_expr -> term - arith_expr
1151
>
arith_expr -> term - arith_expr
1151
<
arith_expr -> term - arith_expr
1151
==
arith_expr -> term - arith_expr
1151
,
arith_expr -> term - arith_expr
1151
and
arith_expr -> term - arith_expr
1151
is
arith_expr -> term - arith_expr
1151
in
arith_expr -> term - arith_expr
1151
^
arith_expr -> term - arith_expr
1151
<<
arith_expr -> term - arith_expr
1151
not
arith_expr -> term - arith_expr
1151
or
arith_expr -> term - arith_expr
1151
<=
arith_expr -> term - arith_expr
1152
+
atom -> ( test_list_comp )
1152
/
atom -> ( test_list_comp )
1152
*
atom -> ( test_list_comp )
1152
[
atom -> ( test_list_comp )
1152
&
atom -> ( test_list_comp )
1152
,
atom -> ( test_list_comp )
1152
**
atom -> ( test_list_comp )
1152
^
atom -> ( test_list_comp )
1152
(
atom -> ( test_list_comp )
1152
and
atom -> ( test_list_comp )
1152
:
atom -> ( test_list_comp )
1152
>
atom -> ( test_list_comp )
1152
as
atom -> ( test_list_comp )
1152
-
atom -> ( test_list_comp )
1152
%
atom -> ( test_list_comp )
1152
//
atom -> ( test_list_comp )
1152
in
atom -> ( test_list_comp )
1152
>>
atom -> ( test_list_comp )
1152
not
atom -> ( test_list_comp )
1152
>=
atom -> ( test_list_comp )
1152
or
atom -> ( test_list_comp )
1152
<
atom -> ( test_list_comp )
1152
if
atom -> ( test_list_comp )
1152
|
atom -> ( test_list_comp )
1152
<<
atom -> ( test_list_comp )
1152
@
atom -> ( test_list_comp )
1152
!=
atom -> ( test_list_comp )
1152
is
atom -> ( test_list_comp )
1152
.
atom -> ( test_list_comp )
1152
<=
atom -> ( test_list_comp )
1152
==
atom -> ( test_list_comp )
1153
as
shift_expr -> arith_expr >> shift_expr
1153
>=
shift_expr -> arith_expr >> shift_expr
1153
,
shift_expr -> arith_expr >> shift_expr
1153
if
shift_expr -> arith_expr >> shift_expr
1153
<=
shift_expr -> arith_expr >> shift_expr
1153
!=
shift_expr -> arith_expr >> shift_expr
1153
or
shift_expr -> arith_expr >> shift_expr
1153
|
shift_expr -> arith_expr >> shift_expr
1153
is
shift_expr -> arith_expr >> shift_expr
1153
and
shift_expr -> arith_expr >> shift_expr
1153
in
shift_expr -> arith_expr >> shift_expr
1153
^
shift_expr -> arith_expr >> shift_expr
1153
not
shift_expr -> arith_expr >> shift_expr
1153
<
shift_expr -> arith_expr >> shift_expr
1153
==
shift_expr -> arith_expr >> shift_expr
1153
:
shift_expr -> arith_expr >> shift_expr
1153
&
shift_expr -> arith_expr >> shift_expr
1153
>
shift_expr -> arith_expr >> shift_expr
1154
>
shift_expr -> arith_expr << shift_expr
1154
or
shift_expr -> arith_expr << shift_expr
1154
^
shift_expr -> arith_expr << shift_expr
1154
as
shift_expr -> arith_expr << shift_expr
1154
not
shift_expr -> arith_expr << shift_expr
1154
<
shift_expr -> arith_expr << shift_expr
1154
if
shift_expr -> arith_expr << shift_expr
1154
in
shift_expr -> arith_expr << shift_expr
1154
!=
shift_expr -> arith_expr << shift_expr
1154
,
shift_expr -> arith_expr << shift_expr
1154
|
shift_expr -> arith_expr << shift_expr
1154
>=
shift_expr -> arith_expr << shift_expr
1154
and
shift_expr -> arith_expr << shift_expr
1154
==
shift_expr -> arith_expr << shift_expr
1154
&
shift_expr -> arith_expr << shift_expr
1154
<=
shift_expr -> arith_expr << shift_expr
1154
is
shift_expr -> arith_expr << shift_expr
1154
:
shift_expr -> arith_expr << shift_expr
1155
begsim
with_stmt -> with with_items : suite
1155
nonlocal
with_stmt -> with with_items : suite
1155
return
with_stmt -> with with_items : suite
1155
False
with_stmt -> with with_items : suite
1155
assert
with_stmt -> with with_items : suite
1155
not
with_stmt -> with with_items : suite
1155
try
with_stmt -> with with_items : suite
1155
class
with_stmt -> with with_items : suite
1155
raise
with_stmt -> with with_items : suite
1155
if
with_stmt -> with with_items : suite
1155
while
with_stmt -> with with_items : suite
1155
resetstats
with_stmt -> with with_items : suite
1155
with
with_stmt -> with with_items : suite
1155
None
with_stmt -> with with_items : suite
1155
~
with_stmt -> with with_items : suite
1155
$
with_stmt -> with with_items : suite
1155
@
with_stmt -> with with_items : suite
1155
{
with_stmt -> with with_items : suite
1155
endsim
with_stmt -> with with_items : suite
1155
for
with_stmt -> with with_items : suite
1155
(
with_stmt -> with with_items : suite
1155
def
with_stmt -> with with_items : suite
1155
global
with_stmt -> with with_items : suite
1155
lambda
with_stmt -> with with_items : suite
1155
pass
with_stmt -> with with_items : suite
1155
[
with_stmt -> with with_items : suite
1155
STRING
with_stmt -> with with_items : suite
1155
del
with_stmt -> with with_items : suite
1155
continue
with_stmt -> with with_items : suite
1155
yield
with_stmt -> with with_items : suite
1155
-
with_stmt -> with with_items : suite
1155
NUMBER
with_stmt -> with with_items : suite
1155
break
with_stmt -> with with_items : suite
1155
True
with_stmt -> with with_items : suite
1155
NAME
with_stmt -> with with_items : suite
1155
NEWLINE
with_stmt -> with with_items : suite
1155
+
with_stmt -> with with_items : suite
1155
conf
with_stmt -> with with_items : suite
1156
in
atom -> [ test_list_comp ]
1156
/
atom -> [ test_list_comp ]
1156
or
atom -> [ test_list_comp ]
1156
if
atom -> [ test_list_comp ]
1156
<<
atom -> [ test_list_comp ]
1156
!=
atom -> [ test_list_comp ]
1156
<=
atom -> [ test_list_comp ]
1156
>>
atom -> [ test_list_comp ]
1156
*
atom -> [ test_list_comp ]
1156
^
atom -> [ test_list_comp ]
1156
.
atom -> [ test_list_comp ]
1156
(
atom -> [ test_list_comp ]
1156
>=
atom -> [ test_list_comp ]
1156
and
atom -> [ test_list_comp ]
1156
<
atom -> [ test_list_comp ]
1156
,
atom -> [ test_list_comp ]
1156
[
atom -> [ test_list_comp ]
1156
==
atom -> [ test_list_comp ]
1156
@
atom -> [ test_list_comp ]
1156
%
atom -> [ test_list_comp ]
1156
-
atom -> [ test_list_comp ]
1156
|
atom -> [ test_list_comp ]
1156
&
atom -> [ test_list_comp ]
1156
:
atom -> [ test_list_comp ]
1156
+
atom -> [ test_list_comp ]
1156
is
atom -> [ test_list_comp ]
1156
//
atom -> [ test_list_comp ]
1156
**
atom -> [ test_list_comp ]
1156
not
atom -> [ test_list_comp ]
1156
as
atom -> [ test_list_comp ]
1156
>
atom -> [ test_list_comp ]
1157
,
lambdef -> lambda : test
1157
as
lambdef -> lambda : test
1157
:
lambdef -> lambda : test
1158
factor
236
1158
term
237
1158
(
238
1158
arith_expr
239
1158
NAME
241
1158
False
242
1158
[
243
1158
~
244
1158
+
245
1158
lambda
246
1158
expr
247
1158
atom_expr
248
1158
shift_expr
249
1158
atom
250
1158
NUMBER
251
1158
STRING
252
1158
-
253
1158
True
254
1158
not_test
255
1158
and_expr
256
1158
xor_expr
257
1158
{
258
1158
test
1667
1158
or_test
259
1158
None
260
1158
comparison
261
1158
and_test
262
1158
lambdef
263
1158
power
264
1158
not
265
1159
and
comparison -> expr comp_op comparison
1159
:
comparison -> expr comp_op comparison
1159
if
comparison -> expr comp_op comparison
1159
as
comparison -> expr comp_op comparison
1159
or
comparison -> expr comp_op comparison
1159
,
comparison -> expr comp_op comparison
1160
+
power -> atom_expr ** factor
1160
&
power -> atom_expr ** factor
1160
>>
power -> atom_expr ** factor
1160
<<
power -> atom_expr ** factor
1160
not
power -> atom_expr ** factor
1160
is
power -> atom_expr ** factor
1160
@
power -> atom_expr ** factor
1160
:
power -> atom_expr ** factor
1160
==
power -> atom_expr ** factor
1160
*
power -> atom_expr ** factor
1160
or
power -> atom_expr ** factor
1160
>
power -> atom_expr ** factor
1160
-
power -> atom_expr ** factor
1160
if
power -> atom_expr ** factor
1160
!=
power -> atom_expr ** factor
1160
>=
power -> atom_expr ** factor
1160
/
power -> atom_expr ** factor
1160
%
power -> atom_expr ** factor
1160
and
power -> atom_expr ** factor
1160
<=
power -> atom_expr ** factor
1160
<
power -> atom_expr ** factor
1160
|
power -> atom_expr ** factor
1160
^
power -> atom_expr ** factor
1160
in
power -> atom_expr ** factor
1160
,
power -> atom_expr ** factor
1160
as
power -> atom_expr ** factor
1160
//
power -> atom_expr ** factor
1161
==
and_expr -> shift_expr & and_expr
1161
in
and_expr -> shift_expr & and_expr
1161
!=
and_expr -> shift_expr & and_expr
1161
,
and_expr -> shift_expr & and_expr
1161
or
and_expr -> shift_expr & and_expr
1161
>
and_expr -> shift_expr & and_expr
1161
not
and_expr -> shift_expr & and_expr
1161
:
and_expr -> shift_expr & and_expr
1161
|
and_expr -> shift_expr & and_expr
1161
<=
and_expr -> shift_expr & and_expr
1161
and
and_expr -> shift_expr & and_expr
1161
as
and_expr -> shift_expr & and_expr
1161
^
and_expr -> shift_expr & and_expr
1161
is
and_expr -> shift_expr & and_expr
1161
>=
and_expr -> shift_expr & and_expr
1161
<
and_expr -> shift_expr & and_expr
1161
if
and_expr -> shift_expr & and_expr
1162
+
trailer_expr -> trailer trailer_expr
1162
,
trailer_expr -> trailer trailer_expr
1162
*
trailer_expr -> trailer trailer_expr
1162
/
trailer_expr -> trailer trailer_expr
1162
not
trailer_expr -> trailer trailer_expr
1162
<<
trailer_expr -> trailer trailer_expr
1162
!=
trailer_expr -> trailer trailer_expr
1162
>=
trailer_expr -> trailer trailer_expr
1162
>>
trailer_expr -> trailer trailer_expr
1162
|
trailer_expr -> trailer trailer_expr
1162
%
trailer_expr -> trailer trailer_expr
1162
>
trailer_expr -> trailer trailer_expr
1162
&
trailer_expr -> trailer trailer_expr
1162
-
trailer_expr -> trailer trailer_expr
1162
<=
trailer_expr -> trailer trailer_expr
1162
:
trailer_expr -> trailer trailer_expr
1162
**
trailer_expr -> trailer trailer_expr
1162
@
trailer_expr -> trailer trailer_expr
1162
if
trailer_expr -> trailer trailer_expr
1162
==
trailer_expr -> trailer trailer_expr
1162
or
trailer_expr -> trailer trailer_expr
1162
<
trailer_expr -> trailer trailer_expr
1162
and
trailer_expr -> trailer trailer_expr
1162
in
trailer_expr -> trailer trailer_expr
1162
is
trailer_expr -> trailer trailer_expr
1162
^
trailer_expr -> trailer trailer_expr
1162
//
trailer_expr -> trailer trailer_expr
1162
as
trailer_expr -> trailer trailer_expr
1163
<=
trailer -> . NAME
1163
<<
trailer -> . NAME
1163
**
trailer -> . NAME
1163
!=
trailer -> . NAME
1163
:
trailer -> . NAME
1163
/
trailer -> . NAME
1163
&
trailer -> . NAME
1163
//
trailer -> . NAME
1163
<
trailer -> . NAME
1163
is
trailer -> . NAME
1163
-
trailer -> . NAME
1163
if
trailer -> . NAME
1163
as
trailer -> . NAME
1163
[
trailer -> . NAME
1163
or
trailer -> . NAME
1163
>
trailer -> . NAME
1163
*
trailer -> . NAME
1163
+
trailer -> . NAME
1163
%
trailer -> . NAME
1163
.
trailer -> . NAME
1163
>=
trailer -> . NAME
1163
|
trailer -> . NAME
1163
and
trailer -> . NAME
1163
(
trailer -> . NAME
1163
,
trailer -> . NAME
1163
==
trailer -> . NAME
1163
^
trailer -> . NAME
1163
in
trailer -> . NAME
1163
@
trailer -> . NAME
1163
not
trailer -> . NAME
1163
>>
trailer -> . NAME
1164
%
trailer -> ( )
1164
<=
trailer -> ( )
1164
and
trailer -> ( )
1164
//
trailer -> ( )
1164
not
trailer -> ( )
1164
as
trailer -> ( )
1164
or
trailer -> ( )
1164
>>
trailer -> ( )
1164
>
trailer -> ( )
1164
<<
trailer -> ( )
1164
[
trailer -> ( )
1164
is
trailer -> ( )
1164
:
trailer -> ( )
1164
-
trailer -> ( )
1164
**
trailer -> ( )
1164
/
trailer -> ( )
1164
,
trailer -> ( )
1164
+
trailer -> ( )
1164
&
trailer -> ( )
1164
in
trailer -> ( )
1164
^
trailer -> ( )
1164
!=
trailer -> ( )
1164
*
trailer -> ( )
1164
if
trailer -> ( )
1164
>=
trailer -> ( )
1164
(
trailer -> ( )
1164
@
trailer -> ( )
1164
==
trailer -> ( )
1164
|
trailer -> ( )
1164
.
trailer -> ( )
1164
<
trailer -> ( )
1165
)
1668
1166
]
1669
1167
,
and_test -> not_test and and_test
1167
as
and_test -> not_test and and_test
1167
:
and_test -> not_test and and_test
1167
if
and_test -> not_test and and_test
1167
or
and_test -> not_test and and_test
1168
<=
xor_expr -> and_expr ^ xor_expr
1168
!=
xor_expr -> and_expr ^ xor_expr
1168
and
xor_expr -> and_expr ^ xor_expr
1168
is
xor_expr -> and_expr ^ xor_expr
1168
>=
xor_expr -> and_expr ^ xor_expr
1168
not
xor_expr -> and_expr ^ xor_expr
1168
<
xor_expr -> and_expr ^ xor_expr
1168
:
xor_expr -> and_expr ^ xor_expr
1168
|
xor_expr -> and_expr ^ xor_expr
1168
in
xor_expr -> and_expr ^ xor_expr
1168
==
xor_expr -> and_expr ^ xor_expr
1168
or
xor_expr -> and_expr ^ xor_expr
1168
,
xor_expr -> and_expr ^ xor_expr
1168
if
xor_expr -> and_expr ^ xor_expr
1168
>
xor_expr -> and_expr ^ xor_expr
1168
as
xor_expr -> and_expr ^ xor_expr
1169
not
expr -> xor_expr | expr
1169
,
expr -> xor_expr | expr
1169
<
expr -> xor_expr | expr
1169
in
expr -> xor_expr | expr
1169
if
expr -> xor_expr | expr
1169
:
expr -> xor_expr | expr
1169
or
expr -> xor_expr | expr
1169
<=
expr -> xor_expr | expr
1169
>
expr -> xor_expr | expr
1169
!=
expr -> xor_expr | expr
1169
==
expr -> xor_expr | expr
1169
>=
expr -> xor_expr | expr
1169
is
expr -> xor_expr | expr
1169
as
expr -> xor_expr | expr
1169
and
expr -> xor_expr | expr
1170
else
1670
1171
as
or_test -> and_test or or_test
1171
,
or_test -> and_test or or_test
1171
if
or_test -> and_test or or_test
1171
:
or_test -> and_test or or_test
1172
<<
term -> factor
1172
//
1671
1172
/
1672
1172
|
term -> factor
1172
@
1673
1172
%
1674
1172
*
1675
1172
-
term -> factor
1172
:
term -> factor
1172
^
term -> factor
1172
,
term -> factor
1172
+
term -> factor
1172
&
term -> factor
1172
>>
term -> factor
1173
-
1676
1173
+
1677
1173
|
arith_expr -> term
1173
:
arith_expr -> term
1173
&
arith_expr -> term
1173
^
arith_expr -> term
1173
<<
arith_expr -> term
1173
,
arith_expr -> term
1173
>>
arith_expr -> term
1174
factor
268
1174
term
270
1174
(
271
1174
arith_expr
272
1174
NAME
273
1174
[
274
1174
+
275
1174
test_list_comp
1678
1174
atom_expr
277
1174
NUMBER
278
1174
atom
279
1174
STRING
280
1174
shift_expr
281
1174
-
282
1174
True
283
1174
not_test
284
1174
lambdef
285
1174
and_expr
286
1174
xor_expr
287
1174
False
288
1174
None
289
1174
expr
290
1174
and_test
291
1174
)
1679
1174
{
292
1174
~
293
1174
power
294
1174
lambda
295
1174
comparison
296
1174
or_test
297
1174
not
298
1174
test
299
1174
test_list
300
1175
.
atom -> True
1175
&
atom -> True
1175
**
atom -> True
1175
(
atom -> True
1175
%
atom -> True
1175
[
atom -> True
1175
>>
atom -> True
1175
<<
atom -> True
1175
//
atom -> True
1175
^
atom -> True
1175
-
atom -> True
1175
+
atom -> True
1175
|
atom -> True
1175
/
atom -> True
1175
@
atom -> True
1175
:
atom -> True
1175
*
atom -> True
1175
,
atom -> True
1176
(
1174
1176
True
1175
1176
[
1177
1176
~
1176
1176
+
1178
1176
STRING
1179
1176
atom_expr
1180
1176
NUMBER
1182
1176
NAME
1183
1176
False
1184
1176
{
1186
1176
factor
1680
1176
None
1187
1176
power
1188
1176
-
1189
1176
atom
1193
1177
factor
117
1177
or_test
118
1177
term
119
1177
(
120
1177
arith_expr
121
1177
NAME
122
1177
[
123
1177
+
125
1177
atom_expr
126
1177
NUMBER
127
1177
atom
128
1177
STRING
129
1177
shift_expr
130
1177
-
131
1177
]
1681
1177
True
133
1177
not_test
134
1177
lambdef
135
1177
and_expr
136
1177
xor_expr
137
1177
False
138
1177
None
139
1177
expr
140
1177
and_test
141
1177
test_list_comp
1682
1177
{
142
1177
~
143
1177
lambda
144
1177
power
145
1177
comparison
146
1177
test_list
147
1177
test
148
1177
not
149
1178
(
1174
1178
True
1175
1178
[
1177
1178
~
1176
1178
+
1178
1178
STRING
1179
1178
atom_expr
1180
1178
NUMBER
1182
1178
NAME
1183
1178
factor
1683
1178
False
1184
1178
{
1186
1178
None
1187
1178
power
1188
1178
-
1189
1178
atom
1193
1179
-
atom -> STRING
1179
^
atom -> STRING
1179
**
atom -> STRING
1179
+
atom -> STRING
1179
%
atom -> STRING
1179
<<
atom -> STRING
1179
//
atom -> STRING
1179
@
atom -> STRING
1179
(
atom -> STRING
1179
>>
atom -> STRING
1179
&
atom -> STRING
1179
[
atom -> STRING
1179
*
atom -> STRING
1179
,
atom -> STRING
1179
.
atom -> STRING
1179
|
atom -> STRING
1179
/
atom -> STRING
1179
:
atom -> STRING
1180
**
1684
1180
+
power -> atom_expr
1180
&
power -> atom_expr
1180
|
power -> atom_expr
1180
>>
power -> atom_expr
1180
^
power -> atom_expr
1180
:
power -> atom_expr
1180
%
power -> atom_expr
1180
<<
power -> atom_expr
1180
@
power -> atom_expr
1180
*
power -> atom_expr
1180
/
power -> atom_expr
1180
//
power -> atom_expr
1180
-
power -> atom_expr
1180
,
power -> atom_expr
1181
>>
1685
1181
,
shift_expr -> arith_expr
1181
&
shift_expr -> arith_expr
1181
<<
1686
1181
|
shift_expr -> arith_expr
1181
:
shift_expr -> arith_expr
1181
^
shift_expr -> arith_expr
1182
+
atom -> NUMBER
1182
%
atom -> NUMBER
1182
[
atom -> NUMBER
1182
,
atom -> NUMBER
1182
*
atom -> NUMBER
1182
-
atom -> NUMBER
1182
:
atom -> NUMBER
1182
.
atom -> NUMBER
1182
&
atom -> NUMBER
1182
>>
atom -> NUMBER
1182
^
atom -> NUMBER
1182
(
atom -> NUMBER
1182
@
atom -> NUMBER
1182
**
atom -> NUMBER
1182
<<
atom -> NUMBER
1182
|
atom -> NUMBER
1182
//
atom -> NUMBER
1182
/
atom -> NUMBER
1183
&
atom -> NAME
1183
[
atom -> NAME
1183
:
atom -> NAME
1183
**
atom -> NAME
1183
-
atom -> NAME
1183
.
atom -> NAME
1183
,
atom -> NAME
1183
>>
atom -> NAME
1183
//
atom -> NAME
1183
^
atom -> NAME
1183
|
atom -> NAME
1183
@
atom -> NAME
1183
(
atom -> NAME
1183
+
atom -> NAME
1183
*
atom -> NAME
1183
%
atom -> NAME
1183
/
atom -> NAME
1183
<<
atom -> NAME
1184
,
atom -> False
1184
:
atom -> False
1184
*
atom -> False
1184
@
atom -> False
1184
-
atom -> False
1184
^
atom -> False
1184
[
atom -> False
1184
%
atom -> False
1184
/
atom -> False
1184
+
atom -> False
1184
.
atom -> False
1184
|
atom -> False
1184
**
atom -> False
1184
>>
atom -> False
1184
&
atom -> False
1184
//
atom -> False
1184
<<
atom -> False
1184
(
atom -> False
1185
,
xor_expr -> and_expr
1185
^
1687
1185
|
xor_expr -> and_expr
1185
:
xor_expr -> and_expr
1186
}
1688
1187
%
atom -> None
1187
[
atom -> None
1187
*
atom -> None
1187
.
atom -> None
1187
//
atom -> None
1187
,
atom -> None
1187
@
atom -> None
1187
^
atom -> None
1187
**
atom -> None
1187
<<
atom -> None
1187
-
atom -> None
1187
>>
atom -> None
1187
(
atom -> None
1187
:
atom -> None
1187
&
atom -> None
1187
|
atom -> None
1187
+
atom -> None
1187
/
atom -> None
1188
&
factor -> power
1188
|
factor -> power
1188
+
factor -> power
1188
^
factor -> power
1188
@
factor -> power
1188
%
factor -> power
1188
>>
factor -> power
1188
<<
factor -> power
1188
-
factor -> power
1188
*
factor -> power
1188
//
factor -> power
1188
:
factor -> power
1188
/
factor -> power
1188
,
factor -> power
1189
(
1174
1189
True
1175
1189
[
1177
1189
~
1176
1189
+
1178
1189
factor
1689
1189
STRING
1179
1189
atom_expr
1180
1189
NUMBER
1182
1189
NAME
1183
1189
False
1184
1189
{
1186
1189
None
1187
1189
power
1188
1189
-
1189
1189
atom
1193
1190
&
1690
1190
^
and_expr -> shift_expr
1190
:
and_expr -> shift_expr
1190
,
and_expr -> shift_expr
1190
|
and_expr -> shift_expr
1191
:
with_item -> test as expr
1191
,
with_item -> test as expr
1192
,
expr -> xor_expr
1192
:
expr -> xor_expr
1192
|
1691
1193
trailer_expr
1692
1193
trailer
1693
1193
(
1694
1193
.
1695
1193
[
1696
1193
<<
trailer_expr -> 
1193
,
trailer_expr -> 
1193
+
trailer_expr -> 
1193
%
trailer_expr -> 
1193
&
trailer_expr -> 
1193
-
trailer_expr -> 
1193
^
trailer_expr -> 
1193
/
trailer_expr -> 
1193
>>
trailer_expr -> 
1193
//
trailer_expr -> 
1193
**
trailer_expr -> 
1193
@
trailer_expr -> 
1193
*
trailer_expr -> 
1193
|
trailer_expr -> 
1193
:
trailer_expr -> 
1194
:
with_items -> with_item , with_items
1195
and
term -> factor // term
1195
if
term -> factor // term
1195
>
term -> factor // term
1195
<
term -> factor // term
1195
for
term -> factor // term
1195
==
term -> factor // term
1195
+
term -> factor // term
1195
-
term -> factor // term
1195
&
term -> factor // term
1195
in
term -> factor // term
1195
!=
term -> factor // term
1195
^
term -> factor // term
1195
,
term -> factor // term
1195
)
term -> factor // term
1195
or
term -> factor // term
1195
<=
term -> factor // term
1195
>=
term -> factor // term
1195
|
term -> factor // term
1195
>>
term -> factor // term
1195
not
term -> factor // term
1195
is
term -> factor // term
1195
<<
term -> factor // term
1196
^
term -> factor * term
1196
+
term -> factor * term
1196
==
term -> factor * term
1196
>>
term -> factor * term
1196
in
term -> factor * term
1196
and
term -> factor * term
1196
if
term -> factor * term
1196
for
term -> factor * term
1196
is
term -> factor * term
1196
<<
term -> factor * term
1196
,
term -> factor * term
1196
-
term -> factor * term
1196
!=
term -> factor * term
1196
or
term -> factor * term
1196
>
term -> factor * term
1196
&
term -> factor * term
1196
)
term -> factor * term
1196
>=
term -> factor * term
1196
|
term -> factor * term
1196
<=
term -> factor * term
1196
not
term -> factor * term
1196
<
term -> factor * term
1197
&
term -> factor % term
1197
==
term -> factor % term
1197
!=
term -> factor % term
1197
)
term -> factor % term
1197
<
term -> factor % term
1197
in
term -> factor % term
1197
>>
term -> factor % term
1197
<<
term -> factor % term
1197
-
term -> factor % term
1197
if
term -> factor % term
1197
>
term -> factor % term
1197
or
term -> factor % term
1197
^
term -> factor % term
1197
+
term -> factor % term
1197
,
term -> factor % term
1197
is
term -> factor % term
1197
|
term -> factor % term
1197
>=
term -> factor % term
1197
<=
term -> factor % term
1197
and
term -> factor % term
1197
not
term -> factor % term
1197
for
term -> factor % term
1198
for
term -> factor @ term
1198
and
term -> factor @ term
1198
in
term -> factor @ term
1198
>=
term -> factor @ term
1198
<
term -> factor @ term
1198
,
term -> factor @ term
1198
>
term -> factor @ term
1198
-
term -> factor @ term
1198
or
term -> factor @ term
1198
)
term -> factor @ term
1198
<<
term -> factor @ term
1198
is
term -> factor @ term
1198
!=
term -> factor @ term
1198
|
term -> factor @ term
1198
&
term -> factor @ term
1198
==
term -> factor @ term
1198
>>
term -> factor @ term
1198
<=
term -> factor @ term
1198
not
term -> factor @ term
1198
+
term -> factor @ term
1198
^
term -> factor @ term
1198
if
term -> factor @ term
1199
or
term -> factor / term
1199
<<
term -> factor / term
1199
not
term -> factor / term
1199
in
term -> factor / term
1199
!=
term -> factor / term
1199
<
term -> factor / term
1199
,
term -> factor / term
1199
+
term -> factor / term
1199
and
term -> factor / term
1199
>>
term -> factor / term
1199
^
term -> factor / term
1199
<=
term -> factor / term
1199
==
term -> factor / term
1199
>
term -> factor / term
1199
&
term -> factor / term
1199
is
term -> factor / term
1199
-
term -> factor / term
1199
for
term -> factor / term
1199
)
term -> factor / term
1199
|
term -> factor / term
1199
>=
term -> factor / term
1199
if
term -> factor / term
1200
for
arith_expr -> term + arith_expr
1200
==
arith_expr -> term + arith_expr
1200
!=
arith_expr -> term + arith_expr
1200
<<
arith_expr -> term + arith_expr
1200
&
arith_expr -> term + arith_expr
1200
<
arith_expr -> term + arith_expr
1200
^
arith_expr -> term + arith_expr
1200
,
arith_expr -> term + arith_expr
1200
>=
arith_expr -> term + arith_expr
1200
in
arith_expr -> term + arith_expr
1200
)
arith_expr -> term + arith_expr
1200
>>
arith_expr -> term + arith_expr
1200
not
arith_expr -> term + arith_expr
1200
<=
arith_expr -> term + arith_expr
1200
is
arith_expr -> term + arith_expr
1200
|
arith_expr -> term + arith_expr
1200
and
arith_expr -> term + arith_expr
1200
or
arith_expr -> term + arith_expr
1200
if
arith_expr -> term + arith_expr
1200
>
arith_expr -> term + arith_expr
1201
if
arith_expr -> term - arith_expr
1201
&
arith_expr -> term - arith_expr
1201
>>
arith_expr -> term - arith_expr
1201
!=
arith_expr -> term - arith_expr
1201
)
arith_expr -> term - arith_expr
1201
>=
arith_expr -> term - arith_expr
1201
|
arith_expr -> term - arith_expr
1201
>
arith_expr -> term - arith_expr
1201
for
arith_expr -> term - arith_expr
1201
<
arith_expr -> term - arith_expr
1201
==
arith_expr -> term - arith_expr
1201
,
arith_expr -> term - arith_expr
1201
and
arith_expr -> term - arith_expr
1201
is
arith_expr -> term - arith_expr
1201
in
arith_expr -> term - arith_expr
1201
^
arith_expr -> term - arith_expr
1201
<<
arith_expr -> term - arith_expr
1201
not
arith_expr -> term - arith_expr
1201
or
arith_expr -> term - arith_expr
1201
<=
arith_expr -> term - arith_expr
1202
+
atom -> ( test_list_comp )
1202
/
atom -> ( test_list_comp )
1202
*
atom -> ( test_list_comp )
1202
[
atom -> ( test_list_comp )
1202
&
atom -> ( test_list_comp )
1202
,
atom -> ( test_list_comp )
1202
**
atom -> ( test_list_comp )
1202
^
atom -> ( test_list_comp )
1202
(
atom -> ( test_list_comp )
1202
and
atom -> ( test_list_comp )
1202
)
atom -> ( test_list_comp )
1202
>
atom -> ( test_list_comp )
1202
-
atom -> ( test_list_comp )
1202
%
atom -> ( test_list_comp )
1202
//
atom -> ( test_list_comp )
1202
in
atom -> ( test_list_comp )
1202
>>
atom -> ( test_list_comp )
1202
for
atom -> ( test_list_comp )
1202
not
atom -> ( test_list_comp )
1202
>=
atom -> ( test_list_comp )
1202
or
atom -> ( test_list_comp )
1202
<
atom -> ( test_list_comp )
1202
if
atom -> ( test_list_comp )
1202
|
atom -> ( test_list_comp )
1202
<<
atom -> ( test_list_comp )
1202
@
atom -> ( test_list_comp )
1202
!=
atom -> ( test_list_comp )
1202
is
atom -> ( test_list_comp )
1202
.
atom -> ( test_list_comp )
1202
<=
atom -> ( test_list_comp )
1202
==
atom -> ( test_list_comp )
1203
>=
shift_expr -> arith_expr >> shift_expr
1203
,
shift_expr -> arith_expr >> shift_expr
1203
if
shift_expr -> arith_expr >> shift_expr
1203
<=
shift_expr -> arith_expr >> shift_expr
1203
!=
shift_expr -> arith_expr >> shift_expr
1203
or
shift_expr -> arith_expr >> shift_expr
1203
|
shift_expr -> arith_expr >> shift_expr
1203
is
shift_expr -> arith_expr >> shift_expr
1203
)
shift_expr -> arith_expr >> shift_expr
1203
and
shift_expr -> arith_expr >> shift_expr
1203
in
shift_expr -> arith_expr >> shift_expr
1203
^
shift_expr -> arith_expr >> shift_expr
1203
not
shift_expr -> arith_expr >> shift_expr
1203
<
shift_expr -> arith_expr >> shift_expr
1203
==
shift_expr -> arith_expr >> shift_expr
1203
for
shift_expr -> arith_expr >> shift_expr
1203
&
shift_expr -> arith_expr >> shift_expr
1203
>
shift_expr -> arith_expr >> shift_expr
1204
>
shift_expr -> arith_expr << shift_expr
1204
or
shift_expr -> arith_expr << shift_expr
1204
^
shift_expr -> arith_expr << shift_expr
1204
for
shift_expr -> arith_expr << shift_expr
1204
not
shift_expr -> arith_expr << shift_expr
1204
<
shift_expr -> arith_expr << shift_expr
1204
if
shift_expr -> arith_expr << shift_expr
1204
in
shift_expr -> arith_expr << shift_expr
1204
!=
shift_expr -> arith_expr << shift_expr
1204
,
shift_expr -> arith_expr << shift_expr
1204
|
shift_expr -> arith_expr << shift_expr
1204
>=
shift_expr -> arith_expr << shift_expr
1204
)
shift_expr -> arith_expr << shift_expr
1204
and
shift_expr -> arith_expr << shift_expr
1204
==
shift_expr -> arith_expr << shift_expr
1204
&
shift_expr -> arith_expr << shift_expr
1204
<=
shift_expr -> arith_expr << shift_expr
1204
is
shift_expr -> arith_expr << shift_expr
1205
in
atom -> [ test_list_comp ]
1205
/
atom -> [ test_list_comp ]
1205
or
atom -> [ test_list_comp ]
1205
if
atom -> [ test_list_comp ]
1205
<<
atom -> [ test_list_comp ]
1205
!=
atom -> [ test_list_comp ]
1205
<=
atom -> [ test_list_comp ]
1205
)
atom -> [ test_list_comp ]
1205
>>
atom -> [ test_list_comp ]
1205
*
atom -> [ test_list_comp ]
1205
^
atom -> [ test_list_comp ]
1205
.
atom -> [ test_list_comp ]
1205
(
atom -> [ test_list_comp ]
1205
>=
atom -> [ test_list_comp ]
1205
and
atom -> [ test_list_comp ]
1205
<
atom -> [ test_list_comp ]
1205
,
atom -> [ test_list_comp ]
1205
[
atom -> [ test_list_comp ]
1205
==
atom -> [ test_list_comp ]
1205
@
atom -> [ test_list_comp ]
1205
%
atom -> [ test_list_comp ]
1205
-
atom -> [ test_list_comp ]
1205
|
atom -> [ test_list_comp ]
1205
&
atom -> [ test_list_comp ]
1205
+
atom -> [ test_list_comp ]
1205
for
atom -> [ test_list_comp ]
1205
is
atom -> [ test_list_comp ]
1205
//
atom -> [ test_list_comp ]
1205
**
atom -> [ test_list_comp ]
1205
not
atom -> [ test_list_comp ]
1205
>
atom -> [ test_list_comp ]
1206
+
power -> atom_expr ** factor
1206
&
power -> atom_expr ** factor
1206
>>
power -> atom_expr ** factor
1206
<<
power -> atom_expr ** factor
1206
not
power -> atom_expr ** factor
1206
is
power -> atom_expr ** factor
1206
@
power -> atom_expr ** factor
1206
==
power -> atom_expr ** factor
1206
*
power -> atom_expr ** factor
1206
or
power -> atom_expr ** factor
1206
>
power -> atom_expr ** factor
1206
-
power -> atom_expr ** factor
1206
)
power -> atom_expr ** factor
1206
if
power -> atom_expr ** factor
1206
!=
power -> atom_expr ** factor
1206
>=
power -> atom_expr ** factor
1206
for
power -> atom_expr ** factor
1206
/
power -> atom_expr ** factor
1206
%
power -> atom_expr ** factor
1206
and
power -> atom_expr ** factor
1206
<=
power -> atom_expr ** factor
1206
<
power -> atom_expr ** factor
1206
|
power -> atom_expr ** factor
1206
^
power -> atom_expr ** factor
1206
in
power -> atom_expr ** factor
1206
,
power -> atom_expr ** factor
1206
//
power -> atom_expr ** factor
1207
+
trailer_expr -> trailer trailer_expr
1207
,
trailer_expr -> trailer trailer_expr
1207
*
trailer_expr -> trailer trailer_expr
1207
for
trailer_expr -> trailer trailer_expr
1207
/
trailer_expr -> trailer trailer_expr
1207
not
trailer_expr -> trailer trailer_expr
1207
<<
trailer_expr -> trailer trailer_expr
1207
!=
trailer_expr -> trailer trailer_expr
1207
>=
trailer_expr -> trailer trailer_expr
1207
)
trailer_expr -> trailer trailer_expr
1207
>>
trailer_expr -> trailer trailer_expr
1207
|
trailer_expr -> trailer trailer_expr
1207
%
trailer_expr -> trailer trailer_expr
1207
>
trailer_expr -> trailer trailer_expr
1207
&
trailer_expr -> trailer trailer_expr
1207
-
trailer_expr -> trailer trailer_expr
1207
<=
trailer_expr -> trailer trailer_expr
1207
**
trailer_expr -> trailer trailer_expr
1207
@
trailer_expr -> trailer trailer_expr
1207
if
trailer_expr -> trailer trailer_expr
1207
==
trailer_expr -> trailer trailer_expr
1207
or
trailer_expr -> trailer trailer_expr
1207
<
trailer_expr -> trailer trailer_expr
1207
and
trailer_expr -> trailer trailer_expr
1207
in
trailer_expr -> trailer trailer_expr
1207
is
trailer_expr -> trailer trailer_expr
1207
^
trailer_expr -> trailer trailer_expr
1207
//
trailer_expr -> trailer trailer_expr
1208
<=
trailer -> . NAME
1208
<<
trailer -> . NAME
1208
**
trailer -> . NAME
1208
!=
trailer -> . NAME
1208
/
trailer -> . NAME
1208
&
trailer -> . NAME
1208
//
trailer -> . NAME
1208
<
trailer -> . NAME
1208
is
trailer -> . NAME
1208
-
trailer -> . NAME
1208
if
trailer -> . NAME
1208
[
trailer -> . NAME
1208
or
trailer -> . NAME
1208
>
trailer -> . NAME
1208
*
trailer -> . NAME
1208
+
trailer -> . NAME
1208
for
trailer -> . NAME
1208
)
trailer -> . NAME
1208
%
trailer -> . NAME
1208
.
trailer -> . NAME
1208
>=
trailer -> . NAME
1208
|
trailer -> . NAME
1208
and
trailer -> . NAME
1208
(
trailer -> . NAME
1208
,
trailer -> . NAME
1208
==
trailer -> . NAME
1208
^
trailer -> . NAME
1208
in
trailer -> . NAME
1208
@
trailer -> . NAME
1208
not
trailer -> . NAME
1208
>>
trailer -> . NAME
1209
%
trailer -> ( )
1209
<=
trailer -> ( )
1209
and
trailer -> ( )
1209
//
trailer -> ( )
1209
not
trailer -> ( )
1209
or
trailer -> ( )
1209
for
trailer -> ( )
1209
>>
trailer -> ( )
1209
>
trailer -> ( )
1209
<<
trailer -> ( )
1209
[
trailer -> ( )
1209
is
trailer -> ( )
1209
-
trailer -> ( )
1209
**
trailer -> ( )
1209
/
trailer -> ( )
1209
,
trailer -> ( )
1209
+
trailer -> ( )
1209
&
trailer -> ( )
1209
in
trailer -> ( )
1209
^
trailer -> ( )
1209
!=
trailer -> ( )
1209
*
trailer -> ( )
1209
if
trailer -> ( )
1209
>=
trailer -> ( )
1209
(
trailer -> ( )
1209
@
trailer -> ( )
1209
)
trailer -> ( )
1209
==
trailer -> ( )
1209
|
trailer -> ( )
1209
.
trailer -> ( )
1209
<
trailer -> ( )
1210
)
1697
1211
]
1698
1212
==
and_expr -> shift_expr & and_expr
1212
in
and_expr -> shift_expr & and_expr
1212
!=
and_expr -> shift_expr & and_expr
1212
,
and_expr -> shift_expr & and_expr
1212
or
and_expr -> shift_expr & and_expr
1212
>
and_expr -> shift_expr & and_expr
1212
not
and_expr -> shift_expr & and_expr
1212
<=
and_expr -> shift_expr & and_expr
1212
|
and_expr -> shift_expr & and_expr
1212
and
and_expr -> shift_expr & and_expr
1212
for
and_expr -> shift_expr & and_expr
1212
)
and_expr -> shift_expr & and_expr
1212
^
and_expr -> shift_expr & and_expr
1212
is
and_expr -> shift_expr & and_expr
1212
>=
and_expr -> shift_expr & and_expr
1212
<
and_expr -> shift_expr & and_expr
1212
if
and_expr -> shift_expr & and_expr
1213
,
and_test -> not_test and and_test
1213
for
and_test -> not_test and and_test
1213
or
and_test -> not_test and and_test
1213
if
and_test -> not_test and and_test
1213
)
and_test -> not_test and and_test
1214
<=
xor_expr -> and_expr ^ xor_expr
1214
!=
xor_expr -> and_expr ^ xor_expr
1214
for
xor_expr -> and_expr ^ xor_expr
1214
and
xor_expr -> and_expr ^ xor_expr
1214
)
xor_expr -> and_expr ^ xor_expr
1214
is
xor_expr -> and_expr ^ xor_expr
1214
>=
xor_expr -> and_expr ^ xor_expr
1214
not
xor_expr -> and_expr ^ xor_expr
1214
<
xor_expr -> and_expr ^ xor_expr
1214
|
xor_expr -> and_expr ^ xor_expr
1214
in
xor_expr -> and_expr ^ xor_expr
1214
==
xor_expr -> and_expr ^ xor_expr
1214
or
xor_expr -> and_expr ^ xor_expr
1214
,
xor_expr -> and_expr ^ xor_expr
1214
if
xor_expr -> and_expr ^ xor_expr
1214
>
xor_expr -> and_expr ^ xor_expr
1215
)
expr -> xor_expr | expr
1215
not
expr -> xor_expr | expr
1215
,
expr -> xor_expr | expr
1215
for
expr -> xor_expr | expr
1215
in
expr -> xor_expr | expr
1215
if
expr -> xor_expr | expr
1215
or
expr -> xor_expr | expr
1215
<=
expr -> xor_expr | expr
1215
>
expr -> xor_expr | expr
1215
!=
expr -> xor_expr | expr
1215
==
expr -> xor_expr | expr
1215
>=
expr -> xor_expr | expr
1215
is
expr -> xor_expr | expr
1215
<
expr -> xor_expr | expr
1215
and
expr -> xor_expr | expr
1216
)
comparison -> expr comp_op comparison
1216
and
comparison -> expr comp_op comparison
1216
if
comparison -> expr comp_op comparison
1216
for
comparison -> expr comp_op comparison
1216
or
comparison -> expr comp_op comparison
1216
,
comparison -> expr comp_op comparison
1217
,
or_test -> and_test or or_test
1217
for
or_test -> and_test or or_test
1217
if
or_test -> and_test or or_test
1217
)
or_test -> and_test or or_test
1218
,
lambdef -> lambda : test
1218
for
lambdef -> lambda : test
1218
)
lambdef -> lambda : test
1219
factor
268
1219
term
270
1219
(
271
1219
arith_expr
272
1219
NAME
273
1219
[
274
1219
+
275
1219
atom_expr
277
1219
NUMBER
278
1219
atom
279
1219
STRING
280
1219
shift_expr
281
1219
-
282
1219
True
283
1219
not_test
284
1219
lambdef
285
1219
and_expr
286
1219
xor_expr
287
1219
False
288
1219
None
289
1219
expr
290
1219
and_test
291
1219
{
292
1219
~
293
1219
power
294
1219
test
1699
1219
lambda
295
1219
comparison
296
1219
or_test
297
1219
not
298
1220
else
1700
1221
//
1701
1221
in
term -> factor
1221
-
term -> factor
1221
*
1702
1221
%
1703
1221
@
1704
1221
>=
term -> factor
1221
/
1705
1221
<
term -> factor
1221
<=
term -> factor
1221
==
term -> factor
1221
!=
term -> factor
1221
>>
term -> factor
1221
is
term -> factor
1221
or
term -> factor
1221
and
term -> factor
1221
^
term -> factor
1221
,
term -> factor
1221
+
term -> factor
1221
&
term -> factor
1221
<<
term -> factor
1221
|
term -> factor
1221
)
term -> factor
1221
>
term -> factor
1221
if
term -> factor
1221
not
term -> factor
1222
+
1706
1222
-
1707
1222
|
arith_expr -> term
1222
)
arith_expr -> term
1222
or
arith_expr -> term
1222
not
arith_expr -> term
1222
<=
arith_expr -> term
1222
!=
arith_expr -> term
1222
<
arith_expr -> term
1222
&
arith_expr -> term
1222
>=
arith_expr -> term
1222
if
arith_expr -> term
1222
==
arith_expr -> term
1222
^
arith_expr -> term
1222
in
arith_expr -> term
1222
is
arith_expr -> term
1222
<<
arith_expr -> term
1222
,
arith_expr -> term
1222
>
arith_expr -> term
1222
and
arith_expr -> term
1222
>>
arith_expr -> term
1223
factor
268
1223
term
270
1223
(
271
1223
arith_expr
272
1223
NAME
273
1223
[
274
1223
+
275
1223
test_list_comp
1708
1223
atom_expr
277
1223
NUMBER
278
1223
atom
279
1223
STRING
280
1223
shift_expr
281
1223
-
282
1223
True
283
1223
not_test
284
1223
lambdef
285
1223
and_expr
286
1223
xor_expr
287
1223
False
288
1223
None
289
1223
expr
290
1223
and_test
291
1223
)
1709
1223
{
292
1223
~
293
1223
power
294
1223
lambda
295
1223
comparison
296
1223
or_test
297
1223
not
298
1223
test
299
1223
test_list
300
1224
>>
1710
1224
<<
1711
1224
&
shift_expr -> arith_expr
1224
<=
shift_expr -> arith_expr
1224
>
shift_expr -> arith_expr
1224
)
shift_expr -> arith_expr
1224
not
shift_expr -> arith_expr
1224
!=
shift_expr -> arith_expr
1224
^
shift_expr -> arith_expr
1224
is
shift_expr -> arith_expr
1224
|
shift_expr -> arith_expr
1224
>=
shift_expr -> arith_expr
1224
or
shift_expr -> arith_expr
1224
,
shift_expr -> arith_expr
1224
==
shift_expr -> arith_expr
1224
if
shift_expr -> arith_expr
1224
and
shift_expr -> arith_expr
1224
<
shift_expr -> arith_expr
1224
in
shift_expr -> arith_expr
1225
-
atom -> NAME
1225
,
atom -> NAME
1225
or
atom -> NAME
1225
>>
atom -> NAME
1225
&
atom -> NAME
1225
[
atom -> NAME
1225
<=
atom -> NAME
1225
<
atom -> NAME
1225
.
atom -> NAME
1225
|
atom -> NAME
1225
*
atom -> NAME
1225
/
atom -> NAME
1225
<<
atom -> NAME
1225
not
atom -> NAME
1225
>
atom -> NAME
1225
is
atom -> NAME
1225
//
atom -> NAME
1225
+
atom -> NAME
1225
if
atom -> NAME
1225
in
atom -> NAME
1225
**
atom -> NAME
1225
!=
atom -> NAME
1225
>=
atom -> NAME
1225
)
atom -> NAME
1225
^
atom -> NAME
1225
@
atom -> NAME
1225
(
atom -> NAME
1225
==
atom -> NAME
1225
and
atom -> NAME
1225
%
atom -> NAME
1226
factor
117
1226
or_test
118
1226
term
119
1226
(
120
1226
test_list_comp
1712
1226
arith_expr
121
1226
NAME
122
1226
[
123
1226
]
1713
1226
+
125
1226
atom_expr
126
1226
NUMBER
127
1226
atom
128
1226
STRING
129
1226
shift_expr
130
1226
-
131
1226
True
133
1226
not_test
134
1226
lambdef
135
1226
and_expr
136
1226
xor_expr
137
1226
False
138
1226
None
139
1226
expr
140
1226
and_test
141
1226
{
142
1226
~
143
1226
lambda
144
1226
power
145
1226
comparison
146
1226
test_list
147
1226
test
148
1226
not
149
1227
(
1223
1227
NAME
1225
1227
[
1226
1227
+
1227
1227
atom_expr
1228
1227
NUMBER
1229
1227
atom
1230
1227
STRING
1231
1227
-
1233
1227
factor
1714
1227
True
1234
1227
None
1238
1227
False
1239
1227
{
1241
1227
~
1242
1227
power
1243
1228
!=
power -> atom_expr
1228
**
1715
1228
>
power -> atom_expr
1228
+
power -> atom_expr
1228
not
power -> atom_expr
1228
&
power -> atom_expr
1228
|
power -> atom_expr
1228
>>
power -> atom_expr
1228
^
power -> atom_expr
1228
==
power -> atom_expr
1228
if
power -> atom_expr
1228
in
power -> atom_expr
1228
%
power -> atom_expr
1228
<<
power -> atom_expr
1228
or
power -> atom_expr
1228
@
power -> atom_expr
1228
*
power -> atom_expr
1228
/
power -> atom_expr
1228
)
power -> atom_expr
1228
<
power -> atom_expr
1228
//
power -> atom_expr
1228
>=
power -> atom_expr
1228
-
power -> atom_expr
1228
is
power -> atom_expr
1228
<=
power -> atom_expr
1228
and
power -> atom_expr
1228
,
power -> atom_expr
1229
[
atom -> NUMBER
1229
>=
atom -> NUMBER
1229
<=
atom -> NUMBER
1229
!=
atom -> NUMBER
1229
//
atom -> NUMBER
1229
in
atom -> NUMBER
1229
/
atom -> NUMBER
1229
or
atom -> NUMBER
1229
>
atom -> NUMBER
1229
,
atom -> NUMBER
1229
not
atom -> NUMBER
1229
>>
atom -> NUMBER
1229
(
atom -> NUMBER
1229
**
atom -> NUMBER
1229
<<
atom -> NUMBER
1229
and
atom -> NUMBER
1229
+
atom -> NUMBER
1229
%
atom -> NUMBER
1229
)
atom -> NUMBER
1229
==
atom -> NUMBER
1229
if
atom -> NUMBER
1229
is
atom -> NUMBER
1229
*
atom -> NUMBER
1229
@
atom -> NUMBER
1229
|
atom -> NUMBER
1229
-
atom -> NUMBER
1229
.
atom -> NUMBER
1229
^
atom -> NUMBER
1229
<
atom -> NUMBER
1229
&
atom -> NUMBER
1230
trailer
1716
1230
.
1717
1230
(
1718
1230
[
1719
1230
trailer_expr
1720
1230
<<
trailer_expr -> 
1230
%
trailer_expr -> 
1230
==
trailer_expr -> 
1230
-
trailer_expr -> 
1230
<
trailer_expr -> 
1230
if
trailer_expr -> 
1230
or
trailer_expr -> 
1230
/
trailer_expr -> 
1230
**
trailer_expr -> 
1230
and
trailer_expr -> 
1230
@
trailer_expr -> 
1230
*
trailer_expr -> 
1230
|
trailer_expr -> 
1230
is
trailer_expr -> 
1230
,
trailer_expr -> 
1230
+
trailer_expr -> 
1230
in
trailer_expr -> 
1230
&
trailer_expr -> 
1230
<=
trailer_expr -> 
1230
>=
trailer_expr -> 
1230
^
trailer_expr -> 
1230
>
trailer_expr -> 
1230
!=
trailer_expr -> 
1230
)
trailer_expr -> 
1230
not
trailer_expr -> 
1230
>>
trailer_expr -> 
1230
//
trailer_expr -> 
1231
and
atom -> STRING
1231
%
atom -> STRING
1231
//
atom -> STRING
1231
>>
atom -> STRING
1231
*
atom -> STRING
1231
<
atom -> STRING
1231
.
atom -> STRING
1231
in
atom -> STRING
1231
^
atom -> STRING
1231
(
atom -> STRING
1231
if
atom -> STRING
1231
==
atom -> STRING
1231
-
atom -> STRING
1231
**
atom -> STRING
1231
<<
atom -> STRING
1231
<=
atom -> STRING
1231
[
atom -> STRING
1231
not
atom -> STRING
1231
or
atom -> STRING
1231
)
atom -> STRING
1231
+
atom -> STRING
1231
>=
atom -> STRING
1231
@
atom -> STRING
1231
&
atom -> STRING
1231
>
atom -> STRING
1231
is
atom -> STRING
1231
,
atom -> STRING
1231
|
atom -> STRING
1231
!=
atom -> STRING
1231
/
atom -> STRING
1232
&
1721
1232
^
and_expr -> shift_expr
1232
|
and_expr -> shift_expr
1232
<=
and_expr -> shift_expr
1232
)
and_expr -> shift_expr
1232
or
and_expr -> shift_expr
1232
>
and_expr -> shift_expr
1232
not
and_expr -> shift_expr
1232
,
and_expr -> shift_expr
1232
!=
and_expr -> shift_expr
1232
and
and_expr -> shift_expr
1232
is
and_expr -> shift_expr
1232
<
and_expr -> shift_expr
1232
if
and_expr -> shift_expr
1232
in
and_expr -> shift_expr
1232
>=
and_expr -> shift_expr
1232
==
and_expr -> shift_expr
1233
(
1223
1233
NAME
1225
1233
[
1226
1233
+
1227
1233
atom_expr
1228
1233
NUMBER
1229
1233
atom
1230
1233
STRING
1231
1233
-
1233
1233
True
1234
1233
None
1238
1233
False
1239
1233
{
1241
1233
~
1242
1233
power
1243
1233
factor
1722
1234
(
atom -> True
1234
[
atom -> True
1234
+
atom -> True
1234
@
atom -> True
1234
<=
atom -> True
1234
&
atom -> True
1234
<<
atom -> True
1234
-
atom -> True
1234
/
atom -> True
1234
)
atom -> True
1234
or
atom -> True
1234
>
atom -> True
1234
%
atom -> True
1234
^
atom -> True
1234
if
atom -> True
1234
!=
atom -> True
1234
is
atom -> True
1234
*
atom -> True
1234
<
atom -> True
1234
,
atom -> True
1234
and
atom -> True
1234
.
atom -> True
1234
==
atom -> True
1234
**
atom -> True
1234
>>
atom -> True
1234
in
atom -> True
1234
|
atom -> True
1234
>=
atom -> True
1234
//
atom -> True
1234
not
atom -> True
1235
and
1723
1235
or
and_test -> not_test
1235
)
and_test -> not_test
1235
,
and_test -> not_test
1235
if
and_test -> not_test
1236
^
1724
1236
not
xor_expr -> and_expr
1236
if
xor_expr -> and_expr
1236
<=
xor_expr -> and_expr
1236
,
xor_expr -> and_expr
1236
>
xor_expr -> and_expr
1236
<
xor_expr -> and_expr
1236
in
xor_expr -> and_expr
1236
>=
xor_expr -> and_expr
1236
==
xor_expr -> and_expr
1236
|
xor_expr -> and_expr
1236
is
xor_expr -> and_expr
1236
and
xor_expr -> and_expr
1236
or
xor_expr -> and_expr
1236
)
xor_expr -> and_expr
1236
!=
xor_expr -> and_expr
1237
|
1725
1237
>=
expr -> xor_expr
1237
,
expr -> xor_expr
1237
==
expr -> xor_expr
1237
)
expr -> xor_expr
1237
is
expr -> xor_expr
1237
if
expr -> xor_expr
1237
or
expr -> xor_expr
1237
>
expr -> xor_expr
1237
and
expr -> xor_expr
1237
<
expr -> xor_expr
1237
in
expr -> xor_expr
1237
<=
expr -> xor_expr
1237
not
expr -> xor_expr
1237
!=
expr -> xor_expr
1238
is
atom -> None
1238
.
atom -> None
1238
==
atom -> None
1238
^
atom -> None
1238
<<
atom -> None
1238
>>
atom -> None
1238
(
atom -> None
1238
|
atom -> None
1238
+
atom -> None
1238
*
atom -> None
1238
//
atom -> None
1238
@
atom -> None
1238
in
atom -> None
1238
>=
atom -> None
1238
!=
atom -> None
1238
%
atom -> None
1238
[
atom -> None
1238
and
atom -> None
1238
-
atom -> None
1238
)
atom -> None
1238
if
atom -> None
1238
&
atom -> None
1238
<=
atom -> None
1238
<
atom -> None
1238
>
atom -> None
1238
,
atom -> None
1238
**
atom -> None
1238
or
atom -> None
1238
/
atom -> None
1238
not
atom -> None
1239
in
atom -> False
1239
>
atom -> False
1239
-
atom -> False
1239
%
atom -> False
1239
<
atom -> False
1239
|
atom -> False
1239
==
atom -> False
1239
&
atom -> False
1239
//
atom -> False
1239
and
atom -> False
1239
not
atom -> False
1239
+
atom -> False
1239
!=
atom -> False
1239
if
atom -> False
1239
)
atom -> False
1239
@
atom -> False
1239
[
atom -> False
1239
or
atom -> False
1239
<=
atom -> False
1239
*
atom -> False
1239
^
atom -> False
1239
is
atom -> False
1239
/
atom -> False
1239
.
atom -> False
1239
>=
atom -> False
1239
**
atom -> False
1239
>>
atom -> False
1239
,
atom -> False
1239
<<
atom -> False
1239
(
atom -> False
1240
,
or_test -> and_test
1240
or
1726
1240
)
or_test -> and_test
1240
if
or_test -> and_test
1241
}
1727
1242
(
1223
1242
NAME
1225
1242
[
1226
1242
+
1227
1242
factor
1728
1242
atom_expr
1228
1242
NUMBER
1229
1242
atom
1230
1242
STRING
1231
1242
-
1233
1242
True
1234
1242
None
1238
1242
False
1239
1242
{
1241
1242
~
1242
1242
power
1243
1243
&
factor -> power
1243
%
factor -> power
1243
<<
factor -> power
1243
-
factor -> power
1243
<=
factor -> power
1243
not
factor -> power
1243
//
factor -> power
1243
/
factor -> power
1243
is
factor -> power
1243
|
factor -> power
1243
<
factor -> power
1243
and
factor -> power
1243
>=
factor -> power
1243
>>
factor -> power
1243
>
factor -> power
1243
)
factor -> power
1243
in
factor -> power
1243
if
factor -> power
1243
^
factor -> power
1243
==
factor -> power
1243
+
factor -> power
1243
,
factor -> power
1243
@
factor -> power
1243
or
factor -> power
1243
*
factor -> power
1243
!=
factor -> power
1244
is
215
1244
<
217
1244
!=
218
1244
in
219
1244
<=
220
1244
not
221
1244
>=
222
1244
>
223
1244
==
224
1244
comp_op
1729
1244
and
comparison -> expr
1244
or
comparison -> expr
1244
if
comparison -> expr
1244
,
comparison -> expr
1244
)
comparison -> expr
1245
NAME
305
1245
varargslist
1730
1245
vfpdef
306
1245
:
1731
1246
or
not_test -> comparison
1246
and
not_test -> comparison
1246
,
not_test -> comparison
1246
if
not_test -> comparison
1246
)
not_test -> comparison
1247
)
test -> or_test
1247
if
1732
1247
,
test -> or_test
1248
)
test_list -> test , test_list
1249
factor
1221
1249
term
1222
1249
(
1223
1249
arith_expr
1224
1249
NAME
1225
1249
[
1226
1249
+
1227
1249
atom_expr
1228
1249
NUMBER
1229
1249
atom
1230
1249
STRING
1231
1249
shift_expr
1232
1249
-
1233
1249
not_test
1733
1249
True
1234
1249
and_expr
1236
1249
xor_expr
1237
1249
None
1238
1249
False
1239
1249
{
1241
1249
~
1242
1249
power
1243
1249
expr
1244
1249
comparison
1246
1249
not
1249
1250
)
test_list -> test
1250
,
685
1251
,
test -> lambdef
1251
)
test -> lambdef
1252
in
1734
1253
INDENT
1735
1254
)
1736
1255
@=
lambdef -> lambda varargslist : test
1255
,
lambdef -> lambda varargslist : test
1255
<<=
lambdef -> lambda varargslist : test
1255
%=
lambdef -> lambda varargslist : test
1255
/=
lambdef -> lambda varargslist : test
1255
NEWLINE
lambdef -> lambda varargslist : test
1255
|=
lambdef -> lambda varargslist : test
1255
//=
lambdef -> lambda varargslist : test
1255
^=
lambdef -> lambda varargslist : test
1255
&=
lambdef -> lambda varargslist : test
1255
**=
lambdef -> lambda varargslist : test
1255
:
lambdef -> lambda varargslist : test
1255
+=
lambdef -> lambda varargslist : test
1255
>>=
lambdef -> lambda varargslist : test
1255
=
lambdef -> lambda varargslist : test
1255
*=
lambdef -> lambda varargslist : test
1255
-=
lambdef -> lambda varargslist : test
1256
:
varargslist -> vfpdef , varargslist
1257
else
1737
1257
begsim
while_stmt -> while test : suite
1257
with
while_stmt -> while test : suite
1257
break
while_stmt -> while test : suite
1257
lambda
while_stmt -> while test : suite
1257
NAME
while_stmt -> while test : suite
1257
STRING
while_stmt -> while test : suite
1257
try
while_stmt -> while test : suite
1257
not
while_stmt -> while test : suite
1257
continue
while_stmt -> while test : suite
1257
global
while_stmt -> while test : suite
1257
(
while_stmt -> while test : suite
1257
{
while_stmt -> while test : suite
1257
nonlocal
while_stmt -> while test : suite
1257
$
while_stmt -> while test : suite
1257
raise
while_stmt -> while test : suite
1257
for
while_stmt -> while test : suite
1257
NEWLINE
while_stmt -> while test : suite
1257
~
while_stmt -> while test : suite
1257
-
while_stmt -> while test : suite
1257
if
while_stmt -> while test : suite
1257
return
while_stmt -> while test : suite
1257
class
while_stmt -> while test : suite
1257
+
while_stmt -> while test : suite
1257
False
while_stmt -> while test : suite
1257
assert
while_stmt -> while test : suite
1257
conf
while_stmt -> while test : suite
1257
yield
while_stmt -> while test : suite
1257
def
while_stmt -> while test : suite
1257
resetstats
while_stmt -> while test : suite
1257
endsim
while_stmt -> while test : suite
1257
NUMBER
while_stmt -> while test : suite
1257
True
while_stmt -> while test : suite
1257
del
while_stmt -> while test : suite
1257
@
while_stmt -> while test : suite
1257
[
while_stmt -> while test : suite
1257
pass
while_stmt -> while test : suite
1257
None
while_stmt -> while test : suite
1257
while
while_stmt -> while test : suite
1258
NEWLINE
1738
1259
INDENT
1739
1260
resetstats
suite -> simple_stmt
1260
+
suite -> simple_stmt
1260
lambda
suite -> simple_stmt
1260
try
suite -> simple_stmt
1260
begsim
suite -> simple_stmt
1260
None
suite -> simple_stmt
1260
not
suite -> simple_stmt
1260
@
suite -> simple_stmt
1260
[
suite -> simple_stmt
1260
class
suite -> simple_stmt
1260
return
suite -> simple_stmt
1260
else
suite -> simple_stmt
1260
nonlocal
suite -> simple_stmt
1260
NUMBER
suite -> simple_stmt
1260
yield
suite -> simple_stmt
1260
STRING
suite -> simple_stmt
1260
NEWLINE
suite -> simple_stmt
1260
-
suite -> simple_stmt
1260
False
suite -> simple_stmt
1260
def
suite -> simple_stmt
1260
conf
suite -> simple_stmt
1260
True
suite -> simple_stmt
1260
raise
suite -> simple_stmt
1260
endsim
suite -> simple_stmt
1260
with
suite -> simple_stmt
1260
global
suite -> simple_stmt
1260
{
suite -> simple_stmt
1260
~
suite -> simple_stmt
1260
assert
suite -> simple_stmt
1260
(
suite -> simple_stmt
1260
$
suite -> simple_stmt
1260
while
suite -> simple_stmt
1260
del
suite -> simple_stmt
1260
pass
suite -> simple_stmt
1260
break
suite -> simple_stmt
1260
for
suite -> simple_stmt
1260
continue
suite -> simple_stmt
1260
NAME
suite -> simple_stmt
1260
if
suite -> simple_stmt
1261
factor
697
1261
(
699
1261
NAME
701
1261
[
702
1261
atom
703
1261
+
704
1261
atom_expr
707
1261
power
706
1261
NUMBER
708
1261
STRING
709
1261
-
712
1261
term
1740
1261
True
715
1261
False
720
1261
None
722
1261
{
725
1261
~
726
1262
factor
697
1262
(
699
1262
NAME
701
1262
[
702
1262
atom
703
1262
+
704
1262
atom_expr
707
1262
power
706
1262
NUMBER
708
1262
STRING
709
1262
-
712
1262
True
715
1262
False
720
1262
None
722
1262
term
1741
1262
{
725
1262
~
726
1263
factor
697
1263
(
699
1263
NAME
701
1263
term
1742
1263
[
702
1263
atom
703
1263
+
704
1263
atom_expr
707
1263
power
706
1263
NUMBER
708
1263
STRING
709
1263
-
712
1263
True
715
1263
False
720
1263
None
722
1263
{
725
1263
~
726
1264
factor
697
1264
(
699
1264
NAME
701
1264
[
702
1264
atom
703
1264
+
704
1264
atom_expr
707
1264
power
706
1264
NUMBER
708
1264
STRING
709
1264
-
712
1264
term
1743
1264
True
715
1264
False
720
1264
None
722
1264
{
725
1264
~
726
1265
factor
697
1265
(
699
1265
NAME
701
1265
[
702
1265
atom
703
1265
+
704
1265
atom_expr
707
1265
power
706
1265
NUMBER
708
1265
term
1744
1265
STRING
709
1265
-
712
1265
True
715
1265
False
720
1265
None
722
1265
{
725
1265
~
726
1266
factor
697
1266
term
698
1266
(
699
1266
NAME
701
1266
[
702
1266
atom
703
1266
+
704
1266
power
706
1266
atom_expr
707
1266
NUMBER
708
1266
STRING
709
1266
-
712
1266
True
715
1266
arith_expr
1745
1266
False
720
1266
None
722
1266
{
725
1266
~
726
1267
factor
697
1267
term
698
1267
(
699
1267
NAME
701
1267
[
702
1267
atom
703
1267
+
704
1267
power
706
1267
atom_expr
707
1267
NUMBER
708
1267
STRING
709
1267
-
712
1267
True
715
1267
False
720
1267
arith_expr
1746
1267
None
722
1267
{
725
1267
~
726
1268
)
1747
1269
for
atom -> ( )
1269
)
atom -> ( )
1269
or
atom -> ( )
1269
<<
atom -> ( )
1269
not
atom -> ( )
1269
&
atom -> ( )
1269
(
atom -> ( )
1269
in
atom -> ( )
1269
**
atom -> ( )
1269
@
atom -> ( )
1269
=
atom -> ( )
1269
<=
atom -> ( )
1269
%
atom -> ( )
1269
[
atom -> ( )
1269
>=
atom -> ( )
1269
/
atom -> ( )
1269
+
atom -> ( )
1269
<
atom -> ( )
1269
is
atom -> ( )
1269
*
atom -> ( )
1269
!=
atom -> ( )
1269
-
atom -> ( )
1269
|
atom -> ( )
1269
//
atom -> ( )
1269
^
atom -> ( )
1269
and
atom -> ( )
1269
==
atom -> ( )
1269
if
atom -> ( )
1269
>
atom -> ( )
1269
,
atom -> ( )
1269
.
atom -> ( )
1269
>>
atom -> ( )
1270
factor
697
1270
term
698
1270
(
699
1270
arith_expr
700
1270
NAME
701
1270
[
702
1270
atom
703
1270
+
704
1270
power
706
1270
atom_expr
707
1270
NUMBER
708
1270
STRING
709
1270
-
712
1270
shift_expr
1748
1270
True
715
1270
False
720
1270
None
722
1270
{
725
1270
~
726
1271
factor
697
1271
term
698
1271
(
699
1271
arith_expr
700
1271
NAME
701
1271
[
702
1271
atom
703
1271
+
704
1271
power
706
1271
atom_expr
707
1271
NUMBER
708
1271
STRING
709
1271
-
712
1271
True
715
1271
shift_expr
1749
1271
False
720
1271
None
722
1271
{
725
1271
~
726
1272
]
1750
1273
<=
atom -> [ ]
1273
is
atom -> [ ]
1273
-
atom -> [ ]
1273
**
atom -> [ ]
1273
)
atom -> [ ]
1273
^
atom -> [ ]
1273
%
atom -> [ ]
1273
/
atom -> [ ]
1273
>=
atom -> [ ]
1273
|
atom -> [ ]
1273
not
atom -> [ ]
1273
@
atom -> [ ]
1273
*
atom -> [ ]
1273
(
atom -> [ ]
1273
,
atom -> [ ]
1273
>>
atom -> [ ]
1273
[
atom -> [ ]
1273
or
atom -> [ ]
1273
!=
atom -> [ ]
1273
and
atom -> [ ]
1273
<<
atom -> [ ]
1273
if
atom -> [ ]
1273
in
atom -> [ ]
1273
+
atom -> [ ]
1273
.
atom -> [ ]
1273
==
atom -> [ ]
1273
>
atom -> [ ]
1273
=
atom -> [ ]
1273
<
atom -> [ ]
1273
for
atom -> [ ]
1273
&
atom -> [ ]
1273
//
atom -> [ ]
1274
trailer_expr
1751
1274
trailer
1274
1274
.
1275
1274
(
1276
1274
[
1277
1274
<<
trailer_expr -> 
1274
%
trailer_expr -> 
1274
==
trailer_expr -> 
1274
-
trailer_expr -> 
1274
<
trailer_expr -> 
1274
if
trailer_expr -> 
1274
or
trailer_expr -> 
1274
/
trailer_expr -> 
1274
**
trailer_expr -> 
1274
and
trailer_expr -> 
1274
@
trailer_expr -> 
1274
=
trailer_expr -> 
1274
*
trailer_expr -> 
1274
|
trailer_expr -> 
1274
is
trailer_expr -> 
1274
,
trailer_expr -> 
1274
+
trailer_expr -> 
1274
in
trailer_expr -> 
1274
for
trailer_expr -> 
1274
&
trailer_expr -> 
1274
<=
trailer_expr -> 
1274
>=
trailer_expr -> 
1274
^
trailer_expr -> 
1274
>
trailer_expr -> 
1274
!=
trailer_expr -> 
1274
)
trailer_expr -> 
1274
not
trailer_expr -> 
1274
>>
trailer_expr -> 
1274
//
trailer_expr -> 
1275
NAME
1752
1276
factor
697
1276
term
698
1276
(
699
1276
arith_expr
700
1276
NAME
701
1276
[
702
1276
atom
703
1276
+
704
1276
power
706
1276
atom_expr
707
1276
NUMBER
708
1276
STRING
709
1276
*
710
1276
shift_expr
711
1276
-
712
1276
argument
714
1276
)
1753
1276
True
715
1276
not_test
716
1276
lambdef
717
1276
and_expr
718
1276
xor_expr
719
1276
False
720
1276
test
721
1276
None
722
1276
arglist
1754
1276
expr
723
1276
and_test
724
1276
{
725
1276
~
726
1276
lambda
727
1276
comparison
728
1276
or_test
729
1276
not
730
1276
**
731
1277
factor
732
1277
or_test
733
1277
term
734
1277
(
735
1277
arith_expr
736
1277
NAME
737
1277
[
738
1277
~
739
1277
subscriptlist
1755
1277
+
741
1277
maybe_test
742
1277
expr
743
1277
atom_expr
744
1277
atom
745
1277
NUMBER
746
1277
STRING
747
1277
shift_expr
748
1277
-
749
1277
True
750
1277
not_test
751
1277
and_expr
752
1277
xor_expr
753
1277
False
754
1277
{
755
1277
None
756
1277
and_test
757
1277
lambda
758
1277
power
759
1277
subscript
760
1277
test
761
1277
lambdef
762
1277
:
maybe_test -> 
1277
comparison
763
1277
not
764
1278
>
atom_expr -> atom trailer_expr
1278
not
atom_expr -> atom trailer_expr
1278
=
atom_expr -> atom trailer_expr
1278
//
atom_expr -> atom trailer_expr
1278
>>
atom_expr -> atom trailer_expr
1278
|
atom_expr -> atom trailer_expr
1278
^
atom_expr -> atom trailer_expr
1278
/
atom_expr -> atom trailer_expr
1278
+
atom_expr -> atom trailer_expr
1278
in
atom_expr -> atom trailer_expr
1278
%
atom_expr -> atom trailer_expr
1278
and
atom_expr -> atom trailer_expr
1278
<=
atom_expr -> atom trailer_expr
1278
is
atom_expr -> atom trailer_expr
1278
<
atom_expr -> atom trailer_expr
1278
@
atom_expr -> atom trailer_expr
1278
-
atom_expr -> atom trailer_expr
1278
&
atom_expr -> atom trailer_expr
1278
*
atom_expr -> atom trailer_expr
1278
**
atom_expr -> atom trailer_expr
1278
>=
atom_expr -> atom trailer_expr
1278
)
atom_expr -> atom trailer_expr
1278
for
atom_expr -> atom trailer_expr
1278
or
atom_expr -> atom trailer_expr
1278
,
atom_expr -> atom trailer_expr
1278
==
atom_expr -> atom trailer_expr
1278
!=
atom_expr -> atom trailer_expr
1278
if
atom_expr -> atom trailer_expr
1278
<<
atom_expr -> atom trailer_expr
1279
<
factor -> + factor
1279
if
factor -> + factor
1279
<<
factor -> + factor
1279
and
factor -> + factor
1279
>=
factor -> + factor
1279
%
factor -> + factor
1279
>>
factor -> + factor
1279
*
factor -> + factor
1279
+
factor -> + factor
1279
)
factor -> + factor
1279
/
factor -> + factor
1279
>
factor -> + factor
1279
<=
factor -> + factor
1279
^
factor -> + factor
1279
is
factor -> + factor
1279
|
factor -> + factor
1279
or
factor -> + factor
1279
=
factor -> + factor
1279
-
factor -> + factor
1279
in
factor -> + factor
1279
for
factor -> + factor
1279
&
factor -> + factor
1279
not
factor -> + factor
1279
//
factor -> + factor
1279
,
factor -> + factor
1279
!=
factor -> + factor
1279
==
factor -> + factor
1279
@
factor -> + factor
1280
**
trailer -> ( arglist )
1280
:
trailer -> ( arglist )
1280
-=
trailer -> ( arglist )
1280
^=
trailer -> ( arglist )
1280
@=
trailer -> ( arglist )
1280
**=
trailer -> ( arglist )
1280
if
trailer -> ( arglist )
1280
<
trailer -> ( arglist )
1280
//
trailer -> ( arglist )
1280
<<
trailer -> ( arglist )
1280
%
trailer -> ( arglist )
1280
NEWLINE
trailer -> ( arglist )
1280
&
trailer -> ( arglist )
1280
==
trailer -> ( arglist )
1280
is
trailer -> ( arglist )
1280
,
trailer -> ( arglist )
1280
!=
trailer -> ( arglist )
1280
/=
trailer -> ( arglist )
1280
=
trailer -> ( arglist )
1280
|=
trailer -> ( arglist )
1280
and
trailer -> ( arglist )
1280
-
trailer -> ( arglist )
1280
>>=
trailer -> ( arglist )
1280
+
trailer -> ( arglist )
1280
>=
trailer -> ( arglist )
1280
or
trailer -> ( arglist )
1280
(
trailer -> ( arglist )
1280
^
trailer -> ( arglist )
1280
.
trailer -> ( arglist )
1280
*=
trailer -> ( arglist )
1280
>>
trailer -> ( arglist )
1280
not
trailer -> ( arglist )
1280
/
trailer -> ( arglist )
1280
//=
trailer -> ( arglist )
1280
*
trailer -> ( arglist )
1280
[
trailer -> ( arglist )
1280
%=
trailer -> ( arglist )
1280
@
trailer -> ( arglist )
1280
&=
trailer -> ( arglist )
1280
>
trailer -> ( arglist )
1280
+=
trailer -> ( arglist )
1280
|
trailer -> ( arglist )
1280
<<=
trailer -> ( arglist )
1280
<=
trailer -> ( arglist )
1280
in
trailer -> ( arglist )
1281
(
699
1281
NAME
701
1281
[
702
1281
atom
703
1281
+
704
1281
atom_expr
707
1281
power
706
1281
NUMBER
708
1281
STRING
709
1281
-
712
1281
factor
1756
1281
True
715
1281
False
720
1281
None
722
1281
{
725
1281
~
726
1282
,
argument -> * test
1282
)
argument -> * test
1283
factor
697
1283
term
698
1283
(
699
1283
arith_expr
700
1283
NAME
701
1283
[
702
1283
atom
703
1283
+
704
1283
power
706
1283
atom_expr
707
1283
NUMBER
708
1283
STRING
709
1283
shift_expr
711
1283
-
712
1283
True
715
1283
False
720
1283
None
722
1283
and_expr
1757
1283
{
725
1283
~
726
1284
for
factor -> - factor
1284
and
factor -> - factor
1284
if
factor -> - factor
1284
or
factor -> - factor
1284
>=
factor -> - factor
1284
<
factor -> - factor
1284
!=
factor -> - factor
1284
-
factor -> - factor
1284
=
factor -> - factor
1284
==
factor -> - factor
1284
@
factor -> - factor
1284
|
factor -> - factor
1284
*
factor -> - factor
1284
%
factor -> - factor
1284
+
factor -> - factor
1284
<=
factor -> - factor
1284
//
factor -> - factor
1284
not
factor -> - factor
1284
>>
factor -> - factor
1284
/
factor -> - factor
1284
&
factor -> - factor
1284
^
factor -> - factor
1284
)
factor -> - factor
1284
in
factor -> - factor
1284
is
factor -> - factor
1284
>
factor -> - factor
1284
,
factor -> - factor
1284
<<
factor -> - factor
1285
factor
697
1285
term
698
1285
(
699
1285
arith_expr
700
1285
NAME
701
1285
[
702
1285
atom
703
1285
+
704
1285
power
706
1285
atom_expr
707
1285
NUMBER
708
1285
STRING
709
1285
*
710
1285
shift_expr
711
1285
-
712
1285
argument
714
1285
True
715
1285
not_test
716
1285
lambdef
717
1285
and_expr
718
1285
xor_expr
719
1285
False
720
1285
test
721
1285
None
722
1285
expr
723
1285
and_test
724
1285
{
725
1285
~
726
1285
lambda
727
1285
comparison
728
1285
or_test
729
1285
not
730
1285
arglist
1758
1285
**
731
1286
factor
697
1286
term
698
1286
(
699
1286
arith_expr
700
1286
NAME
701
1286
[
702
1286
atom
703
1286
+
704
1286
power
706
1286
atom_expr
707
1286
NUMBER
708
1286
STRING
709
1286
shift_expr
711
1286
-
712
1286
True
715
1286
not_test
716
1286
and_expr
718
1286
xor_expr
719
1286
False
720
1286
None
722
1286
expr
723
1286
{
725
1286
~
726
1286
and_test
1759
1286
comparison
728
1286
not
730
1287
factor
697
1287
term
698
1287
(
699
1287
arith_expr
700
1287
NAME
701
1287
[
702
1287
atom
703
1287
+
704
1287
power
706
1287
atom_expr
707
1287
NUMBER
708
1287
STRING
709
1287
shift_expr
711
1287
-
712
1287
True
715
1287
and_expr
718
1287
False
720
1287
None
722
1287
xor_expr
1760
1287
{
725
1287
~
726
1288
factor
697
1288
term
698
1288
(
699
1288
arith_expr
700
1288
NAME
701
1288
[
702
1288
atom
703
1288
+
704
1288
power
706
1288
atom_expr
707
1288
NUMBER
708
1288
STRING
709
1288
shift_expr
711
1288
-
712
1288
True
715
1288
and_expr
718
1288
xor_expr
719
1288
False
720
1288
None
722
1288
{
725
1288
~
726
1288
expr
1761
1289
factor
152
1289
NUMBER
153
1289
term
155
1289
(
156
1289
True
157
1289
[
158
1289
+
159
1289
STRING
160
1289
atom_expr
161
1289
arith_expr
162
1289
expr
163
1289
~
164
1289
NAME
165
1289
False
166
1289
{
167
1289
and_expr
168
1289
xor_expr
169
1289
expr_list
1762
1289
None
170
1289
power
171
1289
-
172
1289
shift_expr
173
1289
atom
174
1290
,
argument -> test comp_for
1290
)
argument -> test comp_for
1291
factor
1221
1291
term
1222
1291
(
1223
1291
arith_expr
1224
1291
NAME
1225
1291
[
1226
1291
+
1227
1291
atom_expr
1228
1291
NUMBER
1229
1291
atom
1230
1291
STRING
1231
1291
shift_expr
1232
1291
-
1233
1291
True
1234
1291
not_test
1235
1291
and_expr
1236
1291
xor_expr
1237
1291
None
1238
1291
False
1239
1291
and_test
1240
1291
{
1241
1291
~
1242
1291
power
1243
1291
expr
1244
1291
lambda
1245
1291
comparison
1246
1291
or_test
1247
1291
test
1763
1291
not
1249
1291
lambdef
1251
1292
factor
697
1292
term
698
1292
(
699
1292
arith_expr
700
1292
NAME
701
1292
[
702
1292
atom
703
1292
+
704
1292
power
706
1292
atom_expr
707
1292
NUMBER
708
1292
STRING
709
1292
shift_expr
711
1292
-
712
1292
True
715
1292
and_expr
718
1292
comparison
1764
1292
xor_expr
719
1292
False
720
1292
None
722
1292
expr
723
1292
{
725
1292
~
726
1293
factor
697
1293
term
698
1293
(
699
1293
arith_expr
700
1293
NAME
701
1293
[
702
1293
atom
703
1293
+
704
1293
power
706
1293
atom_expr
707
1293
NUMBER
708
1293
STRING
709
1293
shift_expr
711
1293
-
712
1293
True
715
1293
not_test
716
1293
and_expr
718
1293
xor_expr
719
1293
False
720
1293
None
722
1293
expr
723
1293
and_test
724
1293
{
725
1293
~
726
1293
comparison
728
1293
or_test
1765
1293
not
730
1294
>
atom -> { }
1294
==
atom -> { }
1294
)
atom -> { }
1294
-
atom -> { }
1294
not
atom -> { }
1294
(
atom -> { }
1294
@
atom -> { }
1294
if
atom -> { }
1294
and
atom -> { }
1294
,
atom -> { }
1294
&
atom -> { }
1294
<<
atom -> { }
1294
!=
atom -> { }
1294
or
atom -> { }
1294
>>
atom -> { }
1294
<=
atom -> { }
1294
>=
atom -> { }
1294
is
atom -> { }
1294
/
atom -> { }
1294
=
atom -> { }
1294
^
atom -> { }
1294
[
atom -> { }
1294
%
atom -> { }
1294
//
atom -> { }
1294
*
atom -> { }
1294
**
atom -> { }
1294
.
atom -> { }
1294
for
atom -> { }
1294
in
atom -> { }
1294
+
atom -> { }
1294
|
atom -> { }
1294
<
atom -> { }
1295
or
factor -> ~ factor
1295
==
factor -> ~ factor
1295
<=
factor -> ~ factor
1295
@
factor -> ~ factor
1295
!=
factor -> ~ factor
1295
>=
factor -> ~ factor
1295
>
factor -> ~ factor
1295
and
factor -> ~ factor
1295
,
factor -> ~ factor
1295
*
factor -> ~ factor
1295
&
factor -> ~ factor
1295
%
factor -> ~ factor
1295
<
factor -> ~ factor
1295
//
factor -> ~ factor
1295
=
factor -> ~ factor
1295
if
factor -> ~ factor
1295
^
factor -> ~ factor
1295
/
factor -> ~ factor
1295
for
factor -> ~ factor
1295
in
factor -> ~ factor
1295
+
factor -> ~ factor
1295
not
factor -> ~ factor
1295
-
factor -> ~ factor
1295
is
factor -> ~ factor
1295
)
factor -> ~ factor
1295
>>
factor -> ~ factor
1295
<<
factor -> ~ factor
1295
|
factor -> ~ factor
1296
factor
697
1296
term
698
1296
(
699
1296
arith_expr
700
1296
NAME
701
1296
[
702
1296
atom
703
1296
+
704
1296
power
706
1296
atom_expr
707
1296
NUMBER
708
1296
STRING
709
1296
shift_expr
711
1296
-
712
1296
True
715
1296
not_test
716
1296
lambdef
717
1296
and_expr
718
1296
xor_expr
719
1296
False
720
1296
None
722
1296
expr
723
1296
and_test
724
1296
{
725
1296
~
726
1296
lambda
727
1296
test
1766
1296
comparison
728
1296
or_test
729
1296
not
730
1297
:
1767
1298
factor
585
1298
(
586
1298
arith_expr
587
1298
NAME
588
1298
[
589
1298
and_expr
590
1298
+
591
1298
term
592
1298
atom_expr
593
1298
NUMBER
594
1298
atom
595
1298
STRING
596
1298
shift_expr
597
1298
-
598
1298
True
599
1298
not
600
1298
xor_expr
601
1298
None
602
1298
False
603
1298
not_test
605
1298
or_test
1768
1298
~
606
1298
power
607
1298
{
608
1298
expr
609
1298
comparison
610
1298
and_test
611
1299
)
not_test -> not not_test
1299
or
not_test -> not not_test
1299
,
not_test -> not not_test
1299
and
not_test -> not not_test
1299
if
not_test -> not not_test
1299
for
not_test -> not not_test
1299
=
not_test -> not not_test
1300
,
argument -> ** test
1300
)
argument -> ** test
1301
factor
732
1301
(
735
1301
NAME
737
1301
[
738
1301
~
739
1301
+
741
1301
atom_expr
744
1301
NUMBER
746
1301
atom
745
1301
STRING
747
1301
-
749
1301
term
1769
1301
True
750
1301
False
754
1301
{
755
1301
None
756
1301
power
759
1302
factor
732
1302
(
735
1302
NAME
737
1302
[
738
1302
~
739
1302
+
741
1302
atom_expr
744
1302
NUMBER
746
1302
atom
745
1302
term
1770
1302
STRING
747
1302
-
749
1302
True
750
1302
False
754
1302
{
755
1302
None
756
1302
power
759
1303
factor
732
1303
(
735
1303
NAME
737
1303
[
738
1303
~
739
1303
+
741
1303
atom_expr
744
1303
NUMBER
746
1303
atom
745
1303
STRING
747
1303
-
749
1303
True
750
1303
False
754
1303
{
755
1303
None
756
1303
term
1771
1303
power
759
1304
factor
732
1304
(
735
1304
NAME
737
1304
term
1772
1304
[
738
1304
~
739
1304
+
741
1304
atom_expr
744
1304
NUMBER
746
1304
atom
745
1304
STRING
747
1304
-
749
1304
True
750
1304
False
754
1304
{
755
1304
None
756
1304
power
759
1305
factor
732
1305
(
735
1305
NAME
737
1305
[
738
1305
~
739
1305
+
741
1305
atom_expr
744
1305
NUMBER
746
1305
atom
745
1305
STRING
747
1305
-
749
1305
term
1773
1305
True
750
1305
False
754
1305
{
755
1305
None
756
1305
power
759
1306
factor
585
1306
(
586
1306
arith_expr
587
1306
NAME
588
1306
[
589
1306
and_expr
590
1306
+
591
1306
term
592
1306
atom_expr
593
1306
NUMBER
594
1306
atom
595
1306
STRING
596
1306
shift_expr
597
1306
-
598
1306
True
599
1306
not
600
1306
xor_expr
601
1306
None
602
1306
False
603
1306
not_test
605
1306
~
606
1306
power
607
1306
{
608
1306
expr
609
1306
or_test
1774
1306
comparison
610
1306
and_test
611
1307
factor
732
1307
term
734
1307
(
735
1307
NAME
737
1307
[
738
1307
~
739
1307
arith_expr
1775
1307
+
741
1307
atom_expr
744
1307
NUMBER
746
1307
atom
745
1307
STRING
747
1307
-
749
1307
True
750
1307
False
754
1307
{
755
1307
None
756
1307
power
759
1308
factor
732
1308
term
734
1308
(
735
1308
NAME
737
1308
[
738
1308
~
739
1308
+
741
1308
atom_expr
744
1308
NUMBER
746
1308
atom
745
1308
STRING
747
1308
-
749
1308
True
750
1308
False
754
1308
{
755
1308
None
756
1308
arith_expr
1776
1308
power
759
1309
)
1777
1310
or
atom -> ( )
1310
<<
atom -> ( )
1310
not
atom -> ( )
1310
&
atom -> ( )
1310
(
atom -> ( )
1310
in
atom -> ( )
1310
**
atom -> ( )
1310
@
atom -> ( )
1310
<=
atom -> ( )
1310
%
atom -> ( )
1310
[
atom -> ( )
1310
>=
atom -> ( )
1310
/
atom -> ( )
1310
+
atom -> ( )
1310
<
atom -> ( )
1310
]
atom -> ( )
1310
is
atom -> ( )
1310
:
atom -> ( )
1310
*
atom -> ( )
1310
!=
atom -> ( )
1310
-
atom -> ( )
1310
|
atom -> ( )
1310
//
atom -> ( )
1310
^
atom -> ( )
1310
and
atom -> ( )
1310
==
atom -> ( )
1310
if
atom -> ( )
1310
>
atom -> ( )
1310
,
atom -> ( )
1310
.
atom -> ( )
1310
>>
atom -> ( )
1311
factor
732
1311
term
734
1311
(
735
1311
arith_expr
736
1311
NAME
737
1311
[
738
1311
~
739
1311
+
741
1311
atom_expr
744
1311
NUMBER
746
1311
atom
745
1311
STRING
747
1311
-
749
1311
shift_expr
1778
1311
True
750
1311
False
754
1311
{
755
1311
None
756
1311
power
759
1312
factor
732
1312
term
734
1312
(
735
1312
arith_expr
736
1312
NAME
737
1312
[
738
1312
~
739
1312
+
741
1312
atom_expr
744
1312
NUMBER
746
1312
atom
745
1312
STRING
747
1312
-
749
1312
shift_expr
1779
1312
True
750
1312
False
754
1312
{
755
1312
None
756
1312
power
759
1313
<=
atom -> [ ]
1313
is
atom -> [ ]
1313
-
atom -> [ ]
1313
]
atom -> [ ]
1313
**
atom -> [ ]
1313
^
atom -> [ ]
1313
%
atom -> [ ]
1313
/
atom -> [ ]
1313
>=
atom -> [ ]
1313
|
atom -> [ ]
1313
not
atom -> [ ]
1313
@
atom -> [ ]
1313
*
atom -> [ ]
1313
(
atom -> [ ]
1313
,
atom -> [ ]
1313
>>
atom -> [ ]
1313
[
atom -> [ ]
1313
:
atom -> [ ]
1313
or
atom -> [ ]
1313
!=
atom -> [ ]
1313
and
atom -> [ ]
1313
<<
atom -> [ ]
1313
if
atom -> [ ]
1313
in
atom -> [ ]
1313
+
atom -> [ ]
1313
.
atom -> [ ]
1313
==
atom -> [ ]
1313
>
atom -> [ ]
1313
<
atom -> [ ]
1313
&
atom -> [ ]
1313
//
atom -> [ ]
1314
]
1780
1315
or
factor -> ~ factor
1315
==
factor -> ~ factor
1315
<=
factor -> ~ factor
1315
@
factor -> ~ factor
1315
!=
factor -> ~ factor
1315
>=
factor -> ~ factor
1315
>
factor -> ~ factor
1315
and
factor -> ~ factor
1315
,
factor -> ~ factor
1315
:
factor -> ~ factor
1315
*
factor -> ~ factor
1315
&
factor -> ~ factor
1315
%
factor -> ~ factor
1315
<
factor -> ~ factor
1315
//
factor -> ~ factor
1315
if
factor -> ~ factor
1315
^
factor -> ~ factor
1315
/
factor -> ~ factor
1315
in
factor -> ~ factor
1315
+
factor -> ~ factor
1315
not
factor -> ~ factor
1315
-
factor -> ~ factor
1315
is
factor -> ~ factor
1315
>>
factor -> ~ factor
1315
<<
factor -> ~ factor
1315
]
factor -> ~ factor
1315
|
factor -> ~ factor
1316
|
trailer -> [ subscriptlist ]
1316
-=
trailer -> [ subscriptlist ]
1316
not
trailer -> [ subscriptlist ]
1316
in
trailer -> [ subscriptlist ]
1316
|=
trailer -> [ subscriptlist ]
1316
&=
trailer -> [ subscriptlist ]
1316
==
trailer -> [ subscriptlist ]
1316
**
trailer -> [ subscriptlist ]
1316
>>
trailer -> [ subscriptlist ]
1316
!=
trailer -> [ subscriptlist ]
1316
*
trailer -> [ subscriptlist ]
1316
%=
trailer -> [ subscriptlist ]
1316
@=
trailer -> [ subscriptlist ]
1316
or
trailer -> [ subscriptlist ]
1316
<<=
trailer -> [ subscriptlist ]
1316
>=
trailer -> [ subscriptlist ]
1316
/
trailer -> [ subscriptlist ]
1316
[
trailer -> [ subscriptlist ]
1316
>
trailer -> [ subscriptlist ]
1316
<
trailer -> [ subscriptlist ]
1316
.
trailer -> [ subscriptlist ]
1316
and
trailer -> [ subscriptlist ]
1316
(
trailer -> [ subscriptlist ]
1316
<=
trailer -> [ subscriptlist ]
1316
/=
trailer -> [ subscriptlist ]
1316
>>=
trailer -> [ subscriptlist ]
1316
-
trailer -> [ subscriptlist ]
1316
//=
trailer -> [ subscriptlist ]
1316
**=
trailer -> [ subscriptlist ]
1316
@
trailer -> [ subscriptlist ]
1316
<<
trailer -> [ subscriptlist ]
1316
^=
trailer -> [ subscriptlist ]
1316
+=
trailer -> [ subscriptlist ]
1316
*=
trailer -> [ subscriptlist ]
1316
&
trailer -> [ subscriptlist ]
1316
,
trailer -> [ subscriptlist ]
1316
:
trailer -> [ subscriptlist ]
1316
^
trailer -> [ subscriptlist ]
1316
is
trailer -> [ subscriptlist ]
1316
%
trailer -> [ subscriptlist ]
1316
+
trailer -> [ subscriptlist ]
1316
//
trailer -> [ subscriptlist ]
1316
NEWLINE
trailer -> [ subscriptlist ]
1316
=
trailer -> [ subscriptlist ]
1316
if
trailer -> [ subscriptlist ]
1317
<
factor -> + factor
1317
if
factor -> + factor
1317
<<
factor -> + factor
1317
]
factor -> + factor
1317
and
factor -> + factor
1317
>=
factor -> + factor
1317
%
factor -> + factor
1317
>>
factor -> + factor
1317
*
factor -> + factor
1317
+
factor -> + factor
1317
/
factor -> + factor
1317
>
factor -> + factor
1317
<=
factor -> + factor
1317
^
factor -> + factor
1317
is
factor -> + factor
1317
|
factor -> + factor
1317
or
factor -> + factor
1317
-
factor -> + factor
1317
in
factor -> + factor
1317
&
factor -> + factor
1317
not
factor -> + factor
1317
//
factor -> + factor
1317
,
factor -> + factor
1317
!=
factor -> + factor
1317
:
factor -> + factor
1317
==
factor -> + factor
1317
@
factor -> + factor
1318
factor
732
1318
or_test
733
1318
term
734
1318
(
735
1318
arith_expr
736
1318
NAME
737
1318
[
738
1318
~
739
1318
+
741
1318
expr
743
1318
atom_expr
744
1318
atom
745
1318
NUMBER
746
1318
STRING
747
1318
shift_expr
748
1318
-
749
1318
True
750
1318
not_test
751
1318
and_expr
752
1318
xor_expr
753
1318
False
754
1318
{
755
1318
None
756
1318
and_test
757
1318
lambda
758
1318
power
759
1318
maybe_test
1781
1318
test
1782
1318
lambdef
762
1318
:
maybe_test -> 
1318
comparison
763
1318
not
764
1318
]
maybe_test -> 
1318
,
maybe_test -> 
1319
factor
732
1319
term
734
1319
(
735
1319
arith_expr
736
1319
NAME
737
1319
[
738
1319
~
739
1319
+
741
1319
expr
743
1319
atom_expr
744
1319
atom
745
1319
NUMBER
746
1319
STRING
747
1319
shift_expr
748
1319
-
749
1319
True
750
1319
and_expr
752
1319
comparison
1783
1319
xor_expr
753
1319
False
754
1319
{
755
1319
None
756
1319
power
759
1320
(
735
1320
NAME
737
1320
[
738
1320
~
739
1320
+
741
1320
atom_expr
744
1320
NUMBER
746
1320
atom
745
1320
STRING
747
1320
-
749
1320
factor
1784
1320
True
750
1320
False
754
1320
{
755
1320
None
756
1320
power
759
1321
trailer_expr
1785
1321
trailer
1321
1321
.
1322
1321
(
1323
1321
[
1324
1321
<<
trailer_expr -> 
1321
%
trailer_expr -> 
1321
==
trailer_expr -> 
1321
-
trailer_expr -> 
1321
<
trailer_expr -> 
1321
if
trailer_expr -> 
1321
or
trailer_expr -> 
1321
/
trailer_expr -> 
1321
**
trailer_expr -> 
1321
and
trailer_expr -> 
1321
@
trailer_expr -> 
1321
*
trailer_expr -> 
1321
|
trailer_expr -> 
1321
is
trailer_expr -> 
1321
,
trailer_expr -> 
1321
+
trailer_expr -> 
1321
in
trailer_expr -> 
1321
&
trailer_expr -> 
1321
<=
trailer_expr -> 
1321
>=
trailer_expr -> 
1321
^
trailer_expr -> 
1321
>
trailer_expr -> 
1321
!=
trailer_expr -> 
1321
not
trailer_expr -> 
1321
>>
trailer_expr -> 
1321
//
trailer_expr -> 
1321
]
trailer_expr -> 
1321
:
trailer_expr -> 
1322
NAME
1786
1323
factor
697
1323
term
698
1323
(
699
1323
arith_expr
700
1323
NAME
701
1323
[
702
1323
atom
703
1323
+
704
1323
power
706
1323
atom_expr
707
1323
NUMBER
708
1323
STRING
709
1323
*
710
1323
shift_expr
711
1323
-
712
1323
argument
714
1323
)
1787
1323
True
715
1323
not_test
716
1323
lambdef
717
1323
and_expr
718
1323
xor_expr
719
1323
False
720
1323
test
721
1323
None
722
1323
arglist
1788
1323
expr
723
1323
and_test
724
1323
{
725
1323
~
726
1323
lambda
727
1323
comparison
728
1323
or_test
729
1323
not
730
1323
**
731
1324
factor
732
1324
or_test
733
1324
term
734
1324
(
735
1324
arith_expr
736
1324
NAME
737
1324
[
738
1324
~
739
1324
subscriptlist
1789
1324
+
741
1324
maybe_test
742
1324
expr
743
1324
atom_expr
744
1324
atom
745
1324
NUMBER
746
1324
STRING
747
1324
shift_expr
748
1324
-
749
1324
True
750
1324
not_test
751
1324
and_expr
752
1324
xor_expr
753
1324
False
754
1324
{
755
1324
None
756
1324
and_test
757
1324
lambda
758
1324
power
759
1324
subscript
760
1324
test
761
1324
lambdef
762
1324
:
maybe_test -> 
1324
comparison
763
1324
not
764
1325
>
atom_expr -> atom trailer_expr
1325
not
atom_expr -> atom trailer_expr
1325
//
atom_expr -> atom trailer_expr
1325
>>
atom_expr -> atom trailer_expr
1325
|
atom_expr -> atom trailer_expr
1325
^
atom_expr -> atom trailer_expr
1325
/
atom_expr -> atom trailer_expr
1325
+
atom_expr -> atom trailer_expr
1325
in
atom_expr -> atom trailer_expr
1325
%
atom_expr -> atom trailer_expr
1325
and
atom_expr -> atom trailer_expr
1325
<=
atom_expr -> atom trailer_expr
1325
is
atom_expr -> atom trailer_expr
1325
<
atom_expr -> atom trailer_expr
1325
@
atom_expr -> atom trailer_expr
1325
-
atom_expr -> atom trailer_expr
1325
]
atom_expr -> atom trailer_expr
1325
&
atom_expr -> atom trailer_expr
1325
:
atom_expr -> atom trailer_expr
1325
*
atom_expr -> atom trailer_expr
1325
**
atom_expr -> atom trailer_expr
1325
>=
atom_expr -> atom trailer_expr
1325
or
atom_expr -> atom trailer_expr
1325
,
atom_expr -> atom trailer_expr
1325
==
atom_expr -> atom trailer_expr
1325
!=
atom_expr -> atom trailer_expr
1325
if
atom_expr -> atom trailer_expr
1325
<<
atom_expr -> atom trailer_expr
1326
factor
732
1326
term
734
1326
(
735
1326
arith_expr
736
1326
NAME
737
1326
[
738
1326
~
739
1326
+
741
1326
atom_expr
744
1326
NUMBER
746
1326
atom
745
1326
STRING
747
1326
shift_expr
748
1326
-
749
1326
True
750
1326
False
754
1326
{
755
1326
None
756
1326
and_expr
1790
1326
power
759
1327
and
factor -> - factor
1327
if
factor -> - factor
1327
or
factor -> - factor
1327
>=
factor -> - factor
1327
<
factor -> - factor
1327
!=
factor -> - factor
1327
-
factor -> - factor
1327
==
factor -> - factor
1327
]
factor -> - factor
1327
@
factor -> - factor
1327
|
factor -> - factor
1327
*
factor -> - factor
1327
%
factor -> - factor
1327
+
factor -> - factor
1327
<=
factor -> - factor
1327
//
factor -> - factor
1327
not
factor -> - factor
1327
>>
factor -> - factor
1327
/
factor -> - factor
1327
&
factor -> - factor
1327
^
factor -> - factor
1327
in
factor -> - factor
1327
is
factor -> - factor
1327
>
factor -> - factor
1327
,
factor -> - factor
1327
:
factor -> - factor
1327
<<
factor -> - factor
1328
factor
732
1328
term
734
1328
(
735
1328
arith_expr
736
1328
NAME
737
1328
[
738
1328
~
739
1328
+
741
1328
expr
743
1328
atom_expr
744
1328
atom
745
1328
NUMBER
746
1328
STRING
747
1328
shift_expr
748
1328
-
749
1328
True
750
1328
not_test
751
1328
and_test
1791
1328
and_expr
752
1328
xor_expr
753
1328
False
754
1328
{
755
1328
None
756
1328
power
759
1328
comparison
763
1328
not
764
1329
factor
732
1329
term
734
1329
(
735
1329
arith_expr
736
1329
NAME
737
1329
[
738
1329
~
739
1329
+
741
1329
atom_expr
744
1329
NUMBER
746
1329
atom
745
1329
STRING
747
1329
shift_expr
748
1329
-
749
1329
True
750
1329
and_expr
752
1329
False
754
1329
{
755
1329
None
756
1329
xor_expr
1792
1329
power
759
1330
factor
732
1330
term
734
1330
(
735
1330
arith_expr
736
1330
NAME
737
1330
[
738
1330
~
739
1330
+
741
1330
atom_expr
744
1330
NUMBER
746
1330
atom
745
1330
STRING
747
1330
shift_expr
748
1330
-
749
1330
True
750
1330
and_expr
752
1330
xor_expr
753
1330
False
754
1330
{
755
1330
None
756
1330
power
759
1330
expr
1793
1331
>
atom -> { }
1331
==
atom -> { }
1331
-
atom -> { }
1331
]
atom -> { }
1331
not
atom -> { }
1331
(
atom -> { }
1331
@
atom -> { }
1331
if
atom -> { }
1331
and
atom -> { }
1331
,
atom -> { }
1331
:
atom -> { }
1331
&
atom -> { }
1331
<<
atom -> { }
1331
!=
atom -> { }
1331
or
atom -> { }
1331
>>
atom -> { }
1331
<=
atom -> { }
1331
>=
atom -> { }
1331
is
atom -> { }
1331
/
atom -> { }
1331
^
atom -> { }
1331
[
atom -> { }
1331
%
atom -> { }
1331
//
atom -> { }
1331
*
atom -> { }
1331
**
atom -> { }
1331
.
atom -> { }
1331
in
atom -> { }
1331
+
atom -> { }
1331
|
atom -> { }
1331
<
atom -> { }
1332
factor
732
1332
term
734
1332
(
735
1332
arith_expr
736
1332
NAME
737
1332
[
738
1332
~
739
1332
+
741
1332
expr
743
1332
atom_expr
744
1332
atom
745
1332
NUMBER
746
1332
STRING
747
1332
shift_expr
748
1332
-
749
1332
True
750
1332
not_test
751
1332
and_expr
752
1332
xor_expr
753
1332
False
754
1332
{
755
1332
None
756
1332
and_test
757
1332
power
759
1332
comparison
763
1332
or_test
1794
1332
not
764
1333
factor
732
1333
or_test
733
1333
term
734
1333
(
735
1333
arith_expr
736
1333
NAME
737
1333
[
738
1333
~
739
1333
+
741
1333
expr
743
1333
atom_expr
744
1333
atom
745
1333
NUMBER
746
1333
STRING
747
1333
shift_expr
748
1333
-
749
1333
True
750
1333
not_test
751
1333
and_expr
752
1333
xor_expr
753
1333
False
754
1333
{
755
1333
None
756
1333
and_test
757
1333
test
1795
1333
lambda
758
1333
power
759
1333
lambdef
762
1333
comparison
763
1333
not
764
1334
:
1796
1335
factor
732
1335
or_test
733
1335
term
734
1335
(
735
1335
arith_expr
736
1335
NAME
737
1335
[
738
1335
~
739
1335
+
741
1335
maybe_test
742
1335
expr
743
1335
atom_expr
744
1335
atom
745
1335
NUMBER
746
1335
STRING
747
1335
shift_expr
748
1335
-
749
1335
True
750
1335
not_test
751
1335
and_expr
752
1335
xor_expr
753
1335
False
754
1335
{
755
1335
None
756
1335
and_test
757
1335
lambda
758
1335
power
759
1335
subscript
760
1335
test
761
1335
lambdef
762
1335
:
maybe_test -> 
1335
comparison
763
1335
not
764
1335
subscriptlist
1797
1336
]
not_test -> not not_test
1336
or
not_test -> not not_test
1336
,
not_test -> not not_test
1336
and
not_test -> not not_test
1336
if
not_test -> not not_test
1336
:
not_test -> not not_test
1337
factor
766
1337
(
768
1337
NAME
770
1337
[
771
1337
atom
772
1337
+
773
1337
atom_expr
775
1337
power
774
1337
NUMBER
776
1337
STRING
777
1337
-
779
1337
term
1798
1337
True
780
1337
None
784
1337
False
786
1337
{
790
1337
~
789
1338
factor
766
1338
(
768
1338
NAME
770
1338
[
771
1338
atom
772
1338
+
773
1338
atom_expr
775
1338
power
774
1338
NUMBER
776
1338
STRING
777
1338
-
779
1338
True
780
1338
None
784
1338
term
1799
1338
False
786
1338
{
790
1338
~
789
1339
factor
766
1339
(
768
1339
NAME
770
1339
term
1800
1339
[
771
1339
atom
772
1339
+
773
1339
atom_expr
775
1339
power
774
1339
NUMBER
776
1339
STRING
777
1339
-
779
1339
True
780
1339
None
784
1339
False
786
1339
{
790
1339
~
789
1340
factor
766
1340
(
768
1340
NAME
770
1340
[
771
1340
atom
772
1340
+
773
1340
atom_expr
775
1340
power
774
1340
NUMBER
776
1340
STRING
777
1340
-
779
1340
term
1801
1340
True
780
1340
None
784
1340
False
786
1340
{
790
1340
~
789
1341
factor
766
1341
(
768
1341
NAME
770
1341
[
771
1341
atom
772
1341
+
773
1341
atom_expr
775
1341
power
774
1341
NUMBER
776
1341
term
1802
1341
STRING
777
1341
-
779
1341
True
780
1341
None
784
1341
False
786
1341
{
790
1341
~
789
1342
factor
766
1342
term
767
1342
(
768
1342
NAME
770
1342
[
771
1342
atom
772
1342
+
773
1342
power
774
1342
atom_expr
775
1342
NUMBER
776
1342
STRING
777
1342
-
779
1342
True
780
1342
arith_expr
1803
1342
None
784
1342
False
786
1342
{
790
1342
~
789
1343
factor
766
1343
term
767
1343
(
768
1343
NAME
770
1343
[
771
1343
atom
772
1343
+
773
1343
power
774
1343
atom_expr
775
1343
NUMBER
776
1343
STRING
777
1343
-
779
1343
True
780
1343
arith_expr
1804
1343
None
784
1343
False
786
1343
{
790
1343
~
789
1344
)
1805
1345
or
atom -> ( )
1345
<<
atom -> ( )
1345
NEWLINE
atom -> ( )
1345
not
atom -> ( )
1345
&
atom -> ( )
1345
(
atom -> ( )
1345
in
atom -> ( )
1345
**
atom -> ( )
1345
@
atom -> ( )
1345
=
atom -> ( )
1345
<=
atom -> ( )
1345
%
atom -> ( )
1345
[
atom -> ( )
1345
>=
atom -> ( )
1345
/
atom -> ( )
1345
+
atom -> ( )
1345
<
atom -> ( )
1345
is
atom -> ( )
1345
*
atom -> ( )
1345
!=
atom -> ( )
1345
-
atom -> ( )
1345
|
atom -> ( )
1345
//
atom -> ( )
1345
^
atom -> ( )
1345
and
atom -> ( )
1345
==
atom -> ( )
1345
if
atom -> ( )
1345
>
atom -> ( )
1345
,
atom -> ( )
1345
.
atom -> ( )
1345
>>
atom -> ( )
1346
factor
766
1346
term
767
1346
(
768
1346
arith_expr
769
1346
NAME
770
1346
[
771
1346
atom
772
1346
+
773
1346
power
774
1346
atom_expr
775
1346
NUMBER
776
1346
STRING
777
1346
-
779
1346
shift_expr
1806
1346
True
780
1346
None
784
1346
False
786
1346
{
790
1346
~
789
1347
factor
766
1347
term
767
1347
(
768
1347
arith_expr
769
1347
NAME
770
1347
[
771
1347
atom
772
1347
+
773
1347
power
774
1347
atom_expr
775
1347
NUMBER
776
1347
STRING
777
1347
-
779
1347
True
780
1347
shift_expr
1807
1347
None
784
1347
False
786
1347
{
790
1347
~
789
1348
<=
atom -> [ ]
1348
is
atom -> [ ]
1348
-
atom -> [ ]
1348
**
atom -> [ ]
1348
^
atom -> [ ]
1348
%
atom -> [ ]
1348
/
atom -> [ ]
1348
>=
atom -> [ ]
1348
|
atom -> [ ]
1348
not
atom -> [ ]
1348
@
atom -> [ ]
1348
*
atom -> [ ]
1348
(
atom -> [ ]
1348
,
atom -> [ ]
1348
>>
atom -> [ ]
1348
[
atom -> [ ]
1348
NEWLINE
atom -> [ ]
1348
or
atom -> [ ]
1348
!=
atom -> [ ]
1348
and
atom -> [ ]
1348
<<
atom -> [ ]
1348
if
atom -> [ ]
1348
in
atom -> [ ]
1348
+
atom -> [ ]
1348
.
atom -> [ ]
1348
==
atom -> [ ]
1348
>
atom -> [ ]
1348
=
atom -> [ ]
1348
<
atom -> [ ]
1348
&
atom -> [ ]
1348
//
atom -> [ ]
1349
]
1808
1350
trailer_expr
1809
1350
trailer
1350
1350
.
1351
1350
(
1352
1350
[
1353
1350
<<
trailer_expr -> 
1350
%
trailer_expr -> 
1350
==
trailer_expr -> 
1350
-
trailer_expr -> 
1350
<
trailer_expr -> 
1350
NEWLINE
trailer_expr -> 
1350
if
trailer_expr -> 
1350
or
trailer_expr -> 
1350
/
trailer_expr -> 
1350
**
trailer_expr -> 
1350
and
trailer_expr -> 
1350
@
trailer_expr -> 
1350
=
trailer_expr -> 
1350
*
trailer_expr -> 
1350
|
trailer_expr -> 
1350
is
trailer_expr -> 
1350
,
trailer_expr -> 
1350
+
trailer_expr -> 
1350
in
trailer_expr -> 
1350
&
trailer_expr -> 
1350
<=
trailer_expr -> 
1350
>=
trailer_expr -> 
1350
^
trailer_expr -> 
1350
>
trailer_expr -> 
1350
!=
trailer_expr -> 
1350
not
trailer_expr -> 
1350
>>
trailer_expr -> 
1350
//
trailer_expr -> 
1351
NAME
1810
1352
factor
697
1352
term
698
1352
(
699
1352
arith_expr
700
1352
NAME
701
1352
[
702
1352
atom
703
1352
+
704
1352
power
706
1352
atom_expr
707
1352
NUMBER
708
1352
STRING
709
1352
arglist
1811
1352
*
710
1352
shift_expr
711
1352
-
712
1352
argument
714
1352
)
1812
1352
True
715
1352
not_test
716
1352
lambdef
717
1352
and_expr
718
1352
xor_expr
719
1352
False
720
1352
test
721
1352
None
722
1352
expr
723
1352
and_test
724
1352
{
725
1352
~
726
1352
lambda
727
1352
comparison
728
1352
or_test
729
1352
not
730
1352
**
731
1353
factor
732
1353
or_test
733
1353
term
734
1353
(
735
1353
arith_expr
736
1353
NAME
737
1353
[
738
1353
~
739
1353
subscriptlist
1813
1353
+
741
1353
maybe_test
742
1353
expr
743
1353
atom_expr
744
1353
atom
745
1353
NUMBER
746
1353
STRING
747
1353
shift_expr
748
1353
-
749
1353
True
750
1353
not_test
751
1353
and_expr
752
1353
xor_expr
753
1353
False
754
1353
{
755
1353
None
756
1353
and_test
757
1353
lambda
758
1353
power
759
1353
subscript
760
1353
test
761
1353
lambdef
762
1353
:
maybe_test -> 
1353
comparison
763
1353
not
764
1354
>
atom_expr -> atom trailer_expr
1354
not
atom_expr -> atom trailer_expr
1354
=
atom_expr -> atom trailer_expr
1354
//
atom_expr -> atom trailer_expr
1354
>>
atom_expr -> atom trailer_expr
1354
|
atom_expr -> atom trailer_expr
1354
^
atom_expr -> atom trailer_expr
1354
/
atom_expr -> atom trailer_expr
1354
+
atom_expr -> atom trailer_expr
1354
in
atom_expr -> atom trailer_expr
1354
%
atom_expr -> atom trailer_expr
1354
and
atom_expr -> atom trailer_expr
1354
<=
atom_expr -> atom trailer_expr
1354
is
atom_expr -> atom trailer_expr
1354
<
atom_expr -> atom trailer_expr
1354
@
atom_expr -> atom trailer_expr
1354
-
atom_expr -> atom trailer_expr
1354
NEWLINE
atom_expr -> atom trailer_expr
1354
&
atom_expr -> atom trailer_expr
1354
*
atom_expr -> atom trailer_expr
1354
**
atom_expr -> atom trailer_expr
1354
>=
atom_expr -> atom trailer_expr
1354
or
atom_expr -> atom trailer_expr
1354
,
atom_expr -> atom trailer_expr
1354
==
atom_expr -> atom trailer_expr
1354
!=
atom_expr -> atom trailer_expr
1354
if
atom_expr -> atom trailer_expr
1354
<<
atom_expr -> atom trailer_expr
1355
<
factor -> + factor
1355
if
factor -> + factor
1355
<<
factor -> + factor
1355
and
factor -> + factor
1355
>=
factor -> + factor
1355
%
factor -> + factor
1355
>>
factor -> + factor
1355
*
factor -> + factor
1355
+
factor -> + factor
1355
/
factor -> + factor
1355
>
factor -> + factor
1355
<=
factor -> + factor
1355
^
factor -> + factor
1355
is
factor -> + factor
1355
|
factor -> + factor
1355
or
factor -> + factor
1355
=
factor -> + factor
1355
-
factor -> + factor
1355
in
factor -> + factor
1355
NEWLINE
factor -> + factor
1355
&
factor -> + factor
1355
not
factor -> + factor
1355
//
factor -> + factor
1355
,
factor -> + factor
1355
!=
factor -> + factor
1355
==
factor -> + factor
1355
@
factor -> + factor
1356
(
768
1356
NAME
770
1356
[
771
1356
atom
772
1356
+
773
1356
atom_expr
775
1356
power
774
1356
NUMBER
776
1356
STRING
777
1356
-
779
1356
factor
1814
1356
True
780
1356
None
784
1356
False
786
1356
{
790
1356
~
789
1357
factor
766
1357
term
767
1357
(
768
1357
arith_expr
769
1357
NAME
770
1357
[
771
1357
atom
772
1357
+
773
1357
power
774
1357
atom_expr
775
1357
NUMBER
776
1357
STRING
777
1357
shift_expr
778
1357
-
779
1357
True
780
1357
None
784
1357
and_expr
1815
1357
False
786
1357
{
790
1357
~
789
1358
and
factor -> - factor
1358
if
factor -> - factor
1358
or
factor -> - factor
1358
>=
factor -> - factor
1358
<
factor -> - factor
1358
!=
factor -> - factor
1358
-
factor -> - factor
1358
=
factor -> - factor
1358
==
factor -> - factor
1358
@
factor -> - factor
1358
|
factor -> - factor
1358
*
factor -> - factor
1358
%
factor -> - factor
1358
+
factor -> - factor
1358
<=
factor -> - factor
1358
//
factor -> - factor
1358
not
factor -> - factor
1358
>>
factor -> - factor
1358
/
factor -> - factor
1358
&
factor -> - factor
1358
^
factor -> - factor
1358
in
factor -> - factor
1358
is
factor -> - factor
1358
>
factor -> - factor
1358
NEWLINE
factor -> - factor
1358
,
factor -> - factor
1358
<<
factor -> - factor
1359
factor
766
1359
term
767
1359
(
768
1359
arith_expr
769
1359
NAME
770
1359
[
771
1359
atom
772
1359
+
773
1359
power
774
1359
atom_expr
775
1359
NUMBER
776
1359
STRING
777
1359
shift_expr
778
1359
-
779
1359
True
780
1359
not_test
781
1359
and_expr
782
1359
xor_expr
783
1359
None
784
1359
expr
785
1359
False
786
1359
~
789
1359
{
790
1359
and_test
1816
1359
not
792
1359
comparison
797
1360
factor
766
1360
term
767
1360
(
768
1360
arith_expr
769
1360
NAME
770
1360
[
771
1360
atom
772
1360
+
773
1360
power
774
1360
atom_expr
775
1360
NUMBER
776
1360
STRING
777
1360
shift_expr
778
1360
-
779
1360
True
780
1360
and_expr
782
1360
None
784
1360
False
786
1360
{
790
1360
~
789
1360
xor_expr
1817
1361
factor
766
1361
term
767
1361
(
768
1361
arith_expr
769
1361
NAME
770
1361
[
771
1361
atom
772
1361
+
773
1361
power
774
1361
atom_expr
775
1361
NUMBER
776
1361
STRING
777
1361
shift_expr
778
1361
-
779
1361
True
780
1361
and_expr
782
1361
xor_expr
783
1361
None
784
1361
False
786
1361
~
789
1361
{
790
1361
expr
1818
1362
factor
766
1362
term
767
1362
(
768
1362
arith_expr
769
1362
NAME
770
1362
[
771
1362
atom
772
1362
+
773
1362
power
774
1362
atom_expr
775
1362
NUMBER
776
1362
STRING
777
1362
shift_expr
778
1362
-
779
1362
True
780
1362
and_expr
782
1362
comparison
1819
1362
xor_expr
783
1362
None
784
1362
expr
785
1362
False
786
1362
~
789
1362
{
790
1363
factor
766
1363
term
767
1363
(
768
1363
arith_expr
769
1363
NAME
770
1363
[
771
1363
atom
772
1363
+
773
1363
or_test
1820
1363
power
774
1363
atom_expr
775
1363
NUMBER
776
1363
STRING
777
1363
shift_expr
778
1363
-
779
1363
True
780
1363
not_test
781
1363
and_expr
782
1363
xor_expr
783
1363
None
784
1363
expr
785
1363
False
786
1363
and_test
787
1363
~
789
1363
{
790
1363
not
792
1363
comparison
797
1364
factor
766
1364
term
767
1364
(
768
1364
arith_expr
769
1364
NAME
770
1364
[
771
1364
atom
772
1364
+
773
1364
power
774
1364
atom_expr
775
1364
NUMBER
776
1364
STRING
777
1364
shift_expr
778
1364
-
779
1364
True
780
1364
not_test
781
1364
and_expr
782
1364
xor_expr
783
1364
None
784
1364
expr
785
1364
False
786
1364
and_test
787
1364
lambda
788
1364
~
789
1364
{
790
1364
not
792
1364
or_test
793
1364
lambdef
795
1364
test
1821
1364
comparison
797
1365
:
1822
1366
or
factor -> ~ factor
1366
==
factor -> ~ factor
1366
<=
factor -> ~ factor
1366
@
factor -> ~ factor
1366
!=
factor -> ~ factor
1366
>=
factor -> ~ factor
1366
>
factor -> ~ factor
1366
and
factor -> ~ factor
1366
,
factor -> ~ factor
1366
*
factor -> ~ factor
1366
&
factor -> ~ factor
1366
%
factor -> ~ factor
1366
<
factor -> ~ factor
1366
//
factor -> ~ factor
1366
=
factor -> ~ factor
1366
if
factor -> ~ factor
1366
^
factor -> ~ factor
1366
/
factor -> ~ factor
1366
in
factor -> ~ factor
1366
+
factor -> ~ factor
1366
not
factor -> ~ factor
1366
-
factor -> ~ factor
1366
is
factor -> ~ factor
1366
>>
factor -> ~ factor
1366
<<
factor -> ~ factor
1366
NEWLINE
factor -> ~ factor
1366
|
factor -> ~ factor
1367
>
atom -> { }
1367
==
atom -> { }
1367
-
atom -> { }
1367
not
atom -> { }
1367
(
atom -> { }
1367
@
atom -> { }
1367
if
atom -> { }
1367
and
atom -> { }
1367
,
atom -> { }
1367
&
atom -> { }
1367
<<
atom -> { }
1367
!=
atom -> { }
1367
or
atom -> { }
1367
>>
atom -> { }
1367
<=
atom -> { }
1367
NEWLINE
atom -> { }
1367
>=
atom -> { }
1367
is
atom -> { }
1367
/
atom -> { }
1367
=
atom -> { }
1367
^
atom -> { }
1367
[
atom -> { }
1367
%
atom -> { }
1367
//
atom -> { }
1367
*
atom -> { }
1367
**
atom -> { }
1367
.
atom -> { }
1367
in
atom -> { }
1367
+
atom -> { }
1367
|
atom -> { }
1367
<
atom -> { }
1368
factor
766
1368
term
767
1368
(
768
1368
arith_expr
769
1368
NAME
770
1368
[
771
1368
atom
772
1368
+
773
1368
test_list
1823
1368
power
774
1368
atom_expr
775
1368
NUMBER
776
1368
STRING
777
1368
shift_expr
778
1368
-
779
1368
True
780
1368
not_test
781
1368
and_expr
782
1368
xor_expr
783
1368
None
784
1368
expr
785
1368
False
786
1368
and_test
787
1368
lambda
788
1368
~
789
1368
{
790
1368
test
791
1368
not
792
1368
or_test
793
1368
lambdef
795
1368
comparison
797
1369
or
not_test -> not not_test
1369
,
not_test -> not not_test
1369
and
not_test -> not not_test
1369
if
not_test -> not not_test
1369
NEWLINE
not_test -> not not_test
1369
=
not_test -> not not_test
1370
factor
585
1370
(
586
1370
arith_expr
587
1370
NAME
588
1370
[
589
1370
and_expr
590
1370
+
591
1370
term
592
1370
atom_expr
593
1370
NUMBER
594
1370
atom
595
1370
STRING
596
1370
shift_expr
597
1370
-
598
1370
True
599
1370
not
600
1370
xor_expr
601
1370
None
602
1370
False
603
1370
not_test
605
1370
~
606
1370
power
607
1370
{
608
1370
expr
609
1370
or_test
1824
1370
comparison
610
1370
and_test
611
1371
NEWLINE
assign -> = yield_expr assign
1372
=
yield_arg -> test_list
1372
NEWLINE
yield_arg -> test_list
1373
NEWLINE
yield_expr -> yield yield_arg
1373
=
yield_expr -> yield yield_arg
1374
factor
1825
1374
(
1826
1374
arith_expr
1827
1374
NAME
1828
1374
[
1829
1374
atom
1830
1374
+
1831
1374
term
1832
1374
power
1833
1374
atom_expr
1834
1374
NUMBER
1835
1374
STRING
1836
1374
shift_expr
1837
1374
-
1838
1374
test
1839
1374
True
1840
1374
and_expr
1841
1374
xor_expr
1842
1374
None
1843
1374
expr
1844
1374
False
1845
1374
and_test
1846
1374
lambda
1847
1374
~
1848
1374
not_test
1849
1374
{
1850
1374
not
1851
1374
lambdef
1852
1374
or_test
1853
1374
comparison
1854
1375
NEWLINE
assign -> = test_list assign
1376
NEWLINE
yield_arg -> test_list
1377
factor
396
1377
(
397
1377
arith_expr
398
1377
NAME
399
1377
[
400
1377
+
401
1377
term
402
1377
atom_expr
403
1377
atom
404
1377
NUMBER
405
1377
STRING
406
1377
shift_expr
407
1377
-
408
1377
test
1855
1377
True
409
1377
and_expr
410
1377
xor_expr
411
1377
None
412
1377
expr
413
1377
False
414
1377
and_test
415
1377
lambda
416
1377
{
417
1377
~
418
1377
power
419
1377
not_test
420
1377
not
421
1377
comparison
422
1377
or_test
423
1377
lambdef
424
1378
NEWLINE
yield_expr -> yield yield_arg
1379
factor
803
1379
(
804
1379
NAME
806
1379
[
807
1379
atom
808
1379
+
809
1379
atom_expr
812
1379
power
811
1379
NUMBER
813
1379
STRING
814
1379
-
816
1379
term
1856
1379
True
817
1379
None
820
1379
False
821
1379
{
823
1379
~
824
1380
factor
803
1380
(
804
1380
NAME
806
1380
[
807
1380
atom
808
1380
+
809
1380
atom_expr
812
1380
power
811
1380
NUMBER
813
1380
STRING
814
1380
-
816
1380
True
817
1380
None
820
1380
term
1857
1380
False
821
1380
{
823
1380
~
824
1381
factor
803
1381
(
804
1381
NAME
806
1381
term
1858
1381
[
807
1381
atom
808
1381
+
809
1381
atom_expr
812
1381
power
811
1381
NUMBER
813
1381
STRING
814
1381
-
816
1381
True
817
1381
None
820
1381
False
821
1381
{
823
1381
~
824
1382
factor
803
1382
(
804
1382
NAME
806
1382
[
807
1382
atom
808
1382
+
809
1382
atom_expr
812
1382
power
811
1382
NUMBER
813
1382
STRING
814
1382
-
816
1382
term
1859
1382
True
817
1382
None
820
1382
False
821
1382
{
823
1382
~
824
1383
factor
803
1383
(
804
1383
NAME
806
1383
[
807
1383
atom
808
1383
+
809
1383
atom_expr
812
1383
power
811
1383
NUMBER
813
1383
term
1860
1383
STRING
814
1383
-
816
1383
True
817
1383
None
820
1383
False
821
1383
{
823
1383
~
824
1384
)
1861
1385
or
atom -> ( )
1385
<<
atom -> ( )
1385
not
atom -> ( )
1385
&
atom -> ( )
1385
(
atom -> ( )
1385
in
atom -> ( )
1385
**
atom -> ( )
1385
@
atom -> ( )
1385
=
atom -> ( )
1385
<=
atom -> ( )
1385
%
atom -> ( )
1385
[
atom -> ( )
1385
>=
atom -> ( )
1385
/
atom -> ( )
1385
+
atom -> ( )
1385
<
atom -> ( )
1385
is
atom -> ( )
1385
*
atom -> ( )
1385
!=
atom -> ( )
1385
-
atom -> ( )
1385
|
atom -> ( )
1385
//
atom -> ( )
1385
^
atom -> ( )
1385
and
atom -> ( )
1385
==
atom -> ( )
1385
if
atom -> ( )
1385
>
atom -> ( )
1385
.
atom -> ( )
1385
>>
atom -> ( )
1386
factor
803
1386
(
804
1386
arith_expr
805
1386
NAME
806
1386
[
807
1386
atom
808
1386
+
809
1386
term
810
1386
power
811
1386
atom_expr
812
1386
NUMBER
813
1386
STRING
814
1386
-
816
1386
shift_expr
1862
1386
True
817
1386
None
820
1386
False
821
1386
{
823
1386
~
824
1387
factor
803
1387
(
804
1387
arith_expr
805
1387
NAME
806
1387
[
807
1387
atom
808
1387
+
809
1387
term
810
1387
power
811
1387
atom_expr
812
1387
NUMBER
813
1387
STRING
814
1387
-
816
1387
True
817
1387
shift_expr
1863
1387
None
820
1387
False
821
1387
{
823
1387
~
824
1388
<=
atom -> [ ]
1388
is
atom -> [ ]
1388
-
atom -> [ ]
1388
**
atom -> [ ]
1388
^
atom -> [ ]
1388
%
atom -> [ ]
1388
/
atom -> [ ]
1388
>=
atom -> [ ]
1388
|
atom -> [ ]
1388
not
atom -> [ ]
1388
@
atom -> [ ]
1388
*
atom -> [ ]
1388
(
atom -> [ ]
1388
>>
atom -> [ ]
1388
[
atom -> [ ]
1388
or
atom -> [ ]
1388
!=
atom -> [ ]
1388
and
atom -> [ ]
1388
<<
atom -> [ ]
1388
if
atom -> [ ]
1388
in
atom -> [ ]
1388
+
atom -> [ ]
1388
.
atom -> [ ]
1388
==
atom -> [ ]
1388
>
atom -> [ ]
1388
=
atom -> [ ]
1388
<
atom -> [ ]
1388
&
atom -> [ ]
1388
//
atom -> [ ]
1389
]
1864
1390
trailer_expr
1865
1390
trailer
1390
1390
.
1391
1390
(
1392
1390
[
1393
1390
<<
trailer_expr -> 
1390
%
trailer_expr -> 
1390
==
trailer_expr -> 
1390
-
trailer_expr -> 
1390
<
trailer_expr -> 
1390
if
trailer_expr -> 
1390
or
trailer_expr -> 
1390
/
trailer_expr -> 
1390
**
trailer_expr -> 
1390
and
trailer_expr -> 
1390
@
trailer_expr -> 
1390
=
trailer_expr -> 
1390
*
trailer_expr -> 
1390
|
trailer_expr -> 
1390
is
trailer_expr -> 
1390
+
trailer_expr -> 
1390
in
trailer_expr -> 
1390
&
trailer_expr -> 
1390
<=
trailer_expr -> 
1390
>=
trailer_expr -> 
1390
^
trailer_expr -> 
1390
>
trailer_expr -> 
1390
!=
trailer_expr -> 
1390
not
trailer_expr -> 
1390
>>
trailer_expr -> 
1390
//
trailer_expr -> 
1391
NAME
1866
1392
factor
697
1392
term
698
1392
(
699
1392
arith_expr
700
1392
NAME
701
1392
[
702
1392
atom
703
1392
+
704
1392
power
706
1392
atom_expr
707
1392
NUMBER
708
1392
STRING
709
1392
*
710
1392
shift_expr
711
1392
-
712
1392
argument
714
1392
)
1867
1392
True
715
1392
not_test
716
1392
lambdef
717
1392
and_expr
718
1392
xor_expr
719
1392
False
720
1392
test
721
1392
None
722
1392
arglist
1868
1392
expr
723
1392
and_test
724
1392
{
725
1392
~
726
1392
lambda
727
1392
comparison
728
1392
or_test
729
1392
not
730
1392
**
731
1393
factor
732
1393
or_test
733
1393
term
734
1393
(
735
1393
arith_expr
736
1393
NAME
737
1393
[
738
1393
~
739
1393
subscriptlist
1869
1393
+
741
1393
maybe_test
742
1393
expr
743
1393
atom_expr
744
1393
atom
745
1393
NUMBER
746
1393
STRING
747
1393
shift_expr
748
1393
-
749
1393
True
750
1393
not_test
751
1393
and_expr
752
1393
xor_expr
753
1393
False
754
1393
{
755
1393
None
756
1393
and_test
757
1393
lambda
758
1393
power
759
1393
subscript
760
1393
test
761
1393
lambdef
762
1393
:
maybe_test -> 
1393
comparison
763
1393
not
764
1394
>
atom_expr -> atom trailer_expr
1394
not
atom_expr -> atom trailer_expr
1394
=
atom_expr -> atom trailer_expr
1394
//
atom_expr -> atom trailer_expr
1394
>>
atom_expr -> atom trailer_expr
1394
|
atom_expr -> atom trailer_expr
1394
^
atom_expr -> atom trailer_expr
1394
/
atom_expr -> atom trailer_expr
1394
+
atom_expr -> atom trailer_expr
1394
in
atom_expr -> atom trailer_expr
1394
%
atom_expr -> atom trailer_expr
1394
and
atom_expr -> atom trailer_expr
1394
<=
atom_expr -> atom trailer_expr
1394
is
atom_expr -> atom trailer_expr
1394
<
atom_expr -> atom trailer_expr
1394
@
atom_expr -> atom trailer_expr
1394
-
atom_expr -> atom trailer_expr
1394
&
atom_expr -> atom trailer_expr
1394
*
atom_expr -> atom trailer_expr
1394
**
atom_expr -> atom trailer_expr
1394
>=
atom_expr -> atom trailer_expr
1394
or
atom_expr -> atom trailer_expr
1394
==
atom_expr -> atom trailer_expr
1394
!=
atom_expr -> atom trailer_expr
1394
if
atom_expr -> atom trailer_expr
1394
<<
atom_expr -> atom trailer_expr
1395
<
factor -> + factor
1395
if
factor -> + factor
1395
<<
factor -> + factor
1395
and
factor -> + factor
1395
>=
factor -> + factor
1395
%
factor -> + factor
1395
>>
factor -> + factor
1395
*
factor -> + factor
1395
+
factor -> + factor
1395
/
factor -> + factor
1395
>
factor -> + factor
1395
<=
factor -> + factor
1395
^
factor -> + factor
1395
is
factor -> + factor
1395
|
factor -> + factor
1395
or
factor -> + factor
1395
=
factor -> + factor
1395
-
factor -> + factor
1395
in
factor -> + factor
1395
&
factor -> + factor
1395
not
factor -> + factor
1395
//
factor -> + factor
1395
!=
factor -> + factor
1395
==
factor -> + factor
1395
@
factor -> + factor
1396
factor
803
1396
(
804
1396
NAME
806
1396
[
807
1396
atom
808
1396
+
809
1396
term
810
1396
power
811
1396
atom_expr
812
1396
NUMBER
813
1396
STRING
814
1396
-
816
1396
True
817
1396
arith_expr
1870
1396
None
820
1396
False
821
1396
{
823
1396
~
824
1397
factor
803
1397
(
804
1397
NAME
806
1397
[
807
1397
atom
808
1397
+
809
1397
term
810
1397
power
811
1397
atom_expr
812
1397
NUMBER
813
1397
STRING
814
1397
-
816
1397
True
817
1397
arith_expr
1871
1397
None
820
1397
False
821
1397
{
823
1397
~
824
1398
(
804
1398
NAME
806
1398
[
807
1398
atom
808
1398
+
809
1398
atom_expr
812
1398
power
811
1398
NUMBER
813
1398
STRING
814
1398
-
816
1398
factor
1872
1398
True
817
1398
None
820
1398
False
821
1398
{
823
1398
~
824
1399
factor
803
1399
(
804
1399
arith_expr
805
1399
NAME
806
1399
[
807
1399
atom
808
1399
+
809
1399
term
810
1399
power
811
1399
atom_expr
812
1399
NUMBER
813
1399
STRING
814
1399
shift_expr
815
1399
-
816
1399
True
817
1399
None
820
1399
and_expr
1873
1399
False
821
1399
{
823
1399
~
824
1400
and
factor -> - factor
1400
if
factor -> - factor
1400
or
factor -> - factor
1400
>=
factor -> - factor
1400
<
factor -> - factor
1400
!=
factor -> - factor
1400
-
factor -> - factor
1400
=
factor -> - factor
1400
==
factor -> - factor
1400
@
factor -> - factor
1400
|
factor -> - factor
1400
*
factor -> - factor
1400
%
factor -> - factor
1400
+
factor -> - factor
1400
<=
factor -> - factor
1400
//
factor -> - factor
1400
not
factor -> - factor
1400
>>
factor -> - factor
1400
/
factor -> - factor
1400
&
factor -> - factor
1400
^
factor -> - factor
1400
in
factor -> - factor
1400
is
factor -> - factor
1400
>
factor -> - factor
1400
<<
factor -> - factor
1401
factor
803
1401
(
804
1401
arith_expr
805
1401
NAME
806
1401
[
807
1401
atom
808
1401
+
809
1401
term
810
1401
power
811
1401
atom_expr
812
1401
NUMBER
813
1401
STRING
814
1401
shift_expr
815
1401
-
816
1401
True
817
1401
and_expr
818
1401
None
820
1401
False
821
1401
{
823
1401
~
824
1401
xor_expr
1874
1402
factor
803
1402
(
804
1402
arith_expr
805
1402
NAME
806
1402
[
807
1402
atom
808
1402
+
809
1402
term
810
1402
power
811
1402
atom_expr
812
1402
NUMBER
813
1402
STRING
814
1402
shift_expr
815
1402
-
816
1402
True
817
1402
and_expr
818
1402
xor_expr
819
1402
None
820
1402
False
821
1402
{
823
1402
~
824
1402
expr
1875
1403
factor
803
1403
(
804
1403
arith_expr
805
1403
NAME
806
1403
[
807
1403
atom
808
1403
+
809
1403
term
810
1403
power
811
1403
atom_expr
812
1403
NUMBER
813
1403
STRING
814
1403
shift_expr
815
1403
-
816
1403
True
817
1403
and_expr
818
1403
xor_expr
819
1403
None
820
1403
False
821
1403
and_test
822
1403
{
823
1403
~
824
1403
not_test
825
1403
expr
826
1403
not
830
1403
comparison
831
1403
or_test
1876
1404
>
atom -> { }
1404
==
atom -> { }
1404
-
atom -> { }
1404
not
atom -> { }
1404
(
atom -> { }
1404
@
atom -> { }
1404
if
atom -> { }
1404
and
atom -> { }
1404
&
atom -> { }
1404
<<
atom -> { }
1404
!=
atom -> { }
1404
or
atom -> { }
1404
>>
atom -> { }
1404
<=
atom -> { }
1404
>=
atom -> { }
1404
is
atom -> { }
1404
/
atom -> { }
1404
=
atom -> { }
1404
^
atom -> { }
1404
[
atom -> { }
1404
%
atom -> { }
1404
//
atom -> { }
1404
*
atom -> { }
1404
**
atom -> { }
1404
.
atom -> { }
1404
in
atom -> { }
1404
+
atom -> { }
1404
|
atom -> { }
1404
<
atom -> { }
1405
or
factor -> ~ factor
1405
==
factor -> ~ factor
1405
<=
factor -> ~ factor
1405
@
factor -> ~ factor
1405
!=
factor -> ~ factor
1405
>=
factor -> ~ factor
1405
>
factor -> ~ factor
1405
and
factor -> ~ factor
1405
*
factor -> ~ factor
1405
&
factor -> ~ factor
1405
%
factor -> ~ factor
1405
<
factor -> ~ factor
1405
//
factor -> ~ factor
1405
=
factor -> ~ factor
1405
if
factor -> ~ factor
1405
^
factor -> ~ factor
1405
/
factor -> ~ factor
1405
in
factor -> ~ factor
1405
+
factor -> ~ factor
1405
not
factor -> ~ factor
1405
-
factor -> ~ factor
1405
is
factor -> ~ factor
1405
>>
factor -> ~ factor
1405
<<
factor -> ~ factor
1405
|
factor -> ~ factor
1406
factor
803
1406
(
804
1406
arith_expr
805
1406
NAME
806
1406
[
807
1406
atom
808
1406
+
809
1406
term
810
1406
power
811
1406
atom_expr
812
1406
NUMBER
813
1406
STRING
814
1406
shift_expr
815
1406
-
816
1406
True
817
1406
and_expr
818
1406
xor_expr
819
1406
None
820
1406
False
821
1406
{
823
1406
~
824
1406
not_test
825
1406
and_test
1877
1406
expr
826
1406
not
830
1406
comparison
831
1407
factor
803
1407
(
804
1407
arith_expr
805
1407
NAME
806
1407
[
807
1407
atom
808
1407
+
809
1407
term
810
1407
power
811
1407
atom_expr
812
1407
NUMBER
813
1407
STRING
814
1407
shift_expr
815
1407
-
816
1407
True
817
1407
and_expr
818
1407
comparison
1878
1407
xor_expr
819
1407
None
820
1407
False
821
1407
{
823
1407
~
824
1407
expr
826
1408
factor
803
1408
(
804
1408
arith_expr
805
1408
NAME
806
1408
[
807
1408
atom
808
1408
+
809
1408
term
810
1408
power
811
1408
atom_expr
812
1408
NUMBER
813
1408
STRING
814
1408
shift_expr
815
1408
-
816
1408
True
817
1408
and_expr
818
1408
xor_expr
819
1408
None
820
1408
False
821
1408
and_test
822
1408
{
823
1408
~
824
1408
not_test
825
1408
expr
826
1408
lambdef
827
1408
lambda
828
1408
or_test
829
1408
not
830
1408
comparison
831
1408
test
1879
1409
:
1880
1410
factor
585
1410
(
586
1410
arith_expr
587
1410
NAME
588
1410
[
589
1410
and_expr
590
1410
+
591
1410
term
592
1410
atom_expr
593
1410
NUMBER
594
1410
atom
595
1410
STRING
596
1410
shift_expr
597
1410
-
598
1410
True
599
1410
not
600
1410
xor_expr
601
1410
None
602
1410
False
603
1410
not_test
605
1410
~
606
1410
power
607
1410
{
608
1410
expr
609
1410
comparison
610
1410
and_test
611
1410
or_test
1881
1411
if
not_test -> not not_test
1411
=
not_test -> not not_test
1411
or
not_test -> not not_test
1411
and
not_test -> not not_test
1412
factor
396
1412
(
397
1412
arith_expr
398
1412
NAME
399
1412
[
400
1412
+
401
1412
term
402
1412
atom_expr
403
1412
atom
404
1412
NUMBER
405
1412
STRING
406
1412
shift_expr
407
1412
-
408
1412
True
409
1412
and_expr
410
1412
xor_expr
411
1412
None
412
1412
expr
413
1412
False
414
1412
and_test
415
1412
lambda
416
1412
{
417
1412
~
418
1412
power
419
1412
not_test
420
1412
not
421
1412
test
1882
1412
comparison
422
1412
or_test
423
1412
lambdef
424
1413
and
term -> factor // term
1413
if
term -> factor // term
1413
>
term -> factor // term
1413
<
term -> factor // term
1413
==
term -> factor // term
1413
+
term -> factor // term
1413
-
term -> factor // term
1413
&
term -> factor // term
1413
in
term -> factor // term
1413
!=
term -> factor // term
1413
^
term -> factor // term
1413
or
term -> factor // term
1413
NEWLINE
term -> factor // term
1413
<=
term -> factor // term
1413
>=
term -> factor // term
1413
|
term -> factor // term
1413
from
term -> factor // term
1413
>>
term -> factor // term
1413
not
term -> factor // term
1413
is
term -> factor // term
1413
<<
term -> factor // term
1414
^
term -> factor * term
1414
+
term -> factor * term
1414
==
term -> factor * term
1414
>>
term -> factor * term
1414
in
term -> factor * term
1414
and
term -> factor * term
1414
if
term -> factor * term
1414
is
term -> factor * term
1414
<<
term -> factor * term
1414
-
term -> factor * term
1414
!=
term -> factor * term
1414
or
term -> factor * term
1414
>
term -> factor * term
1414
&
term -> factor * term
1414
from
term -> factor * term
1414
NEWLINE
term -> factor * term
1414
>=
term -> factor * term
1414
|
term -> factor * term
1414
<=
term -> factor * term
1414
not
term -> factor * term
1414
<
term -> factor * term
1415
&
term -> factor % term
1415
from
term -> factor % term
1415
==
term -> factor % term
1415
!=
term -> factor % term
1415
<
term -> factor % term
1415
in
term -> factor % term
1415
>>
term -> factor % term
1415
<<
term -> factor % term
1415
NEWLINE
term -> factor % term
1415
-
term -> factor % term
1415
if
term -> factor % term
1415
>
term -> factor % term
1415
or
term -> factor % term
1415
^
term -> factor % term
1415
+
term -> factor % term
1415
is
term -> factor % term
1415
|
term -> factor % term
1415
>=
term -> factor % term
1415
<=
term -> factor % term
1415
and
term -> factor % term
1415
not
term -> factor % term
1416
and
term -> factor @ term
1416
in
term -> factor @ term
1416
>=
term -> factor @ term
1416
<
term -> factor @ term
1416
>
term -> factor @ term
1416
-
term -> factor @ term
1416
NEWLINE
term -> factor @ term
1416
or
term -> factor @ term
1416
<<
term -> factor @ term
1416
is
term -> factor @ term
1416
!=
term -> factor @ term
1416
|
term -> factor @ term
1416
&
term -> factor @ term
1416
==
term -> factor @ term
1416
>>
term -> factor @ term
1416
<=
term -> factor @ term
1416
not
term -> factor @ term
1416
from
term -> factor @ term
1416
+
term -> factor @ term
1416
^
term -> factor @ term
1416
if
term -> factor @ term
1417
from
term -> factor / term
1417
or
term -> factor / term
1417
<<
term -> factor / term
1417
not
term -> factor / term
1417
in
term -> factor / term
1417
!=
term -> factor / term
1417
<
term -> factor / term
1417
+
term -> factor / term
1417
and
term -> factor / term
1417
>>
term -> factor / term
1417
^
term -> factor / term
1417
<=
term -> factor / term
1417
==
term -> factor / term
1417
>
term -> factor / term
1417
&
term -> factor / term
1417
is
term -> factor / term
1417
-
term -> factor / term
1417
NEWLINE
term -> factor / term
1417
|
term -> factor / term
1417
>=
term -> factor / term
1417
if
term -> factor / term
1418
+
power -> atom_expr ** factor
1418
&
power -> atom_expr ** factor
1418
>>
power -> atom_expr ** factor
1418
<<
power -> atom_expr ** factor
1418
not
power -> atom_expr ** factor
1418
is
power -> atom_expr ** factor
1418
@
power -> atom_expr ** factor
1418
==
power -> atom_expr ** factor
1418
*
power -> atom_expr ** factor
1418
or
power -> atom_expr ** factor
1418
>
power -> atom_expr ** factor
1418
from
power -> atom_expr ** factor
1418
-
power -> atom_expr ** factor
1418
if
power -> atom_expr ** factor
1418
!=
power -> atom_expr ** factor
1418
>=
power -> atom_expr ** factor
1418
/
power -> atom_expr ** factor
1418
%
power -> atom_expr ** factor
1418
and
power -> atom_expr ** factor
1418
<=
power -> atom_expr ** factor
1418
NEWLINE
power -> atom_expr ** factor
1418
<
power -> atom_expr ** factor
1418
|
power -> atom_expr ** factor
1418
^
power -> atom_expr ** factor
1418
in
power -> atom_expr ** factor
1418
//
power -> atom_expr ** factor
1419
+
atom -> ( test_list_comp )
1419
/
atom -> ( test_list_comp )
1419
*
atom -> ( test_list_comp )
1419
[
atom -> ( test_list_comp )
1419
&
atom -> ( test_list_comp )
1419
**
atom -> ( test_list_comp )
1419
^
atom -> ( test_list_comp )
1419
(
atom -> ( test_list_comp )
1419
and
atom -> ( test_list_comp )
1419
>
atom -> ( test_list_comp )
1419
-
atom -> ( test_list_comp )
1419
%
atom -> ( test_list_comp )
1419
//
atom -> ( test_list_comp )
1419
in
atom -> ( test_list_comp )
1419
>>
atom -> ( test_list_comp )
1419
not
atom -> ( test_list_comp )
1419
>=
atom -> ( test_list_comp )
1419
or
atom -> ( test_list_comp )
1419
<
atom -> ( test_list_comp )
1419
if
atom -> ( test_list_comp )
1419
|
atom -> ( test_list_comp )
1419
<<
atom -> ( test_list_comp )
1419
@
atom -> ( test_list_comp )
1419
!=
atom -> ( test_list_comp )
1419
is
atom -> ( test_list_comp )
1419
NEWLINE
atom -> ( test_list_comp )
1419
.
atom -> ( test_list_comp )
1419
<=
atom -> ( test_list_comp )
1419
from
atom -> ( test_list_comp )
1419
==
atom -> ( test_list_comp )
1420
>=
shift_expr -> arith_expr >> shift_expr
1420
from
shift_expr -> arith_expr >> shift_expr
1420
if
shift_expr -> arith_expr >> shift_expr
1420
<=
shift_expr -> arith_expr >> shift_expr
1420
!=
shift_expr -> arith_expr >> shift_expr
1420
or
shift_expr -> arith_expr >> shift_expr
1420
|
shift_expr -> arith_expr >> shift_expr
1420
is
shift_expr -> arith_expr >> shift_expr
1420
and
shift_expr -> arith_expr >> shift_expr
1420
NEWLINE
shift_expr -> arith_expr >> shift_expr
1420
in
shift_expr -> arith_expr >> shift_expr
1420
^
shift_expr -> arith_expr >> shift_expr
1420
not
shift_expr -> arith_expr >> shift_expr
1420
<
shift_expr -> arith_expr >> shift_expr
1420
==
shift_expr -> arith_expr >> shift_expr
1420
&
shift_expr -> arith_expr >> shift_expr
1420
>
shift_expr -> arith_expr >> shift_expr
1421
>
shift_expr -> arith_expr << shift_expr
1421
or
shift_expr -> arith_expr << shift_expr
1421
^
shift_expr -> arith_expr << shift_expr
1421
not
shift_expr -> arith_expr << shift_expr
1421
<
shift_expr -> arith_expr << shift_expr
1421
if
shift_expr -> arith_expr << shift_expr
1421
in
shift_expr -> arith_expr << shift_expr
1421
!=
shift_expr -> arith_expr << shift_expr
1421
==
shift_expr -> arith_expr << shift_expr
1421
|
shift_expr -> arith_expr << shift_expr
1421
>=
shift_expr -> arith_expr << shift_expr
1421
and
shift_expr -> arith_expr << shift_expr
1421
from
shift_expr -> arith_expr << shift_expr
1421
NEWLINE
shift_expr -> arith_expr << shift_expr
1421
&
shift_expr -> arith_expr << shift_expr
1421
<=
shift_expr -> arith_expr << shift_expr
1421
is
shift_expr -> arith_expr << shift_expr
1422
factor
340
1422
atom_expr
341
1422
(
342
1422
arith_expr
343
1422
lambda
344
1422
NAME
345
1422
[
346
1422
+
347
1422
term
348
1422
atom
349
1422
NUMBER
350
1422
shift_expr
351
1422
STRING
352
1422
-
353
1422
or_test
354
1422
True
355
1422
and_expr
356
1422
not
357
1422
xor_expr
358
1422
None
359
1422
expr
360
1422
False
361
1422
and_test
362
1422
{
363
1422
~
364
1422
power
365
1422
not_test
366
1422
comparison
367
1422
lambdef
368
1422
test
1883
1423
from
lambdef -> lambda : test
1423
NEWLINE
lambdef -> lambda : test
1424
in
atom -> [ test_list_comp ]
1424
/
atom -> [ test_list_comp ]
1424
or
atom -> [ test_list_comp ]
1424
if
atom -> [ test_list_comp ]
1424
<<
atom -> [ test_list_comp ]
1424
!=
atom -> [ test_list_comp ]
1424
<=
atom -> [ test_list_comp ]
1424
>>
atom -> [ test_list_comp ]
1424
*
atom -> [ test_list_comp ]
1424
^
atom -> [ test_list_comp ]
1424
.
atom -> [ test_list_comp ]
1424
(
atom -> [ test_list_comp ]
1424
>=
atom -> [ test_list_comp ]
1424
and
atom -> [ test_list_comp ]
1424
<
atom -> [ test_list_comp ]
1424
[
atom -> [ test_list_comp ]
1424
==
atom -> [ test_list_comp ]
1424
@
atom -> [ test_list_comp ]
1424
%
atom -> [ test_list_comp ]
1424
-
atom -> [ test_list_comp ]
1424
|
atom -> [ test_list_comp ]
1424
&
atom -> [ test_list_comp ]
1424
+
atom -> [ test_list_comp ]
1424
is
atom -> [ test_list_comp ]
1424
//
atom -> [ test_list_comp ]
1424
**
atom -> [ test_list_comp ]
1424
from
atom -> [ test_list_comp ]
1424
not
atom -> [ test_list_comp ]
1424
NEWLINE
atom -> [ test_list_comp ]
1424
>
atom -> [ test_list_comp ]
1425
==
arith_expr -> term + arith_expr
1425
!=
arith_expr -> term + arith_expr
1425
<<
arith_expr -> term + arith_expr
1425
&
arith_expr -> term + arith_expr
1425
<
arith_expr -> term + arith_expr
1425
^
arith_expr -> term + arith_expr
1425
>=
arith_expr -> term + arith_expr
1425
NEWLINE
arith_expr -> term + arith_expr
1425
from
arith_expr -> term + arith_expr
1425
in
arith_expr -> term + arith_expr
1425
>>
arith_expr -> term + arith_expr
1425
not
arith_expr -> term + arith_expr
1425
<=
arith_expr -> term + arith_expr
1425
is
arith_expr -> term + arith_expr
1425
|
arith_expr -> term + arith_expr
1425
and
arith_expr -> term + arith_expr
1425
or
arith_expr -> term + arith_expr
1425
if
arith_expr -> term + arith_expr
1425
>
arith_expr -> term + arith_expr
1426
if
arith_expr -> term - arith_expr
1426
&
arith_expr -> term - arith_expr
1426
>>
arith_expr -> term - arith_expr
1426
NEWLINE
arith_expr -> term - arith_expr
1426
!=
arith_expr -> term - arith_expr
1426
>=
arith_expr -> term - arith_expr
1426
|
arith_expr -> term - arith_expr
1426
>
arith_expr -> term - arith_expr
1426
<
arith_expr -> term - arith_expr
1426
==
arith_expr -> term - arith_expr
1426
from
arith_expr -> term - arith_expr
1426
and
arith_expr -> term - arith_expr
1426
is
arith_expr -> term - arith_expr
1426
in
arith_expr -> term - arith_expr
1426
^
arith_expr -> term - arith_expr
1426
<<
arith_expr -> term - arith_expr
1426
not
arith_expr -> term - arith_expr
1426
or
arith_expr -> term - arith_expr
1426
<=
arith_expr -> term - arith_expr
1427
+
trailer_expr -> trailer trailer_expr
1427
*
trailer_expr -> trailer trailer_expr
1427
/
trailer_expr -> trailer trailer_expr
1427
not
trailer_expr -> trailer trailer_expr
1427
<<
trailer_expr -> trailer trailer_expr
1427
!=
trailer_expr -> trailer trailer_expr
1427
>=
trailer_expr -> trailer trailer_expr
1427
>>
trailer_expr -> trailer trailer_expr
1427
|
trailer_expr -> trailer trailer_expr
1427
%
trailer_expr -> trailer trailer_expr
1427
>
trailer_expr -> trailer trailer_expr
1427
&
trailer_expr -> trailer trailer_expr
1427
-
trailer_expr -> trailer trailer_expr
1427
<=
trailer_expr -> trailer trailer_expr
1427
**
trailer_expr -> trailer trailer_expr
1427
@
trailer_expr -> trailer trailer_expr
1427
if
trailer_expr -> trailer trailer_expr
1427
NEWLINE
trailer_expr -> trailer trailer_expr
1427
==
trailer_expr -> trailer trailer_expr
1427
or
trailer_expr -> trailer trailer_expr
1427
<
trailer_expr -> trailer trailer_expr
1427
and
trailer_expr -> trailer trailer_expr
1427
from
trailer_expr -> trailer trailer_expr
1427
in
trailer_expr -> trailer trailer_expr
1427
is
trailer_expr -> trailer trailer_expr
1427
^
trailer_expr -> trailer trailer_expr
1427
//
trailer_expr -> trailer trailer_expr
1428
<=
trailer -> . NAME
1428
<<
trailer -> . NAME
1428
**
trailer -> . NAME
1428
!=
trailer -> . NAME
1428
/
trailer -> . NAME
1428
&
trailer -> . NAME
1428
//
trailer -> . NAME
1428
<
trailer -> . NAME
1428
is
trailer -> . NAME
1428
-
trailer -> . NAME
1428
if
trailer -> . NAME
1428
[
trailer -> . NAME
1428
or
trailer -> . NAME
1428
>
trailer -> . NAME
1428
*
trailer -> . NAME
1428
+
trailer -> . NAME
1428
%
trailer -> . NAME
1428
.
trailer -> . NAME
1428
>=
trailer -> . NAME
1428
|
trailer -> . NAME
1428
and
trailer -> . NAME
1428
(
trailer -> . NAME
1428
NEWLINE
trailer -> . NAME
1428
from
trailer -> . NAME
1428
==
trailer -> . NAME
1428
^
trailer -> . NAME
1428
in
trailer -> . NAME
1428
@
trailer -> . NAME
1428
not
trailer -> . NAME
1428
>>
trailer -> . NAME
1429
)
1884
1430
%
trailer -> ( )
1430
<=
trailer -> ( )
1430
and
trailer -> ( )
1430
//
trailer -> ( )
1430
not
trailer -> ( )
1430
or
trailer -> ( )
1430
NEWLINE
trailer -> ( )
1430
>>
trailer -> ( )
1430
>
trailer -> ( )
1430
<<
trailer -> ( )
1430
from
trailer -> ( )
1430
[
trailer -> ( )
1430
is
trailer -> ( )
1430
-
trailer -> ( )
1430
**
trailer -> ( )
1430
/
trailer -> ( )
1430
+
trailer -> ( )
1430
&
trailer -> ( )
1430
in
trailer -> ( )
1430
^
trailer -> ( )
1430
!=
trailer -> ( )
1430
*
trailer -> ( )
1430
if
trailer -> ( )
1430
>=
trailer -> ( )
1430
(
trailer -> ( )
1430
@
trailer -> ( )
1430
==
trailer -> ( )
1430
|
trailer -> ( )
1430
.
trailer -> ( )
1430
<
trailer -> ( )
1431
]
1885
1432
==
and_expr -> shift_expr & and_expr
1432
in
and_expr -> shift_expr & and_expr
1432
!=
and_expr -> shift_expr & and_expr
1432
or
and_expr -> shift_expr & and_expr
1432
>
and_expr -> shift_expr & and_expr
1432
not
and_expr -> shift_expr & and_expr
1432
<=
and_expr -> shift_expr & and_expr
1432
|
and_expr -> shift_expr & and_expr
1432
from
and_expr -> shift_expr & and_expr
1432
and
and_expr -> shift_expr & and_expr
1432
NEWLINE
and_expr -> shift_expr & and_expr
1432
^
and_expr -> shift_expr & and_expr
1432
is
and_expr -> shift_expr & and_expr
1432
>=
and_expr -> shift_expr & and_expr
1432
<
and_expr -> shift_expr & and_expr
1432
if
and_expr -> shift_expr & and_expr
1433
else
1886
1434
<=
xor_expr -> and_expr ^ xor_expr
1434
!=
xor_expr -> and_expr ^ xor_expr
1434
and
xor_expr -> and_expr ^ xor_expr
1434
from
xor_expr -> and_expr ^ xor_expr
1434
is
xor_expr -> and_expr ^ xor_expr
1434
>=
xor_expr -> and_expr ^ xor_expr
1434
not
xor_expr -> and_expr ^ xor_expr
1434
<
xor_expr -> and_expr ^ xor_expr
1434
|
xor_expr -> and_expr ^ xor_expr
1434
in
xor_expr -> and_expr ^ xor_expr
1434
==
xor_expr -> and_expr ^ xor_expr
1434
or
xor_expr -> and_expr ^ xor_expr
1434
if
xor_expr -> and_expr ^ xor_expr
1434
>
xor_expr -> and_expr ^ xor_expr
1434
NEWLINE
xor_expr -> and_expr ^ xor_expr
1435
not
expr -> xor_expr | expr
1435
in
expr -> xor_expr | expr
1435
if
expr -> xor_expr | expr
1435
or
expr -> xor_expr | expr
1435
<=
expr -> xor_expr | expr
1435
>
expr -> xor_expr | expr
1435
!=
expr -> xor_expr | expr
1435
==
expr -> xor_expr | expr
1435
NEWLINE
expr -> xor_expr | expr
1435
>=
expr -> xor_expr | expr
1435
from
expr -> xor_expr | expr
1435
is
expr -> xor_expr | expr
1435
<
expr -> xor_expr | expr
1435
and
expr -> xor_expr | expr
1436
and
comparison -> expr comp_op comparison
1436
if
comparison -> expr comp_op comparison
1436
from
comparison -> expr comp_op comparison
1436
or
comparison -> expr comp_op comparison
1436
NEWLINE
comparison -> expr comp_op comparison
1437
NEWLINE
or_test -> and_test or or_test
1437
if
or_test -> and_test or or_test
1437
from
or_test -> and_test or or_test
1438
NEWLINE
and_test -> not_test and and_test
1438
from
and_test -> not_test and and_test
1438
if
and_test -> not_test and and_test
1438
or
and_test -> not_test and and_test
1439
NEWLINE
raise_stmt -> raise test from test
1440
+
term -> factor // term
1440
,
term -> factor // term
1440
>>
term -> factor // term
1440
&
term -> factor // term
1440
-
term -> factor // term
1440
NEWLINE
term -> factor // term
1440
^
term -> factor // term
1440
<<
term -> factor // term
1440
|
term -> factor // term
1441
>>
term -> factor / term
1441
+
term -> factor / term
1441
^
term -> factor / term
1441
|
term -> factor / term
1441
<<
term -> factor / term
1441
&
term -> factor / term
1441
-
term -> factor / term
1441
NEWLINE
term -> factor / term
1441
,
term -> factor / term
1442
<<
term -> factor % term
1442
|
term -> factor % term
1442
NEWLINE
term -> factor % term
1442
&
term -> factor % term
1442
-
term -> factor % term
1442
^
term -> factor % term
1442
+
term -> factor % term
1442
,
term -> factor % term
1442
>>
term -> factor % term
1443
,
term -> factor * term
1443
-
term -> factor * term
1443
|
term -> factor * term
1443
^
term -> factor * term
1443
+
term -> factor * term
1443
>>
term -> factor * term
1443
<<
term -> factor * term
1443
NEWLINE
term -> factor * term
1443
&
term -> factor * term
1444
,
term -> factor @ term
1444
>>
term -> factor @ term
1444
-
term -> factor @ term
1444
NEWLINE
term -> factor @ term
1444
|
term -> factor @ term
1444
+
term -> factor @ term
1444
<<
term -> factor @ term
1444
&
term -> factor @ term
1444
^
term -> factor @ term
1445
&
arith_expr -> term - arith_expr
1445
>>
arith_expr -> term - arith_expr
1445
NEWLINE
arith_expr -> term - arith_expr
1445
^
arith_expr -> term - arith_expr
1445
<<
arith_expr -> term - arith_expr
1445
,
arith_expr -> term - arith_expr
1445
|
arith_expr -> term - arith_expr
1446
,
arith_expr -> term + arith_expr
1446
NEWLINE
arith_expr -> term + arith_expr
1446
|
arith_expr -> term + arith_expr
1446
>>
arith_expr -> term + arith_expr
1446
&
arith_expr -> term + arith_expr
1446
<<
arith_expr -> term + arith_expr
1446
^
arith_expr -> term + arith_expr
1447
(
atom -> ( test_list_comp )
1447
+
atom -> ( test_list_comp )
1447
**
atom -> ( test_list_comp )
1447
>>
atom -> ( test_list_comp )
1447
.
atom -> ( test_list_comp )
1447
/
atom -> ( test_list_comp )
1447
*
atom -> ( test_list_comp )
1447
-
atom -> ( test_list_comp )
1447
[
atom -> ( test_list_comp )
1447
&
atom -> ( test_list_comp )
1447
^
atom -> ( test_list_comp )
1447
,
atom -> ( test_list_comp )
1447
|
atom -> ( test_list_comp )
1447
@
atom -> ( test_list_comp )
1447
<<
atom -> ( test_list_comp )
1447
%
atom -> ( test_list_comp )
1447
NEWLINE
atom -> ( test_list_comp )
1447
//
atom -> ( test_list_comp )
1448
,
atom -> [ test_list_comp ]
1448
/
atom -> [ test_list_comp ]
1448
.
atom -> [ test_list_comp ]
1448
[
atom -> [ test_list_comp ]
1448
//
atom -> [ test_list_comp ]
1448
<<
atom -> [ test_list_comp ]
1448
(
atom -> [ test_list_comp ]
1448
-
atom -> [ test_list_comp ]
1448
%
atom -> [ test_list_comp ]
1448
**
atom -> [ test_list_comp ]
1448
*
atom -> [ test_list_comp ]
1448
>>
atom -> [ test_list_comp ]
1448
@
atom -> [ test_list_comp ]
1448
^
atom -> [ test_list_comp ]
1448
|
atom -> [ test_list_comp ]
1448
&
atom -> [ test_list_comp ]
1448
NEWLINE
atom -> [ test_list_comp ]
1448
+
atom -> [ test_list_comp ]
1449
+
power -> atom_expr ** factor
1449
NEWLINE
power -> atom_expr ** factor
1449
&
power -> atom_expr ** factor
1449
*
power -> atom_expr ** factor
1449
|
power -> atom_expr ** factor
1449
^
power -> atom_expr ** factor
1449
@
power -> atom_expr ** factor
1449
>>
power -> atom_expr ** factor
1449
<<
power -> atom_expr ** factor
1449
,
power -> atom_expr ** factor
1449
/
power -> atom_expr ** factor
1449
%
power -> atom_expr ** factor
1449
//
power -> atom_expr ** factor
1449
-
power -> atom_expr ** factor
1450
,
shift_expr -> arith_expr >> shift_expr
1450
|
shift_expr -> arith_expr >> shift_expr
1450
NEWLINE
shift_expr -> arith_expr >> shift_expr
1450
^
shift_expr -> arith_expr >> shift_expr
1450
&
shift_expr -> arith_expr >> shift_expr
1451
^
shift_expr -> arith_expr << shift_expr
1451
,
shift_expr -> arith_expr << shift_expr
1451
|
shift_expr -> arith_expr << shift_expr
1451
NEWLINE
shift_expr -> arith_expr << shift_expr
1451
&
shift_expr -> arith_expr << shift_expr
1452
,
xor_expr -> and_expr ^ xor_expr
1452
NEWLINE
xor_expr -> and_expr ^ xor_expr
1452
|
xor_expr -> and_expr ^ xor_expr
1453
,
and_expr -> shift_expr & and_expr
1453
^
and_expr -> shift_expr & and_expr
1453
NEWLINE
and_expr -> shift_expr & and_expr
1453
|
and_expr -> shift_expr & and_expr
1454
NEWLINE
expr_list -> expr , expr_list
1455
,
expr -> xor_expr | expr
1455
NEWLINE
expr -> xor_expr | expr
1456
**
trailer_expr -> trailer trailer_expr
1456
,
trailer_expr -> trailer trailer_expr
1456
*
trailer_expr -> trailer trailer_expr
1456
+
trailer_expr -> trailer trailer_expr
1456
%
trailer_expr -> trailer trailer_expr
1456
//
trailer_expr -> trailer trailer_expr
1456
&
trailer_expr -> trailer trailer_expr
1456
-
trailer_expr -> trailer trailer_expr
1456
@
trailer_expr -> trailer trailer_expr
1456
/
trailer_expr -> trailer trailer_expr
1456
<<
trailer_expr -> trailer trailer_expr
1456
NEWLINE
trailer_expr -> trailer trailer_expr
1456
^
trailer_expr -> trailer trailer_expr
1456
>>
trailer_expr -> trailer trailer_expr
1456
|
trailer_expr -> trailer trailer_expr
1457
)
1887
1458
-
trailer -> ( )
1458
%
trailer -> ( )
1458
**
trailer -> ( )
1458
/
trailer -> ( )
1458
,
trailer -> ( )
1458
+
trailer -> ( )
1458
&
trailer -> ( )
1458
^
trailer -> ( )
1458
>>
trailer -> ( )
1458
<<
trailer -> ( )
1458
//
trailer -> ( )
1458
(
trailer -> ( )
1458
@
trailer -> ( )
1458
[
trailer -> ( )
1458
|
trailer -> ( )
1458
.
trailer -> ( )
1458
*
trailer -> ( )
1458
NEWLINE
trailer -> ( )
1459
-
trailer -> . NAME
1459
,
trailer -> . NAME
1459
/
trailer -> . NAME
1459
[
trailer -> . NAME
1459
+
trailer -> . NAME
1459
NEWLINE
trailer -> . NAME
1459
^
trailer -> . NAME
1459
@
trailer -> . NAME
1459
.
trailer -> . NAME
1459
%
trailer -> . NAME
1459
<<
trailer -> . NAME
1459
|
trailer -> . NAME
1459
*
trailer -> . NAME
1459
**
trailer -> . NAME
1459
(
trailer -> . NAME
1459
&
trailer -> . NAME
1459
//
trailer -> . NAME
1459
>>
trailer -> . NAME
1460
]
1888
1461
and
term -> factor // term
1461
if
term -> factor // term
1461
>
term -> factor // term
1461
<
term -> factor // term
1461
==
term -> factor // term
1461
+
term -> factor // term
1461
-
term -> factor // term
1461
&
term -> factor // term
1461
in
term -> factor // term
1461
!=
term -> factor // term
1461
^
term -> factor // term
1461
or
term -> factor // term
1461
NEWLINE
term -> factor // term
1461
<=
term -> factor // term
1461
>=
term -> factor // term
1461
|
term -> factor // term
1461
>>
term -> factor // term
1461
not
term -> factor // term
1461
is
term -> factor // term
1461
<<
term -> factor // term
1462
^
term -> factor * term
1462
+
term -> factor * term
1462
==
term -> factor * term
1462
>>
term -> factor * term
1462
in
term -> factor * term
1462
and
term -> factor * term
1462
if
term -> factor * term
1462
is
term -> factor * term
1462
<<
term -> factor * term
1462
-
term -> factor * term
1462
!=
term -> factor * term
1462
or
term -> factor * term
1462
>
term -> factor * term
1462
&
term -> factor * term
1462
|
term -> factor * term
1462
NEWLINE
term -> factor * term
1462
>=
term -> factor * term
1462
<=
term -> factor * term
1462
not
term -> factor * term
1462
<
term -> factor * term
1463
&
term -> factor % term
1463
==
term -> factor % term
1463
!=
term -> factor % term
1463
<
term -> factor % term
1463
in
term -> factor % term
1463
>>
term -> factor % term
1463
<<
term -> factor % term
1463
NEWLINE
term -> factor % term
1463
-
term -> factor % term
1463
if
term -> factor % term
1463
>
term -> factor % term
1463
or
term -> factor % term
1463
^
term -> factor % term
1463
+
term -> factor % term
1463
is
term -> factor % term
1463
|
term -> factor % term
1463
>=
term -> factor % term
1463
<=
term -> factor % term
1463
and
term -> factor % term
1463
not
term -> factor % term
1464
and
term -> factor @ term
1464
in
term -> factor @ term
1464
>=
term -> factor @ term
1464
<
term -> factor @ term
1464
>
term -> factor @ term
1464
-
term -> factor @ term
1464
NEWLINE
term -> factor @ term
1464
or
term -> factor @ term
1464
<<
term -> factor @ term
1464
is
term -> factor @ term
1464
!=
term -> factor @ term
1464
|
term -> factor @ term
1464
&
term -> factor @ term
1464
==
term -> factor @ term
1464
>>
term -> factor @ term
1464
<=
term -> factor @ term
1464
not
term -> factor @ term
1464
+
term -> factor @ term
1464
^
term -> factor @ term
1464
if
term -> factor @ term
1465
or
term -> factor / term
1465
<<
term -> factor / term
1465
not
term -> factor / term
1465
in
term -> factor / term
1465
!=
term -> factor / term
1465
<
term -> factor / term
1465
+
term -> factor / term
1465
and
term -> factor / term
1465
>>
term -> factor / term
1465
^
term -> factor / term
1465
<=
term -> factor / term
1465
==
term -> factor / term
1465
>
term -> factor / term
1465
&
term -> factor / term
1465
is
term -> factor / term
1465
-
term -> factor / term
1465
NEWLINE
term -> factor / term
1465
|
term -> factor / term
1465
>=
term -> factor / term
1465
if
term -> factor / term
1466
+
atom -> ( test_list_comp )
1466
/
atom -> ( test_list_comp )
1466
*
atom -> ( test_list_comp )
1466
[
atom -> ( test_list_comp )
1466
&
atom -> ( test_list_comp )
1466
**
atom -> ( test_list_comp )
1466
^
atom -> ( test_list_comp )
1466
(
atom -> ( test_list_comp )
1466
and
atom -> ( test_list_comp )
1466
>
atom -> ( test_list_comp )
1466
-
atom -> ( test_list_comp )
1466
%
atom -> ( test_list_comp )
1466
//
atom -> ( test_list_comp )
1466
in
atom -> ( test_list_comp )
1466
>>
atom -> ( test_list_comp )
1466
not
atom -> ( test_list_comp )
1466
>=
atom -> ( test_list_comp )
1466
or
atom -> ( test_list_comp )
1466
<
atom -> ( test_list_comp )
1466
if
atom -> ( test_list_comp )
1466
|
atom -> ( test_list_comp )
1466
<<
atom -> ( test_list_comp )
1466
@
atom -> ( test_list_comp )
1466
!=
atom -> ( test_list_comp )
1466
is
atom -> ( test_list_comp )
1466
NEWLINE
atom -> ( test_list_comp )
1466
.
atom -> ( test_list_comp )
1466
<=
atom -> ( test_list_comp )
1466
==
atom -> ( test_list_comp )
1467
>=
shift_expr -> arith_expr >> shift_expr
1467
if
shift_expr -> arith_expr >> shift_expr
1467
<=
shift_expr -> arith_expr >> shift_expr
1467
!=
shift_expr -> arith_expr >> shift_expr
1467
or
shift_expr -> arith_expr >> shift_expr
1467
|
shift_expr -> arith_expr >> shift_expr
1467
is
shift_expr -> arith_expr >> shift_expr
1467
and
shift_expr -> arith_expr >> shift_expr
1467
NEWLINE
shift_expr -> arith_expr >> shift_expr
1467
in
shift_expr -> arith_expr >> shift_expr
1467
^
shift_expr -> arith_expr >> shift_expr
1467
not
shift_expr -> arith_expr >> shift_expr
1467
<
shift_expr -> arith_expr >> shift_expr
1467
==
shift_expr -> arith_expr >> shift_expr
1467
&
shift_expr -> arith_expr >> shift_expr
1467
>
shift_expr -> arith_expr >> shift_expr
1468
>
shift_expr -> arith_expr << shift_expr
1468
or
shift_expr -> arith_expr << shift_expr
1468
^
shift_expr -> arith_expr << shift_expr
1468
not
shift_expr -> arith_expr << shift_expr
1468
<
shift_expr -> arith_expr << shift_expr
1468
if
shift_expr -> arith_expr << shift_expr
1468
in
shift_expr -> arith_expr << shift_expr
1468
!=
shift_expr -> arith_expr << shift_expr
1468
==
shift_expr -> arith_expr << shift_expr
1468
|
shift_expr -> arith_expr << shift_expr
1468
>=
shift_expr -> arith_expr << shift_expr
1468
and
shift_expr -> arith_expr << shift_expr
1468
NEWLINE
shift_expr -> arith_expr << shift_expr
1468
&
shift_expr -> arith_expr << shift_expr
1468
<=
shift_expr -> arith_expr << shift_expr
1468
is
shift_expr -> arith_expr << shift_expr
1469
in
atom -> [ test_list_comp ]
1469
/
atom -> [ test_list_comp ]
1469
or
atom -> [ test_list_comp ]
1469
if
atom -> [ test_list_comp ]
1469
<<
atom -> [ test_list_comp ]
1469
!=
atom -> [ test_list_comp ]
1469
<=
atom -> [ test_list_comp ]
1469
>>
atom -> [ test_list_comp ]
1469
*
atom -> [ test_list_comp ]
1469
^
atom -> [ test_list_comp ]
1469
.
atom -> [ test_list_comp ]
1469
(
atom -> [ test_list_comp ]
1469
>=
atom -> [ test_list_comp ]
1469
and
atom -> [ test_list_comp ]
1469
<
atom -> [ test_list_comp ]
1469
[
atom -> [ test_list_comp ]
1469
==
atom -> [ test_list_comp ]
1469
@
atom -> [ test_list_comp ]
1469
%
atom -> [ test_list_comp ]
1469
-
atom -> [ test_list_comp ]
1469
|
atom -> [ test_list_comp ]
1469
&
atom -> [ test_list_comp ]
1469
+
atom -> [ test_list_comp ]
1469
is
atom -> [ test_list_comp ]
1469
//
atom -> [ test_list_comp ]
1469
**
atom -> [ test_list_comp ]
1469
not
atom -> [ test_list_comp ]
1469
NEWLINE
atom -> [ test_list_comp ]
1469
>
atom -> [ test_list_comp ]
1470
==
arith_expr -> term + arith_expr
1470
if
arith_expr -> term + arith_expr
1470
>=
arith_expr -> term + arith_expr
1470
NEWLINE
arith_expr -> term + arith_expr
1470
!=
arith_expr -> term + arith_expr
1470
is
arith_expr -> term + arith_expr
1470
<<
arith_expr -> term + arith_expr
1470
|
arith_expr -> term + arith_expr
1470
and
arith_expr -> term + arith_expr
1470
^
arith_expr -> term + arith_expr
1470
>>
arith_expr -> term + arith_expr
1470
<
arith_expr -> term + arith_expr
1470
or
arith_expr -> term + arith_expr
1470
in
arith_expr -> term + arith_expr
1470
>
arith_expr -> term + arith_expr
1470
&
arith_expr -> term + arith_expr
1470
not
arith_expr -> term + arith_expr
1470
<=
arith_expr -> term + arith_expr
1471
if
arith_expr -> term - arith_expr
1471
>
arith_expr -> term - arith_expr
1471
>>
arith_expr -> term - arith_expr
1471
&
arith_expr -> term - arith_expr
1471
and
arith_expr -> term - arith_expr
1471
>=
arith_expr -> term - arith_expr
1471
is
arith_expr -> term - arith_expr
1471
NEWLINE
arith_expr -> term - arith_expr
1471
in
arith_expr -> term - arith_expr
1471
!=
arith_expr -> term - arith_expr
1471
^
arith_expr -> term - arith_expr
1471
<
arith_expr -> term - arith_expr
1471
<<
arith_expr -> term - arith_expr
1471
not
arith_expr -> term - arith_expr
1471
==
arith_expr -> term - arith_expr
1471
|
arith_expr -> term - arith_expr
1471
or
arith_expr -> term - arith_expr
1471
<=
arith_expr -> term - arith_expr
1472
+
power -> atom_expr ** factor
1472
&
power -> atom_expr ** factor
1472
>>
power -> atom_expr ** factor
1472
<<
power -> atom_expr ** factor
1472
not
power -> atom_expr ** factor
1472
is
power -> atom_expr ** factor
1472
@
power -> atom_expr ** factor
1472
==
power -> atom_expr ** factor
1472
*
power -> atom_expr ** factor
1472
or
power -> atom_expr ** factor
1472
>
power -> atom_expr ** factor
1472
-
power -> atom_expr ** factor
1472
if
power -> atom_expr ** factor
1472
!=
power -> atom_expr ** factor
1472
>=
power -> atom_expr ** factor
1472
/
power -> atom_expr ** factor
1472
%
power -> atom_expr ** factor
1472
and
power -> atom_expr ** factor
1472
<=
power -> atom_expr ** factor
1472
NEWLINE
power -> atom_expr ** factor
1472
<
power -> atom_expr ** factor
1472
|
power -> atom_expr ** factor
1472
^
power -> atom_expr ** factor
1472
in
power -> atom_expr ** factor
1472
//
power -> atom_expr ** factor
1473
+
trailer_expr -> trailer trailer_expr
1473
*
trailer_expr -> trailer trailer_expr
1473
/
trailer_expr -> trailer trailer_expr
1473
not
trailer_expr -> trailer trailer_expr
1473
<<
trailer_expr -> trailer trailer_expr
1473
!=
trailer_expr -> trailer trailer_expr
1473
>=
trailer_expr -> trailer trailer_expr
1473
>>
trailer_expr -> trailer trailer_expr
1473
|
trailer_expr -> trailer trailer_expr
1473
%
trailer_expr -> trailer trailer_expr
1473
>
trailer_expr -> trailer trailer_expr
1473
&
trailer_expr -> trailer trailer_expr
1473
-
trailer_expr -> trailer trailer_expr
1473
<=
trailer_expr -> trailer trailer_expr
1473
**
trailer_expr -> trailer trailer_expr
1473
@
trailer_expr -> trailer trailer_expr
1473
if
trailer_expr -> trailer trailer_expr
1473
NEWLINE
trailer_expr -> trailer trailer_expr
1473
==
trailer_expr -> trailer trailer_expr
1473
or
trailer_expr -> trailer trailer_expr
1473
<
trailer_expr -> trailer trailer_expr
1473
and
trailer_expr -> trailer trailer_expr
1473
in
trailer_expr -> trailer trailer_expr
1473
is
trailer_expr -> trailer trailer_expr
1473
^
trailer_expr -> trailer trailer_expr
1473
//
trailer_expr -> trailer trailer_expr
1474
<<
trailer -> . NAME
1474
<=
trailer -> . NAME
1474
**
trailer -> . NAME
1474
!=
trailer -> . NAME
1474
/
trailer -> . NAME
1474
&
trailer -> . NAME
1474
//
trailer -> . NAME
1474
<
trailer -> . NAME
1474
is
trailer -> . NAME
1474
-
trailer -> . NAME
1474
if
trailer -> . NAME
1474
[
trailer -> . NAME
1474
or
trailer -> . NAME
1474
>
trailer -> . NAME
1474
*
trailer -> . NAME
1474
+
trailer -> . NAME
1474
%
trailer -> . NAME
1474
.
trailer -> . NAME
1474
>=
trailer -> . NAME
1474
|
trailer -> . NAME
1474
and
trailer -> . NAME
1474
(
trailer -> . NAME
1474
NEWLINE
trailer -> . NAME
1474
==
trailer -> . NAME
1474
^
trailer -> . NAME
1474
in
trailer -> . NAME
1474
@
trailer -> . NAME
1474
not
trailer -> . NAME
1474
>>
trailer -> . NAME
1475
)
1889
1476
%
trailer -> ( )
1476
<=
trailer -> ( )
1476
and
trailer -> ( )
1476
//
trailer -> ( )
1476
not
trailer -> ( )
1476
or
trailer -> ( )
1476
NEWLINE
trailer -> ( )
1476
>>
trailer -> ( )
1476
>
trailer -> ( )
1476
<<
trailer -> ( )
1476
[
trailer -> ( )
1476
is
trailer -> ( )
1476
-
trailer -> ( )
1476
**
trailer -> ( )
1476
/
trailer -> ( )
1476
+
trailer -> ( )
1476
&
trailer -> ( )
1476
in
trailer -> ( )
1476
^
trailer -> ( )
1476
!=
trailer -> ( )
1476
*
trailer -> ( )
1476
if
trailer -> ( )
1476
>=
trailer -> ( )
1476
(
trailer -> ( )
1476
@
trailer -> ( )
1476
==
trailer -> ( )
1476
|
trailer -> ( )
1476
.
trailer -> ( )
1476
<
trailer -> ( )
1477
]
1890
1478
==
and_expr -> shift_expr & and_expr
1478
in
and_expr -> shift_expr & and_expr
1478
!=
and_expr -> shift_expr & and_expr
1478
or
and_expr -> shift_expr & and_expr
1478
>
and_expr -> shift_expr & and_expr
1478
not
and_expr -> shift_expr & and_expr
1478
<=
and_expr -> shift_expr & and_expr
1478
|
and_expr -> shift_expr & and_expr
1478
and
and_expr -> shift_expr & and_expr
1478
NEWLINE
and_expr -> shift_expr & and_expr
1478
^
and_expr -> shift_expr & and_expr
1478
is
and_expr -> shift_expr & and_expr
1478
>=
and_expr -> shift_expr & and_expr
1478
<
and_expr -> shift_expr & and_expr
1478
if
and_expr -> shift_expr & and_expr
1479
<=
xor_expr -> and_expr ^ xor_expr
1479
!=
xor_expr -> and_expr ^ xor_expr
1479
and
xor_expr -> and_expr ^ xor_expr
1479
is
xor_expr -> and_expr ^ xor_expr
1479
>=
xor_expr -> and_expr ^ xor_expr
1479
not
xor_expr -> and_expr ^ xor_expr
1479
<
xor_expr -> and_expr ^ xor_expr
1479
|
xor_expr -> and_expr ^ xor_expr
1479
in
xor_expr -> and_expr ^ xor_expr
1479
==
xor_expr -> and_expr ^ xor_expr
1479
or
xor_expr -> and_expr ^ xor_expr
1479
if
xor_expr -> and_expr ^ xor_expr
1479
>
xor_expr -> and_expr ^ xor_expr
1479
NEWLINE
xor_expr -> and_expr ^ xor_expr
1480
not
expr -> xor_expr | expr
1480
in
expr -> xor_expr | expr
1480
if
expr -> xor_expr | expr
1480
or
expr -> xor_expr | expr
1480
<=
expr -> xor_expr | expr
1480
>
expr -> xor_expr | expr
1480
!=
expr -> xor_expr | expr
1480
==
expr -> xor_expr | expr
1480
NEWLINE
expr -> xor_expr | expr
1480
>=
expr -> xor_expr | expr
1480
is
expr -> xor_expr | expr
1480
<
expr -> xor_expr | expr
1480
and
expr -> xor_expr | expr
1481
or
comparison -> expr comp_op comparison
1481
and
comparison -> expr comp_op comparison
1481
NEWLINE
comparison -> expr comp_op comparison
1481
if
comparison -> expr comp_op comparison
1482
NEWLINE
or_test -> and_test or or_test
1482
if
or_test -> and_test or or_test
1483
factor
396
1483
(
397
1483
arith_expr
398
1483
NAME
399
1483
[
400
1483
+
401
1483
term
402
1483
atom_expr
403
1483
atom
404
1483
NUMBER
405
1483
STRING
406
1483
shift_expr
407
1483
-
408
1483
True
409
1483
and_expr
410
1483
xor_expr
411
1483
None
412
1483
expr
413
1483
False
414
1483
and_test
415
1483
lambda
416
1483
{
417
1483
~
418
1483
power
419
1483
not_test
420
1483
not
421
1483
comparison
422
1483
or_test
423
1483
lambdef
424
1483
test
1891
1484
NEWLINE
lambdef -> lambda : test
1485
NEWLINE
and_test -> not_test and and_test
1485
if
and_test -> not_test and and_test
1485
or
and_test -> not_test and and_test
1486
else
1892
1487
**
trailer -> ( arglist )
1487
:
trailer -> ( arglist )
1487
if
trailer -> ( arglist )
1487
<
trailer -> ( arglist )
1487
//
trailer -> ( arglist )
1487
<<
trailer -> ( arglist )
1487
%
trailer -> ( arglist )
1487
&
trailer -> ( arglist )
1487
==
trailer -> ( arglist )
1487
is
trailer -> ( arglist )
1487
!=
trailer -> ( arglist )
1487
and
trailer -> ( arglist )
1487
-
trailer -> ( arglist )
1487
+
trailer -> ( arglist )
1487
>=
trailer -> ( arglist )
1487
or
trailer -> ( arglist )
1487
(
trailer -> ( arglist )
1487
^
trailer -> ( arglist )
1487
.
trailer -> ( arglist )
1487
not
trailer -> ( arglist )
1487
>>
trailer -> ( arglist )
1487
/
trailer -> ( arglist )
1487
*
trailer -> ( arglist )
1487
[
trailer -> ( arglist )
1487
@
trailer -> ( arglist )
1487
>
trailer -> ( arglist )
1487
|
trailer -> ( arglist )
1487
<=
trailer -> ( arglist )
1487
in
trailer -> ( arglist )
1488
|
trailer -> [ subscriptlist ]
1488
not
trailer -> [ subscriptlist ]
1488
in
trailer -> [ subscriptlist ]
1488
==
trailer -> [ subscriptlist ]
1488
**
trailer -> [ subscriptlist ]
1488
>>
trailer -> [ subscriptlist ]
1488
!=
trailer -> [ subscriptlist ]
1488
*
trailer -> [ subscriptlist ]
1488
or
trailer -> [ subscriptlist ]
1488
>=
trailer -> [ subscriptlist ]
1488
/
trailer -> [ subscriptlist ]
1488
[
trailer -> [ subscriptlist ]
1488
>
trailer -> [ subscriptlist ]
1488
<
trailer -> [ subscriptlist ]
1488
.
trailer -> [ subscriptlist ]
1488
and
trailer -> [ subscriptlist ]
1488
(
trailer -> [ subscriptlist ]
1488
<=
trailer -> [ subscriptlist ]
1488
-
trailer -> [ subscriptlist ]
1488
@
trailer -> [ subscriptlist ]
1488
<<
trailer -> [ subscriptlist ]
1488
&
trailer -> [ subscriptlist ]
1488
:
trailer -> [ subscriptlist ]
1488
^
trailer -> [ subscriptlist ]
1488
is
trailer -> [ subscriptlist ]
1488
%
trailer -> [ subscriptlist ]
1488
+
trailer -> [ subscriptlist ]
1488
//
trailer -> [ subscriptlist ]
1488
if
trailer -> [ subscriptlist ]
1489
nonlocal
simple_stmt -> small_stmt NEWLINE
1489
True
simple_stmt -> small_stmt NEWLINE
1489
False
simple_stmt -> small_stmt NEWLINE
1489
(
simple_stmt -> small_stmt NEWLINE
1489
continue
simple_stmt -> small_stmt NEWLINE
1489
begsim
simple_stmt -> small_stmt NEWLINE
1489
NAME
simple_stmt -> small_stmt NEWLINE
1489
endsim
simple_stmt -> small_stmt NEWLINE
1489
break
simple_stmt -> small_stmt NEWLINE
1489
return
simple_stmt -> small_stmt NEWLINE
1489
NUMBER
simple_stmt -> small_stmt NEWLINE
1489
[
simple_stmt -> small_stmt NEWLINE
1489
global
simple_stmt -> small_stmt NEWLINE
1489
resetstats
simple_stmt -> small_stmt NEWLINE
1489
yield
simple_stmt -> small_stmt NEWLINE
1489
conf
simple_stmt -> small_stmt NEWLINE
1489
$
simple_stmt -> small_stmt NEWLINE
1489
not
simple_stmt -> small_stmt NEWLINE
1489
lambda
simple_stmt -> small_stmt NEWLINE
1489
del
simple_stmt -> small_stmt NEWLINE
1489
pass
simple_stmt -> small_stmt NEWLINE
1489
for
simple_stmt -> small_stmt NEWLINE
1489
@
simple_stmt -> small_stmt NEWLINE
1489
with
simple_stmt -> small_stmt NEWLINE
1489
class
simple_stmt -> small_stmt NEWLINE
1489
NEWLINE
simple_stmt -> small_stmt NEWLINE
1489
if
simple_stmt -> small_stmt NEWLINE
1489
assert
simple_stmt -> small_stmt NEWLINE
1489
None
simple_stmt -> small_stmt NEWLINE
1489
else
simple_stmt -> small_stmt NEWLINE
1489
+
simple_stmt -> small_stmt NEWLINE
1489
-
simple_stmt -> small_stmt NEWLINE
1489
STRING
simple_stmt -> small_stmt NEWLINE
1489
while
simple_stmt -> small_stmt NEWLINE
1489
{
simple_stmt -> small_stmt NEWLINE
1489
raise
simple_stmt -> small_stmt NEWLINE
1489
~
simple_stmt -> small_stmt NEWLINE
1489
elif
simple_stmt -> small_stmt NEWLINE
1489
def
simple_stmt -> small_stmt NEWLINE
1489
try
simple_stmt -> small_stmt NEWLINE
1490
factor
85
1490
(
86
1490
arith_expr
87
1490
NAME
88
1490
term
89
1490
[
90
1490
~
91
1490
test
1893
1490
+
92
1490
expr
93
1490
atom_expr
94
1490
atom
95
1490
NUMBER
96
1490
STRING
97
1490
shift_expr
99
1490
-
100
1490
True
101
1490
and_expr
102
1490
xor_expr
103
1490
False
104
1490
{
105
1490
None
106
1490
and_test
107
1490
power
108
1490
not_test
109
1490
lambdef
110
1490
or_test
111
1490
comparison
112
1490
not
113
1490
lambda
114
1491
else
1894
1491
pass
if_stmt -> if test : suite elif_clause
1491
lambda
if_stmt -> if test : suite elif_clause
1491
True
if_stmt -> if test : suite elif_clause
1491
begsim
if_stmt -> if test : suite elif_clause
1491
~
if_stmt -> if test : suite elif_clause
1491
assert
if_stmt -> if test : suite elif_clause
1491
raise
if_stmt -> if test : suite elif_clause
1491
nonlocal
if_stmt -> if test : suite elif_clause
1491
{
if_stmt -> if test : suite elif_clause
1491
with
if_stmt -> if test : suite elif_clause
1491
conf
if_stmt -> if test : suite elif_clause
1491
while
if_stmt -> if test : suite elif_clause
1491
yield
if_stmt -> if test : suite elif_clause
1491
return
if_stmt -> if test : suite elif_clause
1491
continue
if_stmt -> if test : suite elif_clause
1491
if
if_stmt -> if test : suite elif_clause
1491
NAME
if_stmt -> if test : suite elif_clause
1491
for
if_stmt -> if test : suite elif_clause
1491
del
if_stmt -> if test : suite elif_clause
1491
STRING
if_stmt -> if test : suite elif_clause
1491
+
if_stmt -> if test : suite elif_clause
1491
def
if_stmt -> if test : suite elif_clause
1491
$
if_stmt -> if test : suite elif_clause
1491
break
if_stmt -> if test : suite elif_clause
1491
global
if_stmt -> if test : suite elif_clause
1491
None
if_stmt -> if test : suite elif_clause
1491
resetstats
if_stmt -> if test : suite elif_clause
1491
class
if_stmt -> if test : suite elif_clause
1491
@
if_stmt -> if test : suite elif_clause
1491
False
if_stmt -> if test : suite elif_clause
1491
endsim
if_stmt -> if test : suite elif_clause
1491
-
if_stmt -> if test : suite elif_clause
1491
[
if_stmt -> if test : suite elif_clause
1491
try
if_stmt -> if test : suite elif_clause
1491
NEWLINE
if_stmt -> if test : suite elif_clause
1491
not
if_stmt -> if test : suite elif_clause
1491
NUMBER
if_stmt -> if test : suite elif_clause
1491
(
if_stmt -> if test : suite elif_clause
1492
if
1566
1492
arith_expr
2
1492
try
1567
1492
[
3
1492
class
1568
1492
for
1569
1492
stmt_list
1895
1492
with_stmt
1570
1492
while_stmt
1571
1492
factor
9
1492
@
10
1492
simple_stmt
1572
1492
decorators
1573
1492
return
13
1492
confdef
1574
1492
flow_stmt
15
1492
expr
16
1492
True
17
1492
not_test
18
1492
and_expr
19
1492
def
1575
1492
term
21
1492
xor_expr
22
1492
or_test
23
1492
atom_expr
24
1492
global
25
1492
for_stmt
1576
1492
NUMBER
27
1492
STRING
28
1492
NAME
29
1492
decorator
30
1492
if_stmt
1577
1492
with
1578
1492
endsim
33
1492
classdef
1579
1492
False
35
1492
(
36
1492
and_test
37
1492
conf
1580
1492
comparison
39
1492
lambda
40
1492
while
1581
1492
None
42
1492
try_stmt
1582
1492
funcdef
1583
1492
~
45
1492
decorated
1584
1492
small_stmt
1585
1492
test
48
1492
-
49
1492
shift_expr
50
1492
{
52
1492
lambdef
53
1492
atom
54
1492
+
55
1492
power
56
1492
not
57
1492
compound_stmt
1587
1492
continue
59
1492
del_stmt
60
1492
test_list
61
1492
raise
62
1492
raise_stmt
63
1492
resetstats
64
1492
pass_stmt
65
1492
stmt
1588
1492
nonlocal
66
1492
global_stmt
67
1492
yield
68
1492
continue_stmt
69
1492
assert
70
1492
nonlocal_stmt
71
1492
expr_stmt
72
1492
break_stmt
74
1492
return_stmt
75
1492
break
76
1492
sim_stmt
77
1492
stat_stmt
78
1492
yield_stmt
79
1492
assert_stmt
80
1492
pass
81
1492
begsim
83
1492
del
84
1493
factor
85
1493
(
86
1493
arith_expr
87
1493
NAME
88
1493
term
89
1493
[
90
1493
~
91
1493
+
92
1493
expr
93
1493
atom_expr
94
1493
atom
95
1493
NUMBER
96
1493
STRING
97
1493
shift_expr
99
1493
-
100
1493
True
101
1493
and_expr
102
1493
xor_expr
103
1493
False
104
1493
{
105
1493
None
106
1493
and_test
107
1493
power
108
1493
not_test
109
1493
test
1896
1493
lambdef
110
1493
or_test
111
1493
comparison
112
1493
not
113
1493
lambda
114
1494
:
lambdef -> lambda varargslist : test
1495
factor
117
1495
or_test
118
1495
term
119
1495
(
120
1495
arith_expr
121
1495
NAME
122
1495
[
123
1495
+
125
1495
atom_expr
126
1495
NUMBER
127
1495
atom
128
1495
STRING
129
1495
shift_expr
130
1495
-
131
1495
True
133
1495
not_test
134
1495
lambdef
135
1495
and_expr
136
1495
xor_expr
137
1495
False
138
1495
None
139
1495
expr
140
1495
and_test
141
1495
{
142
1495
~
143
1495
lambda
144
1495
power
145
1495
comparison
146
1495
test
1897
1495
not
149
1496
for
trailer -> ( arglist )
1496
**
trailer -> ( arglist )
1496
if
trailer -> ( arglist )
1496
<
trailer -> ( arglist )
1496
//
trailer -> ( arglist )
1496
<<
trailer -> ( arglist )
1496
%
trailer -> ( arglist )
1496
&
trailer -> ( arglist )
1496
==
trailer -> ( arglist )
1496
is
trailer -> ( arglist )
1496
,
trailer -> ( arglist )
1496
!=
trailer -> ( arglist )
1496
]
trailer -> ( arglist )
1496
and
trailer -> ( arglist )
1496
-
trailer -> ( arglist )
1496
+
trailer -> ( arglist )
1496
>=
trailer -> ( arglist )
1496
or
trailer -> ( arglist )
1496
(
trailer -> ( arglist )
1496
^
trailer -> ( arglist )
1496
.
trailer -> ( arglist )
1496
not
trailer -> ( arglist )
1496
>>
trailer -> ( arglist )
1496
/
trailer -> ( arglist )
1496
*
trailer -> ( arglist )
1496
[
trailer -> ( arglist )
1496
@
trailer -> ( arglist )
1496
>
trailer -> ( arglist )
1496
|
trailer -> ( arglist )
1496
<=
trailer -> ( arglist )
1496
in
trailer -> ( arglist )
1497
|
trailer -> [ subscriptlist ]
1497
not
trailer -> [ subscriptlist ]
1497
in
trailer -> [ subscriptlist ]
1497
==
trailer -> [ subscriptlist ]
1497
**
trailer -> [ subscriptlist ]
1497
>>
trailer -> [ subscriptlist ]
1497
!=
trailer -> [ subscriptlist ]
1497
*
trailer -> [ subscriptlist ]
1497
or
trailer -> [ subscriptlist ]
1497
>=
trailer -> [ subscriptlist ]
1497
/
trailer -> [ subscriptlist ]
1497
for
trailer -> [ subscriptlist ]
1497
[
trailer -> [ subscriptlist ]
1497
]
trailer -> [ subscriptlist ]
1497
>
trailer -> [ subscriptlist ]
1497
<
trailer -> [ subscriptlist ]
1497
.
trailer -> [ subscriptlist ]
1497
and
trailer -> [ subscriptlist ]
1497
(
trailer -> [ subscriptlist ]
1497
<=
trailer -> [ subscriptlist ]
1497
-
trailer -> [ subscriptlist ]
1497
@
trailer -> [ subscriptlist ]
1497
<<
trailer -> [ subscriptlist ]
1497
&
trailer -> [ subscriptlist ]
1497
,
trailer -> [ subscriptlist ]
1497
^
trailer -> [ subscriptlist ]
1497
is
trailer -> [ subscriptlist ]
1497
%
trailer -> [ subscriptlist ]
1497
+
trailer -> [ subscriptlist ]
1497
//
trailer -> [ subscriptlist ]
1497
if
trailer -> [ subscriptlist ]
1498
]
lambdef -> lambda varargslist : test
1498
,
lambdef -> lambda varargslist : test
1498
for
lambdef -> lambda varargslist : test
1499
factor
1898
1499
(
1899
1499
arith_expr
1900
1499
NAME
1901
1499
[
1902
1499
+
1903
1499
term
1904
1499
atom_expr
1905
1499
NUMBER
1906
1499
atom
1907
1499
STRING
1908
1499
shift_expr
1909
1499
-
1910
1499
True
1911
1499
and_expr
1912
1499
xor_expr
1913
1499
False
1914
1499
not_test
1915
1499
None
1916
1499
expr
1917
1499
and_test
1918
1499
{
1919
1499
~
1920
1499
power
1921
1499
comparison
1922
1499
not
1923
1499
or_test
1924
1500
factor
984
1500
(
987
1500
NAME
989
1500
[
991
1500
+
992
1500
atom_expr
993
1500
NUMBER
994
1500
atom
995
1500
STRING
996
1500
-
998
1500
term
1925
1500
True
999
1500
None
1003
1500
False
1004
1500
{
1006
1500
~
1007
1500
power
1009
1501
factor
984
1501
(
987
1501
NAME
989
1501
[
991
1501
+
992
1501
atom_expr
993
1501
NUMBER
994
1501
atom
995
1501
STRING
996
1501
-
998
1501
True
999
1501
None
1003
1501
term
1926
1501
False
1004
1501
{
1006
1501
~
1007
1501
power
1009
1502
factor
984
1502
(
987
1502
NAME
989
1502
term
1927
1502
[
991
1502
+
992
1502
atom_expr
993
1502
NUMBER
994
1502
atom
995
1502
STRING
996
1502
-
998
1502
True
999
1502
None
1003
1502
False
1004
1502
{
1006
1502
~
1007
1502
power
1009
1503
factor
984
1503
(
987
1503
NAME
989
1503
[
991
1503
+
992
1503
atom_expr
993
1503
NUMBER
994
1503
atom
995
1503
STRING
996
1503
-
998
1503
term
1928
1503
True
999
1503
None
1003
1503
False
1004
1503
{
1006
1503
~
1007
1503
power
1009
1504
factor
984
1504
(
987
1504
NAME
989
1504
[
991
1504
+
992
1504
atom_expr
993
1504
NUMBER
994
1504
atom
995
1504
term
1929
1504
STRING
996
1504
-
998
1504
True
999
1504
None
1003
1504
False
1004
1504
{
1006
1504
~
1007
1504
power
1009
1505
factor
585
1505
(
586
1505
arith_expr
587
1505
NAME
588
1505
[
589
1505
and_expr
590
1505
+
591
1505
term
592
1505
atom_expr
593
1505
NUMBER
594
1505
atom
595
1505
STRING
596
1505
shift_expr
597
1505
-
598
1505
True
599
1505
not
600
1505
xor_expr
601
1505
None
602
1505
False
603
1505
not_test
605
1505
~
606
1505
power
607
1505
{
608
1505
expr
609
1505
or_test
1930
1505
comparison
610
1505
and_test
611
1506
factor
984
1506
term
986
1506
(
987
1506
NAME
989
1506
[
991
1506
arith_expr
1931
1506
+
992
1506
atom_expr
993
1506
NUMBER
994
1506
atom
995
1506
STRING
996
1506
-
998
1506
True
999
1506
None
1003
1506
False
1004
1506
{
1006
1506
~
1007
1506
power
1009
1507
factor
984
1507
term
986
1507
(
987
1507
NAME
989
1507
[
991
1507
+
992
1507
atom_expr
993
1507
NUMBER
994
1507
atom
995
1507
STRING
996
1507
-
998
1507
True
999
1507
None
1003
1507
False
1004
1507
arith_expr
1932
1507
{
1006
1507
~
1007
1507
power
1009
1508
)
1933
1509
or
atom -> ( )
1509
<<
atom -> ( )
1509
not
atom -> ( )
1509
&
atom -> ( )
1509
(
atom -> ( )
1509
in
atom -> ( )
1509
**
atom -> ( )
1509
@
atom -> ( )
1509
<=
atom -> ( )
1509
%
atom -> ( )
1509
[
atom -> ( )
1509
>=
atom -> ( )
1509
/
atom -> ( )
1509
+
atom -> ( )
1509
<
atom -> ( )
1509
]
atom -> ( )
1509
is
atom -> ( )
1509
*
atom -> ( )
1509
!=
atom -> ( )
1509
-
atom -> ( )
1509
|
atom -> ( )
1509
//
atom -> ( )
1509
^
atom -> ( )
1509
and
atom -> ( )
1509
==
atom -> ( )
1509
if
atom -> ( )
1509
>
atom -> ( )
1509
,
atom -> ( )
1509
.
atom -> ( )
1509
>>
atom -> ( )
1510
factor
984
1510
term
986
1510
(
987
1510
arith_expr
988
1510
NAME
989
1510
[
991
1510
+
992
1510
atom_expr
993
1510
NUMBER
994
1510
atom
995
1510
STRING
996
1510
-
998
1510
shift_expr
1934
1510
True
999
1510
None
1003
1510
False
1004
1510
{
1006
1510
~
1007
1510
power
1009
1511
factor
984
1511
term
986
1511
(
987
1511
arith_expr
988
1511
NAME
989
1511
[
991
1511
+
992
1511
atom_expr
993
1511
NUMBER
994
1511
atom
995
1511
STRING
996
1511
-
998
1511
shift_expr
1935
1511
True
999
1511
None
1003
1511
False
1004
1511
{
1006
1511
~
1007
1511
power
1009
1512
<=
atom -> [ ]
1512
is
atom -> [ ]
1512
-
atom -> [ ]
1512
]
atom -> [ ]
1512
**
atom -> [ ]
1512
^
atom -> [ ]
1512
%
atom -> [ ]
1512
/
atom -> [ ]
1512
>=
atom -> [ ]
1512
|
atom -> [ ]
1512
not
atom -> [ ]
1512
@
atom -> [ ]
1512
*
atom -> [ ]
1512
(
atom -> [ ]
1512
,
atom -> [ ]
1512
>>
atom -> [ ]
1512
[
atom -> [ ]
1512
or
atom -> [ ]
1512
!=
atom -> [ ]
1512
and
atom -> [ ]
1512
<<
atom -> [ ]
1512
if
atom -> [ ]
1512
in
atom -> [ ]
1512
+
atom -> [ ]
1512
.
atom -> [ ]
1512
==
atom -> [ ]
1512
>
atom -> [ ]
1512
<
atom -> [ ]
1512
&
atom -> [ ]
1512
//
atom -> [ ]
1513
]
1936
1514
<
factor -> + factor
1514
if
factor -> + factor
1514
<<
factor -> + factor
1514
]
factor -> + factor
1514
and
factor -> + factor
1514
>=
factor -> + factor
1514
%
factor -> + factor
1514
>>
factor -> + factor
1514
*
factor -> + factor
1514
+
factor -> + factor
1514
/
factor -> + factor
1514
>
factor -> + factor
1514
<=
factor -> + factor
1514
^
factor -> + factor
1514
is
factor -> + factor
1514
|
factor -> + factor
1514
or
factor -> + factor
1514
-
factor -> + factor
1514
in
factor -> + factor
1514
&
factor -> + factor
1514
not
factor -> + factor
1514
//
factor -> + factor
1514
,
factor -> + factor
1514
!=
factor -> + factor
1514
==
factor -> + factor
1514
@
factor -> + factor
1515
(
987
1515
NAME
989
1515
[
991
1515
+
992
1515
atom_expr
993
1515
NUMBER
994
1515
atom
995
1515
STRING
996
1515
-
998
1515
factor
1937
1515
True
999
1515
None
1003
1515
False
1004
1515
{
1006
1515
~
1007
1515
power
1009
1516
trailer_expr
1938
1516
trailer
1516
1516
.
1517
1516
(
1518
1516
[
1519
1516
<<
trailer_expr -> 
1516
%
trailer_expr -> 
1516
==
trailer_expr -> 
1516
-
trailer_expr -> 
1516
<
trailer_expr -> 
1516
if
trailer_expr -> 
1516
or
trailer_expr -> 
1516
/
trailer_expr -> 
1516
**
trailer_expr -> 
1516
and
trailer_expr -> 
1516
@
trailer_expr -> 
1516
*
trailer_expr -> 
1516
|
trailer_expr -> 
1516
is
trailer_expr -> 
1516
,
trailer_expr -> 
1516
+
trailer_expr -> 
1516
in
trailer_expr -> 
1516
&
trailer_expr -> 
1516
<=
trailer_expr -> 
1516
>=
trailer_expr -> 
1516
^
trailer_expr -> 
1516
>
trailer_expr -> 
1516
!=
trailer_expr -> 
1516
not
trailer_expr -> 
1516
>>
trailer_expr -> 
1516
//
trailer_expr -> 
1516
]
trailer_expr -> 
1517
NAME
1939
1518
factor
697
1518
term
698
1518
(
699
1518
arith_expr
700
1518
NAME
701
1518
[
702
1518
atom
703
1518
+
704
1518
power
706
1518
atom_expr
707
1518
NUMBER
708
1518
STRING
709
1518
*
710
1518
shift_expr
711
1518
-
712
1518
argument
714
1518
)
1940
1518
True
715
1518
not_test
716
1518
lambdef
717
1518
and_expr
718
1518
xor_expr
719
1518
False
720
1518
test
721
1518
None
722
1518
arglist
1941
1518
expr
723
1518
and_test
724
1518
{
725
1518
~
726
1518
lambda
727
1518
comparison
728
1518
or_test
729
1518
not
730
1518
**
731
1519
factor
732
1519
or_test
733
1519
term
734
1519
(
735
1519
arith_expr
736
1519
NAME
737
1519
[
738
1519
~
739
1519
subscriptlist
1942
1519
+
741
1519
maybe_test
742
1519
expr
743
1519
atom_expr
744
1519
atom
745
1519
NUMBER
746
1519
STRING
747
1519
shift_expr
748
1519
-
749
1519
True
750
1519
not_test
751
1519
and_expr
752
1519
xor_expr
753
1519
False
754
1519
{
755
1519
None
756
1519
and_test
757
1519
lambda
758
1519
power
759
1519
subscript
760
1519
test
761
1519
lambdef
762
1519
:
maybe_test -> 
1519
comparison
763
1519
not
764
1520
>
atom_expr -> atom trailer_expr
1520
not
atom_expr -> atom trailer_expr
1520
//
atom_expr -> atom trailer_expr
1520
>>
atom_expr -> atom trailer_expr
1520
|
atom_expr -> atom trailer_expr
1520
^
atom_expr -> atom trailer_expr
1520
/
atom_expr -> atom trailer_expr
1520
+
atom_expr -> atom trailer_expr
1520
in
atom_expr -> atom trailer_expr
1520
%
atom_expr -> atom trailer_expr
1520
and
atom_expr -> atom trailer_expr
1520
<=
atom_expr -> atom trailer_expr
1520
is
atom_expr -> atom trailer_expr
1520
<
atom_expr -> atom trailer_expr
1520
@
atom_expr -> atom trailer_expr
1520
-
atom_expr -> atom trailer_expr
1520
]
atom_expr -> atom trailer_expr
1520
&
atom_expr -> atom trailer_expr
1520
*
atom_expr -> atom trailer_expr
1520
**
atom_expr -> atom trailer_expr
1520
>=
atom_expr -> atom trailer_expr
1520
or
atom_expr -> atom trailer_expr
1520
,
atom_expr -> atom trailer_expr
1520
==
atom_expr -> atom trailer_expr
1520
!=
atom_expr -> atom trailer_expr
1520
if
atom_expr -> atom trailer_expr
1520
<<
atom_expr -> atom trailer_expr
1521
factor
984
1521
term
986
1521
(
987
1521
arith_expr
988
1521
NAME
989
1521
[
991
1521
+
992
1521
atom_expr
993
1521
NUMBER
994
1521
atom
995
1521
STRING
996
1521
shift_expr
997
1521
-
998
1521
True
999
1521
None
1003
1521
and_expr
1943
1521
False
1004
1521
{
1006
1521
~
1007
1521
power
1009
1522
and
factor -> - factor
1522
if
factor -> - factor
1522
or
factor -> - factor
1522
>=
factor -> - factor
1522
<
factor -> - factor
1522
!=
factor -> - factor
1522
-
factor -> - factor
1522
==
factor -> - factor
1522
]
factor -> - factor
1522
@
factor -> - factor
1522
|
factor -> - factor
1522
*
factor -> - factor
1522
%
factor -> - factor
1522
+
factor -> - factor
1522
<=
factor -> - factor
1522
//
factor -> - factor
1522
not
factor -> - factor
1522
>>
factor -> - factor
1522
/
factor -> - factor
1522
&
factor -> - factor
1522
^
factor -> - factor
1522
in
factor -> - factor
1522
is
factor -> - factor
1522
>
factor -> - factor
1522
,
factor -> - factor
1522
<<
factor -> - factor
1523
factor
984
1523
term
986
1523
(
987
1523
arith_expr
988
1523
NAME
989
1523
[
991
1523
+
992
1523
atom_expr
993
1523
NUMBER
994
1523
atom
995
1523
STRING
996
1523
shift_expr
997
1523
-
998
1523
True
999
1523
not_test
1000
1523
and_expr
1001
1523
xor_expr
1002
1523
None
1003
1523
False
1004
1523
{
1006
1523
~
1007
1523
and_test
1944
1523
power
1009
1523
expr
1010
1523
not
1013
1523
comparison
1014
1524
factor
984
1524
term
986
1524
(
987
1524
arith_expr
988
1524
NAME
989
1524
[
991
1524
+
992
1524
atom_expr
993
1524
NUMBER
994
1524
atom
995
1524
STRING
996
1524
shift_expr
997
1524
-
998
1524
True
999
1524
and_expr
1001
1524
None
1003
1524
False
1004
1524
{
1006
1524
~
1007
1524
xor_expr
1945
1524
power
1009
1525
factor
984
1525
term
986
1525
(
987
1525
arith_expr
988
1525
NAME
989
1525
[
991
1525
+
992
1525
atom_expr
993
1525
NUMBER
994
1525
atom
995
1525
STRING
996
1525
shift_expr
997
1525
-
998
1525
True
999
1525
and_expr
1001
1525
xor_expr
1002
1525
None
1003
1525
False
1004
1525
{
1006
1525
~
1007
1525
power
1009
1525
expr
1946
1526
factor
984
1526
term
986
1526
(
987
1526
arith_expr
988
1526
NAME
989
1526
[
991
1526
+
992
1526
atom_expr
993
1526
NUMBER
994
1526
atom
995
1526
STRING
996
1526
shift_expr
997
1526
-
998
1526
True
999
1526
not_test
1000
1526
and_expr
1001
1526
xor_expr
1002
1526
None
1003
1526
False
1004
1526
and_test
1005
1526
{
1006
1526
~
1007
1526
power
1009
1526
expr
1010
1526
or_test
1947
1526
not
1013
1526
comparison
1014
1527
>
atom -> { }
1527
==
atom -> { }
1527
-
atom -> { }
1527
]
atom -> { }
1527
not
atom -> { }
1527
(
atom -> { }
1527
@
atom -> { }
1527
if
atom -> { }
1527
and
atom -> { }
1527
,
atom -> { }
1527
&
atom -> { }
1527
<<
atom -> { }
1527
!=
atom -> { }
1527
or
atom -> { }
1527
>>
atom -> { }
1527
<=
atom -> { }
1527
>=
atom -> { }
1527
is
atom -> { }
1527
/
atom -> { }
1527
^
atom -> { }
1527
[
atom -> { }
1527
%
atom -> { }
1527
//
atom -> { }
1527
*
atom -> { }
1527
**
atom -> { }
1527
.
atom -> { }
1527
in
atom -> { }
1527
+
atom -> { }
1527
|
atom -> { }
1527
<
atom -> { }
1528
or
factor -> ~ factor
1528
==
factor -> ~ factor
1528
<=
factor -> ~ factor
1528
@
factor -> ~ factor
1528
!=
factor -> ~ factor
1528
>=
factor -> ~ factor
1528
>
factor -> ~ factor
1528
and
factor -> ~ factor
1528
,
factor -> ~ factor
1528
*
factor -> ~ factor
1528
&
factor -> ~ factor
1528
%
factor -> ~ factor
1528
<
factor -> ~ factor
1528
//
factor -> ~ factor
1528
if
factor -> ~ factor
1528
^
factor -> ~ factor
1528
/
factor -> ~ factor
1528
in
factor -> ~ factor
1528
+
factor -> ~ factor
1528
not
factor -> ~ factor
1528
-
factor -> ~ factor
1528
is
factor -> ~ factor
1528
>>
factor -> ~ factor
1528
<<
factor -> ~ factor
1528
]
factor -> ~ factor
1528
|
factor -> ~ factor
1529
factor
984
1529
or_test
985
1529
term
986
1529
(
987
1529
arith_expr
988
1529
NAME
989
1529
[
991
1529
+
992
1529
atom_expr
993
1529
NUMBER
994
1529
atom
995
1529
STRING
996
1529
shift_expr
997
1529
-
998
1529
True
999
1529
not_test
1000
1529
and_expr
1001
1529
xor_expr
1002
1529
None
1003
1529
False
1004
1529
and_test
1005
1529
{
1006
1529
~
1007
1529
lambda
1008
1529
power
1009
1529
expr
1010
1529
lambdef
1011
1529
test
1948
1529
not
1013
1529
comparison
1014
1530
:
1949
1531
factor
984
1531
term
986
1531
(
987
1531
arith_expr
988
1531
NAME
989
1531
[
991
1531
+
992
1531
atom_expr
993
1531
NUMBER
994
1531
atom
995
1531
STRING
996
1531
shift_expr
997
1531
-
998
1531
True
999
1531
and_expr
1001
1531
comparison
1950
1531
xor_expr
1002
1531
None
1003
1531
False
1004
1531
{
1006
1531
~
1007
1531
power
1009
1531
expr
1010
1532
]
not_test -> not not_test
1532
or
not_test -> not not_test
1532
,
not_test -> not not_test
1532
and
not_test -> not not_test
1532
if
not_test -> not not_test
1533
:
1951
1534
:
1952
1535
as
1953
1535
:
1954
1536
//
1955
1536
/
1956
1536
in
term -> factor
1536
-
term -> factor
1536
*
1957
1536
%
1958
1536
@
1959
1536
:
term -> factor
1536
>=
term -> factor
1536
<
term -> factor
1536
<=
term -> factor
1536
==
term -> factor
1536
!=
term -> factor
1536
>>
term -> factor
1536
is
term -> factor
1536
or
term -> factor
1536
and
term -> factor
1536
as
term -> factor
1536
^
term -> factor
1536
+
term -> factor
1536
&
term -> factor
1536
<<
term -> factor
1536
|
term -> factor
1536
>
term -> factor
1536
if
term -> factor
1536
not
term -> factor
1537
factor
268
1537
term
270
1537
(
271
1537
arith_expr
272
1537
NAME
273
1537
[
274
1537
+
275
1537
test_list_comp
1960
1537
atom_expr
277
1537
NUMBER
278
1537
atom
279
1537
STRING
280
1537
shift_expr
281
1537
-
282
1537
True
283
1537
not_test
284
1537
lambdef
285
1537
and_expr
286
1537
xor_expr
287
1537
False
288
1537
None
289
1537
expr
290
1537
and_test
291
1537
)
1961
1537
{
292
1537
~
293
1537
power
294
1537
lambda
295
1537
comparison
296
1537
or_test
297
1537
not
298
1537
test
299
1537
test_list
300
1538
>>
1962
1538
<<
1963
1538
&
shift_expr -> arith_expr
1538
<=
shift_expr -> arith_expr
1538
>
shift_expr -> arith_expr
1538
not
shift_expr -> arith_expr
1538
!=
shift_expr -> arith_expr
1538
as
shift_expr -> arith_expr
1538
^
shift_expr -> arith_expr
1538
is
shift_expr -> arith_expr
1538
|
shift_expr -> arith_expr
1538
>=
shift_expr -> arith_expr
1538
or
shift_expr -> arith_expr
1538
==
shift_expr -> arith_expr
1538
if
shift_expr -> arith_expr
1538
and
shift_expr -> arith_expr
1538
<
shift_expr -> arith_expr
1538
:
shift_expr -> arith_expr
1538
in
shift_expr -> arith_expr
1539
:
atom -> NAME
1539
-
atom -> NAME
1539
or
atom -> NAME
1539
>>
atom -> NAME
1539
&
atom -> NAME
1539
[
atom -> NAME
1539
<=
atom -> NAME
1539
<
atom -> NAME
1539
.
atom -> NAME
1539
as
atom -> NAME
1539
|
atom -> NAME
1539
*
atom -> NAME
1539
/
atom -> NAME
1539
<<
atom -> NAME
1539
not
atom -> NAME
1539
>
atom -> NAME
1539
is
atom -> NAME
1539
//
atom -> NAME
1539
+
atom -> NAME
1539
if
atom -> NAME
1539
in
atom -> NAME
1539
**
atom -> NAME
1539
!=
atom -> NAME
1539
>=
atom -> NAME
1539
^
atom -> NAME
1539
@
atom -> NAME
1539
(
atom -> NAME
1539
==
atom -> NAME
1539
and
atom -> NAME
1539
%
atom -> NAME
1540
+
1964
1540
-
1965
1540
|
arith_expr -> term
1540
:
arith_expr -> term
1540
or
arith_expr -> term
1540
as
arith_expr -> term
1540
not
arith_expr -> term
1540
<=
arith_expr -> term
1540
!=
arith_expr -> term
1540
<
arith_expr -> term
1540
&
arith_expr -> term
1540
>=
arith_expr -> term
1540
if
arith_expr -> term
1540
==
arith_expr -> term
1540
^
arith_expr -> term
1540
in
arith_expr -> term
1540
is
arith_expr -> term
1540
<<
arith_expr -> term
1540
>
arith_expr -> term
1540
and
arith_expr -> term
1540
>>
arith_expr -> term
1541
factor
117
1541
or_test
118
1541
term
119
1541
(
120
1541
arith_expr
121
1541
NAME
122
1541
[
123
1541
]
1966
1541
+
125
1541
atom_expr
126
1541
NUMBER
127
1541
atom
128
1541
STRING
129
1541
shift_expr
130
1541
-
131
1541
test_list_comp
1967
1541
True
133
1541
not_test
134
1541
lambdef
135
1541
and_expr
136
1541
xor_expr
137
1541
False
138
1541
None
139
1541
expr
140
1541
and_test
141
1541
{
142
1541
~
143
1541
lambda
144
1541
power
145
1541
comparison
146
1541
test_list
147
1541
test
148
1541
not
149
1542
(
1537
1542
NAME
1539
1542
[
1541
1542
~
1542
1542
+
1543
1542
factor
1968
1542
atom_expr
1546
1542
NUMBER
1549
1542
atom
1548
1542
STRING
1550
1542
-
1552
1542
True
1553
1542
False
1557
1542
{
1558
1542
None
1560
1542
power
1564
1543
(
1537
1543
NAME
1539
1543
[
1541
1543
~
1542
1543
+
1543
1543
factor
1969
1543
atom_expr
1546
1543
NUMBER
1549
1543
atom
1548
1543
STRING
1550
1543
-
1552
1543
True
1553
1543
False
1557
1543
{
1558
1543
None
1560
1543
power
1564
1544
:
1970
1544
varargslist
1971
1544
NAME
305
1544
vfpdef
306
1545
is
215
1545
<
217
1545
!=
218
1545
in
219
1545
<=
220
1545
not
221
1545
>=
222
1545
as
comparison -> expr
1545
>
223
1545
==
224
1545
comp_op
1972
1545
and
comparison -> expr
1545
or
comparison -> expr
1545
:
comparison -> expr
1545
if
comparison -> expr
1546
!=
power -> atom_expr
1546
**
1973
1546
as
power -> atom_expr
1546
>
power -> atom_expr
1546
+
power -> atom_expr
1546
not
power -> atom_expr
1546
&
power -> atom_expr
1546
|
power -> atom_expr
1546
>>
power -> atom_expr
1546
:
power -> atom_expr
1546
^
power -> atom_expr
1546
==
power -> atom_expr
1546
if
power -> atom_expr
1546
in
power -> atom_expr
1546
%
power -> atom_expr
1546
<<
power -> atom_expr
1546
or
power -> atom_expr
1546
@
power -> atom_expr
1546
*
power -> atom_expr
1546
/
power -> atom_expr
1546
<
power -> atom_expr
1546
//
power -> atom_expr
1546
>=
power -> atom_expr
1546
-
power -> atom_expr
1546
is
power -> atom_expr
1546
<=
power -> atom_expr
1546
and
power -> atom_expr
1547
&
1974
1547
^
and_expr -> shift_expr
1547
|
and_expr -> shift_expr
1547
<=
and_expr -> shift_expr
1547
or
and_expr -> shift_expr
1547
>
and_expr -> shift_expr
1547
not
and_expr -> shift_expr
1547
!=
and_expr -> shift_expr
1547
and
and_expr -> shift_expr
1547
is
and_expr -> shift_expr
1547
<
and_expr -> shift_expr
1547
as
and_expr -> shift_expr
1547
if
and_expr -> shift_expr
1547
in
and_expr -> shift_expr
1547
>=
and_expr -> shift_expr
1547
:
and_expr -> shift_expr
1547
==
and_expr -> shift_expr
1548
trailer
1975
1548
.
1976
1548
(
1977
1548
[
1978
1548
trailer_expr
1979
1548
<<
trailer_expr -> 
1548
%
trailer_expr -> 
1548
==
trailer_expr -> 
1548
-
trailer_expr -> 
1548
<
trailer_expr -> 
1548
if
trailer_expr -> 
1548
or
trailer_expr -> 
1548
/
trailer_expr -> 
1548
**
trailer_expr -> 
1548
and
trailer_expr -> 
1548
@
trailer_expr -> 
1548
*
trailer_expr -> 
1548
|
trailer_expr -> 
1548
is
trailer_expr -> 
1548
+
trailer_expr -> 
1548
in
trailer_expr -> 
1548
&
trailer_expr -> 
1548
<=
trailer_expr -> 
1548
>=
trailer_expr -> 
1548
^
trailer_expr -> 
1548
>
trailer_expr -> 
1548
!=
trailer_expr -> 
1548
not
trailer_expr -> 
1548
>>
trailer_expr -> 
1548
//
trailer_expr -> 
1548
as
trailer_expr -> 
1548
:
trailer_expr -> 
1549
[
atom -> NUMBER
1549
>=
atom -> NUMBER
1549
<=
atom -> NUMBER
1549
!=
atom -> NUMBER
1549
//
atom -> NUMBER
1549
in
atom -> NUMBER
1549
/
atom -> NUMBER
1549
:
atom -> NUMBER
1549
or
atom -> NUMBER
1549
>
atom -> NUMBER
1549
as
atom -> NUMBER
1549
not
atom -> NUMBER
1549
>>
atom -> NUMBER
1549
(
atom -> NUMBER
1549
**
atom -> NUMBER
1549
<<
atom -> NUMBER
1549
and
atom -> NUMBER
1549
+
atom -> NUMBER
1549
%
atom -> NUMBER
1549
==
atom -> NUMBER
1549
if
atom -> NUMBER
1549
is
atom -> NUMBER
1549
*
atom -> NUMBER
1549
@
atom -> NUMBER
1549
|
atom -> NUMBER
1549
-
atom -> NUMBER
1549
.
atom -> NUMBER
1549
^
atom -> NUMBER
1549
<
atom -> NUMBER
1549
&
atom -> NUMBER
1550
and
atom -> STRING
1550
%
atom -> STRING
1550
//
atom -> STRING
1550
>>
atom -> STRING
1550
*
atom -> STRING
1550
<
atom -> STRING
1550
.
atom -> STRING
1550
in
atom -> STRING
1550
:
atom -> STRING
1550
^
atom -> STRING
1550
(
atom -> STRING
1550
if
atom -> STRING
1550
==
atom -> STRING
1550
-
atom -> STRING
1550
**
atom -> STRING
1550
as
atom -> STRING
1550
<<
atom -> STRING
1550
<=
atom -> STRING
1550
[
atom -> STRING
1550
not
atom -> STRING
1550
or
atom -> STRING
1550
+
atom -> STRING
1550
>=
atom -> STRING
1550
@
atom -> STRING
1550
&
atom -> STRING
1550
>
atom -> STRING
1550
is
atom -> STRING
1550
|
atom -> STRING
1550
!=
atom -> STRING
1550
/
atom -> STRING
1551
factor
9
1551
arith_expr
2
1551
NAME
29
1551
term
21
1551
[
3
1551
~
45
1551
suite
1980
1551
atom_expr
24
1551
expr
16
1551
power
56
1551
(
36
1551
return
13
1551
small_stmt
1981
1551
flow_stmt
15
1551
True
17
1551
not_test
18
1551
and_expr
19
1551
xor_expr
22
1551
{
52
1551
lambdef
53
1551
atom
54
1551
or_test
23
1551
shift_expr
50
1551
False
35
1551
NEWLINE
1982
1551
-
49
1551
None
42
1551
lambda
40
1551
global
25
1551
NUMBER
27
1551
STRING
28
1551
test
48
1551
endsim
33
1551
and_test
37
1551
simple_stmt
1983
1551
comparison
39
1551
break_stmt
74
1551
+
55
1551
not
57
1551
raise
62
1551
continue
59
1551
return_stmt
75
1551
del_stmt
60
1551
test_list
61
1551
raise_stmt
63
1551
resetstats
64
1551
pass_stmt
65
1551
nonlocal
66
1551
break
76
1551
sim_stmt
77
1551
stat_stmt
78
1551
global_stmt
67
1551
yield_stmt
79
1551
assert_stmt
80
1551
pass
81
1551
yield
68
1551
continue_stmt
69
1551
assert
70
1551
nonlocal_stmt
71
1551
expr_stmt
72
1551
begsim
83
1551
del
84
1552
(
1537
1552
NAME
1539
1552
[
1541
1552
~
1542
1552
+
1543
1552
atom_expr
1546
1552
NUMBER
1549
1552
atom
1548
1552
STRING
1550
1552
-
1552
1552
True
1553
1552
False
1557
1552
{
1558
1552
None
1560
1552
power
1564
1552
factor
1984
1553
(
atom -> True
1553
[
atom -> True
1553
+
atom -> True
1553
@
atom -> True
1553
not
atom -> True
1553
<=
atom -> True
1553
&
atom -> True
1553
<<
atom -> True
1553
-
atom -> True
1553
/
atom -> True
1553
as
atom -> True
1553
or
atom -> True
1553
>
atom -> True
1553
%
atom -> True
1553
^
atom -> True
1553
if
atom -> True
1553
!=
atom -> True
1553
is
atom -> True
1553
*
atom -> True
1553
<
atom -> True
1553
and
atom -> True
1553
.
atom -> True
1553
==
atom -> True
1553
**
atom -> True
1553
>>
atom -> True
1553
in
atom -> True
1553
|
atom -> True
1553
>=
atom -> True
1553
//
atom -> True
1553
:
atom -> True
1554
and
1985
1554
or
and_test -> not_test
1554
as
and_test -> not_test
1554
if
and_test -> not_test
1554
:
and_test -> not_test
1555
as
xor_expr -> and_expr
1555
^
1986
1555
not
xor_expr -> and_expr
1555
if
xor_expr -> and_expr
1555
<=
xor_expr -> and_expr
1555
:
xor_expr -> and_expr
1555
>
xor_expr -> and_expr
1555
<
xor_expr -> and_expr
1555
in
xor_expr -> and_expr
1555
>=
xor_expr -> and_expr
1555
==
xor_expr -> and_expr
1555
|
xor_expr -> and_expr
1555
is
xor_expr -> and_expr
1555
and
xor_expr -> and_expr
1555
or
xor_expr -> and_expr
1555
!=
xor_expr -> and_expr
1556
|
1987
1556
>=
expr -> xor_expr
1556
==
expr -> xor_expr
1556
is
expr -> xor_expr
1556
as
expr -> xor_expr
1556
:
expr -> xor_expr
1556
if
expr -> xor_expr
1556
or
expr -> xor_expr
1556
>
expr -> xor_expr
1556
and
expr -> xor_expr
1556
<
expr -> xor_expr
1556
in
expr -> xor_expr
1556
<=
expr -> xor_expr
1556
not
expr -> xor_expr
1556
!=
expr -> xor_expr
1557
in
atom -> False
1557
>
atom -> False
1557
-
atom -> False
1557
%
atom -> False
1557
<
atom -> False
1557
|
atom -> False
1557
==
atom -> False
1557
&
atom -> False
1557
//
atom -> False
1557
and
atom -> False
1557
:
atom -> False
1557
not
atom -> False
1557
+
atom -> False
1557
!=
atom -> False
1557
if
atom -> False
1557
as
atom -> False
1557
@
atom -> False
1557
[
atom -> False
1557
or
atom -> False
1557
<=
atom -> False
1557
*
atom -> False
1557
^
atom -> False
1557
is
atom -> False
1557
/
atom -> False
1557
.
atom -> False
1557
>=
atom -> False
1557
**
atom -> False
1557
>>
atom -> False
1557
<<
atom -> False
1557
(
atom -> False
1558
}
1988
1559
as
test -> or_test
1559
if
1989
1559
:
test -> or_test
1560
is
atom -> None
1560
.
atom -> None
1560
==
atom -> None
1560
^
atom -> None
1560
as
atom -> None
1560
<<
atom -> None
1560
>>
atom -> None
1560
(
atom -> None
1560
|
atom -> None
1560
+
atom -> None
1560
*
atom -> None
1560
//
atom -> None
1560
@
atom -> None
1560
in
atom -> None
1560
>=
atom -> None
1560
!=
atom -> None
1560
%
atom -> None
1560
[
atom -> None
1560
and
atom -> None
1560
-
atom -> None
1560
if
atom -> None
1560
&
atom -> None
1560
<=
atom -> None
1560
<
atom -> None
1560
>
atom -> None
1560
**
atom -> None
1560
:
atom -> None
1560
or
atom -> None
1560
/
atom -> None
1560
not
atom -> None
1561
:
not_test -> comparison
1561
or
not_test -> comparison
1561
as
not_test -> comparison
1561
and
not_test -> comparison
1561
if
not_test -> comparison
1562
or
1990
1562
:
or_test -> and_test
1562
as
or_test -> and_test
1562
if
or_test -> and_test
1563
as
test -> lambdef
1563
:
test -> lambdef
1564
&
factor -> power
1564
%
factor -> power
1564
<<
factor -> power
1564
-
factor -> power
1564
<=
factor -> power
1564
not
factor -> power
1564
//
factor -> power
1564
/
factor -> power
1564
is
factor -> power
1564
|
factor -> power
1564
<
factor -> power
1564
and
factor -> power
1564
>=
factor -> power
1564
>>
factor -> power
1564
>
factor -> power
1564
in
factor -> power
1564
if
factor -> power
1564
^
factor -> power
1564
==
factor -> power
1564
as
factor -> power
1564
+
factor -> power
1564
@
factor -> power
1564
or
factor -> power
1564
*
factor -> power
1564
:
factor -> power
1564
!=
factor -> power
1565
factor
1536
1565
(
1537
1565
arith_expr
1538
1565
NAME
1539
1565
term
1540
1565
[
1541
1565
~
1542
1565
+
1543
1565
expr
1545
1565
atom_expr
1546
1565
shift_expr
1547
1565
atom
1548
1565
NUMBER
1549
1565
STRING
1550
1565
-
1552
1565
not_test
1991
1565
True
1553
1565
and_expr
1555
1565
xor_expr
1556
1565
False
1557
1565
{
1558
1565
None
1560
1565
comparison
1561
1565
power
1564
1565
not
1565
1566
factor
85
1566
(
86
1566
arith_expr
87
1566
NAME
88
1566
term
89
1566
[
90
1566
~
91
1566
+
92
1566
expr
93
1566
atom_expr
94
1566
atom
95
1566
NUMBER
96
1566
STRING
97
1566
test
1992
1566
shift_expr
99
1566
-
100
1566
True
101
1566
and_expr
102
1566
xor_expr
103
1566
False
104
1566
{
105
1566
None
106
1566
and_test
107
1566
power
108
1566
not_test
109
1566
lambdef
110
1566
or_test
111
1566
comparison
112
1566
not
113
1566
lambda
114
1567
:
1993
1568
NAME
1994
1569
factor
152
1569
NUMBER
153
1569
expr_list
1995
1569
term
155
1569
(
156
1569
True
157
1569
[
158
1569
+
159
1569
STRING
160
1569
atom_expr
161
1569
arith_expr
162
1569
expr
163
1569
~
164
1569
NAME
165
1569
False
166
1569
{
167
1569
and_expr
168
1569
xor_expr
169
1569
None
170
1569
power
171
1569
-
172
1569
shift_expr
173
1569
atom
174
1570
STRING
compound_stmt -> with_stmt
1570
global
compound_stmt -> with_stmt
1570
(
compound_stmt -> with_stmt
1570
-
compound_stmt -> with_stmt
1570
yield
compound_stmt -> with_stmt
1570
continue
compound_stmt -> with_stmt
1570
[
compound_stmt -> with_stmt
1570
+
compound_stmt -> with_stmt
1570
True
compound_stmt -> with_stmt
1570
@
compound_stmt -> with_stmt
1570
begsim
compound_stmt -> with_stmt
1570
not
compound_stmt -> with_stmt
1570
nonlocal
compound_stmt -> with_stmt
1570
break
compound_stmt -> with_stmt
1570
pass
compound_stmt -> with_stmt
1570
NAME
compound_stmt -> with_stmt
1570
del
compound_stmt -> with_stmt
1570
resetstats
compound_stmt -> with_stmt
1570
def
compound_stmt -> with_stmt
1570
raise
compound_stmt -> with_stmt
1570
~
compound_stmt -> with_stmt
1570
with
compound_stmt -> with_stmt
1570
conf
compound_stmt -> with_stmt
1570
class
compound_stmt -> with_stmt
1570
NUMBER
compound_stmt -> with_stmt
1570
None
compound_stmt -> with_stmt
1570
endsim
compound_stmt -> with_stmt
1570
while
compound_stmt -> with_stmt
1570
False
compound_stmt -> with_stmt
1570
return
compound_stmt -> with_stmt
1570
DEDENT
compound_stmt -> with_stmt
1570
{
compound_stmt -> with_stmt
1570
for
compound_stmt -> with_stmt
1570
if
compound_stmt -> with_stmt
1570
lambda
compound_stmt -> with_stmt
1570
assert
compound_stmt -> with_stmt
1570
try
compound_stmt -> with_stmt
1571
def
compound_stmt -> while_stmt
1571
if
compound_stmt -> while_stmt
1571
assert
compound_stmt -> while_stmt
1571
-
compound_stmt -> while_stmt
1571
+
compound_stmt -> while_stmt
1571
{
compound_stmt -> while_stmt
1571
NUMBER
compound_stmt -> while_stmt
1571
begsim
compound_stmt -> while_stmt
1571
pass
compound_stmt -> while_stmt
1571
raise
compound_stmt -> while_stmt
1571
continue
compound_stmt -> while_stmt
1571
try
compound_stmt -> while_stmt
1571
False
compound_stmt -> while_stmt
1571
lambda
compound_stmt -> while_stmt
1571
conf
compound_stmt -> while_stmt
1571
(
compound_stmt -> while_stmt
1571
del
compound_stmt -> while_stmt
1571
resetstats
compound_stmt -> while_stmt
1571
yield
compound_stmt -> while_stmt
1571
None
compound_stmt -> while_stmt
1571
~
compound_stmt -> while_stmt
1571
for
compound_stmt -> while_stmt
1571
STRING
compound_stmt -> while_stmt
1571
endsim
compound_stmt -> while_stmt
1571
DEDENT
compound_stmt -> while_stmt
1571
nonlocal
compound_stmt -> while_stmt
1571
True
compound_stmt -> while_stmt
1571
@
compound_stmt -> while_stmt
1571
NAME
compound_stmt -> while_stmt
1571
[
compound_stmt -> while_stmt
1571
while
compound_stmt -> while_stmt
1571
return
compound_stmt -> while_stmt
1571
class
compound_stmt -> while_stmt
1571
global
compound_stmt -> while_stmt
1571
break
compound_stmt -> while_stmt
1571
not
compound_stmt -> while_stmt
1571
with
compound_stmt -> while_stmt
1572
return
stmt -> simple_stmt
1572
continue
stmt -> simple_stmt
1572
False
stmt -> simple_stmt
1572
-
stmt -> simple_stmt
1572
~
stmt -> simple_stmt
1572
not
stmt -> simple_stmt
1572
if
stmt -> simple_stmt
1572
class
stmt -> simple_stmt
1572
[
stmt -> simple_stmt
1572
raise
stmt -> simple_stmt
1572
@
stmt -> simple_stmt
1572
pass
stmt -> simple_stmt
1572
def
stmt -> simple_stmt
1572
+
stmt -> simple_stmt
1572
del
stmt -> simple_stmt
1572
yield
stmt -> simple_stmt
1572
(
stmt -> simple_stmt
1572
conf
stmt -> simple_stmt
1572
{
stmt -> simple_stmt
1572
break
stmt -> simple_stmt
1572
while
stmt -> simple_stmt
1572
True
stmt -> simple_stmt
1572
with
stmt -> simple_stmt
1572
lambda
stmt -> simple_stmt
1572
begsim
stmt -> simple_stmt
1572
endsim
stmt -> simple_stmt
1572
try
stmt -> simple_stmt
1572
nonlocal
stmt -> simple_stmt
1572
None
stmt -> simple_stmt
1572
for
stmt -> simple_stmt
1572
assert
stmt -> simple_stmt
1572
NAME
stmt -> simple_stmt
1572
resetstats
stmt -> simple_stmt
1572
STRING
stmt -> simple_stmt
1572
global
stmt -> simple_stmt
1572
NUMBER
stmt -> simple_stmt
1572
DEDENT
stmt -> simple_stmt
1573
def
1575
1573
class
1568
1573
classdef
1996
1573
funcdef
1997
1574
with
compound_stmt -> confdef
1574
@
compound_stmt -> confdef
1574
break
compound_stmt -> confdef
1574
pass
compound_stmt -> confdef
1574
not
compound_stmt -> confdef
1574
+
compound_stmt -> confdef
1574
nonlocal
compound_stmt -> confdef
1574
class
compound_stmt -> confdef
1574
endsim
compound_stmt -> confdef
1574
STRING
compound_stmt -> confdef
1574
conf
compound_stmt -> confdef
1574
def
compound_stmt -> confdef
1574
for
compound_stmt -> confdef
1574
global
compound_stmt -> confdef
1574
resetstats
compound_stmt -> confdef
1574
DEDENT
compound_stmt -> confdef
1574
NUMBER
compound_stmt -> confdef
1574
if
compound_stmt -> confdef
1574
begsim
compound_stmt -> confdef
1574
yield
compound_stmt -> confdef
1574
[
compound_stmt -> confdef
1574
lambda
compound_stmt -> confdef
1574
-
compound_stmt -> confdef
1574
True
compound_stmt -> confdef
1574
return
compound_stmt -> confdef
1574
while
compound_stmt -> confdef
1574
assert
compound_stmt -> confdef
1574
NAME
compound_stmt -> confdef
1574
del
compound_stmt -> confdef
1574
None
compound_stmt -> confdef
1574
(
compound_stmt -> confdef
1574
False
compound_stmt -> confdef
1574
{
compound_stmt -> confdef
1574
~
compound_stmt -> confdef
1574
try
compound_stmt -> confdef
1574
continue
compound_stmt -> confdef
1574
raise
compound_stmt -> confdef
1575
NAME
1998
1576
class
compound_stmt -> for_stmt
1576
conf
compound_stmt -> for_stmt
1576
False
compound_stmt -> for_stmt
1576
assert
compound_stmt -> for_stmt
1576
{
compound_stmt -> for_stmt
1576
yield
compound_stmt -> for_stmt
1576
~
compound_stmt -> for_stmt
1576
global
compound_stmt -> for_stmt
1576
not
compound_stmt -> for_stmt
1576
break
compound_stmt -> for_stmt
1576
NUMBER
compound_stmt -> for_stmt
1576
def
compound_stmt -> for_stmt
1576
for
compound_stmt -> for_stmt
1576
del
compound_stmt -> for_stmt
1576
if
compound_stmt -> for_stmt
1576
[
compound_stmt -> for_stmt
1576
return
compound_stmt -> for_stmt
1576
try
compound_stmt -> for_stmt
1576
raise
compound_stmt -> for_stmt
1576
+
compound_stmt -> for_stmt
1576
while
compound_stmt -> for_stmt
1576
@
compound_stmt -> for_stmt
1576
True
compound_stmt -> for_stmt
1576
resetstats
compound_stmt -> for_stmt
1576
begsim
compound_stmt -> for_stmt
1576
STRING
compound_stmt -> for_stmt
1576
None
compound_stmt -> for_stmt
1576
nonlocal
compound_stmt -> for_stmt
1576
endsim
compound_stmt -> for_stmt
1576
DEDENT
compound_stmt -> for_stmt
1576
pass
compound_stmt -> for_stmt
1576
(
compound_stmt -> for_stmt
1576
-
compound_stmt -> for_stmt
1576
continue
compound_stmt -> for_stmt
1576
NAME
compound_stmt -> for_stmt
1576
with
compound_stmt -> for_stmt
1576
lambda
compound_stmt -> for_stmt
1577
STRING
compound_stmt -> if_stmt
1577
try
compound_stmt -> if_stmt
1577
{
compound_stmt -> if_stmt
1577
del
compound_stmt -> if_stmt
1577
True
compound_stmt -> if_stmt
1577
+
compound_stmt -> if_stmt
1577
class
compound_stmt -> if_stmt
1577
None
compound_stmt -> if_stmt
1577
return
compound_stmt -> if_stmt
1577
[
compound_stmt -> if_stmt
1577
NUMBER
compound_stmt -> if_stmt
1577
for
compound_stmt -> if_stmt
1577
assert
compound_stmt -> if_stmt
1577
lambda
compound_stmt -> if_stmt
1577
False
compound_stmt -> if_stmt
1577
with
compound_stmt -> if_stmt
1577
global
compound_stmt -> if_stmt
1577
endsim
compound_stmt -> if_stmt
1577
@
compound_stmt -> if_stmt
1577
begsim
compound_stmt -> if_stmt
1577
DEDENT
compound_stmt -> if_stmt
1577
yield
compound_stmt -> if_stmt
1577
(
compound_stmt -> if_stmt
1577
conf
compound_stmt -> if_stmt
1577
nonlocal
compound_stmt -> if_stmt
1577
not
compound_stmt -> if_stmt
1577
break
compound_stmt -> if_stmt
1577
NAME
compound_stmt -> if_stmt
1577
if
compound_stmt -> if_stmt
1577
-
compound_stmt -> if_stmt
1577
raise
compound_stmt -> if_stmt
1577
while
compound_stmt -> if_stmt
1577
def
compound_stmt -> if_stmt
1577
pass
compound_stmt -> if_stmt
1577
resetstats
compound_stmt -> if_stmt
1577
continue
compound_stmt -> if_stmt
1577
~
compound_stmt -> if_stmt
1578
factor
236
1578
term
237
1578
(
238
1578
arith_expr
239
1578
NAME
241
1578
False
242
1578
[
243
1578
~
244
1578
+
245
1578
lambda
246
1578
expr
247
1578
atom_expr
248
1578
with_items
1999
1578
shift_expr
249
1578
atom
250
1578
NUMBER
251
1578
STRING
252
1578
-
253
1578
True
254
1578
not_test
255
1578
and_expr
256
1578
xor_expr
257
1578
{
258
1578
or_test
259
1578
None
260
1578
comparison
261
1578
and_test
262
1578
lambdef
263
1578
power
264
1578
not
265
1578
test
266
1578
with_item
267
1579
pass
compound_stmt -> classdef
1579
endsim
compound_stmt -> classdef
1579
conf
compound_stmt -> classdef
1579
False
compound_stmt -> classdef
1579
~
compound_stmt -> classdef
1579
continue
compound_stmt -> classdef
1579
with
compound_stmt -> classdef
1579
class
compound_stmt -> classdef
1579
if
compound_stmt -> classdef
1579
nonlocal
compound_stmt -> classdef
1579
while
compound_stmt -> classdef
1579
{
compound_stmt -> classdef
1579
True
compound_stmt -> classdef
1579
raise
compound_stmt -> classdef
1579
NUMBER
compound_stmt -> classdef
1579
global
compound_stmt -> classdef
1579
for
compound_stmt -> classdef
1579
@
compound_stmt -> classdef
1579
resetstats
compound_stmt -> classdef
1579
STRING
compound_stmt -> classdef
1579
def
compound_stmt -> classdef
1579
[
compound_stmt -> classdef
1579
DEDENT
compound_stmt -> classdef
1579
(
compound_stmt -> classdef
1579
NAME
compound_stmt -> classdef
1579
try
compound_stmt -> classdef
1579
not
compound_stmt -> classdef
1579
del
compound_stmt -> classdef
1579
yield
compound_stmt -> classdef
1579
-
compound_stmt -> classdef
1579
return
compound_stmt -> classdef
1579
begsim
compound_stmt -> classdef
1579
lambda
compound_stmt -> classdef
1579
+
compound_stmt -> classdef
1579
assert
compound_stmt -> classdef
1579
None
compound_stmt -> classdef
1579
break
compound_stmt -> classdef
1580
NAME
2000
1581
factor
85
1581
(
86
1581
arith_expr
87
1581
NAME
88
1581
term
89
1581
[
90
1581
~
91
1581
+
92
1581
expr
93
1581
atom_expr
94
1581
atom
95
1581
NUMBER
96
1581
STRING
97
1581
shift_expr
99
1581
-
100
1581
test
2001
1581
True
101
1581
and_expr
102
1581
xor_expr
103
1581
False
104
1581
{
105
1581
None
106
1581
and_test
107
1581
power
108
1581
not_test
109
1581
lambdef
110
1581
or_test
111
1581
comparison
112
1581
not
113
1581
lambda
114
1582
assert
compound_stmt -> try_stmt
1582
@
compound_stmt -> try_stmt
1582
with
compound_stmt -> try_stmt
1582
{
compound_stmt -> try_stmt
1582
endsim
compound_stmt -> try_stmt
1582
pass
compound_stmt -> try_stmt
1582
not
compound_stmt -> try_stmt
1582
False
compound_stmt -> try_stmt
1582
-
compound_stmt -> try_stmt
1582
begsim
compound_stmt -> try_stmt
1582
resetstats
compound_stmt -> try_stmt
1582
return
compound_stmt -> try_stmt
1582
break
compound_stmt -> try_stmt
1582
def
compound_stmt -> try_stmt
1582
NAME
compound_stmt -> try_stmt
1582
raise
compound_stmt -> try_stmt
1582
for
compound_stmt -> try_stmt
1582
NUMBER
compound_stmt -> try_stmt
1582
+
compound_stmt -> try_stmt
1582
nonlocal
compound_stmt -> try_stmt
1582
global
compound_stmt -> try_stmt
1582
STRING
compound_stmt -> try_stmt
1582
while
compound_stmt -> try_stmt
1582
if
compound_stmt -> try_stmt
1582
DEDENT
compound_stmt -> try_stmt
1582
class
compound_stmt -> try_stmt
1582
del
compound_stmt -> try_stmt
1582
continue
compound_stmt -> try_stmt
1582
True
compound_stmt -> try_stmt
1582
yield
compound_stmt -> try_stmt
1582
(
compound_stmt -> try_stmt
1582
~
compound_stmt -> try_stmt
1582
conf
compound_stmt -> try_stmt
1582
None
compound_stmt -> try_stmt
1582
lambda
compound_stmt -> try_stmt
1582
[
compound_stmt -> try_stmt
1582
try
compound_stmt -> try_stmt
1583
pass
compound_stmt -> funcdef
1583
[
compound_stmt -> funcdef
1583
~
compound_stmt -> funcdef
1583
yield
compound_stmt -> funcdef
1583
endsim
compound_stmt -> funcdef
1583
False
compound_stmt -> funcdef
1583
while
compound_stmt -> funcdef
1583
not
compound_stmt -> funcdef
1583
nonlocal
compound_stmt -> funcdef
1583
+
compound_stmt -> funcdef
1583
for
compound_stmt -> funcdef
1583
DEDENT
compound_stmt -> funcdef
1583
assert
compound_stmt -> funcdef
1583
None
compound_stmt -> funcdef
1583
resetstats
compound_stmt -> funcdef
1583
global
compound_stmt -> funcdef
1583
True
compound_stmt -> funcdef
1583
-
compound_stmt -> funcdef
1583
{
compound_stmt -> funcdef
1583
continue
compound_stmt -> funcdef
1583
(
compound_stmt -> funcdef
1583
break
compound_stmt -> funcdef
1583
lambda
compound_stmt -> funcdef
1583
begsim
compound_stmt -> funcdef
1583
def
compound_stmt -> funcdef
1583
raise
compound_stmt -> funcdef
1583
STRING
compound_stmt -> funcdef
1583
class
compound_stmt -> funcdef
1583
return
compound_stmt -> funcdef
1583
NAME
compound_stmt -> funcdef
1583
@
compound_stmt -> funcdef
1583
try
compound_stmt -> funcdef
1583
with
compound_stmt -> funcdef
1583
NUMBER
compound_stmt -> funcdef
1583
del
compound_stmt -> funcdef
1583
if
compound_stmt -> funcdef
1583
conf
compound_stmt -> funcdef
1584
-
compound_stmt -> decorated
1584
return
compound_stmt -> decorated
1584
False
compound_stmt -> decorated
1584
with
compound_stmt -> decorated
1584
if
compound_stmt -> decorated
1584
def
compound_stmt -> decorated
1584
assert
compound_stmt -> decorated
1584
None
compound_stmt -> decorated
1584
True
compound_stmt -> decorated
1584
pass
compound_stmt -> decorated
1584
del
compound_stmt -> decorated
1584
lambda
compound_stmt -> decorated
1584
continue
compound_stmt -> decorated
1584
nonlocal
compound_stmt -> decorated
1584
NAME
compound_stmt -> decorated
1584
(
compound_stmt -> decorated
1584
global
compound_stmt -> decorated
1584
endsim
compound_stmt -> decorated
1584
begsim
compound_stmt -> decorated
1584
try
compound_stmt -> decorated
1584
[
compound_stmt -> decorated
1584
{
compound_stmt -> decorated
1584
for
compound_stmt -> decorated
1584
not
compound_stmt -> decorated
1584
DEDENT
compound_stmt -> decorated
1584
class
compound_stmt -> decorated
1584
+
compound_stmt -> decorated
1584
yield
compound_stmt -> decorated
1584
~
compound_stmt -> decorated
1584
@
compound_stmt -> decorated
1584
NUMBER
compound_stmt -> decorated
1584
break
compound_stmt -> decorated
1584
while
compound_stmt -> decorated
1584
STRING
compound_stmt -> decorated
1584
raise
compound_stmt -> decorated
1584
conf
compound_stmt -> decorated
1584
resetstats
compound_stmt -> decorated
1585
NEWLINE
2002
1586
DEDENT
2003
1587
(
stmt -> compound_stmt
1587
[
stmt -> compound_stmt
1587
assert
stmt -> compound_stmt
1587
raise
stmt -> compound_stmt
1587
{
stmt -> compound_stmt
1587
def
stmt -> compound_stmt
1587
continue
stmt -> compound_stmt
1587
@
stmt -> compound_stmt
1587
lambda
stmt -> compound_stmt
1587
False
stmt -> compound_stmt
1587
+
stmt -> compound_stmt
1587
class
stmt -> compound_stmt
1587
not
stmt -> compound_stmt
1587
conf
stmt -> compound_stmt
1587
True
stmt -> compound_stmt
1587
if
stmt -> compound_stmt
1587
-
stmt -> compound_stmt
1587
del
stmt -> compound_stmt
1587
NUMBER
stmt -> compound_stmt
1587
NAME
stmt -> compound_stmt
1587
return
stmt -> compound_stmt
1587
try
stmt -> compound_stmt
1587
~
stmt -> compound_stmt
1587
nonlocal
stmt -> compound_stmt
1587
global
stmt -> compound_stmt
1587
yield
stmt -> compound_stmt
1587
None
stmt -> compound_stmt
1587
while
stmt -> compound_stmt
1587
break
stmt -> compound_stmt
1587
DEDENT
stmt -> compound_stmt
1587
with
stmt -> compound_stmt
1587
pass
stmt -> compound_stmt
1587
STRING
stmt -> compound_stmt
1587
for
stmt -> compound_stmt
1587
endsim
stmt -> compound_stmt
1587
resetstats
stmt -> compound_stmt
1587
begsim
stmt -> compound_stmt
1588
if
1566
1588
arith_expr
2
1588
try
1567
1588
[
3
1588
class
1568
1588
for
1569
1588
with_stmt
1570
1588
while_stmt
1571
1588
factor
9
1588
@
10
1588
simple_stmt
1572
1588
decorators
1573
1588
return
13
1588
confdef
1574
1588
flow_stmt
15
1588
expr
16
1588
True
17
1588
not_test
18
1588
and_expr
19
1588
def
1575
1588
term
21
1588
xor_expr
22
1588
or_test
23
1588
atom_expr
24
1588
global
25
1588
for_stmt
1576
1588
NUMBER
27
1588
STRING
28
1588
NAME
29
1588
decorator
30
1588
if_stmt
1577
1588
with
1578
1588
endsim
33
1588
classdef
1579
1588
False
35
1588
(
36
1588
and_test
37
1588
conf
1580
1588
comparison
39
1588
lambda
40
1588
while
1581
1588
None
42
1588
try_stmt
1582
1588
funcdef
1583
1588
~
45
1588
decorated
1584
1588
small_stmt
1585
1588
test
48
1588
-
49
1588
shift_expr
50
1588
{
52
1588
lambdef
53
1588
atom
54
1588
+
55
1588
power
56
1588
not
57
1588
compound_stmt
1587
1588
continue
59
1588
del_stmt
60
1588
test_list
61
1588
raise
62
1588
raise_stmt
63
1588
resetstats
64
1588
pass_stmt
65
1588
stmt
1588
1588
nonlocal
66
1588
global_stmt
67
1588
yield
68
1588
continue_stmt
69
1588
assert
70
1588
nonlocal_stmt
71
1588
expr_stmt
72
1588
break_stmt
74
1588
stmt_list
2004
1588
return_stmt
75
1588
break
76
1588
sim_stmt
77
1588
stat_stmt
78
1588
yield_stmt
79
1588
DEDENT
stmt_list -> stmt
1588
assert_stmt
80
1588
pass
81
1588
begsim
83
1588
del
84
1589
:
2005
1590
factor
9
1590
arith_expr
2
1590
NAME
29
1590
term
21
1590
[
3
1590
~
45
1590
atom_expr
24
1590
expr
16
1590
power
56
1590
(
36
1590
return
13
1590
small_stmt
47
1590
flow_stmt
15
1590
True
17
1590
not_test
18
1590
and_expr
19
1590
xor_expr
22
1590
{
52
1590
lambdef
53
1590
atom
54
1590
or_test
23
1590
shift_expr
50
1590
False
35
1590
NEWLINE
1022
1590
-
49
1590
None
42
1590
lambda
40
1590
global
25
1590
NUMBER
27
1590
STRING
28
1590
test
48
1590
endsim
33
1590
suite
2006
1590
and_test
37
1590
simple_stmt
1023
1590
comparison
39
1590
break_stmt
74
1590
+
55
1590
not
57
1590
raise
62
1590
continue
59
1590
return_stmt
75
1590
del_stmt
60
1590
test_list
61
1590
raise_stmt
63
1590
resetstats
64
1590
pass_stmt
65
1590
nonlocal
66
1590
break
76
1590
sim_stmt
77
1590
stat_stmt
78
1590
global_stmt
67
1590
yield_stmt
79
1590
assert_stmt
80
1590
pass
81
1590
yield
68
1590
continue_stmt
69
1590
assert
70
1590
nonlocal_stmt
71
1590
expr_stmt
72
1590
begsim
83
1590
del
84
1591
if
1566
1591
arith_expr
2
1591
try
1567
1591
[
3
1591
class
1568
1591
for
1569
1591
stmt_list
2007
1591
with_stmt
1570
1591
while_stmt
1571
1591
factor
9
1591
@
10
1591
simple_stmt
1572
1591
decorators
1573
1591
return
13
1591
confdef
1574
1591
flow_stmt
15
1591
expr
16
1591
True
17
1591
not_test
18
1591
and_expr
19
1591
def
1575
1591
term
21
1591
xor_expr
22
1591
or_test
23
1591
atom_expr
24
1591
global
25
1591
for_stmt
1576
1591
NUMBER
27
1591
STRING
28
1591
NAME
29
1591
decorator
30
1591
if_stmt
1577
1591
with
1578
1591
endsim
33
1591
classdef
1579
1591
False
35
1591
(
36
1591
and_test
37
1591
conf
1580
1591
comparison
39
1591
lambda
40
1591
while
1581
1591
None
42
1591
try_stmt
1582
1591
funcdef
1583
1591
~
45
1591
decorated
1584
1591
small_stmt
1585
1591
test
48
1591
-
49
1591
shift_expr
50
1591
{
52
1591
lambdef
53
1591
atom
54
1591
+
55
1591
power
56
1591
not
57
1591
compound_stmt
1587
1591
continue
59
1591
del_stmt
60
1591
test_list
61
1591
raise
62
1591
raise_stmt
63
1591
resetstats
64
1591
pass_stmt
65
1591
stmt
1588
1591
nonlocal
66
1591
global_stmt
67
1591
yield
68
1591
continue_stmt
69
1591
assert
70
1591
nonlocal_stmt
71
1591
expr_stmt
72
1591
break_stmt
74
1591
return_stmt
75
1591
break
76
1591
sim_stmt
77
1591
stat_stmt
78
1591
yield_stmt
79
1591
assert_stmt
80
1591
pass
81
1591
begsim
83
1591
del
84
1592
factor
1029
1592
(
1032
1592
NAME
1034
1592
[
1035
1592
~
1036
1592
+
1037
1592
atom_expr
1039
1592
NUMBER
1041
1592
atom
1040
1592
STRING
1042
1592
-
1044
1592
term
2008
1592
True
1045
1592
False
1049
1592
{
1050
1592
None
1051
1592
power
1054
1593
factor
1029
1593
(
1032
1593
NAME
1034
1593
[
1035
1593
~
1036
1593
+
1037
1593
atom_expr
1039
1593
NUMBER
1041
1593
atom
1040
1593
term
2009
1593
STRING
1042
1593
-
1044
1593
True
1045
1593
False
1049
1593
{
1050
1593
None
1051
1593
power
1054
1594
factor
1029
1594
(
1032
1594
NAME
1034
1594
[
1035
1594
~
1036
1594
+
1037
1594
atom_expr
1039
1594
NUMBER
1041
1594
atom
1040
1594
STRING
1042
1594
-
1044
1594
True
1045
1594
False
1049
1594
{
1050
1594
None
1051
1594
term
2010
1594
power
1054
1595
factor
1029
1595
(
1032
1595
NAME
1034
1595
term
2011
1595
[
1035
1595
~
1036
1595
+
1037
1595
atom_expr
1039
1595
NUMBER
1041
1595
atom
1040
1595
STRING
1042
1595
-
1044
1595
True
1045
1595
False
1049
1595
{
1050
1595
None
1051
1595
power
1054
1596
factor
1029
1596
(
1032
1596
NAME
1034
1596
[
1035
1596
~
1036
1596
+
1037
1596
atom_expr
1039
1596
NUMBER
1041
1596
atom
1040
1596
STRING
1042
1596
-
1044
1596
term
2012
1596
True
1045
1596
False
1049
1596
{
1050
1596
None
1051
1596
power
1054
1597
factor
9
1597
arith_expr
2
1597
NAME
29
1597
suite
2013
1597
term
21
1597
[
3
1597
~
45
1597
atom_expr
24
1597
expr
16
1597
power
56
1597
(
36
1597
return
13
1597
small_stmt
1258
1597
flow_stmt
15
1597
True
17
1597
not_test
18
1597
and_expr
19
1597
xor_expr
22
1597
{
52
1597
lambdef
53
1597
atom
54
1597
or_test
23
1597
shift_expr
50
1597
False
35
1597
NEWLINE
1259
1597
-
49
1597
lambda
40
1597
None
42
1597
global
25
1597
NUMBER
27
1597
STRING
28
1597
test
48
1597
endsim
33
1597
and_test
37
1597
simple_stmt
1260
1597
comparison
39
1597
break_stmt
74
1597
+
55
1597
not
57
1597
raise
62
1597
continue
59
1597
return_stmt
75
1597
del_stmt
60
1597
test_list
61
1597
raise_stmt
63
1597
resetstats
64
1597
pass_stmt
65
1597
nonlocal
66
1597
break
76
1597
sim_stmt
77
1597
stat_stmt
78
1597
global_stmt
67
1597
yield_stmt
79
1597
assert_stmt
80
1597
pass
81
1597
yield
68
1597
continue_stmt
69
1597
assert
70
1597
nonlocal_stmt
71
1597
expr_stmt
72
1597
begsim
83
1597
del
84
1598
factor
1029
1598
term
1031
1598
(
1032
1598
NAME
1034
1598
[
1035
1598
~
1036
1598
+
1037
1598
atom_expr
1039
1598
NUMBER
1041
1598
atom
1040
1598
STRING
1042
1598
-
1044
1598
True
1045
1598
arith_expr
2014
1598
False
1049
1598
{
1050
1598
None
1051
1598
power
1054
1599
factor
1029
1599
term
1031
1599
(
1032
1599
NAME
1034
1599
[
1035
1599
~
1036
1599
+
1037
1599
atom_expr
1039
1599
NUMBER
1041
1599
atom
1040
1599
STRING
1042
1599
-
1044
1599
True
1045
1599
False
1049
1599
{
1050
1599
None
1051
1599
arith_expr
2015
1599
power
1054
1600
)
2016
1601
or
atom -> ( )
1601
<<
atom -> ( )
1601
not
atom -> ( )
1601
&
atom -> ( )
1601
(
atom -> ( )
1601
in
atom -> ( )
1601
**
atom -> ( )
1601
@
atom -> ( )
1601
<=
atom -> ( )
1601
%
atom -> ( )
1601
[
atom -> ( )
1601
>=
atom -> ( )
1601
/
atom -> ( )
1601
+
atom -> ( )
1601
<
atom -> ( )
1601
is
atom -> ( )
1601
:
atom -> ( )
1601
*
atom -> ( )
1601
!=
atom -> ( )
1601
-
atom -> ( )
1601
|
atom -> ( )
1601
//
atom -> ( )
1601
^
atom -> ( )
1601
and
atom -> ( )
1601
==
atom -> ( )
1601
if
atom -> ( )
1601
>
atom -> ( )
1601
,
atom -> ( )
1601
.
atom -> ( )
1601
>>
atom -> ( )
1602
factor
1029
1602
term
1031
1602
(
1032
1602
arith_expr
1033
1602
NAME
1034
1602
[
1035
1602
~
1036
1602
+
1037
1602
atom_expr
1039
1602
NUMBER
1041
1602
atom
1040
1602
STRING
1042
1602
-
1044
1602
shift_expr
2017
1602
True
1045
1602
False
1049
1602
{
1050
1602
None
1051
1602
power
1054
1603
factor
1029
1603
term
1031
1603
(
1032
1603
arith_expr
1033
1603
NAME
1034
1603
[
1035
1603
~
1036
1603
+
1037
1603
atom_expr
1039
1603
NUMBER
1041
1603
atom
1040
1603
STRING
1042
1603
-
1044
1603
True
1045
1603
shift_expr
2018
1603
False
1049
1603
{
1050
1603
None
1051
1603
power
1054
1604
<=
atom -> [ ]
1604
is
atom -> [ ]
1604
-
atom -> [ ]
1604
**
atom -> [ ]
1604
^
atom -> [ ]
1604
%
atom -> [ ]
1604
/
atom -> [ ]
1604
>=
atom -> [ ]
1604
|
atom -> [ ]
1604
not
atom -> [ ]
1604
@
atom -> [ ]
1604
*
atom -> [ ]
1604
(
atom -> [ ]
1604
,
atom -> [ ]
1604
>>
atom -> [ ]
1604
[
atom -> [ ]
1604
:
atom -> [ ]
1604
or
atom -> [ ]
1604
!=
atom -> [ ]
1604
and
atom -> [ ]
1604
<<
atom -> [ ]
1604
if
atom -> [ ]
1604
in
atom -> [ ]
1604
+
atom -> [ ]
1604
.
atom -> [ ]
1604
==
atom -> [ ]
1604
>
atom -> [ ]
1604
<
atom -> [ ]
1604
&
atom -> [ ]
1604
//
atom -> [ ]
1605
]
2019
1606
or
factor -> ~ factor
1606
==
factor -> ~ factor
1606
<=
factor -> ~ factor
1606
@
factor -> ~ factor
1606
!=
factor -> ~ factor
1606
>=
factor -> ~ factor
1606
>
factor -> ~ factor
1606
and
factor -> ~ factor
1606
,
factor -> ~ factor
1606
:
factor -> ~ factor
1606
*
factor -> ~ factor
1606
&
factor -> ~ factor
1606
%
factor -> ~ factor
1606
<
factor -> ~ factor
1606
//
factor -> ~ factor
1606
if
factor -> ~ factor
1606
^
factor -> ~ factor
1606
/
factor -> ~ factor
1606
in
factor -> ~ factor
1606
+
factor -> ~ factor
1606
not
factor -> ~ factor
1606
-
factor -> ~ factor
1606
is
factor -> ~ factor
1606
>>
factor -> ~ factor
1606
<<
factor -> ~ factor
1606
|
factor -> ~ factor
1607
<
factor -> + factor
1607
if
factor -> + factor
1607
<<
factor -> + factor
1607
and
factor -> + factor
1607
>=
factor -> + factor
1607
%
factor -> + factor
1607
>>
factor -> + factor
1607
*
factor -> + factor
1607
+
factor -> + factor
1607
/
factor -> + factor
1607
>
factor -> + factor
1607
<=
factor -> + factor
1607
^
factor -> + factor
1607
is
factor -> + factor
1607
|
factor -> + factor
1607
or
factor -> + factor
1607
-
factor -> + factor
1607
in
factor -> + factor
1607
&
factor -> + factor
1607
not
factor -> + factor
1607
//
factor -> + factor
1607
,
factor -> + factor
1607
!=
factor -> + factor
1607
:
factor -> + factor
1607
==
factor -> + factor
1607
@
factor -> + factor
1608
factor
1029
1608
term
1031
1608
(
1032
1608
arith_expr
1033
1608
NAME
1034
1608
[
1035
1608
~
1036
1608
+
1037
1608
expr
1038
1608
atom_expr
1039
1608
atom
1040
1608
NUMBER
1041
1608
STRING
1042
1608
shift_expr
1043
1608
-
1044
1608
True
1045
1608
and_expr
1047
1608
comparison
2020
1608
xor_expr
1048
1608
False
1049
1608
{
1050
1608
None
1051
1608
power
1054
1609
(
1032
1609
NAME
1034
1609
[
1035
1609
~
1036
1609
+
1037
1609
atom_expr
1039
1609
NUMBER
1041
1609
atom
1040
1609
STRING
1042
1609
-
1044
1609
factor
2021
1609
True
1045
1609
False
1049
1609
{
1050
1609
None
1051
1609
power
1054
1610
trailer_expr
2022
1610
trailer
1610
1610
.
1611
1610
(
1612
1610
[
1613
1610
<<
trailer_expr -> 
1610
%
trailer_expr -> 
1610
==
trailer_expr -> 
1610
-
trailer_expr -> 
1610
<
trailer_expr -> 
1610
if
trailer_expr -> 
1610
or
trailer_expr -> 
1610
/
trailer_expr -> 
1610
**
trailer_expr -> 
1610
and
trailer_expr -> 
1610
@
trailer_expr -> 
1610
*
trailer_expr -> 
1610
|
trailer_expr -> 
1610
is
trailer_expr -> 
1610
,
trailer_expr -> 
1610
+
trailer_expr -> 
1610
in
trailer_expr -> 
1610
&
trailer_expr -> 
1610
<=
trailer_expr -> 
1610
>=
trailer_expr -> 
1610
^
trailer_expr -> 
1610
>
trailer_expr -> 
1610
!=
trailer_expr -> 
1610
not
trailer_expr -> 
1610
>>
trailer_expr -> 
1610
//
trailer_expr -> 
1610
:
trailer_expr -> 
1611
NAME
2023
1612
factor
697
1612
term
698
1612
(
699
1612
arith_expr
700
1612
NAME
701
1612
[
702
1612
atom
703
1612
+
704
1612
power
706
1612
atom_expr
707
1612
NUMBER
708
1612
STRING
709
1612
*
710
1612
shift_expr
711
1612
-
712
1612
argument
714
1612
)
2024
1612
True
715
1612
not_test
716
1612
lambdef
717
1612
and_expr
718
1612
xor_expr
719
1612
False
720
1612
test
721
1612
None
722
1612
arglist
2025
1612
expr
723
1612
and_test
724
1612
{
725
1612
~
726
1612
lambda
727
1612
comparison
728
1612
or_test
729
1612
not
730
1612
**
731
1613
factor
732
1613
or_test
733
1613
term
734
1613
(
735
1613
arith_expr
736
1613
NAME
737
1613
[
738
1613
~
739
1613
subscriptlist
2026
1613
+
741
1613
maybe_test
742
1613
expr
743
1613
atom_expr
744
1613
atom
745
1613
NUMBER
746
1613
STRING
747
1613
shift_expr
748
1613
-
749
1613
True
750
1613
not_test
751
1613
and_expr
752
1613
xor_expr
753
1613
False
754
1613
{
755
1613
None
756
1613
and_test
757
1613
lambda
758
1613
power
759
1613
subscript
760
1613
test
761
1613
lambdef
762
1613
:
maybe_test -> 
1613
comparison
763
1613
not
764
1614
>
atom_expr -> atom trailer_expr
1614
not
atom_expr -> atom trailer_expr
1614
//
atom_expr -> atom trailer_expr
1614
>>
atom_expr -> atom trailer_expr
1614
|
atom_expr -> atom trailer_expr
1614
^
atom_expr -> atom trailer_expr
1614
/
atom_expr -> atom trailer_expr
1614
+
atom_expr -> atom trailer_expr
1614
in
atom_expr -> atom trailer_expr
1614
%
atom_expr -> atom trailer_expr
1614
and
atom_expr -> atom trailer_expr
1614
<=
atom_expr -> atom trailer_expr
1614
is
atom_expr -> atom trailer_expr
1614
<
atom_expr -> atom trailer_expr
1614
@
atom_expr -> atom trailer_expr
1614
-
atom_expr -> atom trailer_expr
1614
&
atom_expr -> atom trailer_expr
1614
:
atom_expr -> atom trailer_expr
1614
*
atom_expr -> atom trailer_expr
1614
**
atom_expr -> atom trailer_expr
1614
>=
atom_expr -> atom trailer_expr
1614
or
atom_expr -> atom trailer_expr
1614
,
atom_expr -> atom trailer_expr
1614
==
atom_expr -> atom trailer_expr
1614
!=
atom_expr -> atom trailer_expr
1614
if
atom_expr -> atom trailer_expr
1614
<<
atom_expr -> atom trailer_expr
1615
factor
1029
1615
term
1031
1615
(
1032
1615
arith_expr
1033
1615
NAME
1034
1615
[
1035
1615
~
1036
1615
+
1037
1615
atom_expr
1039
1615
NUMBER
1041
1615
atom
1040
1615
STRING
1042
1615
shift_expr
1043
1615
-
1044
1615
True
1045
1615
False
1049
1615
{
1050
1615
None
1051
1615
and_expr
2027
1615
power
1054
1616
and
factor -> - factor
1616
if
factor -> - factor
1616
or
factor -> - factor
1616
>=
factor -> - factor
1616
<
factor -> - factor
1616
!=
factor -> - factor
1616
-
factor -> - factor
1616
==
factor -> - factor
1616
@
factor -> - factor
1616
|
factor -> - factor
1616
*
factor -> - factor
1616
%
factor -> - factor
1616
+
factor -> - factor
1616
<=
factor -> - factor
1616
//
factor -> - factor
1616
not
factor -> - factor
1616
>>
factor -> - factor
1616
/
factor -> - factor
1616
&
factor -> - factor
1616
^
factor -> - factor
1616
in
factor -> - factor
1616
is
factor -> - factor
1616
>
factor -> - factor
1616
,
factor -> - factor
1616
:
factor -> - factor
1616
<<
factor -> - factor
1617
factor
1029
1617
term
1031
1617
(
1032
1617
arith_expr
1033
1617
NAME
1034
1617
[
1035
1617
~
1036
1617
+
1037
1617
expr
1038
1617
atom_expr
1039
1617
atom
1040
1617
NUMBER
1041
1617
STRING
1042
1617
shift_expr
1043
1617
-
1044
1617
True
1045
1617
not_test
1046
1617
and_test
2028
1617
and_expr
1047
1617
xor_expr
1048
1617
False
1049
1617
{
1050
1617
None
1051
1617
power
1054
1617
comparison
1058
1617
not
1059
1618
factor
1029
1618
term
1031
1618
(
1032
1618
arith_expr
1033
1618
NAME
1034
1618
[
1035
1618
~
1036
1618
+
1037
1618
atom_expr
1039
1618
NUMBER
1041
1618
atom
1040
1618
STRING
1042
1618
shift_expr
1043
1618
-
1044
1618
True
1045
1618
and_expr
1047
1618
False
1049
1618
{
1050
1618
None
1051
1618
xor_expr
2029
1618
power
1054
1619
factor
1029
1619
term
1031
1619
(
1032
1619
arith_expr
1033
1619
NAME
1034
1619
[
1035
1619
~
1036
1619
+
1037
1619
atom_expr
1039
1619
NUMBER
1041
1619
atom
1040
1619
STRING
1042
1619
shift_expr
1043
1619
-
1044
1619
True
1045
1619
and_expr
1047
1619
xor_expr
1048
1619
False
1049
1619
{
1050
1619
None
1051
1619
power
1054
1619
expr
2030
1620
>
atom -> { }
1620
==
atom -> { }
1620
-
atom -> { }
1620
not
atom -> { }
1620
(
atom -> { }
1620
@
atom -> { }
1620
if
atom -> { }
1620
and
atom -> { }
1620
,
atom -> { }
1620
:
atom -> { }
1620
&
atom -> { }
1620
<<
atom -> { }
1620
!=
atom -> { }
1620
or
atom -> { }
1620
>>
atom -> { }
1620
<=
atom -> { }
1620
>=
atom -> { }
1620
is
atom -> { }
1620
/
atom -> { }
1620
^
atom -> { }
1620
[
atom -> { }
1620
%
atom -> { }
1620
//
atom -> { }
1620
*
atom -> { }
1620
**
atom -> { }
1620
.
atom -> { }
1620
in
atom -> { }
1620
+
atom -> { }
1620
|
atom -> { }
1620
<
atom -> { }
1621
factor
1029
1621
term
1031
1621
(
1032
1621
arith_expr
1033
1621
NAME
1034
1621
[
1035
1621
~
1036
1621
+
1037
1621
expr
1038
1621
atom_expr
1039
1621
atom
1040
1621
NUMBER
1041
1621
STRING
1042
1621
shift_expr
1043
1621
-
1044
1621
True
1045
1621
not_test
1046
1621
and_expr
1047
1621
xor_expr
1048
1621
False
1049
1621
{
1050
1621
None
1051
1621
test
1052
1621
and_test
1053
1621
power
1054
1621
lambda
1055
1621
or_test
1056
1621
lambdef
1057
1621
comparison
1058
1621
not
1059
1621
test_list
2031
1622
factor
1029
1622
term
1031
1622
(
1032
1622
arith_expr
1033
1622
NAME
1034
1622
[
1035
1622
~
1036
1622
+
1037
1622
expr
1038
1622
atom_expr
1039
1622
atom
1040
1622
NUMBER
1041
1622
STRING
1042
1622
shift_expr
1043
1622
-
1044
1622
True
1045
1622
not_test
1046
1622
and_expr
1047
1622
xor_expr
1048
1622
False
1049
1622
{
1050
1622
None
1051
1622
and_test
1053
1622
power
1054
1622
comparison
1058
1622
or_test
2032
1622
not
1059
1623
factor
1029
1623
term
1031
1623
(
1032
1623
arith_expr
1033
1623
NAME
1034
1623
[
1035
1623
~
1036
1623
+
1037
1623
expr
1038
1623
atom_expr
1039
1623
atom
1040
1623
NUMBER
1041
1623
STRING
1042
1623
shift_expr
1043
1623
-
1044
1623
True
1045
1623
not_test
1046
1623
and_expr
1047
1623
xor_expr
1048
1623
False
1049
1623
{
1050
1623
None
1051
1623
and_test
1053
1623
test
2033
1623
power
1054
1623
lambda
1055
1623
or_test
1056
1623
lambdef
1057
1623
comparison
1058
1623
not
1059
1624
:
2034
1625
factor
585
1625
(
586
1625
arith_expr
587
1625
NAME
588
1625
[
589
1625
and_expr
590
1625
+
591
1625
term
592
1625
atom_expr
593
1625
NUMBER
594
1625
atom
595
1625
STRING
596
1625
shift_expr
597
1625
-
598
1625
True
599
1625
not
600
1625
xor_expr
601
1625
None
602
1625
False
603
1625
not_test
605
1625
~
606
1625
power
607
1625
{
608
1625
expr
609
1625
or_test
2035
1625
comparison
610
1625
and_test
611
1626
or
not_test -> not not_test
1626
,
not_test -> not not_test
1626
and
not_test -> not not_test
1626
if
not_test -> not not_test
1626
:
not_test -> not not_test
1627
[
trailer -> ( arglist )
1627
**
trailer -> ( arglist )
1627
@
trailer -> ( arglist )
1627
-
trailer -> ( arglist )
1627
,
trailer -> ( arglist )
1627
&
trailer -> ( arglist )
1627
+
trailer -> ( arglist )
1627
^
trailer -> ( arglist )
1627
//
trailer -> ( arglist )
1627
.
trailer -> ( arglist )
1627
|
trailer -> ( arglist )
1627
>>
trailer -> ( arglist )
1627
*
trailer -> ( arglist )
1627
(
trailer -> ( arglist )
1627
<<
trailer -> ( arglist )
1627
/
trailer -> ( arglist )
1627
%
trailer -> ( arglist )
1627
in
trailer -> ( arglist )
1628
,
trailer -> [ subscriptlist ]
1628
|
trailer -> [ subscriptlist ]
1628
.
trailer -> [ subscriptlist ]
1628
<<
trailer -> [ subscriptlist ]
1628
(
trailer -> [ subscriptlist ]
1628
^
trailer -> [ subscriptlist ]
1628
in
trailer -> [ subscriptlist ]
1628
[
trailer -> [ subscriptlist ]
1628
>>
trailer -> [ subscriptlist ]
1628
-
trailer -> [ subscriptlist ]
1628
%
trailer -> [ subscriptlist ]
1628
+
trailer -> [ subscriptlist ]
1628
/
trailer -> [ subscriptlist ]
1628
@
trailer -> [ subscriptlist ]
1628
//
trailer -> [ subscriptlist ]
1628
**
trailer -> [ subscriptlist ]
1628
*
trailer -> [ subscriptlist ]
1628
&
trailer -> [ subscriptlist ]
1629
def
decorator -> @ dotted_name ( ) NEWLINE
1629
class
decorator -> @ dotted_name ( ) NEWLINE
1629
@
decorator -> @ dotted_name ( ) NEWLINE
1630
NEWLINE
2036
1631
**
trailer -> ( arglist )
1631
if
trailer -> ( arglist )
1631
<
trailer -> ( arglist )
1631
//
trailer -> ( arglist )
1631
<<
trailer -> ( arglist )
1631
%
trailer -> ( arglist )
1631
&
trailer -> ( arglist )
1631
NEWLINE
trailer -> ( arglist )
1631
==
trailer -> ( arglist )
1631
is
trailer -> ( arglist )
1631
,
trailer -> ( arglist )
1631
!=
trailer -> ( arglist )
1631
and
trailer -> ( arglist )
1631
-
trailer -> ( arglist )
1631
+
trailer -> ( arglist )
1631
>=
trailer -> ( arglist )
1631
or
trailer -> ( arglist )
1631
(
trailer -> ( arglist )
1631
^
trailer -> ( arglist )
1631
.
trailer -> ( arglist )
1631
not
trailer -> ( arglist )
1631
>>
trailer -> ( arglist )
1631
/
trailer -> ( arglist )
1631
*
trailer -> ( arglist )
1631
[
trailer -> ( arglist )
1631
@
trailer -> ( arglist )
1631
>
trailer -> ( arglist )
1631
|
trailer -> ( arglist )
1631
<=
trailer -> ( arglist )
1631
in
trailer -> ( arglist )
1632
|
trailer -> [ subscriptlist ]
1632
not
trailer -> [ subscriptlist ]
1632
in
trailer -> [ subscriptlist ]
1632
==
trailer -> [ subscriptlist ]
1632
**
trailer -> [ subscriptlist ]
1632
>>
trailer -> [ subscriptlist ]
1632
!=
trailer -> [ subscriptlist ]
1632
*
trailer -> [ subscriptlist ]
1632
or
trailer -> [ subscriptlist ]
1632
>=
trailer -> [ subscriptlist ]
1632
/
trailer -> [ subscriptlist ]
1632
[
trailer -> [ subscriptlist ]
1632
>
trailer -> [ subscriptlist ]
1632
<
trailer -> [ subscriptlist ]
1632
.
trailer -> [ subscriptlist ]
1632
and
trailer -> [ subscriptlist ]
1632
(
trailer -> [ subscriptlist ]
1632
<=
trailer -> [ subscriptlist ]
1632
-
trailer -> [ subscriptlist ]
1632
@
trailer -> [ subscriptlist ]
1632
<<
trailer -> [ subscriptlist ]
1632
&
trailer -> [ subscriptlist ]
1632
,
trailer -> [ subscriptlist ]
1632
^
trailer -> [ subscriptlist ]
1632
is
trailer -> [ subscriptlist ]
1632
%
trailer -> [ subscriptlist ]
1632
+
trailer -> [ subscriptlist ]
1632
//
trailer -> [ subscriptlist ]
1632
NEWLINE
trailer -> [ subscriptlist ]
1632
if
trailer -> [ subscriptlist ]
1633
NEWLINE
lambdef -> lambda varargslist : test
1633
,
lambdef -> lambda varargslist : test
1634
factor
184
1634
term
185
1634
(
186
1634
arith_expr
187
1634
NAME
188
1634
[
189
1634
+
190
1634
atom_expr
191
1634
atom
192
1634
NUMBER
193
1634
STRING
194
1634
shift_expr
195
1634
-
196
1634
True
197
1634
not_test
198
1634
and_expr
199
1634
xor_expr
200
1634
None
201
1634
expr
202
1634
False
203
1634
and_test
204
1634
lambda
205
1634
{
206
1634
~
207
1634
power
208
1634
not
210
1634
test
2037
1634
or_test
211
1634
comparison
212
1634
lambdef
214
1635
factor
9
1635
arith_expr
2
1635
NAME
29
1635
term
21
1635
[
3
1635
~
45
1635
atom_expr
24
1635
expr
16
1635
power
56
1635
(
36
1635
return
13
1635
small_stmt
47
1635
flow_stmt
15
1635
True
17
1635
not_test
18
1635
and_expr
19
1635
xor_expr
22
1635
{
52
1635
lambdef
53
1635
atom
54
1635
or_test
23
1635
shift_expr
50
1635
False
35
1635
suite
2038
1635
NEWLINE
1022
1635
-
49
1635
None
42
1635
lambda
40
1635
global
25
1635
NUMBER
27
1635
STRING
28
1635
test
48
1635
endsim
33
1635
and_test
37
1635
simple_stmt
1023
1635
comparison
39
1635
break_stmt
74
1635
+
55
1635
not
57
1635
raise
62
1635
continue
59
1635
return_stmt
75
1635
del_stmt
60
1635
test_list
61
1635
raise_stmt
63
1635
resetstats
64
1635
pass_stmt
65
1635
nonlocal
66
1635
break
76
1635
sim_stmt
77
1635
stat_stmt
78
1635
global_stmt
67
1635
yield_stmt
79
1635
assert_stmt
80
1635
pass
81
1635
yield
68
1635
continue_stmt
69
1635
assert
70
1635
nonlocal_stmt
71
1635
expr_stmt
72
1635
begsim
83
1635
del
84
1636
:
2039
1637
factor
1221
1637
term
1222
1637
(
1223
1637
arith_expr
1224
1637
NAME
1225
1637
[
1226
1637
+
1227
1637
atom_expr
1228
1637
NUMBER
1229
1637
atom
1230
1637
STRING
1231
1637
shift_expr
1232
1637
-
1233
1637
True
1234
1637
not_test
1235
1637
and_expr
1236
1637
xor_expr
1237
1637
None
1238
1637
False
1239
1637
and_test
1240
1637
test
2040
1637
{
1241
1637
~
1242
1637
power
1243
1637
expr
1244
1637
lambda
1245
1637
comparison
1246
1637
or_test
1247
1637
not
1249
1637
lambdef
1251
1638
,
tfpdef -> NAME
1638
)
tfpdef -> NAME
1638
:
2041
1639
)
param -> ** tfpdef
1639
,
param -> ** tfpdef
1640
NAME
1112
1640
*
1111
1640
tfpdef
1108
1640
param
1110
1640
**
1109
1640
parameters
2042
1641
,
param -> * tfpdef
1641
)
param -> * tfpdef
1642
factor
2043
1642
term
2044
1642
(
2045
1642
arith_expr
2046
1642
NAME
2047
1642
[
2048
1642
atom
2049
1642
+
2050
1642
power
2051
1642
atom_expr
2052
1642
NUMBER
2053
1642
STRING
2054
1642
shift_expr
2055
1642
-
2056
1642
True
2057
1642
not_test
2058
1642
and_expr
2059
1642
xor_expr
2060
1642
None
2061
1642
False
2062
1642
and_test
2063
1642
{
2064
1642
~
2065
1642
expr
2066
1642
lambda
2067
1642
comparison
2068
1642
test
2069
1642
or_test
2070
1642
lambdef
2071
1642
not
2072
1643
and
term -> factor // term
1643
>
term -> factor // term
1643
<
term -> factor // term
1643
==
term -> factor // term
1643
+
term -> factor // term
1643
-
term -> factor // term
1643
&
term -> factor // term
1643
in
term -> factor // term
1643
!=
term -> factor // term
1643
^
term -> factor // term
1643
or
term -> factor // term
1643
<=
term -> factor // term
1643
>=
term -> factor // term
1643
|
term -> factor // term
1643
>>
term -> factor // term
1643
not
term -> factor // term
1643
else
term -> factor // term
1643
is
term -> factor // term
1643
<<
term -> factor // term
1644
and
term -> factor @ term
1644
in
term -> factor @ term
1644
>=
term -> factor @ term
1644
<
term -> factor @ term
1644
>
term -> factor @ term
1644
-
term -> factor @ term
1644
or
term -> factor @ term
1644
<<
term -> factor @ term
1644
else
term -> factor @ term
1644
is
term -> factor @ term
1644
!=
term -> factor @ term
1644
|
term -> factor @ term
1644
&
term -> factor @ term
1644
==
term -> factor @ term
1644
>>
term -> factor @ term
1644
<=
term -> factor @ term
1644
not
term -> factor @ term
1644
+
term -> factor @ term
1644
^
term -> factor @ term
1645
else
term -> factor * term
1645
^
term -> factor * term
1645
+
term -> factor * term
1645
==
term -> factor * term
1645
>>
term -> factor * term
1645
in
term -> factor * term
1645
and
term -> factor * term
1645
is
term -> factor * term
1645
<<
term -> factor * term
1645
-
term -> factor * term
1645
!=
term -> factor * term
1645
or
term -> factor * term
1645
>
term -> factor * term
1645
&
term -> factor * term
1645
|
term -> factor * term
1645
>=
term -> factor * term
1645
<=
term -> factor * term
1645
not
term -> factor * term
1645
<
term -> factor * term
1646
&
term -> factor % term
1646
==
term -> factor % term
1646
!=
term -> factor % term
1646
<
term -> factor % term
1646
in
term -> factor % term
1646
>>
term -> factor % term
1646
<<
term -> factor % term
1646
-
term -> factor % term
1646
>
term -> factor % term
1646
or
term -> factor % term
1646
^
term -> factor % term
1646
+
term -> factor % term
1646
else
term -> factor % term
1646
is
term -> factor % term
1646
|
term -> factor % term
1646
>=
term -> factor % term
1646
<=
term -> factor % term
1646
and
term -> factor % term
1646
not
term -> factor % term
1647
or
term -> factor / term
1647
<<
term -> factor / term
1647
not
term -> factor / term
1647
in
term -> factor / term
1647
!=
term -> factor / term
1647
<
term -> factor / term
1647
+
term -> factor / term
1647
and
term -> factor / term
1647
>>
term -> factor / term
1647
^
term -> factor / term
1647
<=
term -> factor / term
1647
==
term -> factor / term
1647
>
term -> factor / term
1647
&
term -> factor / term
1647
is
term -> factor / term
1647
-
term -> factor / term
1647
|
term -> factor / term
1647
>=
term -> factor / term
1647
else
term -> factor / term
1648
+
atom -> ( test_list_comp )
1648
/
atom -> ( test_list_comp )
1648
*
atom -> ( test_list_comp )
1648
[
atom -> ( test_list_comp )
1648
&
atom -> ( test_list_comp )
1648
**
atom -> ( test_list_comp )
1648
else
atom -> ( test_list_comp )
1648
^
atom -> ( test_list_comp )
1648
(
atom -> ( test_list_comp )
1648
and
atom -> ( test_list_comp )
1648
>
atom -> ( test_list_comp )
1648
-
atom -> ( test_list_comp )
1648
%
atom -> ( test_list_comp )
1648
//
atom -> ( test_list_comp )
1648
in
atom -> ( test_list_comp )
1648
>>
atom -> ( test_list_comp )
1648
not
atom -> ( test_list_comp )
1648
>=
atom -> ( test_list_comp )
1648
or
atom -> ( test_list_comp )
1648
<
atom -> ( test_list_comp )
1648
|
atom -> ( test_list_comp )
1648
<<
atom -> ( test_list_comp )
1648
@
atom -> ( test_list_comp )
1648
!=
atom -> ( test_list_comp )
1648
is
atom -> ( test_list_comp )
1648
.
atom -> ( test_list_comp )
1648
<=
atom -> ( test_list_comp )
1648
==
atom -> ( test_list_comp )
1649
>=
shift_expr -> arith_expr >> shift_expr
1649
<=
shift_expr -> arith_expr >> shift_expr
1649
!=
shift_expr -> arith_expr >> shift_expr
1649
or
shift_expr -> arith_expr >> shift_expr
1649
|
shift_expr -> arith_expr >> shift_expr
1649
is
shift_expr -> arith_expr >> shift_expr
1649
and
shift_expr -> arith_expr >> shift_expr
1649
else
shift_expr -> arith_expr >> shift_expr
1649
in
shift_expr -> arith_expr >> shift_expr
1649
^
shift_expr -> arith_expr >> shift_expr
1649
not
shift_expr -> arith_expr >> shift_expr
1649
<
shift_expr -> arith_expr >> shift_expr
1649
==
shift_expr -> arith_expr >> shift_expr
1649
&
shift_expr -> arith_expr >> shift_expr
1649
>
shift_expr -> arith_expr >> shift_expr
1650
>
shift_expr -> arith_expr << shift_expr
1650
or
shift_expr -> arith_expr << shift_expr
1650
^
shift_expr -> arith_expr << shift_expr
1650
not
shift_expr -> arith_expr << shift_expr
1650
<
shift_expr -> arith_expr << shift_expr
1650
==
shift_expr -> arith_expr << shift_expr
1650
in
shift_expr -> arith_expr << shift_expr
1650
!=
shift_expr -> arith_expr << shift_expr
1650
|
shift_expr -> arith_expr << shift_expr
1650
>=
shift_expr -> arith_expr << shift_expr
1650
and
shift_expr -> arith_expr << shift_expr
1650
else
shift_expr -> arith_expr << shift_expr
1650
&
shift_expr -> arith_expr << shift_expr
1650
<=
shift_expr -> arith_expr << shift_expr
1650
is
shift_expr -> arith_expr << shift_expr
1651
in
atom -> [ test_list_comp ]
1651
/
atom -> [ test_list_comp ]
1651
or
atom -> [ test_list_comp ]
1651
<<
atom -> [ test_list_comp ]
1651
!=
atom -> [ test_list_comp ]
1651
<=
atom -> [ test_list_comp ]
1651
>>
atom -> [ test_list_comp ]
1651
*
atom -> [ test_list_comp ]
1651
^
atom -> [ test_list_comp ]
1651
.
atom -> [ test_list_comp ]
1651
(
atom -> [ test_list_comp ]
1651
>=
atom -> [ test_list_comp ]
1651
and
atom -> [ test_list_comp ]
1651
<
atom -> [ test_list_comp ]
1651
else
atom -> [ test_list_comp ]
1651
[
atom -> [ test_list_comp ]
1651
==
atom -> [ test_list_comp ]
1651
@
atom -> [ test_list_comp ]
1651
%
atom -> [ test_list_comp ]
1651
-
atom -> [ test_list_comp ]
1651
|
atom -> [ test_list_comp ]
1651
&
atom -> [ test_list_comp ]
1651
+
atom -> [ test_list_comp ]
1651
is
atom -> [ test_list_comp ]
1651
//
atom -> [ test_list_comp ]
1651
**
atom -> [ test_list_comp ]
1651
not
atom -> [ test_list_comp ]
1651
>
atom -> [ test_list_comp ]
1652
<=
xor_expr -> and_expr ^ xor_expr
1652
!=
xor_expr -> and_expr ^ xor_expr
1652
and
xor_expr -> and_expr ^ xor_expr
1652
is
xor_expr -> and_expr ^ xor_expr
1652
>=
xor_expr -> and_expr ^ xor_expr
1652
not
xor_expr -> and_expr ^ xor_expr
1652
<
xor_expr -> and_expr ^ xor_expr
1652
|
xor_expr -> and_expr ^ xor_expr
1652
in
xor_expr -> and_expr ^ xor_expr
1652
==
xor_expr -> and_expr ^ xor_expr
1652
or
xor_expr -> and_expr ^ xor_expr
1652
else
xor_expr -> and_expr ^ xor_expr
1652
>
xor_expr -> and_expr ^ xor_expr
1653
==
arith_expr -> term + arith_expr
1653
>=
arith_expr -> term + arith_expr
1653
!=
arith_expr -> term + arith_expr
1653
is
arith_expr -> term + arith_expr
1653
<<
arith_expr -> term + arith_expr
1653
|
arith_expr -> term + arith_expr
1653
and
arith_expr -> term + arith_expr
1653
^
arith_expr -> term + arith_expr
1653
>>
arith_expr -> term + arith_expr
1653
<
arith_expr -> term + arith_expr
1653
or
arith_expr -> term + arith_expr
1653
in
arith_expr -> term + arith_expr
1653
>
arith_expr -> term + arith_expr
1653
&
arith_expr -> term + arith_expr
1653
not
arith_expr -> term + arith_expr
1653
else
arith_expr -> term + arith_expr
1653
<=
arith_expr -> term + arith_expr
1654
else
arith_expr -> term - arith_expr
1654
>
arith_expr -> term - arith_expr
1654
>>
arith_expr -> term - arith_expr
1654
&
arith_expr -> term - arith_expr
1654
and
arith_expr -> term - arith_expr
1654
>=
arith_expr -> term - arith_expr
1654
is
arith_expr -> term - arith_expr
1654
in
arith_expr -> term - arith_expr
1654
!=
arith_expr -> term - arith_expr
1654
^
arith_expr -> term - arith_expr
1654
<
arith_expr -> term - arith_expr
1654
<<
arith_expr -> term - arith_expr
1654
not
arith_expr -> term - arith_expr
1654
==
arith_expr -> term - arith_expr
1654
|
arith_expr -> term - arith_expr
1654
or
arith_expr -> term - arith_expr
1654
<=
arith_expr -> term - arith_expr
1655
+
power -> atom_expr ** factor
1655
&
power -> atom_expr ** factor
1655
>>
power -> atom_expr ** factor
1655
<<
power -> atom_expr ** factor
1655
not
power -> atom_expr ** factor
1655
is
power -> atom_expr ** factor
1655
@
power -> atom_expr ** factor
1655
==
power -> atom_expr ** factor
1655
*
power -> atom_expr ** factor
1655
or
power -> atom_expr ** factor
1655
>
power -> atom_expr ** factor
1655
-
power -> atom_expr ** factor
1655
!=
power -> atom_expr ** factor
1655
>=
power -> atom_expr ** factor
1655
/
power -> atom_expr ** factor
1655
%
power -> atom_expr ** factor
1655
and
power -> atom_expr ** factor
1655
else
power -> atom_expr ** factor
1655
<=
power -> atom_expr ** factor
1655
<
power -> atom_expr ** factor
1655
|
power -> atom_expr ** factor
1655
^
power -> atom_expr ** factor
1655
in
power -> atom_expr ** factor
1655
//
power -> atom_expr ** factor
1656
]
2073
1657
+
trailer_expr -> trailer trailer_expr
1657
*
trailer_expr -> trailer trailer_expr
1657
/
trailer_expr -> trailer trailer_expr
1657
not
trailer_expr -> trailer trailer_expr
1657
<<
trailer_expr -> trailer trailer_expr
1657
!=
trailer_expr -> trailer trailer_expr
1657
>=
trailer_expr -> trailer trailer_expr
1657
>>
trailer_expr -> trailer trailer_expr
1657
|
trailer_expr -> trailer trailer_expr
1657
%
trailer_expr -> trailer trailer_expr
1657
>
trailer_expr -> trailer trailer_expr
1657
&
trailer_expr -> trailer trailer_expr
1657
-
trailer_expr -> trailer trailer_expr
1657
<=
trailer_expr -> trailer trailer_expr
1657
else
trailer_expr -> trailer trailer_expr
1657
**
trailer_expr -> trailer trailer_expr
1657
@
trailer_expr -> trailer trailer_expr
1657
==
trailer_expr -> trailer trailer_expr
1657
or
trailer_expr -> trailer trailer_expr
1657
<
trailer_expr -> trailer trailer_expr
1657
and
trailer_expr -> trailer trailer_expr
1657
in
trailer_expr -> trailer trailer_expr
1657
is
trailer_expr -> trailer trailer_expr
1657
^
trailer_expr -> trailer trailer_expr
1657
//
trailer_expr -> trailer trailer_expr
1658
<<
trailer -> . NAME
1658
<=
trailer -> . NAME
1658
**
trailer -> . NAME
1658
!=
trailer -> . NAME
1658
/
trailer -> . NAME
1658
&
trailer -> . NAME
1658
//
trailer -> . NAME
1658
<
trailer -> . NAME
1658
is
trailer -> . NAME
1658
-
trailer -> . NAME
1658
[
trailer -> . NAME
1658
or
trailer -> . NAME
1658
>
trailer -> . NAME
1658
else
trailer -> . NAME
1658
*
trailer -> . NAME
1658
+
trailer -> . NAME
1658
%
trailer -> . NAME
1658
.
trailer -> . NAME
1658
>=
trailer -> . NAME
1658
|
trailer -> . NAME
1658
and
trailer -> . NAME
1658
(
trailer -> . NAME
1658
==
trailer -> . NAME
1658
^
trailer -> . NAME
1658
in
trailer -> . NAME
1658
@
trailer -> . NAME
1658
not
trailer -> . NAME
1658
>>
trailer -> . NAME
1659
%
trailer -> ( )
1659
<=
trailer -> ( )
1659
and
trailer -> ( )
1659
//
trailer -> ( )
1659
not
trailer -> ( )
1659
or
trailer -> ( )
1659
>>
trailer -> ( )
1659
>
trailer -> ( )
1659
<<
trailer -> ( )
1659
[
trailer -> ( )
1659
is
trailer -> ( )
1659
-
trailer -> ( )
1659
**
trailer -> ( )
1659
/
trailer -> ( )
1659
+
trailer -> ( )
1659
&
trailer -> ( )
1659
in
trailer -> ( )
1659
else
trailer -> ( )
1659
!=
trailer -> ( )
1659
^
trailer -> ( )
1659
*
trailer -> ( )
1659
>=
trailer -> ( )
1659
(
trailer -> ( )
1659
@
trailer -> ( )
1659
==
trailer -> ( )
1659
|
trailer -> ( )
1659
.
trailer -> ( )
1659
<
trailer -> ( )
1660
)
2074
1661
else
and_expr -> shift_expr & and_expr
1661
==
and_expr -> shift_expr & and_expr
1661
in
and_expr -> shift_expr & and_expr
1661
!=
and_expr -> shift_expr & and_expr
1661
or
and_expr -> shift_expr & and_expr
1661
>
and_expr -> shift_expr & and_expr
1661
not
and_expr -> shift_expr & and_expr
1661
<=
and_expr -> shift_expr & and_expr
1661
|
and_expr -> shift_expr & and_expr
1661
and
and_expr -> shift_expr & and_expr
1661
^
and_expr -> shift_expr & and_expr
1661
is
and_expr -> shift_expr & and_expr
1661
>=
and_expr -> shift_expr & and_expr
1661
<
and_expr -> shift_expr & and_expr
1662
not
expr -> xor_expr | expr
1662
in
expr -> xor_expr | expr
1662
or
expr -> xor_expr | expr
1662
else
expr -> xor_expr | expr
1662
<=
expr -> xor_expr | expr
1662
>
expr -> xor_expr | expr
1662
!=
expr -> xor_expr | expr
1662
==
expr -> xor_expr | expr
1662
>=
expr -> xor_expr | expr
1662
is
expr -> xor_expr | expr
1662
<
expr -> xor_expr | expr
1662
and
expr -> xor_expr | expr
1663
<<=
test -> or_test if or_test else test
1663
^=
test -> or_test if or_test else test
1663
NEWLINE
test -> or_test if or_test else test
1663
//=
test -> or_test if or_test else test
1663
|=
test -> or_test if or_test else test
1663
:
test -> or_test if or_test else test
1663
+=
test -> or_test if or_test else test
1663
@=
test -> or_test if or_test else test
1663
-=
test -> or_test if or_test else test
1663
%=
test -> or_test if or_test else test
1663
&=
test -> or_test if or_test else test
1663
/=
test -> or_test if or_test else test
1663
*=
test -> or_test if or_test else test
1663
=
test -> or_test if or_test else test
1663
**=
test -> or_test if or_test else test
1663
,
test -> or_test if or_test else test
1663
>>=
test -> or_test if or_test else test
1664
else
and_test -> not_test and and_test
1664
or
and_test -> not_test and and_test
1665
or
comparison -> expr comp_op comparison
1665
else
comparison -> expr comp_op comparison
1665
and
comparison -> expr comp_op comparison
1666
else
or_test -> and_test or or_test
1667
,
lambdef -> lambda varargslist : test
1667
:
lambdef -> lambda varargslist : test
1667
as
lambdef -> lambda varargslist : test
1668
**
trailer -> ( arglist )
1668
:
trailer -> ( arglist )
1668
if
trailer -> ( arglist )
1668
<
trailer -> ( arglist )
1668
//
trailer -> ( arglist )
1668
<<
trailer -> ( arglist )
1668
%
trailer -> ( arglist )
1668
&
trailer -> ( arglist )
1668
==
trailer -> ( arglist )
1668
is
trailer -> ( arglist )
1668
,
trailer -> ( arglist )
1668
as
trailer -> ( arglist )
1668
!=
trailer -> ( arglist )
1668
and
trailer -> ( arglist )
1668
-
trailer -> ( arglist )
1668
+
trailer -> ( arglist )
1668
>=
trailer -> ( arglist )
1668
or
trailer -> ( arglist )
1668
(
trailer -> ( arglist )
1668
^
trailer -> ( arglist )
1668
.
trailer -> ( arglist )
1668
not
trailer -> ( arglist )
1668
>>
trailer -> ( arglist )
1668
/
trailer -> ( arglist )
1668
*
trailer -> ( arglist )
1668
[
trailer -> ( arglist )
1668
@
trailer -> ( arglist )
1668
>
trailer -> ( arglist )
1668
|
trailer -> ( arglist )
1668
<=
trailer -> ( arglist )
1668
in
trailer -> ( arglist )
1669
|
trailer -> [ subscriptlist ]
1669
not
trailer -> [ subscriptlist ]
1669
in
trailer -> [ subscriptlist ]
1669
==
trailer -> [ subscriptlist ]
1669
**
trailer -> [ subscriptlist ]
1669
>>
trailer -> [ subscriptlist ]
1669
!=
trailer -> [ subscriptlist ]
1669
*
trailer -> [ subscriptlist ]
1669
or
trailer -> [ subscriptlist ]
1669
>=
trailer -> [ subscriptlist ]
1669
as
trailer -> [ subscriptlist ]
1669
/
trailer -> [ subscriptlist ]
1669
[
trailer -> [ subscriptlist ]
1669
>
trailer -> [ subscriptlist ]
1669
<
trailer -> [ subscriptlist ]
1669
.
trailer -> [ subscriptlist ]
1669
and
trailer -> [ subscriptlist ]
1669
(
trailer -> [ subscriptlist ]
1669
<=
trailer -> [ subscriptlist ]
1669
-
trailer -> [ subscriptlist ]
1669
@
trailer -> [ subscriptlist ]
1669
<<
trailer -> [ subscriptlist ]
1669
&
trailer -> [ subscriptlist ]
1669
,
trailer -> [ subscriptlist ]
1669
:
trailer -> [ subscriptlist ]
1669
^
trailer -> [ subscriptlist ]
1669
is
trailer -> [ subscriptlist ]
1669
%
trailer -> [ subscriptlist ]
1669
+
trailer -> [ subscriptlist ]
1669
//
trailer -> [ subscriptlist ]
1669
if
trailer -> [ subscriptlist ]
1670
factor
236
1670
term
237
1670
(
238
1670
arith_expr
239
1670
NAME
241
1670
False
242
1670
[
243
1670
~
244
1670
+
245
1670
lambda
246
1670
expr
247
1670
atom_expr
248
1670
shift_expr
249
1670
atom
250
1670
NUMBER
251
1670
STRING
252
1670
-
253
1670
True
254
1670
not_test
255
1670
and_expr
256
1670
xor_expr
257
1670
{
258
1670
or_test
259
1670
None
260
1670
comparison
261
1670
and_test
262
1670
lambdef
263
1670
power
264
1670
not
265
1670
test
2075
1671
factor
1172
1671
(
1174
1671
True
1175
1671
[
1177
1671
~
1176
1671
+
1178
1671
STRING
1179
1671
atom_expr
1180
1671
NUMBER
1182
1671
NAME
1183
1671
False
1184
1671
{
1186
1671
term
2076
1671
None
1187
1671
power
1188
1671
-
1189
1671
atom
1193
1672
factor
1172
1672
(
1174
1672
True
1175
1672
[
1177
1672
~
1176
1672
+
1178
1672
STRING
1179
1672
atom_expr
1180
1672
NUMBER
1182
1672
NAME
1183
1672
term
2077
1672
False
1184
1672
{
1186
1672
None
1187
1672
power
1188
1672
-
1189
1672
atom
1193
1673
factor
1172
1673
(
1174
1673
True
1175
1673
[
1177
1673
~
1176
1673
+
1178
1673
STRING
1179
1673
atom_expr
1180
1673
NUMBER
1182
1673
NAME
1183
1673
False
1184
1673
{
1186
1673
None
1187
1673
term
2078
1673
power
1188
1673
-
1189
1673
atom
1193
1674
factor
1172
1674
(
1174
1674
term
2079
1674
True
1175
1674
[
1177
1674
~
1176
1674
+
1178
1674
STRING
1179
1674
atom_expr
1180
1674
NUMBER
1182
1674
NAME
1183
1674
False
1184
1674
{
1186
1674
None
1187
1674
power
1188
1674
-
1189
1674
atom
1193
1675
factor
1172
1675
(
1174
1675
True
1175
1675
[
1177
1675
~
1176
1675
+
1178
1675
STRING
1179
1675
term
2080
1675
atom_expr
1180
1675
NUMBER
1182
1675
NAME
1183
1675
False
1184
1675
{
1186
1675
None
1187
1675
power
1188
1675
-
1189
1675
atom
1193
1676
factor
1172
1676
term
1173
1676
(
1174
1676
True
1175
1676
~
1176
1676
[
1177
1676
+
1178
1676
STRING
1179
1676
atom_expr
1180
1676
NUMBER
1182
1676
arith_expr
2081
1676
NAME
1183
1676
False
1184
1676
{
1186
1676
None
1187
1676
power
1188
1676
-
1189
1676
atom
1193
1677
factor
1172
1677
term
1173
1677
(
1174
1677
True
1175
1677
~
1176
1677
[
1177
1677
+
1178
1677
STRING
1179
1677
atom_expr
1180
1677
NUMBER
1182
1677
arith_expr
2082
1677
NAME
1183
1677
False
1184
1677
{
1186
1677
None
1187
1677
power
1188
1677
-
1189
1677
atom
1193
1678
)
2083
1679
@
atom -> ( )
1679
.
atom -> ( )
1679
|
atom -> ( )
1679
%
atom -> ( )
1679
[
atom -> ( )
1679
(
atom -> ( )
1679
//
atom -> ( )
1679
^
atom -> ( )
1679
**
atom -> ( )
1679
<<
atom -> ( )
1679
,
atom -> ( )
1679
/
atom -> ( )
1679
:
atom -> ( )
1679
+
atom -> ( )
1679
&
atom -> ( )
1679
*
atom -> ( )
1679
-
atom -> ( )
1679
>>
atom -> ( )
1680
-
factor -> ~ factor
1680
,
factor -> ~ factor
1680
:
factor -> ~ factor
1680
*
factor -> ~ factor
1680
@
factor -> ~ factor
1680
^
factor -> ~ factor
1680
/
factor -> ~ factor
1680
&
factor -> ~ factor
1680
%
factor -> ~ factor
1680
>>
factor -> ~ factor
1680
+
factor -> ~ factor
1680
<<
factor -> ~ factor
1680
|
factor -> ~ factor
1680
//
factor -> ~ factor
1681
:
atom -> [ ]
1681
^
atom -> [ ]
1681
%
atom -> [ ]
1681
/
atom -> [ ]
1681
|
atom -> [ ]
1681
+
atom -> [ ]
1681
.
atom -> [ ]
1681
@
atom -> [ ]
1681
*
atom -> [ ]
1681
-
atom -> [ ]
1681
(
atom -> [ ]
1681
<<
atom -> [ ]
1681
>>
atom -> [ ]
1681
[
atom -> [ ]
1681
,
atom -> [ ]
1681
**
atom -> [ ]
1681
&
atom -> [ ]
1681
//
atom -> [ ]
1682
]
2084
1683
%
factor -> + factor
1683
+
factor -> + factor
1683
>>
factor -> + factor
1683
*
factor -> + factor
1683
|
factor -> + factor
1683
<<
factor -> + factor
1683
-
factor -> + factor
1683
/
factor -> + factor
1683
&
factor -> + factor
1683
,
factor -> + factor
1683
^
factor -> + factor
1683
:
factor -> + factor
1683
@
factor -> + factor
1683
//
factor -> + factor
1684
(
1174
1684
True
1175
1684
[
1177
1684
~
1176
1684
factor
2085
1684
+
1178
1684
STRING
1179
1684
atom_expr
1180
1684
NUMBER
1182
1684
NAME
1183
1684
False
1184
1684
{
1186
1684
None
1187
1684
power
1188
1684
-
1189
1684
atom
1193
1685
factor
1172
1685
term
1173
1685
(
1174
1685
True
1175
1685
~
1176
1685
[
1177
1685
+
1178
1685
STRING
1179
1685
atom_expr
1180
1685
arith_expr
1181
1685
NUMBER
1182
1685
NAME
1183
1685
False
1184
1685
{
1186
1685
None
1187
1685
power
1188
1685
-
1189
1685
shift_expr
2086
1685
atom
1193
1686
factor
1172
1686
term
1173
1686
(
1174
1686
True
1175
1686
~
1176
1686
[
1177
1686
+
1178
1686
STRING
1179
1686
atom_expr
1180
1686
arith_expr
1181
1686
NUMBER
1182
1686
NAME
1183
1686
False
1184
1686
{
1186
1686
None
1187
1686
shift_expr
2087
1686
power
1188
1686
-
1189
1686
atom
1193
1687
factor
1172
1687
term
1173
1687
(
1174
1687
True
1175
1687
~
1176
1687
[
1177
1687
+
1178
1687
STRING
1179
1687
atom_expr
1180
1687
arith_expr
1181
1687
NUMBER
1182
1687
NAME
1183
1687
False
1184
1687
and_expr
1185
1687
{
1186
1687
None
1187
1687
power
1188
1687
-
1189
1687
shift_expr
1190
1687
atom
1193
1687
xor_expr
2088
1688
**
atom -> { }
1688
[
atom -> { }
1688
<<
atom -> { }
1688
%
atom -> { }
1688
//
atom -> { }
1688
-
atom -> { }
1688
.
atom -> { }
1688
^
atom -> { }
1688
>>
atom -> { }
1688
(
atom -> { }
1688
@
atom -> { }
1688
*
atom -> { }
1688
+
atom -> { }
1688
,
atom -> { }
1688
|
atom -> { }
1688
:
atom -> { }
1688
/
atom -> { }
1688
&
atom -> { }
1689
%
factor -> - factor
1689
&
factor -> - factor
1689
*
factor -> - factor
1689
^
factor -> - factor
1689
+
factor -> - factor
1689
-
factor -> - factor
1689
//
factor -> - factor
1689
,
factor -> - factor
1689
@
factor -> - factor
1689
|
factor -> - factor
1689
:
factor -> - factor
1689
<<
factor -> - factor
1689
>>
factor -> - factor
1689
/
factor -> - factor
1690
factor
1172
1690
term
1173
1690
(
1174
1690
True
1175
1690
~
1176
1690
[
1177
1690
+
1178
1690
STRING
1179
1690
atom_expr
1180
1690
arith_expr
1181
1690
NUMBER
1182
1690
and_expr
2089
1690
NAME
1183
1690
False
1184
1690
{
1186
1690
None
1187
1690
power
1188
1690
-
1189
1690
shift_expr
1190
1690
atom
1193
1691
factor
1172
1691
term
1173
1691
(
1174
1691
True
1175
1691
~
1176
1691
[
1177
1691
+
1178
1691
STRING
1179
1691
atom_expr
1180
1691
arith_expr
1181
1691
NUMBER
1182
1691
NAME
1183
1691
False
1184
1691
and_expr
1185
1691
{
1186
1691
None
1187
1691
power
1188
1691
-
1189
1691
shift_expr
1190
1691
xor_expr
1192
1691
atom
1193
1691
expr
2090
1692
@
atom_expr -> atom trailer_expr
1692
,
atom_expr -> atom trailer_expr
1692
-
atom_expr -> atom trailer_expr
1692
<<
atom_expr -> atom trailer_expr
1692
+
atom_expr -> atom trailer_expr
1692
/
atom_expr -> atom trailer_expr
1692
&
atom_expr -> atom trailer_expr
1692
:
atom_expr -> atom trailer_expr
1692
%
atom_expr -> atom trailer_expr
1692
*
atom_expr -> atom trailer_expr
1692
^
atom_expr -> atom trailer_expr
1692
//
atom_expr -> atom trailer_expr
1692
**
atom_expr -> atom trailer_expr
1692
>>
atom_expr -> atom trailer_expr
1692
|
atom_expr -> atom trailer_expr
1693
trailer_expr
2091
1693
trailer
1693
1693
(
1694
1693
.
1695
1693
[
1696
1693
<<
trailer_expr -> 
1693
,
trailer_expr -> 
1693
+
trailer_expr -> 
1693
%
trailer_expr -> 
1693
&
trailer_expr -> 
1693
-
trailer_expr -> 
1693
^
trailer_expr -> 
1693
/
trailer_expr -> 
1693
>>
trailer_expr -> 
1693
//
trailer_expr -> 
1693
**
trailer_expr -> 
1693
@
trailer_expr -> 
1693
*
trailer_expr -> 
1693
|
trailer_expr -> 
1693
:
trailer_expr -> 
1694
factor
697
1694
term
698
1694
(
699
1694
arith_expr
700
1694
NAME
701
1694
[
702
1694
atom
703
1694
+
704
1694
power
706
1694
atom_expr
707
1694
NUMBER
708
1694
STRING
709
1694
*
710
1694
shift_expr
711
1694
-
712
1694
argument
714
1694
True
715
1694
not_test
716
1694
lambdef
717
1694
and_expr
718
1694
xor_expr
719
1694
False
720
1694
test
721
1694
None
722
1694
arglist
2092
1694
expr
723
1694
)
2093
1694
and_test
724
1694
{
725
1694
~
726
1694
lambda
727
1694
comparison
728
1694
or_test
729
1694
not
730
1694
**
731
1695
NAME
2094
1696
factor
732
1696
or_test
733
1696
term
734
1696
(
735
1696
arith_expr
736
1696
NAME
737
1696
[
738
1696
~
739
1696
subscriptlist
2095
1696
+
741
1696
maybe_test
742
1696
expr
743
1696
atom_expr
744
1696
atom
745
1696
NUMBER
746
1696
STRING
747
1696
shift_expr
748
1696
-
749
1696
True
750
1696
not_test
751
1696
and_expr
752
1696
xor_expr
753
1696
False
754
1696
{
755
1696
None
756
1696
and_test
757
1696
lambda
758
1696
power
759
1696
subscript
760
1696
test
761
1696
lambdef
762
1696
:
maybe_test -> 
1696
comparison
763
1696
not
764
1697
for
trailer -> ( arglist )
1697
**
trailer -> ( arglist )
1697
if
trailer -> ( arglist )
1697
<
trailer -> ( arglist )
1697
//
trailer -> ( arglist )
1697
<<
trailer -> ( arglist )
1697
%
trailer -> ( arglist )
1697
)
trailer -> ( arglist )
1697
&
trailer -> ( arglist )
1697
==
trailer -> ( arglist )
1697
is
trailer -> ( arglist )
1697
,
trailer -> ( arglist )
1697
!=
trailer -> ( arglist )
1697
and
trailer -> ( arglist )
1697
-
trailer -> ( arglist )
1697
+
trailer -> ( arglist )
1697
>=
trailer -> ( arglist )
1697
or
trailer -> ( arglist )
1697
(
trailer -> ( arglist )
1697
^
trailer -> ( arglist )
1697
.
trailer -> ( arglist )
1697
not
trailer -> ( arglist )
1697
>>
trailer -> ( arglist )
1697
/
trailer -> ( arglist )
1697
*
trailer -> ( arglist )
1697
[
trailer -> ( arglist )
1697
@
trailer -> ( arglist )
1697
>
trailer -> ( arglist )
1697
|
trailer -> ( arglist )
1697
<=
trailer -> ( arglist )
1697
in
trailer -> ( arglist )
1698
|
trailer -> [ subscriptlist ]
1698
not
trailer -> [ subscriptlist ]
1698
in
trailer -> [ subscriptlist ]
1698
==
trailer -> [ subscriptlist ]
1698
**
trailer -> [ subscriptlist ]
1698
>>
trailer -> [ subscriptlist ]
1698
!=
trailer -> [ subscriptlist ]
1698
*
trailer -> [ subscriptlist ]
1698
or
trailer -> [ subscriptlist ]
1698
>=
trailer -> [ subscriptlist ]
1698
/
trailer -> [ subscriptlist ]
1698
for
trailer -> [ subscriptlist ]
1698
[
trailer -> [ subscriptlist ]
1698
>
trailer -> [ subscriptlist ]
1698
<
trailer -> [ subscriptlist ]
1698
.
trailer -> [ subscriptlist ]
1698
and
trailer -> [ subscriptlist ]
1698
(
trailer -> [ subscriptlist ]
1698
<=
trailer -> [ subscriptlist ]
1698
-
trailer -> [ subscriptlist ]
1698
@
trailer -> [ subscriptlist ]
1698
<<
trailer -> [ subscriptlist ]
1698
&
trailer -> [ subscriptlist ]
1698
,
trailer -> [ subscriptlist ]
1698
^
trailer -> [ subscriptlist ]
1698
is
trailer -> [ subscriptlist ]
1698
%
trailer -> [ subscriptlist ]
1698
+
trailer -> [ subscriptlist ]
1698
//
trailer -> [ subscriptlist ]
1698
)
trailer -> [ subscriptlist ]
1698
if
trailer -> [ subscriptlist ]
1699
,
lambdef -> lambda varargslist : test
1699
)
lambdef -> lambda varargslist : test
1699
for
lambdef -> lambda varargslist : test
1700
factor
268
1700
term
270
1700
(
271
1700
arith_expr
272
1700
NAME
273
1700
[
274
1700
+
275
1700
atom_expr
277
1700
NUMBER
278
1700
atom
279
1700
STRING
280
1700
shift_expr
281
1700
-
282
1700
True
283
1700
not_test
284
1700
lambdef
285
1700
and_expr
286
1700
xor_expr
287
1700
False
288
1700
test
2096
1700
None
289
1700
expr
290
1700
and_test
291
1700
{
292
1700
~
293
1700
power
294
1700
lambda
295
1700
comparison
296
1700
or_test
297
1700
not
298
1701
factor
1221
1701
(
1223
1701
NAME
1225
1701
[
1226
1701
+
1227
1701
atom_expr
1228
1701
NUMBER
1229
1701
atom
1230
1701
STRING
1231
1701
-
1233
1701
term
2097
1701
True
1234
1701
None
1238
1701
False
1239
1701
{
1241
1701
~
1242
1701
power
1243
1702
factor
1221
1702
(
1223
1702
NAME
1225
1702
[
1226
1702
+
1227
1702
atom_expr
1228
1702
NUMBER
1229
1702
atom
1230
1702
STRING
1231
1702
-
1233
1702
True
1234
1702
None
1238
1702
term
2098
1702
False
1239
1702
{
1241
1702
~
1242
1702
power
1243
1703
factor
1221
1703
(
1223
1703
NAME
1225
1703
term
2099
1703
[
1226
1703
+
1227
1703
atom_expr
1228
1703
NUMBER
1229
1703
atom
1230
1703
STRING
1231
1703
-
1233
1703
True
1234
1703
None
1238
1703
False
1239
1703
{
1241
1703
~
1242
1703
power
1243
1704
factor
1221
1704
(
1223
1704
NAME
1225
1704
[
1226
1704
+
1227
1704
atom_expr
1228
1704
NUMBER
1229
1704
atom
1230
1704
STRING
1231
1704
-
1233
1704
term
2100
1704
True
1234
1704
None
1238
1704
False
1239
1704
{
1241
1704
~
1242
1704
power
1243
1705
factor
1221
1705
(
1223
1705
NAME
1225
1705
[
1226
1705
+
1227
1705
atom_expr
1228
1705
NUMBER
1229
1705
atom
1230
1705
term
2101
1705
STRING
1231
1705
-
1233
1705
True
1234
1705
None
1238
1705
False
1239
1705
{
1241
1705
~
1242
1705
power
1243
1706
factor
1221
1706
term
1222
1706
(
1223
1706
NAME
1225
1706
[
1226
1706
+
1227
1706
atom_expr
1228
1706
NUMBER
1229
1706
atom
1230
1706
STRING
1231
1706
-
1233
1706
True
1234
1706
arith_expr
2102
1706
None
1238
1706
False
1239
1706
{
1241
1706
~
1242
1706
power
1243
1707
factor
1221
1707
term
1222
1707
(
1223
1707
NAME
1225
1707
[
1226
1707
+
1227
1707
atom_expr
1228
1707
NUMBER
1229
1707
atom
1230
1707
STRING
1231
1707
-
1233
1707
True
1234
1707
None
1238
1707
False
1239
1707
arith_expr
2103
1707
{
1241
1707
~
1242
1707
power
1243
1708
)
2104
1709
)
atom -> ( )
1709
or
atom -> ( )
1709
<<
atom -> ( )
1709
not
atom -> ( )
1709
&
atom -> ( )
1709
(
atom -> ( )
1709
in
atom -> ( )
1709
**
atom -> ( )
1709
@
atom -> ( )
1709
<=
atom -> ( )
1709
%
atom -> ( )
1709
[
atom -> ( )
1709
>=
atom -> ( )
1709
/
atom -> ( )
1709
+
atom -> ( )
1709
<
atom -> ( )
1709
is
atom -> ( )
1709
*
atom -> ( )
1709
!=
atom -> ( )
1709
-
atom -> ( )
1709
|
atom -> ( )
1709
//
atom -> ( )
1709
^
atom -> ( )
1709
and
atom -> ( )
1709
==
atom -> ( )
1709
if
atom -> ( )
1709
>
atom -> ( )
1709
,
atom -> ( )
1709
.
atom -> ( )
1709
>>
atom -> ( )
1710
factor
1221
1710
term
1222
1710
(
1223
1710
arith_expr
1224
1710
NAME
1225
1710
[
1226
1710
+
1227
1710
atom_expr
1228
1710
NUMBER
1229
1710
atom
1230
1710
STRING
1231
1710
-
1233
1710
shift_expr
2105
1710
True
1234
1710
None
1238
1710
False
1239
1710
{
1241
1710
~
1242
1710
power
1243
1711
factor
1221
1711
term
1222
1711
(
1223
1711
arith_expr
1224
1711
NAME
1225
1711
[
1226
1711
+
1227
1711
atom_expr
1228
1711
NUMBER
1229
1711
atom
1230
1711
STRING
1231
1711
-
1233
1711
True
1234
1711
shift_expr
2106
1711
None
1238
1711
False
1239
1711
{
1241
1711
~
1242
1711
power
1243
1712
]
2107
1713
<=
atom -> [ ]
1713
is
atom -> [ ]
1713
-
atom -> [ ]
1713
**
atom -> [ ]
1713
)
atom -> [ ]
1713
^
atom -> [ ]
1713
%
atom -> [ ]
1713
/
atom -> [ ]
1713
>=
atom -> [ ]
1713
|
atom -> [ ]
1713
not
atom -> [ ]
1713
@
atom -> [ ]
1713
*
atom -> [ ]
1713
(
atom -> [ ]
1713
,
atom -> [ ]
1713
>>
atom -> [ ]
1713
[
atom -> [ ]
1713
or
atom -> [ ]
1713
!=
atom -> [ ]
1713
and
atom -> [ ]
1713
<<
atom -> [ ]
1713
if
atom -> [ ]
1713
in
atom -> [ ]
1713
+
atom -> [ ]
1713
.
atom -> [ ]
1713
==
atom -> [ ]
1713
>
atom -> [ ]
1713
<
atom -> [ ]
1713
&
atom -> [ ]
1713
//
atom -> [ ]
1714
<
factor -> + factor
1714
if
factor -> + factor
1714
<<
factor -> + factor
1714
and
factor -> + factor
1714
>=
factor -> + factor
1714
%
factor -> + factor
1714
>>
factor -> + factor
1714
*
factor -> + factor
1714
+
factor -> + factor
1714
)
factor -> + factor
1714
/
factor -> + factor
1714
>
factor -> + factor
1714
<=
factor -> + factor
1714
^
factor -> + factor
1714
is
factor -> + factor
1714
|
factor -> + factor
1714
or
factor -> + factor
1714
-
factor -> + factor
1714
in
factor -> + factor
1714
&
factor -> + factor
1714
not
factor -> + factor
1714
//
factor -> + factor
1714
,
factor -> + factor
1714
!=
factor -> + factor
1714
==
factor -> + factor
1714
@
factor -> + factor
1715
(
1223
1715
NAME
1225
1715
[
1226
1715
+
1227
1715
atom_expr
1228
1715
NUMBER
1229
1715
atom
1230
1715
STRING
1231
1715
-
1233
1715
factor
2108
1715
True
1234
1715
None
1238
1715
False
1239
1715
{
1241
1715
~
1242
1715
power
1243
1716
trailer_expr
2109
1716
trailer
1716
1716
.
1717
1716
(
1718
1716
[
1719
1716
<<
trailer_expr -> 
1716
%
trailer_expr -> 
1716
==
trailer_expr -> 
1716
-
trailer_expr -> 
1716
<
trailer_expr -> 
1716
if
trailer_expr -> 
1716
or
trailer_expr -> 
1716
/
trailer_expr -> 
1716
**
trailer_expr -> 
1716
and
trailer_expr -> 
1716
@
trailer_expr -> 
1716
*
trailer_expr -> 
1716
|
trailer_expr -> 
1716
is
trailer_expr -> 
1716
,
trailer_expr -> 
1716
+
trailer_expr -> 
1716
in
trailer_expr -> 
1716
&
trailer_expr -> 
1716
<=
trailer_expr -> 
1716
>=
trailer_expr -> 
1716
^
trailer_expr -> 
1716
>
trailer_expr -> 
1716
!=
trailer_expr -> 
1716
)
trailer_expr -> 
1716
not
trailer_expr -> 
1716
>>
trailer_expr -> 
1716
//
trailer_expr -> 
1717
NAME
2110
1718
factor
697
1718
term
698
1718
(
699
1718
arith_expr
700
1718
NAME
701
1718
[
702
1718
atom
703
1718
+
704
1718
power
706
1718
atom_expr
707
1718
NUMBER
708
1718
STRING
709
1718
*
710
1718
shift_expr
711
1718
-
712
1718
argument
714
1718
)
2111
1718
True
715
1718
not_test
716
1718
lambdef
717
1718
and_expr
718
1718
xor_expr
719
1718
False
720
1718
test
721
1718
None
722
1718
arglist
2112
1718
expr
723
1718
and_test
724
1718
{
725
1718
~
726
1718
lambda
727
1718
comparison
728
1718
or_test
729
1718
not
730
1718
**
731
1719
factor
732
1719
or_test
733
1719
term
734
1719
(
735
1719
arith_expr
736
1719
NAME
737
1719
[
738
1719
~
739
1719
subscriptlist
2113
1719
+
741
1719
maybe_test
742
1719
expr
743
1719
atom_expr
744
1719
atom
745
1719
NUMBER
746
1719
STRING
747
1719
shift_expr
748
1719
-
749
1719
True
750
1719
not_test
751
1719
and_expr
752
1719
xor_expr
753
1719
False
754
1719
{
755
1719
None
756
1719
and_test
757
1719
lambda
758
1719
power
759
1719
subscript
760
1719
test
761
1719
lambdef
762
1719
:
maybe_test -> 
1719
comparison
763
1719
not
764
1720
>
atom_expr -> atom trailer_expr
1720
not
atom_expr -> atom trailer_expr
1720
//
atom_expr -> atom trailer_expr
1720
>>
atom_expr -> atom trailer_expr
1720
|
atom_expr -> atom trailer_expr
1720
^
atom_expr -> atom trailer_expr
1720
/
atom_expr -> atom trailer_expr
1720
+
atom_expr -> atom trailer_expr
1720
in
atom_expr -> atom trailer_expr
1720
%
atom_expr -> atom trailer_expr
1720
and
atom_expr -> atom trailer_expr
1720
<=
atom_expr -> atom trailer_expr
1720
is
atom_expr -> atom trailer_expr
1720
<
atom_expr -> atom trailer_expr
1720
@
atom_expr -> atom trailer_expr
1720
-
atom_expr -> atom trailer_expr
1720
&
atom_expr -> atom trailer_expr
1720
*
atom_expr -> atom trailer_expr
1720
**
atom_expr -> atom trailer_expr
1720
>=
atom_expr -> atom trailer_expr
1720
)
atom_expr -> atom trailer_expr
1720
or
atom_expr -> atom trailer_expr
1720
,
atom_expr -> atom trailer_expr
1720
==
atom_expr -> atom trailer_expr
1720
!=
atom_expr -> atom trailer_expr
1720
if
atom_expr -> atom trailer_expr
1720
<<
atom_expr -> atom trailer_expr
1721
factor
1221
1721
term
1222
1721
(
1223
1721
arith_expr
1224
1721
NAME
1225
1721
[
1226
1721
+
1227
1721
atom_expr
1228
1721
NUMBER
1229
1721
atom
1230
1721
STRING
1231
1721
shift_expr
1232
1721
-
1233
1721
True
1234
1721
None
1238
1721
and_expr
2114
1721
False
1239
1721
{
1241
1721
~
1242
1721
power
1243
1722
and
factor -> - factor
1722
if
factor -> - factor
1722
or
factor -> - factor
1722
>=
factor -> - factor
1722
<
factor -> - factor
1722
!=
factor -> - factor
1722
-
factor -> - factor
1722
==
factor -> - factor
1722
@
factor -> - factor
1722
|
factor -> - factor
1722
*
factor -> - factor
1722
%
factor -> - factor
1722
+
factor -> - factor
1722
<=
factor -> - factor
1722
//
factor -> - factor
1722
not
factor -> - factor
1722
>>
factor -> - factor
1722
/
factor -> - factor
1722
&
factor -> - factor
1722
^
factor -> - factor
1722
)
factor -> - factor
1722
in
factor -> - factor
1722
is
factor -> - factor
1722
>
factor -> - factor
1722
,
factor -> - factor
1722
<<
factor -> - factor
1723
factor
1221
1723
term
1222
1723
(
1223
1723
arith_expr
1224
1723
NAME
1225
1723
[
1226
1723
+
1227
1723
atom_expr
1228
1723
NUMBER
1229
1723
atom
1230
1723
STRING
1231
1723
shift_expr
1232
1723
-
1233
1723
True
1234
1723
not_test
1235
1723
and_expr
1236
1723
xor_expr
1237
1723
None
1238
1723
False
1239
1723
{
1241
1723
~
1242
1723
and_test
2115
1723
power
1243
1723
expr
1244
1723
comparison
1246
1723
not
1249
1724
factor
1221
1724
term
1222
1724
(
1223
1724
arith_expr
1224
1724
NAME
1225
1724
[
1226
1724
+
1227
1724
atom_expr
1228
1724
NUMBER
1229
1724
atom
1230
1724
STRING
1231
1724
shift_expr
1232
1724
-
1233
1724
True
1234
1724
and_expr
1236
1724
None
1238
1724
False
1239
1724
{
1241
1724
~
1242
1724
xor_expr
2116
1724
power
1243
1725
factor
1221
1725
term
1222
1725
(
1223
1725
arith_expr
1224
1725
NAME
1225
1725
[
1226
1725
+
1227
1725
atom_expr
1228
1725
NUMBER
1229
1725
atom
1230
1725
STRING
1231
1725
shift_expr
1232
1725
-
1233
1725
True
1234
1725
and_expr
1236
1725
xor_expr
1237
1725
None
1238
1725
False
1239
1725
{
1241
1725
~
1242
1725
power
1243
1725
expr
2117
1726
factor
1221
1726
term
1222
1726
(
1223
1726
arith_expr
1224
1726
NAME
1225
1726
[
1226
1726
+
1227
1726
atom_expr
1228
1726
NUMBER
1229
1726
atom
1230
1726
STRING
1231
1726
shift_expr
1232
1726
-
1233
1726
True
1234
1726
not_test
1235
1726
and_expr
1236
1726
xor_expr
1237
1726
None
1238
1726
False
1239
1726
and_test
1240
1726
{
1241
1726
~
1242
1726
power
1243
1726
expr
1244
1726
comparison
1246
1726
or_test
2118
1726
not
1249
1727
>
atom -> { }
1727
==
atom -> { }
1727
)
atom -> { }
1727
-
atom -> { }
1727
not
atom -> { }
1727
(
atom -> { }
1727
@
atom -> { }
1727
if
atom -> { }
1727
and
atom -> { }
1727
,
atom -> { }
1727
&
atom -> { }
1727
<<
atom -> { }
1727
!=
atom -> { }
1727
or
atom -> { }
1727
>>
atom -> { }
1727
<=
atom -> { }
1727
>=
atom -> { }
1727
is
atom -> { }
1727
/
atom -> { }
1727
^
atom -> { }
1727
[
atom -> { }
1727
%
atom -> { }
1727
//
atom -> { }
1727
*
atom -> { }
1727
**
atom -> { }
1727
.
atom -> { }
1727
in
atom -> { }
1727
+
atom -> { }
1727
|
atom -> { }
1727
<
atom -> { }
1728
or
factor -> ~ factor
1728
==
factor -> ~ factor
1728
<=
factor -> ~ factor
1728
@
factor -> ~ factor
1728
!=
factor -> ~ factor
1728
>=
factor -> ~ factor
1728
>
factor -> ~ factor
1728
and
factor -> ~ factor
1728
,
factor -> ~ factor
1728
*
factor -> ~ factor
1728
&
factor -> ~ factor
1728
%
factor -> ~ factor
1728
<
factor -> ~ factor
1728
//
factor -> ~ factor
1728
if
factor -> ~ factor
1728
^
factor -> ~ factor
1728
/
factor -> ~ factor
1728
in
factor -> ~ factor
1728
+
factor -> ~ factor
1728
not
factor -> ~ factor
1728
-
factor -> ~ factor
1728
is
factor -> ~ factor
1728
)
factor -> ~ factor
1728
>>
factor -> ~ factor
1728
<<
factor -> ~ factor
1728
|
factor -> ~ factor
1729
factor
1221
1729
term
1222
1729
(
1223
1729
arith_expr
1224
1729
NAME
1225
1729
[
1226
1729
+
1227
1729
atom_expr
1228
1729
NUMBER
1229
1729
atom
1230
1729
STRING
1231
1729
shift_expr
1232
1729
-
1233
1729
True
1234
1729
and_expr
1236
1729
comparison
2119
1729
xor_expr
1237
1729
None
1238
1729
False
1239
1729
{
1241
1729
~
1242
1729
power
1243
1729
expr
1244
1730
:
2120
1731
factor
1221
1731
term
1222
1731
(
1223
1731
arith_expr
1224
1731
NAME
1225
1731
[
1226
1731
+
1227
1731
atom_expr
1228
1731
NUMBER
1229
1731
atom
1230
1731
STRING
1231
1731
shift_expr
1232
1731
-
1233
1731
True
1234
1731
not_test
1235
1731
and_expr
1236
1731
xor_expr
1237
1731
None
1238
1731
False
1239
1731
and_test
1240
1731
{
1241
1731
~
1242
1731
power
1243
1731
test
2121
1731
expr
1244
1731
lambda
1245
1731
comparison
1246
1731
or_test
1247
1731
not
1249
1731
lambdef
1251
1732
factor
585
1732
(
586
1732
arith_expr
587
1732
NAME
588
1732
[
589
1732
and_expr
590
1732
+
591
1732
term
592
1732
atom_expr
593
1732
NUMBER
594
1732
atom
595
1732
STRING
596
1732
shift_expr
597
1732
-
598
1732
True
599
1732
not
600
1732
xor_expr
601
1732
None
602
1732
False
603
1732
not_test
605
1732
~
606
1732
power
607
1732
{
608
1732
expr
609
1732
or_test
2122
1732
comparison
610
1732
and_test
611
1733
)
not_test -> not not_test
1733
or
not_test -> not not_test
1733
,
not_test -> not not_test
1733
and
not_test -> not not_test
1733
if
not_test -> not not_test
1734
factor
2123
1734
(
2124
1734
arith_expr
2125
1734
NAME
2126
1734
[
2127
1734
+
2128
1734
term
2129
1734
atom_expr
2130
1734
NUMBER
2131
1734
atom
2132
1734
STRING
2133
1734
shift_expr
2134
1734
-
2135
1734
True
2136
1734
and_expr
2137
1734
xor_expr
2138
1734
False
2139
1734
not_test
2140
1734
None
2141
1734
expr
2142
1734
and_test
2143
1734
{
2144
1734
~
2145
1734
power
2146
1734
comparison
2147
1734
or_test
2148
1734
not
2149
1735
confbody
2150
1735
NAME
2151
1736
:
2152
1737
:
2153
1738
nonlocal
simple_stmt -> small_stmt NEWLINE
1738
True
simple_stmt -> small_stmt NEWLINE
1738
False
simple_stmt -> small_stmt NEWLINE
1738
(
simple_stmt -> small_stmt NEWLINE
1738
continue
simple_stmt -> small_stmt NEWLINE
1738
begsim
simple_stmt -> small_stmt NEWLINE
1738
NAME
simple_stmt -> small_stmt NEWLINE
1738
endsim
simple_stmt -> small_stmt NEWLINE
1738
break
simple_stmt -> small_stmt NEWLINE
1738
return
simple_stmt -> small_stmt NEWLINE
1738
NUMBER
simple_stmt -> small_stmt NEWLINE
1738
[
simple_stmt -> small_stmt NEWLINE
1738
global
simple_stmt -> small_stmt NEWLINE
1738
resetstats
simple_stmt -> small_stmt NEWLINE
1738
yield
simple_stmt -> small_stmt NEWLINE
1738
conf
simple_stmt -> small_stmt NEWLINE
1738
$
simple_stmt -> small_stmt NEWLINE
1738
not
simple_stmt -> small_stmt NEWLINE
1738
lambda
simple_stmt -> small_stmt NEWLINE
1738
del
simple_stmt -> small_stmt NEWLINE
1738
pass
simple_stmt -> small_stmt NEWLINE
1738
for
simple_stmt -> small_stmt NEWLINE
1738
@
simple_stmt -> small_stmt NEWLINE
1738
with
simple_stmt -> small_stmt NEWLINE
1738
class
simple_stmt -> small_stmt NEWLINE
1738
NEWLINE
simple_stmt -> small_stmt NEWLINE
1738
if
simple_stmt -> small_stmt NEWLINE
1738
assert
simple_stmt -> small_stmt NEWLINE
1738
None
simple_stmt -> small_stmt NEWLINE
1738
else
simple_stmt -> small_stmt NEWLINE
1738
+
simple_stmt -> small_stmt NEWLINE
1738
-
simple_stmt -> small_stmt NEWLINE
1738
STRING
simple_stmt -> small_stmt NEWLINE
1738
while
simple_stmt -> small_stmt NEWLINE
1738
{
simple_stmt -> small_stmt NEWLINE
1738
raise
simple_stmt -> small_stmt NEWLINE
1738
~
simple_stmt -> small_stmt NEWLINE
1738
def
simple_stmt -> small_stmt NEWLINE
1738
try
simple_stmt -> small_stmt NEWLINE
1739
if
1566
1739
arith_expr
2
1739
try
1567
1739
[
3
1739
class
1568
1739
for
1569
1739
stmt_list
2154
1739
with_stmt
1570
1739
while_stmt
1571
1739
factor
9
1739
@
10
1739
simple_stmt
1572
1739
decorators
1573
1739
return
13
1739
confdef
1574
1739
flow_stmt
15
1739
expr
16
1739
True
17
1739
not_test
18
1739
and_expr
19
1739
def
1575
1739
term
21
1739
xor_expr
22
1739
or_test
23
1739
atom_expr
24
1739
global
25
1739
for_stmt
1576
1739
NUMBER
27
1739
STRING
28
1739
NAME
29
1739
decorator
30
1739
if_stmt
1577
1739
with
1578
1739
endsim
33
1739
classdef
1579
1739
False
35
1739
(
36
1739
and_test
37
1739
conf
1580
1739
comparison
39
1739
lambda
40
1739
while
1581
1739
None
42
1739
try_stmt
1582
1739
funcdef
1583
1739
~
45
1739
decorated
1584
1739
small_stmt
1585
1739
test
48
1739
-
49
1739
shift_expr
50
1739
{
52
1739
lambdef
53
1739
atom
54
1739
+
55
1739
power
56
1739
not
57
1739
compound_stmt
1587
1739
continue
59
1739
del_stmt
60
1739
test_list
61
1739
raise
62
1739
raise_stmt
63
1739
resetstats
64
1739
pass_stmt
65
1739
stmt
1588
1739
nonlocal
66
1739
global_stmt
67
1739
yield
68
1739
continue_stmt
69
1739
assert
70
1739
nonlocal_stmt
71
1739
expr_stmt
72
1739
break_stmt
74
1739
return_stmt
75
1739
break
76
1739
sim_stmt
77
1739
stat_stmt
78
1739
yield_stmt
79
1739
assert_stmt
80
1739
pass
81
1739
begsim
83
1739
del
84
1740
and
term -> factor // term
1740
if
term -> factor // term
1740
>
term -> factor // term
1740
<
term -> factor // term
1740
for
term -> factor // term
1740
==
term -> factor // term
1740
+
term -> factor // term
1740
-
term -> factor // term
1740
&
term -> factor // term
1740
in
term -> factor // term
1740
!=
term -> factor // term
1740
^
term -> factor // term
1740
,
term -> factor // term
1740
)
term -> factor // term
1740
=
term -> factor // term
1740
or
term -> factor // term
1740
<=
term -> factor // term
1740
>=
term -> factor // term
1740
|
term -> factor // term
1740
>>
term -> factor // term
1740
not
term -> factor // term
1740
is
term -> factor // term
1740
<<
term -> factor // term
1741
^
term -> factor * term
1741
+
term -> factor * term
1741
==
term -> factor * term
1741
>>
term -> factor * term
1741
in
term -> factor * term
1741
and
term -> factor * term
1741
if
term -> factor * term
1741
for
term -> factor * term
1741
is
term -> factor * term
1741
<<
term -> factor * term
1741
,
term -> factor * term
1741
-
term -> factor * term
1741
!=
term -> factor * term
1741
or
term -> factor * term
1741
>
term -> factor * term
1741
&
term -> factor * term
1741
)
term -> factor * term
1741
>=
term -> factor * term
1741
|
term -> factor * term
1741
<=
term -> factor * term
1741
not
term -> factor * term
1741
=
term -> factor * term
1741
<
term -> factor * term
1742
&
term -> factor % term
1742
==
term -> factor % term
1742
!=
term -> factor % term
1742
)
term -> factor % term
1742
<
term -> factor % term
1742
in
term -> factor % term
1742
=
term -> factor % term
1742
>>
term -> factor % term
1742
<<
term -> factor % term
1742
-
term -> factor % term
1742
if
term -> factor % term
1742
>
term -> factor % term
1742
or
term -> factor % term
1742
^
term -> factor % term
1742
+
term -> factor % term
1742
,
term -> factor % term
1742
is
term -> factor % term
1742
|
term -> factor % term
1742
>=
term -> factor % term
1742
<=
term -> factor % term
1742
and
term -> factor % term
1742
not
term -> factor % term
1742
for
term -> factor % term
1743
for
term -> factor @ term
1743
and
term -> factor @ term
1743
in
term -> factor @ term
1743
>=
term -> factor @ term
1743
<
term -> factor @ term
1743
,
term -> factor @ term
1743
>
term -> factor @ term
1743
-
term -> factor @ term
1743
or
term -> factor @ term
1743
)
term -> factor @ term
1743
<<
term -> factor @ term
1743
is
term -> factor @ term
1743
!=
term -> factor @ term
1743
|
term -> factor @ term
1743
&
term -> factor @ term
1743
==
term -> factor @ term
1743
>>
term -> factor @ term
1743
<=
term -> factor @ term
1743
not
term -> factor @ term
1743
+
term -> factor @ term
1743
^
term -> factor @ term
1743
=
term -> factor @ term
1743
if
term -> factor @ term
1744
or
term -> factor / term
1744
<<
term -> factor / term
1744
not
term -> factor / term
1744
in
term -> factor / term
1744
!=
term -> factor / term
1744
<
term -> factor / term
1744
,
term -> factor / term
1744
+
term -> factor / term
1744
and
term -> factor / term
1744
>>
term -> factor / term
1744
^
term -> factor / term
1744
<=
term -> factor / term
1744
==
term -> factor / term
1744
>
term -> factor / term
1744
&
term -> factor / term
1744
is
term -> factor / term
1744
-
term -> factor / term
1744
for
term -> factor / term
1744
)
term -> factor / term
1744
|
term -> factor / term
1744
>=
term -> factor / term
1744
if
term -> factor / term
1744
=
term -> factor / term
1745
for
arith_expr -> term + arith_expr
1745
==
arith_expr -> term + arith_expr
1745
!=
arith_expr -> term + arith_expr
1745
<<
arith_expr -> term + arith_expr
1745
&
arith_expr -> term + arith_expr
1745
<
arith_expr -> term + arith_expr
1745
^
arith_expr -> term + arith_expr
1745
,
arith_expr -> term + arith_expr
1745
>=
arith_expr -> term + arith_expr
1745
in
arith_expr -> term + arith_expr
1745
)
arith_expr -> term + arith_expr
1745
>>
arith_expr -> term + arith_expr
1745
not
arith_expr -> term + arith_expr
1745
<=
arith_expr -> term + arith_expr
1745
is
arith_expr -> term + arith_expr
1745
|
arith_expr -> term + arith_expr
1745
and
arith_expr -> term + arith_expr
1745
=
arith_expr -> term + arith_expr
1745
or
arith_expr -> term + arith_expr
1745
if
arith_expr -> term + arith_expr
1745
>
arith_expr -> term + arith_expr
1746
if
arith_expr -> term - arith_expr
1746
&
arith_expr -> term - arith_expr
1746
>>
arith_expr -> term - arith_expr
1746
!=
arith_expr -> term - arith_expr
1746
)
arith_expr -> term - arith_expr
1746
>=
arith_expr -> term - arith_expr
1746
|
arith_expr -> term - arith_expr
1746
>
arith_expr -> term - arith_expr
1746
for
arith_expr -> term - arith_expr
1746
<
arith_expr -> term - arith_expr
1746
==
arith_expr -> term - arith_expr
1746
,
arith_expr -> term - arith_expr
1746
and
arith_expr -> term - arith_expr
1746
=
arith_expr -> term - arith_expr
1746
is
arith_expr -> term - arith_expr
1746
in
arith_expr -> term - arith_expr
1746
^
arith_expr -> term - arith_expr
1746
<<
arith_expr -> term - arith_expr
1746
not
arith_expr -> term - arith_expr
1746
or
arith_expr -> term - arith_expr
1746
<=
arith_expr -> term - arith_expr
1747
+
atom -> ( test_list_comp )
1747
/
atom -> ( test_list_comp )
1747
*
atom -> ( test_list_comp )
1747
[
atom -> ( test_list_comp )
1747
&
atom -> ( test_list_comp )
1747
,
atom -> ( test_list_comp )
1747
**
atom -> ( test_list_comp )
1747
^
atom -> ( test_list_comp )
1747
(
atom -> ( test_list_comp )
1747
and
atom -> ( test_list_comp )
1747
)
atom -> ( test_list_comp )
1747
>
atom -> ( test_list_comp )
1747
=
atom -> ( test_list_comp )
1747
-
atom -> ( test_list_comp )
1747
%
atom -> ( test_list_comp )
1747
//
atom -> ( test_list_comp )
1747
in
atom -> ( test_list_comp )
1747
>>
atom -> ( test_list_comp )
1747
for
atom -> ( test_list_comp )
1747
not
atom -> ( test_list_comp )
1747
>=
atom -> ( test_list_comp )
1747
or
atom -> ( test_list_comp )
1747
<
atom -> ( test_list_comp )
1747
if
atom -> ( test_list_comp )
1747
|
atom -> ( test_list_comp )
1747
<<
atom -> ( test_list_comp )
1747
@
atom -> ( test_list_comp )
1747
!=
atom -> ( test_list_comp )
1747
is
atom -> ( test_list_comp )
1747
.
atom -> ( test_list_comp )
1747
<=
atom -> ( test_list_comp )
1747
==
atom -> ( test_list_comp )
1748
,
shift_expr -> arith_expr >> shift_expr
1748
or
shift_expr -> arith_expr >> shift_expr
1748
|
shift_expr -> arith_expr >> shift_expr
1748
is
shift_expr -> arith_expr >> shift_expr
1748
in
shift_expr -> arith_expr >> shift_expr
1748
>
shift_expr -> arith_expr >> shift_expr
1748
>=
shift_expr -> arith_expr >> shift_expr
1748
<=
shift_expr -> arith_expr >> shift_expr
1748
!=
shift_expr -> arith_expr >> shift_expr
1748
)
shift_expr -> arith_expr >> shift_expr
1748
and
shift_expr -> arith_expr >> shift_expr
1748
^
shift_expr -> arith_expr >> shift_expr
1748
not
shift_expr -> arith_expr >> shift_expr
1748
for
shift_expr -> arith_expr >> shift_expr
1748
&
shift_expr -> arith_expr >> shift_expr
1748
<
shift_expr -> arith_expr >> shift_expr
1748
if
shift_expr -> arith_expr >> shift_expr
1748
==
shift_expr -> arith_expr >> shift_expr
1748
=
shift_expr -> arith_expr >> shift_expr
1749
not
shift_expr -> arith_expr << shift_expr
1749
<
shift_expr -> arith_expr << shift_expr
1749
in
shift_expr -> arith_expr << shift_expr
1749
|
shift_expr -> arith_expr << shift_expr
1749
)
shift_expr -> arith_expr << shift_expr
1749
>
shift_expr -> arith_expr << shift_expr
1749
or
shift_expr -> arith_expr << shift_expr
1749
^
shift_expr -> arith_expr << shift_expr
1749
for
shift_expr -> arith_expr << shift_expr
1749
!=
shift_expr -> arith_expr << shift_expr
1749
>=
shift_expr -> arith_expr << shift_expr
1749
&
shift_expr -> arith_expr << shift_expr
1749
=
shift_expr -> arith_expr << shift_expr
1749
if
shift_expr -> arith_expr << shift_expr
1749
<=
shift_expr -> arith_expr << shift_expr
1749
is
shift_expr -> arith_expr << shift_expr
1749
==
shift_expr -> arith_expr << shift_expr
1749
,
shift_expr -> arith_expr << shift_expr
1749
and
shift_expr -> arith_expr << shift_expr
1750
in
atom -> [ test_list_comp ]
1750
/
atom -> [ test_list_comp ]
1750
or
atom -> [ test_list_comp ]
1750
if
atom -> [ test_list_comp ]
1750
<<
atom -> [ test_list_comp ]
1750
!=
atom -> [ test_list_comp ]
1750
=
atom -> [ test_list_comp ]
1750
<=
atom -> [ test_list_comp ]
1750
)
atom -> [ test_list_comp ]
1750
>>
atom -> [ test_list_comp ]
1750
*
atom -> [ test_list_comp ]
1750
^
atom -> [ test_list_comp ]
1750
.
atom -> [ test_list_comp ]
1750
(
atom -> [ test_list_comp ]
1750
>=
atom -> [ test_list_comp ]
1750
and
atom -> [ test_list_comp ]
1750
<
atom -> [ test_list_comp ]
1750
,
atom -> [ test_list_comp ]
1750
[
atom -> [ test_list_comp ]
1750
==
atom -> [ test_list_comp ]
1750
@
atom -> [ test_list_comp ]
1750
%
atom -> [ test_list_comp ]
1750
-
atom -> [ test_list_comp ]
1750
|
atom -> [ test_list_comp ]
1750
&
atom -> [ test_list_comp ]
1750
+
atom -> [ test_list_comp ]
1750
for
atom -> [ test_list_comp ]
1750
is
atom -> [ test_list_comp ]
1750
//
atom -> [ test_list_comp ]
1750
**
atom -> [ test_list_comp ]
1750
not
atom -> [ test_list_comp ]
1750
>
atom -> [ test_list_comp ]
1751
+
trailer_expr -> trailer trailer_expr
1751
,
trailer_expr -> trailer trailer_expr
1751
*
trailer_expr -> trailer trailer_expr
1751
for
trailer_expr -> trailer trailer_expr
1751
/
trailer_expr -> trailer trailer_expr
1751
not
trailer_expr -> trailer trailer_expr
1751
<<
trailer_expr -> trailer trailer_expr
1751
!=
trailer_expr -> trailer trailer_expr
1751
=
trailer_expr -> trailer trailer_expr
1751
>=
trailer_expr -> trailer trailer_expr
1751
)
trailer_expr -> trailer trailer_expr
1751
>>
trailer_expr -> trailer trailer_expr
1751
|
trailer_expr -> trailer trailer_expr
1751
%
trailer_expr -> trailer trailer_expr
1751
>
trailer_expr -> trailer trailer_expr
1751
&
trailer_expr -> trailer trailer_expr
1751
-
trailer_expr -> trailer trailer_expr
1751
<=
trailer_expr -> trailer trailer_expr
1751
**
trailer_expr -> trailer trailer_expr
1751
@
trailer_expr -> trailer trailer_expr
1751
if
trailer_expr -> trailer trailer_expr
1751
==
trailer_expr -> trailer trailer_expr
1751
or
trailer_expr -> trailer trailer_expr
1751
<
trailer_expr -> trailer trailer_expr
1751
and
trailer_expr -> trailer trailer_expr
1751
in
trailer_expr -> trailer trailer_expr
1751
is
trailer_expr -> trailer trailer_expr
1751
^
trailer_expr -> trailer trailer_expr
1751
//
trailer_expr -> trailer trailer_expr
1752
<=
trailer -> . NAME
1752
<<
trailer -> . NAME
1752
**
trailer -> . NAME
1752
!=
trailer -> . NAME
1752
/
trailer -> . NAME
1752
&
trailer -> . NAME
1752
//
trailer -> . NAME
1752
<
trailer -> . NAME
1752
is
trailer -> . NAME
1752
-
trailer -> . NAME
1752
if
trailer -> . NAME
1752
[
trailer -> . NAME
1752
or
trailer -> . NAME
1752
>
trailer -> . NAME
1752
*
trailer -> . NAME
1752
+
trailer -> . NAME
1752
for
trailer -> . NAME
1752
)
trailer -> . NAME
1752
%
trailer -> . NAME
1752
.
trailer -> . NAME
1752
>=
trailer -> . NAME
1752
|
trailer -> . NAME
1752
and
trailer -> . NAME
1752
(
trailer -> . NAME
1752
,
trailer -> . NAME
1752
==
trailer -> . NAME
1752
^
trailer -> . NAME
1752
in
trailer -> . NAME
1752
@
trailer -> . NAME
1752
not
trailer -> . NAME
1752
=
trailer -> . NAME
1752
>>
trailer -> . NAME
1753
%
trailer -> ( )
1753
<=
trailer -> ( )
1753
and
trailer -> ( )
1753
//
trailer -> ( )
1753
not
trailer -> ( )
1753
or
trailer -> ( )
1753
for
trailer -> ( )
1753
>>
trailer -> ( )
1753
>
trailer -> ( )
1753
<<
trailer -> ( )
1753
[
trailer -> ( )
1753
is
trailer -> ( )
1753
-
trailer -> ( )
1753
**
trailer -> ( )
1753
/
trailer -> ( )
1753
,
trailer -> ( )
1753
+
trailer -> ( )
1753
&
trailer -> ( )
1753
in
trailer -> ( )
1753
^
trailer -> ( )
1753
!=
trailer -> ( )
1753
*
trailer -> ( )
1753
if
trailer -> ( )
1753
>=
trailer -> ( )
1753
(
trailer -> ( )
1753
@
trailer -> ( )
1753
)
trailer -> ( )
1753
=
trailer -> ( )
1753
==
trailer -> ( )
1753
|
trailer -> ( )
1753
.
trailer -> ( )
1753
<
trailer -> ( )
1754
)
2155
1755
]
2156
1756
+
power -> atom_expr ** factor
1756
&
power -> atom_expr ** factor
1756
>>
power -> atom_expr ** factor
1756
<<
power -> atom_expr ** factor
1756
not
power -> atom_expr ** factor
1756
is
power -> atom_expr ** factor
1756
@
power -> atom_expr ** factor
1756
==
power -> atom_expr ** factor
1756
*
power -> atom_expr ** factor
1756
or
power -> atom_expr ** factor
1756
>
power -> atom_expr ** factor
1756
-
power -> atom_expr ** factor
1756
)
power -> atom_expr ** factor
1756
if
power -> atom_expr ** factor
1756
!=
power -> atom_expr ** factor
1756
>=
power -> atom_expr ** factor
1756
for
power -> atom_expr ** factor
1756
/
power -> atom_expr ** factor
1756
%
power -> atom_expr ** factor
1756
and
power -> atom_expr ** factor
1756
=
power -> atom_expr ** factor
1756
<=
power -> atom_expr ** factor
1756
<
power -> atom_expr ** factor
1756
|
power -> atom_expr ** factor
1756
^
power -> atom_expr ** factor
1756
in
power -> atom_expr ** factor
1756
,
power -> atom_expr ** factor
1756
//
power -> atom_expr ** factor
1757
==
and_expr -> shift_expr & and_expr
1757
in
and_expr -> shift_expr & and_expr
1757
=
and_expr -> shift_expr & and_expr
1757
!=
and_expr -> shift_expr & and_expr
1757
,
and_expr -> shift_expr & and_expr
1757
or
and_expr -> shift_expr & and_expr
1757
>
and_expr -> shift_expr & and_expr
1757
not
and_expr -> shift_expr & and_expr
1757
<=
and_expr -> shift_expr & and_expr
1757
|
and_expr -> shift_expr & and_expr
1757
and
and_expr -> shift_expr & and_expr
1757
for
and_expr -> shift_expr & and_expr
1757
)
and_expr -> shift_expr & and_expr
1757
^
and_expr -> shift_expr & and_expr
1757
is
and_expr -> shift_expr & and_expr
1757
>=
and_expr -> shift_expr & and_expr
1757
<
and_expr -> shift_expr & and_expr
1757
if
and_expr -> shift_expr & and_expr
1758
)
arglist -> argument , arglist
1759
=
and_test -> not_test and and_test
1759
,
and_test -> not_test and and_test
1759
for
and_test -> not_test and and_test
1759
or
and_test -> not_test and and_test
1759
if
and_test -> not_test and and_test
1759
)
and_test -> not_test and and_test
1760
<=
xor_expr -> and_expr ^ xor_expr
1760
!=
xor_expr -> and_expr ^ xor_expr
1760
for
xor_expr -> and_expr ^ xor_expr
1760
and
xor_expr -> and_expr ^ xor_expr
1760
)
xor_expr -> and_expr ^ xor_expr
1760
=
xor_expr -> and_expr ^ xor_expr
1760
is
xor_expr -> and_expr ^ xor_expr
1760
>=
xor_expr -> and_expr ^ xor_expr
1760
not
xor_expr -> and_expr ^ xor_expr
1760
<
xor_expr -> and_expr ^ xor_expr
1760
|
xor_expr -> and_expr ^ xor_expr
1760
in
xor_expr -> and_expr ^ xor_expr
1760
==
xor_expr -> and_expr ^ xor_expr
1760
or
xor_expr -> and_expr ^ xor_expr
1760
,
xor_expr -> and_expr ^ xor_expr
1760
if
xor_expr -> and_expr ^ xor_expr
1760
>
xor_expr -> and_expr ^ xor_expr
1761
)
expr -> xor_expr | expr
1761
not
expr -> xor_expr | expr
1761
,
expr -> xor_expr | expr
1761
for
expr -> xor_expr | expr
1761
in
expr -> xor_expr | expr
1761
if
expr -> xor_expr | expr
1761
or
expr -> xor_expr | expr
1761
<=
expr -> xor_expr | expr
1761
>
expr -> xor_expr | expr
1761
!=
expr -> xor_expr | expr
1761
==
expr -> xor_expr | expr
1761
=
expr -> xor_expr | expr
1761
>=
expr -> xor_expr | expr
1761
is
expr -> xor_expr | expr
1761
<
expr -> xor_expr | expr
1761
and
expr -> xor_expr | expr
1762
in
2157
1763
,
argument -> test = test
1763
)
argument -> test = test
1764
)
comparison -> expr comp_op comparison
1764
and
comparison -> expr comp_op comparison
1764
if
comparison -> expr comp_op comparison
1764
for
comparison -> expr comp_op comparison
1764
=
comparison -> expr comp_op comparison
1764
or
comparison -> expr comp_op comparison
1764
,
comparison -> expr comp_op comparison
1765
,
or_test -> and_test or or_test
1765
if
or_test -> and_test or or_test
1765
for
or_test -> and_test or or_test
1765
=
or_test -> and_test or or_test
1765
)
or_test -> and_test or or_test
1766
,
lambdef -> lambda : test
1766
for
lambdef -> lambda : test
1766
=
lambdef -> lambda : test
1766
)
lambdef -> lambda : test
1767
factor
697
1767
term
698
1767
(
699
1767
arith_expr
700
1767
NAME
701
1767
[
702
1767
atom
703
1767
+
704
1767
power
706
1767
atom_expr
707
1767
NUMBER
708
1767
STRING
709
1767
shift_expr
711
1767
-
712
1767
True
715
1767
not_test
716
1767
lambdef
717
1767
and_expr
718
1767
xor_expr
719
1767
False
720
1767
None
722
1767
expr
723
1767
and_test
724
1767
{
725
1767
~
726
1767
test
2158
1767
lambda
727
1767
comparison
728
1767
or_test
729
1767
not
730
1768
else
2159
1769
and
term -> factor // term
1769
if
term -> factor // term
1769
>
term -> factor // term
1769
<
term -> factor // term
1769
==
term -> factor // term
1769
]
term -> factor // term
1769
+
term -> factor // term
1769
-
term -> factor // term
1769
&
term -> factor // term
1769
in
term -> factor // term
1769
:
term -> factor // term
1769
!=
term -> factor // term
1769
^
term -> factor // term
1769
,
term -> factor // term
1769
or
term -> factor // term
1769
<=
term -> factor // term
1769
>=
term -> factor // term
1769
|
term -> factor // term
1769
>>
term -> factor // term
1769
not
term -> factor // term
1769
is
term -> factor // term
1769
<<
term -> factor // term
1770
or
term -> factor / term
1770
<<
term -> factor / term
1770
not
term -> factor / term
1770
in
term -> factor / term
1770
!=
term -> factor / term
1770
<
term -> factor / term
1770
,
term -> factor / term
1770
]
term -> factor / term
1770
+
term -> factor / term
1770
and
term -> factor / term
1770
>>
term -> factor / term
1770
^
term -> factor / term
1770
<=
term -> factor / term
1770
==
term -> factor / term
1770
>
term -> factor / term
1770
&
term -> factor / term
1770
is
term -> factor / term
1770
-
term -> factor / term
1770
:
term -> factor / term
1770
|
term -> factor / term
1770
>=
term -> factor / term
1770
if
term -> factor / term
1771
^
term -> factor * term
1771
+
term -> factor * term
1771
==
term -> factor * term
1771
>>
term -> factor * term
1771
in
term -> factor * term
1771
and
term -> factor * term
1771
if
term -> factor * term
1771
is
term -> factor * term
1771
]
term -> factor * term
1771
<<
term -> factor * term
1771
:
term -> factor * term
1771
,
term -> factor * term
1771
-
term -> factor * term
1771
!=
term -> factor * term
1771
or
term -> factor * term
1771
>
term -> factor * term
1771
&
term -> factor * term
1771
>=
term -> factor * term
1771
|
term -> factor * term
1771
<=
term -> factor * term
1771
not
term -> factor * term
1771
<
term -> factor * term
1772
&
term -> factor % term
1772
]
term -> factor % term
1772
==
term -> factor % term
1772
!=
term -> factor % term
1772
<
term -> factor % term
1772
in
term -> factor % term
1772
>>
term -> factor % term
1772
<<
term -> factor % term
1772
-
term -> factor % term
1772
if
term -> factor % term
1772
>
term -> factor % term
1772
or
term -> factor % term
1772
^
term -> factor % term
1772
+
term -> factor % term
1772
,
term -> factor % term
1772
is
term -> factor % term
1772
|
term -> factor % term
1772
>=
term -> factor % term
1772
<=
term -> factor % term
1772
and
term -> factor % term
1772
not
term -> factor % term
1772
:
term -> factor % term
1773
and
term -> factor @ term
1773
in
term -> factor @ term
1773
>=
term -> factor @ term
1773
<
term -> factor @ term
1773
:
term -> factor @ term
1773
,
term -> factor @ term
1773
>
term -> factor @ term
1773
-
term -> factor @ term
1773
or
term -> factor @ term
1773
<<
term -> factor @ term
1773
is
term -> factor @ term
1773
!=
term -> factor @ term
1773
|
term -> factor @ term
1773
&
term -> factor @ term
1773
==
term -> factor @ term
1773
>>
term -> factor @ term
1773
]
term -> factor @ term
1773
not
term -> factor @ term
1773
<=
term -> factor @ term
1773
+
term -> factor @ term
1773
^
term -> factor @ term
1773
if
term -> factor @ term
1774
else
2160
1775
==
arith_expr -> term + arith_expr
1775
]
arith_expr -> term + arith_expr
1775
!=
arith_expr -> term + arith_expr
1775
<<
arith_expr -> term + arith_expr
1775
&
arith_expr -> term + arith_expr
1775
<
arith_expr -> term + arith_expr
1775
^
arith_expr -> term + arith_expr
1775
,
arith_expr -> term + arith_expr
1775
>=
arith_expr -> term + arith_expr
1775
in
arith_expr -> term + arith_expr
1775
>>
arith_expr -> term + arith_expr
1775
not
arith_expr -> term + arith_expr
1775
:
arith_expr -> term + arith_expr
1775
<=
arith_expr -> term + arith_expr
1775
is
arith_expr -> term + arith_expr
1775
|
arith_expr -> term + arith_expr
1775
and
arith_expr -> term + arith_expr
1775
or
arith_expr -> term + arith_expr
1775
if
arith_expr -> term + arith_expr
1775
>
arith_expr -> term + arith_expr
1776
if
arith_expr -> term - arith_expr
1776
&
arith_expr -> term - arith_expr
1776
>>
arith_expr -> term - arith_expr
1776
:
arith_expr -> term - arith_expr
1776
!=
arith_expr -> term - arith_expr
1776
>=
arith_expr -> term - arith_expr
1776
|
arith_expr -> term - arith_expr
1776
>
arith_expr -> term - arith_expr
1776
<
arith_expr -> term - arith_expr
1776
==
arith_expr -> term - arith_expr
1776
,
arith_expr -> term - arith_expr
1776
and
arith_expr -> term - arith_expr
1776
]
arith_expr -> term - arith_expr
1776
is
arith_expr -> term - arith_expr
1776
in
arith_expr -> term - arith_expr
1776
^
arith_expr -> term - arith_expr
1776
<<
arith_expr -> term - arith_expr
1776
not
arith_expr -> term - arith_expr
1776
or
arith_expr -> term - arith_expr
1776
<=
arith_expr -> term - arith_expr
1777
+
atom -> ( test_list_comp )
1777
/
atom -> ( test_list_comp )
1777
*
atom -> ( test_list_comp )
1777
[
atom -> ( test_list_comp )
1777
&
atom -> ( test_list_comp )
1777
,
atom -> ( test_list_comp )
1777
**
atom -> ( test_list_comp )
1777
^
atom -> ( test_list_comp )
1777
(
atom -> ( test_list_comp )
1777
and
atom -> ( test_list_comp )
1777
:
atom -> ( test_list_comp )
1777
>
atom -> ( test_list_comp )
1777
-
atom -> ( test_list_comp )
1777
%
atom -> ( test_list_comp )
1777
//
atom -> ( test_list_comp )
1777
]
atom -> ( test_list_comp )
1777
in
atom -> ( test_list_comp )
1777
>>
atom -> ( test_list_comp )
1777
not
atom -> ( test_list_comp )
1777
>=
atom -> ( test_list_comp )
1777
or
atom -> ( test_list_comp )
1777
<
atom -> ( test_list_comp )
1777
if
atom -> ( test_list_comp )
1777
|
atom -> ( test_list_comp )
1777
<<
atom -> ( test_list_comp )
1777
@
atom -> ( test_list_comp )
1777
!=
atom -> ( test_list_comp )
1777
is
atom -> ( test_list_comp )
1777
.
atom -> ( test_list_comp )
1777
<=
atom -> ( test_list_comp )
1777
==
atom -> ( test_list_comp )
1778
]
shift_expr -> arith_expr >> shift_expr
1778
>=
shift_expr -> arith_expr >> shift_expr
1778
,
shift_expr -> arith_expr >> shift_expr
1778
if
shift_expr -> arith_expr >> shift_expr
1778
<=
shift_expr -> arith_expr >> shift_expr
1778
!=
shift_expr -> arith_expr >> shift_expr
1778
or
shift_expr -> arith_expr >> shift_expr
1778
|
shift_expr -> arith_expr >> shift_expr
1778
is
shift_expr -> arith_expr >> shift_expr
1778
and
shift_expr -> arith_expr >> shift_expr
1778
in
shift_expr -> arith_expr >> shift_expr
1778
^
shift_expr -> arith_expr >> shift_expr
1778
not
shift_expr -> arith_expr >> shift_expr
1778
<
shift_expr -> arith_expr >> shift_expr
1778
==
shift_expr -> arith_expr >> shift_expr
1778
:
shift_expr -> arith_expr >> shift_expr
1778
&
shift_expr -> arith_expr >> shift_expr
1778
>
shift_expr -> arith_expr >> shift_expr
1779
>
shift_expr -> arith_expr << shift_expr
1779
or
shift_expr -> arith_expr << shift_expr
1779
^
shift_expr -> arith_expr << shift_expr
1779
not
shift_expr -> arith_expr << shift_expr
1779
<
shift_expr -> arith_expr << shift_expr
1779
if
shift_expr -> arith_expr << shift_expr
1779
in
shift_expr -> arith_expr << shift_expr
1779
!=
shift_expr -> arith_expr << shift_expr
1779
,
shift_expr -> arith_expr << shift_expr
1779
|
shift_expr -> arith_expr << shift_expr
1779
>=
shift_expr -> arith_expr << shift_expr
1779
and
shift_expr -> arith_expr << shift_expr
1779
==
shift_expr -> arith_expr << shift_expr
1779
]
shift_expr -> arith_expr << shift_expr
1779
&
shift_expr -> arith_expr << shift_expr
1779
<=
shift_expr -> arith_expr << shift_expr
1779
is
shift_expr -> arith_expr << shift_expr
1779
:
shift_expr -> arith_expr << shift_expr
1780
in
atom -> [ test_list_comp ]
1780
/
atom -> [ test_list_comp ]
1780
or
atom -> [ test_list_comp ]
1780
if
atom -> [ test_list_comp ]
1780
<<
atom -> [ test_list_comp ]
1780
!=
atom -> [ test_list_comp ]
1780
<=
atom -> [ test_list_comp ]
1780
>>
atom -> [ test_list_comp ]
1780
*
atom -> [ test_list_comp ]
1780
^
atom -> [ test_list_comp ]
1780
.
atom -> [ test_list_comp ]
1780
(
atom -> [ test_list_comp ]
1780
>=
atom -> [ test_list_comp ]
1780
and
atom -> [ test_list_comp ]
1780
<
atom -> [ test_list_comp ]
1780
]
atom -> [ test_list_comp ]
1780
,
atom -> [ test_list_comp ]
1780
[
atom -> [ test_list_comp ]
1780
==
atom -> [ test_list_comp ]
1780
@
atom -> [ test_list_comp ]
1780
%
atom -> [ test_list_comp ]
1780
-
atom -> [ test_list_comp ]
1780
|
atom -> [ test_list_comp ]
1780
&
atom -> [ test_list_comp ]
1780
:
atom -> [ test_list_comp ]
1780
+
atom -> [ test_list_comp ]
1780
is
atom -> [ test_list_comp ]
1780
//
atom -> [ test_list_comp ]
1780
**
atom -> [ test_list_comp ]
1780
not
atom -> [ test_list_comp ]
1780
>
atom -> [ test_list_comp ]
1781
]
sliceop -> 
1781
:
2161
1781
sliceop
2162
1781
,
sliceop -> 
1782
:
maybe_test -> test
1782
]
maybe_test -> test
1782
,
maybe_test -> test
1783
and
comparison -> expr comp_op comparison
1783
:
comparison -> expr comp_op comparison
1783
]
comparison -> expr comp_op comparison
1783
if
comparison -> expr comp_op comparison
1783
or
comparison -> expr comp_op comparison
1783
,
comparison -> expr comp_op comparison
1784
+
power -> atom_expr ** factor
1784
&
power -> atom_expr ** factor
1784
>>
power -> atom_expr ** factor
1784
<<
power -> atom_expr ** factor
1784
not
power -> atom_expr ** factor
1784
is
power -> atom_expr ** factor
1784
@
power -> atom_expr ** factor
1784
:
power -> atom_expr ** factor
1784
==
power -> atom_expr ** factor
1784
*
power -> atom_expr ** factor
1784
or
power -> atom_expr ** factor
1784
>
power -> atom_expr ** factor
1784
-
power -> atom_expr ** factor
1784
if
power -> atom_expr ** factor
1784
!=
power -> atom_expr ** factor
1784
>=
power -> atom_expr ** factor
1784
/
power -> atom_expr ** factor
1784
%
power -> atom_expr ** factor
1784
and
power -> atom_expr ** factor
1784
<=
power -> atom_expr ** factor
1784
]
power -> atom_expr ** factor
1784
<
power -> atom_expr ** factor
1784
|
power -> atom_expr ** factor
1784
^
power -> atom_expr ** factor
1784
in
power -> atom_expr ** factor
1784
,
power -> atom_expr ** factor
1784
//
power -> atom_expr ** factor
1785
+
trailer_expr -> trailer trailer_expr
1785
,
trailer_expr -> trailer trailer_expr
1785
*
trailer_expr -> trailer trailer_expr
1785
/
trailer_expr -> trailer trailer_expr
1785
not
trailer_expr -> trailer trailer_expr
1785
<<
trailer_expr -> trailer trailer_expr
1785
!=
trailer_expr -> trailer trailer_expr
1785
>=
trailer_expr -> trailer trailer_expr
1785
>>
trailer_expr -> trailer trailer_expr
1785
|
trailer_expr -> trailer trailer_expr
1785
%
trailer_expr -> trailer trailer_expr
1785
>
trailer_expr -> trailer trailer_expr
1785
&
trailer_expr -> trailer trailer_expr
1785
-
trailer_expr -> trailer trailer_expr
1785
<=
trailer_expr -> trailer trailer_expr
1785
:
trailer_expr -> trailer trailer_expr
1785
**
trailer_expr -> trailer trailer_expr
1785
@
trailer_expr -> trailer trailer_expr
1785
if
trailer_expr -> trailer trailer_expr
1785
==
trailer_expr -> trailer trailer_expr
1785
or
trailer_expr -> trailer trailer_expr
1785
<
trailer_expr -> trailer trailer_expr
1785
and
trailer_expr -> trailer trailer_expr
1785
in
trailer_expr -> trailer trailer_expr
1785
is
trailer_expr -> trailer trailer_expr
1785
]
trailer_expr -> trailer trailer_expr
1785
^
trailer_expr -> trailer trailer_expr
1785
//
trailer_expr -> trailer trailer_expr
1786
<=
trailer -> . NAME
1786
<<
trailer -> . NAME
1786
**
trailer -> . NAME
1786
!=
trailer -> . NAME
1786
:
trailer -> . NAME
1786
/
trailer -> . NAME
1786
&
trailer -> . NAME
1786
//
trailer -> . NAME
1786
<
trailer -> . NAME
1786
is
trailer -> . NAME
1786
-
trailer -> . NAME
1786
if
trailer -> . NAME
1786
[
trailer -> . NAME
1786
or
trailer -> . NAME
1786
>
trailer -> . NAME
1786
*
trailer -> . NAME
1786
+
trailer -> . NAME
1786
%
trailer -> . NAME
1786
.
trailer -> . NAME
1786
>=
trailer -> . NAME
1786
|
trailer -> . NAME
1786
and
trailer -> . NAME
1786
(
trailer -> . NAME
1786
]
trailer -> . NAME
1786
,
trailer -> . NAME
1786
==
trailer -> . NAME
1786
^
trailer -> . NAME
1786
in
trailer -> . NAME
1786
@
trailer -> . NAME
1786
not
trailer -> . NAME
1786
>>
trailer -> . NAME
1787
%
trailer -> ( )
1787
<=
trailer -> ( )
1787
and
trailer -> ( )
1787
//
trailer -> ( )
1787
not
trailer -> ( )
1787
or
trailer -> ( )
1787
]
trailer -> ( )
1787
>>
trailer -> ( )
1787
>
trailer -> ( )
1787
<<
trailer -> ( )
1787
[
trailer -> ( )
1787
is
trailer -> ( )
1787
:
trailer -> ( )
1787
-
trailer -> ( )
1787
**
trailer -> ( )
1787
/
trailer -> ( )
1787
,
trailer -> ( )
1787
+
trailer -> ( )
1787
&
trailer -> ( )
1787
in
trailer -> ( )
1787
^
trailer -> ( )
1787
!=
trailer -> ( )
1787
*
trailer -> ( )
1787
if
trailer -> ( )
1787
>=
trailer -> ( )
1787
(
trailer -> ( )
1787
@
trailer -> ( )
1787
==
trailer -> ( )
1787
|
trailer -> ( )
1787
.
trailer -> ( )
1787
<
trailer -> ( )
1788
)
2163
1789
]
2164
1790
==
and_expr -> shift_expr & and_expr
1790
in
and_expr -> shift_expr & and_expr
1790
!=
and_expr -> shift_expr & and_expr
1790
,
and_expr -> shift_expr & and_expr
1790
or
and_expr -> shift_expr & and_expr
1790
>
and_expr -> shift_expr & and_expr
1790
not
and_expr -> shift_expr & and_expr
1790
:
and_expr -> shift_expr & and_expr
1790
|
and_expr -> shift_expr & and_expr
1790
<=
and_expr -> shift_expr & and_expr
1790
and
and_expr -> shift_expr & and_expr
1790
^
and_expr -> shift_expr & and_expr
1790
is
and_expr -> shift_expr & and_expr
1790
]
and_expr -> shift_expr & and_expr
1790
>=
and_expr -> shift_expr & and_expr
1790
<
and_expr -> shift_expr & and_expr
1790
if
and_expr -> shift_expr & and_expr
1791
,
and_test -> not_test and and_test
1791
]
and_test -> not_test and and_test
1791
:
and_test -> not_test and and_test
1791
if
and_test -> not_test and and_test
1791
or
and_test -> not_test and and_test
1792
<=
xor_expr -> and_expr ^ xor_expr
1792
!=
xor_expr -> and_expr ^ xor_expr
1792
and
xor_expr -> and_expr ^ xor_expr
1792
is
xor_expr -> and_expr ^ xor_expr
1792
>=
xor_expr -> and_expr ^ xor_expr
1792
not
xor_expr -> and_expr ^ xor_expr
1792
<
xor_expr -> and_expr ^ xor_expr
1792
:
xor_expr -> and_expr ^ xor_expr
1792
|
xor_expr -> and_expr ^ xor_expr
1792
in
xor_expr -> and_expr ^ xor_expr
1792
==
xor_expr -> and_expr ^ xor_expr
1792
or
xor_expr -> and_expr ^ xor_expr
1792
,
xor_expr -> and_expr ^ xor_expr
1792
if
xor_expr -> and_expr ^ xor_expr
1792
>
xor_expr -> and_expr ^ xor_expr
1792
]
xor_expr -> and_expr ^ xor_expr
1793
not
expr -> xor_expr | expr
1793
,
expr -> xor_expr | expr
1793
in
expr -> xor_expr | expr
1793
if
expr -> xor_expr | expr
1793
:
expr -> xor_expr | expr
1793
or
expr -> xor_expr | expr
1793
<=
expr -> xor_expr | expr
1793
>
expr -> xor_expr | expr
1793
!=
expr -> xor_expr | expr
1793
]
expr -> xor_expr | expr
1793
==
expr -> xor_expr | expr
1793
>=
expr -> xor_expr | expr
1793
is
expr -> xor_expr | expr
1793
<
expr -> xor_expr | expr
1793
and
expr -> xor_expr | expr
1794
,
or_test -> and_test or or_test
1794
if
or_test -> and_test or or_test
1794
]
or_test -> and_test or or_test
1794
:
or_test -> and_test or or_test
1795
,
lambdef -> lambda : test
1795
]
lambdef -> lambda : test
1795
:
lambdef -> lambda : test
1796
factor
732
1796
or_test
733
1796
term
734
1796
(
735
1796
arith_expr
736
1796
NAME
737
1796
[
738
1796
~
739
1796
+
741
1796
expr
743
1796
atom_expr
744
1796
atom
745
1796
NUMBER
746
1796
STRING
747
1796
shift_expr
748
1796
-
749
1796
True
750
1796
not_test
751
1796
and_expr
752
1796
xor_expr
753
1796
False
754
1796
{
755
1796
None
756
1796
and_test
757
1796
lambda
758
1796
power
759
1796
lambdef
762
1796
comparison
763
1796
test
2165
1796
not
764
1797
]
subscriptlist -> subscript , subscriptlist
1798
and
term -> factor // term
1798
if
term -> factor // term
1798
>
term -> factor // term
1798
<
term -> factor // term
1798
==
term -> factor // term
1798
+
term -> factor // term
1798
-
term -> factor // term
1798
&
term -> factor // term
1798
in
term -> factor // term
1798
!=
term -> factor // term
1798
^
term -> factor // term
1798
,
term -> factor // term
1798
=
term -> factor // term
1798
or
term -> factor // term
1798
NEWLINE
term -> factor // term
1798
<=
term -> factor // term
1798
>=
term -> factor // term
1798
|
term -> factor // term
1798
>>
term -> factor // term
1798
not
term -> factor // term
1798
is
term -> factor // term
1798
<<
term -> factor // term
1799
^
term -> factor * term
1799
+
term -> factor * term
1799
==
term -> factor * term
1799
>>
term -> factor * term
1799
in
term -> factor * term
1799
and
term -> factor * term
1799
if
term -> factor * term
1799
is
term -> factor * term
1799
<<
term -> factor * term
1799
,
term -> factor * term
1799
-
term -> factor * term
1799
!=
term -> factor * term
1799
or
term -> factor * term
1799
>
term -> factor * term
1799
&
term -> factor * term
1799
NEWLINE
term -> factor * term
1799
>=
term -> factor * term
1799
|
term -> factor * term
1799
<=
term -> factor * term
1799
not
term -> factor * term
1799
=
term -> factor * term
1799
<
term -> factor * term
1800
&
term -> factor % term
1800
==
term -> factor % term
1800
!=
term -> factor % term
1800
<
term -> factor % term
1800
in
term -> factor % term
1800
=
term -> factor % term
1800
>>
term -> factor % term
1800
<<
term -> factor % term
1800
NEWLINE
term -> factor % term
1800
-
term -> factor % term
1800
if
term -> factor % term
1800
>
term -> factor % term
1800
or
term -> factor % term
1800
^
term -> factor % term
1800
+
term -> factor % term
1800
,
term -> factor % term
1800
is
term -> factor % term
1800
|
term -> factor % term
1800
>=
term -> factor % term
1800
<=
term -> factor % term
1800
and
term -> factor % term
1800
not
term -> factor % term
1801
and
term -> factor @ term
1801
in
term -> factor @ term
1801
>=
term -> factor @ term
1801
<
term -> factor @ term
1801
,
term -> factor @ term
1801
>
term -> factor @ term
1801
-
term -> factor @ term
1801
NEWLINE
term -> factor @ term
1801
or
term -> factor @ term
1801
<<
term -> factor @ term
1801
is
term -> factor @ term
1801
!=
term -> factor @ term
1801
|
term -> factor @ term
1801
&
term -> factor @ term
1801
==
term -> factor @ term
1801
>>
term -> factor @ term
1801
<=
term -> factor @ term
1801
not
term -> factor @ term
1801
+
term -> factor @ term
1801
^
term -> factor @ term
1801
=
term -> factor @ term
1801
if
term -> factor @ term
1802
or
term -> factor / term
1802
<<
term -> factor / term
1802
not
term -> factor / term
1802
in
term -> factor / term
1802
!=
term -> factor / term
1802
<
term -> factor / term
1802
,
term -> factor / term
1802
+
term -> factor / term
1802
and
term -> factor / term
1802
>>
term -> factor / term
1802
^
term -> factor / term
1802
<=
term -> factor / term
1802
==
term -> factor / term
1802
>
term -> factor / term
1802
&
term -> factor / term
1802
is
term -> factor / term
1802
-
term -> factor / term
1802
NEWLINE
term -> factor / term
1802
|
term -> factor / term
1802
>=
term -> factor / term
1802
if
term -> factor / term
1802
=
term -> factor / term
1803
==
arith_expr -> term + arith_expr
1803
!=
arith_expr -> term + arith_expr
1803
<<
arith_expr -> term + arith_expr
1803
&
arith_expr -> term + arith_expr
1803
<
arith_expr -> term + arith_expr
1803
^
arith_expr -> term + arith_expr
1803
,
arith_expr -> term + arith_expr
1803
>=
arith_expr -> term + arith_expr
1803
NEWLINE
arith_expr -> term + arith_expr
1803
in
arith_expr -> term + arith_expr
1803
>>
arith_expr -> term + arith_expr
1803
not
arith_expr -> term + arith_expr
1803
<=
arith_expr -> term + arith_expr
1803
is
arith_expr -> term + arith_expr
1803
|
arith_expr -> term + arith_expr
1803
and
arith_expr -> term + arith_expr
1803
=
arith_expr -> term + arith_expr
1803
or
arith_expr -> term + arith_expr
1803
if
arith_expr -> term + arith_expr
1803
>
arith_expr -> term + arith_expr
1804
if
arith_expr -> term - arith_expr
1804
&
arith_expr -> term - arith_expr
1804
>>
arith_expr -> term - arith_expr
1804
NEWLINE
arith_expr -> term - arith_expr
1804
!=
arith_expr -> term - arith_expr
1804
>=
arith_expr -> term - arith_expr
1804
|
arith_expr -> term - arith_expr
1804
>
arith_expr -> term - arith_expr
1804
<
arith_expr -> term - arith_expr
1804
==
arith_expr -> term - arith_expr
1804
,
arith_expr -> term - arith_expr
1804
and
arith_expr -> term - arith_expr
1804
=
arith_expr -> term - arith_expr
1804
is
arith_expr -> term - arith_expr
1804
in
arith_expr -> term - arith_expr
1804
^
arith_expr -> term - arith_expr
1804
<<
arith_expr -> term - arith_expr
1804
not
arith_expr -> term - arith_expr
1804
or
arith_expr -> term - arith_expr
1804
<=
arith_expr -> term - arith_expr
1805
+
atom -> ( test_list_comp )
1805
/
atom -> ( test_list_comp )
1805
*
atom -> ( test_list_comp )
1805
[
atom -> ( test_list_comp )
1805
&
atom -> ( test_list_comp )
1805
,
atom -> ( test_list_comp )
1805
**
atom -> ( test_list_comp )
1805
^
atom -> ( test_list_comp )
1805
(
atom -> ( test_list_comp )
1805
and
atom -> ( test_list_comp )
1805
>
atom -> ( test_list_comp )
1805
=
atom -> ( test_list_comp )
1805
-
atom -> ( test_list_comp )
1805
%
atom -> ( test_list_comp )
1805
//
atom -> ( test_list_comp )
1805
in
atom -> ( test_list_comp )
1805
>>
atom -> ( test_list_comp )
1805
not
atom -> ( test_list_comp )
1805
>=
atom -> ( test_list_comp )
1805
or
atom -> ( test_list_comp )
1805
<
atom -> ( test_list_comp )
1805
if
atom -> ( test_list_comp )
1805
|
atom -> ( test_list_comp )
1805
<<
atom -> ( test_list_comp )
1805
@
atom -> ( test_list_comp )
1805
!=
atom -> ( test_list_comp )
1805
is
atom -> ( test_list_comp )
1805
NEWLINE
atom -> ( test_list_comp )
1805
.
atom -> ( test_list_comp )
1805
<=
atom -> ( test_list_comp )
1805
==
atom -> ( test_list_comp )
1806
>=
shift_expr -> arith_expr >> shift_expr
1806
,
shift_expr -> arith_expr >> shift_expr
1806
if
shift_expr -> arith_expr >> shift_expr
1806
<=
shift_expr -> arith_expr >> shift_expr
1806
!=
shift_expr -> arith_expr >> shift_expr
1806
or
shift_expr -> arith_expr >> shift_expr
1806
|
shift_expr -> arith_expr >> shift_expr
1806
is
shift_expr -> arith_expr >> shift_expr
1806
and
shift_expr -> arith_expr >> shift_expr
1806
NEWLINE
shift_expr -> arith_expr >> shift_expr
1806
in
shift_expr -> arith_expr >> shift_expr
1806
^
shift_expr -> arith_expr >> shift_expr
1806
not
shift_expr -> arith_expr >> shift_expr
1806
<
shift_expr -> arith_expr >> shift_expr
1806
==
shift_expr -> arith_expr >> shift_expr
1806
=
shift_expr -> arith_expr >> shift_expr
1806
&
shift_expr -> arith_expr >> shift_expr
1806
>
shift_expr -> arith_expr >> shift_expr
1807
>
shift_expr -> arith_expr << shift_expr
1807
or
shift_expr -> arith_expr << shift_expr
1807
^
shift_expr -> arith_expr << shift_expr
1807
not
shift_expr -> arith_expr << shift_expr
1807
<
shift_expr -> arith_expr << shift_expr
1807
if
shift_expr -> arith_expr << shift_expr
1807
in
shift_expr -> arith_expr << shift_expr
1807
!=
shift_expr -> arith_expr << shift_expr
1807
,
shift_expr -> arith_expr << shift_expr
1807
|
shift_expr -> arith_expr << shift_expr
1807
>=
shift_expr -> arith_expr << shift_expr
1807
and
shift_expr -> arith_expr << shift_expr
1807
NEWLINE
shift_expr -> arith_expr << shift_expr
1807
==
shift_expr -> arith_expr << shift_expr
1807
&
shift_expr -> arith_expr << shift_expr
1807
<=
shift_expr -> arith_expr << shift_expr
1807
=
shift_expr -> arith_expr << shift_expr
1807
is
shift_expr -> arith_expr << shift_expr
1808
in
atom -> [ test_list_comp ]
1808
/
atom -> [ test_list_comp ]
1808
or
atom -> [ test_list_comp ]
1808
if
atom -> [ test_list_comp ]
1808
<<
atom -> [ test_list_comp ]
1808
!=
atom -> [ test_list_comp ]
1808
=
atom -> [ test_list_comp ]
1808
<=
atom -> [ test_list_comp ]
1808
>>
atom -> [ test_list_comp ]
1808
*
atom -> [ test_list_comp ]
1808
^
atom -> [ test_list_comp ]
1808
.
atom -> [ test_list_comp ]
1808
(
atom -> [ test_list_comp ]
1808
>=
atom -> [ test_list_comp ]
1808
and
atom -> [ test_list_comp ]
1808
<
atom -> [ test_list_comp ]
1808
,
atom -> [ test_list_comp ]
1808
[
atom -> [ test_list_comp ]
1808
==
atom -> [ test_list_comp ]
1808
@
atom -> [ test_list_comp ]
1808
%
atom -> [ test_list_comp ]
1808
-
atom -> [ test_list_comp ]
1808
|
atom -> [ test_list_comp ]
1808
&
atom -> [ test_list_comp ]
1808
+
atom -> [ test_list_comp ]
1808
is
atom -> [ test_list_comp ]
1808
//
atom -> [ test_list_comp ]
1808
**
atom -> [ test_list_comp ]
1808
not
atom -> [ test_list_comp ]
1808
NEWLINE
atom -> [ test_list_comp ]
1808
>
atom -> [ test_list_comp ]
1809
+
trailer_expr -> trailer trailer_expr
1809
,
trailer_expr -> trailer trailer_expr
1809
*
trailer_expr -> trailer trailer_expr
1809
/
trailer_expr -> trailer trailer_expr
1809
not
trailer_expr -> trailer trailer_expr
1809
<<
trailer_expr -> trailer trailer_expr
1809
!=
trailer_expr -> trailer trailer_expr
1809
=
trailer_expr -> trailer trailer_expr
1809
>=
trailer_expr -> trailer trailer_expr
1809
>>
trailer_expr -> trailer trailer_expr
1809
|
trailer_expr -> trailer trailer_expr
1809
%
trailer_expr -> trailer trailer_expr
1809
>
trailer_expr -> trailer trailer_expr
1809
&
trailer_expr -> trailer trailer_expr
1809
-
trailer_expr -> trailer trailer_expr
1809
<=
trailer_expr -> trailer trailer_expr
1809
**
trailer_expr -> trailer trailer_expr
1809
@
trailer_expr -> trailer trailer_expr
1809
if
trailer_expr -> trailer trailer_expr
1809
NEWLINE
trailer_expr -> trailer trailer_expr
1809
==
trailer_expr -> trailer trailer_expr
1809
or
trailer_expr -> trailer trailer_expr
1809
<
trailer_expr -> trailer trailer_expr
1809
and
trailer_expr -> trailer trailer_expr
1809
in
trailer_expr -> trailer trailer_expr
1809
is
trailer_expr -> trailer trailer_expr
1809
^
trailer_expr -> trailer trailer_expr
1809
//
trailer_expr -> trailer trailer_expr
1810
<=
trailer -> . NAME
1810
<<
trailer -> . NAME
1810
**
trailer -> . NAME
1810
!=
trailer -> . NAME
1810
/
trailer -> . NAME
1810
&
trailer -> . NAME
1810
//
trailer -> . NAME
1810
<
trailer -> . NAME
1810
is
trailer -> . NAME
1810
-
trailer -> . NAME
1810
if
trailer -> . NAME
1810
[
trailer -> . NAME
1810
or
trailer -> . NAME
1810
>
trailer -> . NAME
1810
*
trailer -> . NAME
1810
+
trailer -> . NAME
1810
%
trailer -> . NAME
1810
.
trailer -> . NAME
1810
>=
trailer -> . NAME
1810
|
trailer -> . NAME
1810
and
trailer -> . NAME
1810
(
trailer -> . NAME
1810
,
trailer -> . NAME
1810
NEWLINE
trailer -> . NAME
1810
==
trailer -> . NAME
1810
^
trailer -> . NAME
1810
in
trailer -> . NAME
1810
@
trailer -> . NAME
1810
not
trailer -> . NAME
1810
=
trailer -> . NAME
1810
>>
trailer -> . NAME
1811
)
2166
1812
%
trailer -> ( )
1812
<=
trailer -> ( )
1812
and
trailer -> ( )
1812
//
trailer -> ( )
1812
not
trailer -> ( )
1812
or
trailer -> ( )
1812
NEWLINE
trailer -> ( )
1812
>>
trailer -> ( )
1812
>
trailer -> ( )
1812
<<
trailer -> ( )
1812
[
trailer -> ( )
1812
is
trailer -> ( )
1812
-
trailer -> ( )
1812
**
trailer -> ( )
1812
/
trailer -> ( )
1812
,
trailer -> ( )
1812
+
trailer -> ( )
1812
&
trailer -> ( )
1812
in
trailer -> ( )
1812
^
trailer -> ( )
1812
!=
trailer -> ( )
1812
*
trailer -> ( )
1812
if
trailer -> ( )
1812
>=
trailer -> ( )
1812
(
trailer -> ( )
1812
@
trailer -> ( )
1812
=
trailer -> ( )
1812
==
trailer -> ( )
1812
|
trailer -> ( )
1812
.
trailer -> ( )
1812
<
trailer -> ( )
1813
]
2167
1814
+
power -> atom_expr ** factor
1814
&
power -> atom_expr ** factor
1814
>>
power -> atom_expr ** factor
1814
<<
power -> atom_expr ** factor
1814
not
power -> atom_expr ** factor
1814
is
power -> atom_expr ** factor
1814
@
power -> atom_expr ** factor
1814
==
power -> atom_expr ** factor
1814
*
power -> atom_expr ** factor
1814
or
power -> atom_expr ** factor
1814
>
power -> atom_expr ** factor
1814
-
power -> atom_expr ** factor
1814
if
power -> atom_expr ** factor
1814
!=
power -> atom_expr ** factor
1814
>=
power -> atom_expr ** factor
1814
/
power -> atom_expr ** factor
1814
%
power -> atom_expr ** factor
1814
and
power -> atom_expr ** factor
1814
=
power -> atom_expr ** factor
1814
NEWLINE
power -> atom_expr ** factor
1814
<=
power -> atom_expr ** factor
1814
<
power -> atom_expr ** factor
1814
|
power -> atom_expr ** factor
1814
^
power -> atom_expr ** factor
1814
in
power -> atom_expr ** factor
1814
,
power -> atom_expr ** factor
1814
//
power -> atom_expr ** factor
1815
==
and_expr -> shift_expr & and_expr
1815
in
and_expr -> shift_expr & and_expr
1815
=
and_expr -> shift_expr & and_expr
1815
!=
and_expr -> shift_expr & and_expr
1815
,
and_expr -> shift_expr & and_expr
1815
or
and_expr -> shift_expr & and_expr
1815
>
and_expr -> shift_expr & and_expr
1815
not
and_expr -> shift_expr & and_expr
1815
<=
and_expr -> shift_expr & and_expr
1815
|
and_expr -> shift_expr & and_expr
1815
and
and_expr -> shift_expr & and_expr
1815
NEWLINE
and_expr -> shift_expr & and_expr
1815
^
and_expr -> shift_expr & and_expr
1815
is
and_expr -> shift_expr & and_expr
1815
>=
and_expr -> shift_expr & and_expr
1815
<
and_expr -> shift_expr & and_expr
1815
if
and_expr -> shift_expr & and_expr
1816
NEWLINE
and_test -> not_test and and_test
1816
=
and_test -> not_test and and_test
1816
,
and_test -> not_test and and_test
1816
if
and_test -> not_test and and_test
1816
or
and_test -> not_test and and_test
1817
<=
xor_expr -> and_expr ^ xor_expr
1817
!=
xor_expr -> and_expr ^ xor_expr
1817
and
xor_expr -> and_expr ^ xor_expr
1817
=
xor_expr -> and_expr ^ xor_expr
1817
is
xor_expr -> and_expr ^ xor_expr
1817
>=
xor_expr -> and_expr ^ xor_expr
1817
not
xor_expr -> and_expr ^ xor_expr
1817
<
xor_expr -> and_expr ^ xor_expr
1817
|
xor_expr -> and_expr ^ xor_expr
1817
in
xor_expr -> and_expr ^ xor_expr
1817
==
xor_expr -> and_expr ^ xor_expr
1817
or
xor_expr -> and_expr ^ xor_expr
1817
,
xor_expr -> and_expr ^ xor_expr
1817
if
xor_expr -> and_expr ^ xor_expr
1817
>
xor_expr -> and_expr ^ xor_expr
1817
NEWLINE
xor_expr -> and_expr ^ xor_expr
1818
not
expr -> xor_expr | expr
1818
,
expr -> xor_expr | expr
1818
in
expr -> xor_expr | expr
1818
if
expr -> xor_expr | expr
1818
or
expr -> xor_expr | expr
1818
<=
expr -> xor_expr | expr
1818
>
expr -> xor_expr | expr
1818
!=
expr -> xor_expr | expr
1818
==
expr -> xor_expr | expr
1818
=
expr -> xor_expr | expr
1818
NEWLINE
expr -> xor_expr | expr
1818
>=
expr -> xor_expr | expr
1818
is
expr -> xor_expr | expr
1818
<
expr -> xor_expr | expr
1818
and
expr -> xor_expr | expr
1819
and
comparison -> expr comp_op comparison
1819
if
comparison -> expr comp_op comparison
1819
=
comparison -> expr comp_op comparison
1819
or
comparison -> expr comp_op comparison
1819
NEWLINE
comparison -> expr comp_op comparison
1819
,
comparison -> expr comp_op comparison
1820
NEWLINE
or_test -> and_test or or_test
1820
,
or_test -> and_test or or_test
1820
if
or_test -> and_test or or_test
1820
=
or_test -> and_test or or_test
1821
,
lambdef -> lambda : test
1821
NEWLINE
lambdef -> lambda : test
1821
=
lambdef -> lambda : test
1822
factor
766
1822
term
767
1822
(
768
1822
arith_expr
769
1822
NAME
770
1822
[
771
1822
atom
772
1822
+
773
1822
power
774
1822
atom_expr
775
1822
NUMBER
776
1822
STRING
777
1822
shift_expr
778
1822
-
779
1822
True
780
1822
not_test
781
1822
and_expr
782
1822
xor_expr
783
1822
None
784
1822
expr
785
1822
False
786
1822
and_test
787
1822
lambda
788
1822
~
789
1822
{
790
1822
not
792
1822
or_test
793
1822
lambdef
795
1822
comparison
797
1822
test
2168
1823
NEWLINE
test_list -> test , test_list
1823
=
test_list -> test , test_list
1824
else
2169
1825
//
2170
1825
in
term -> factor
1825
-
term -> factor
1825
*
2171
1825
%
2172
1825
@
2173
1825
>=
term -> factor
1825
/
2174
1825
=
term -> factor
1825
<
term -> factor
1825
<=
term -> factor
1825
==
term -> factor
1825
!=
term -> factor
1825
>>
term -> factor
1825
is
term -> factor
1825
or
term -> factor
1825
and
term -> factor
1825
NEWLINE
term -> factor
1825
^
term -> factor
1825
+
term -> factor
1825
&
term -> factor
1825
<<
term -> factor
1825
|
term -> factor
1825
>
term -> factor
1825
if
term -> factor
1825
not
term -> factor
1826
factor
268
1826
term
270
1826
(
271
1826
arith_expr
272
1826
NAME
273
1826
[
274
1826
+
275
1826
test_list_comp
2175
1826
atom_expr
277
1826
NUMBER
278
1826
atom
279
1826
STRING
280
1826
shift_expr
281
1826
-
282
1826
True
283
1826
not_test
284
1826
lambdef
285
1826
and_expr
286
1826
xor_expr
287
1826
False
288
1826
None
289
1826
expr
290
1826
and_test
291
1826
)
2176
1826
{
292
1826
~
293
1826
power
294
1826
lambda
295
1826
comparison
296
1826
or_test
297
1826
not
298
1826
test
299
1826
test_list
300
1827
>>
2177
1827
<<
2178
1827
&
shift_expr -> arith_expr
1827
<=
shift_expr -> arith_expr
1827
>
shift_expr -> arith_expr
1827
NEWLINE
shift_expr -> arith_expr
1827
not
shift_expr -> arith_expr
1827
!=
shift_expr -> arith_expr
1827
^
shift_expr -> arith_expr
1827
is
shift_expr -> arith_expr
1827
|
shift_expr -> arith_expr
1827
=
shift_expr -> arith_expr
1827
>=
shift_expr -> arith_expr
1827
or
shift_expr -> arith_expr
1827
==
shift_expr -> arith_expr
1827
if
shift_expr -> arith_expr
1827
and
shift_expr -> arith_expr
1827
<
shift_expr -> arith_expr
1827
in
shift_expr -> arith_expr
1828
-
atom -> NAME
1828
or
atom -> NAME
1828
>>
atom -> NAME
1828
NEWLINE
atom -> NAME
1828
&
atom -> NAME
1828
[
atom -> NAME
1828
<=
atom -> NAME
1828
<
atom -> NAME
1828
.
atom -> NAME
1828
|
atom -> NAME
1828
*
atom -> NAME
1828
/
atom -> NAME
1828
<<
atom -> NAME
1828
not
atom -> NAME
1828
>
atom -> NAME
1828
=
atom -> NAME
1828
is
atom -> NAME
1828
//
atom -> NAME
1828
+
atom -> NAME
1828
if
atom -> NAME
1828
in
atom -> NAME
1828
**
atom -> NAME
1828
!=
atom -> NAME
1828
>=
atom -> NAME
1828
^
atom -> NAME
1828
@
atom -> NAME
1828
(
atom -> NAME
1828
==
atom -> NAME
1828
and
atom -> NAME
1828
%
atom -> NAME
1829
factor
117
1829
or_test
118
1829
term
119
1829
(
120
1829
arith_expr
121
1829
NAME
122
1829
[
123
1829
]
2179
1829
+
125
1829
atom_expr
126
1829
NUMBER
127
1829
atom
128
1829
STRING
129
1829
shift_expr
130
1829
-
131
1829
test_list_comp
2180
1829
True
133
1829
not_test
134
1829
lambdef
135
1829
and_expr
136
1829
xor_expr
137
1829
False
138
1829
None
139
1829
expr
140
1829
and_test
141
1829
{
142
1829
~
143
1829
lambda
144
1829
power
145
1829
comparison
146
1829
test_list
147
1829
test
148
1829
not
149
1830
trailer
2181
1830
.
2182
1830
(
2183
1830
[
2184
1830
trailer_expr
2185
1830
<<
trailer_expr -> 
1830
%
trailer_expr -> 
1830
==
trailer_expr -> 
1830
-
trailer_expr -> 
1830
<
trailer_expr -> 
1830
NEWLINE
trailer_expr -> 
1830
if
trailer_expr -> 
1830
or
trailer_expr -> 
1830
/
trailer_expr -> 
1830
**
trailer_expr -> 
1830
and
trailer_expr -> 
1830
@
trailer_expr -> 
1830
=
trailer_expr -> 
1830
*
trailer_expr -> 
1830
|
trailer_expr -> 
1830
is
trailer_expr -> 
1830
+
trailer_expr -> 
1830
in
trailer_expr -> 
1830
&
trailer_expr -> 
1830
<=
trailer_expr -> 
1830
>=
trailer_expr -> 
1830
^
trailer_expr -> 
1830
>
trailer_expr -> 
1830
!=
trailer_expr -> 
1830
not
trailer_expr -> 
1830
>>
trailer_expr -> 
1830
//
trailer_expr -> 
1831
(
1826
1831
NAME
1828
1831
[
1829
1831
atom
1830
1831
+
1831
1831
atom_expr
1834
1831
power
1833
1831
NUMBER
1835
1831
STRING
1836
1831
-
1838
1831
factor
2186
1831
True
1840
1831
None
1843
1831
False
1845
1831
{
1850
1831
~
1848
1832
+
2187
1832
-
2188
1832
NEWLINE
arith_expr -> term
1832
|
arith_expr -> term
1832
or
arith_expr -> term
1832
not
arith_expr -> term
1832
<=
arith_expr -> term
1832
!=
arith_expr -> term
1832
<
arith_expr -> term
1832
=
arith_expr -> term
1832
&
arith_expr -> term
1832
>=
arith_expr -> term
1832
if
arith_expr -> term
1832
==
arith_expr -> term
1832
^
arith_expr -> term
1832
in
arith_expr -> term
1832
is
arith_expr -> term
1832
<<
arith_expr -> term
1832
>
arith_expr -> term
1832
and
arith_expr -> term
1832
>>
arith_expr -> term
1833
&
factor -> power
1833
NEWLINE
factor -> power
1833
%
factor -> power
1833
<<
factor -> power
1833
-
factor -> power
1833
<=
factor -> power
1833
not
factor -> power
1833
//
factor -> power
1833
/
factor -> power
1833
is
factor -> power
1833
|
factor -> power
1833
<
factor -> power
1833
and
factor -> power
1833
>=
factor -> power
1833
>>
factor -> power
1833
>
factor -> power
1833
in
factor -> power
1833
=
factor -> power
1833
if
factor -> power
1833
^
factor -> power
1833
==
factor -> power
1833
+
factor -> power
1833
@
factor -> power
1833
or
factor -> power
1833
*
factor -> power
1833
!=
factor -> power
1834
!=
power -> atom_expr
1834
**
2189
1834
>
power -> atom_expr
1834
+
power -> atom_expr
1834
not
power -> atom_expr
1834
&
power -> atom_expr
1834
|
power -> atom_expr
1834
>>
power -> atom_expr
1834
^
power -> atom_expr
1834
==
power -> atom_expr
1834
if
power -> atom_expr
1834
in
power -> atom_expr
1834
%
power -> atom_expr
1834
<<
power -> atom_expr
1834
or
power -> atom_expr
1834
NEWLINE
power -> atom_expr
1834
@
power -> atom_expr
1834
=
power -> atom_expr
1834
*
power -> atom_expr
1834
/
power -> atom_expr
1834
<
power -> atom_expr
1834
//
power -> atom_expr
1834
>=
power -> atom_expr
1834
-
power -> atom_expr
1834
is
power -> atom_expr
1834
<=
power -> atom_expr
1834
and
power -> atom_expr
1835
[
atom -> NUMBER
1835
=
atom -> NUMBER
1835
>=
atom -> NUMBER
1835
<=
atom -> NUMBER
1835
!=
atom -> NUMBER
1835
//
atom -> NUMBER
1835
in
atom -> NUMBER
1835
/
atom -> NUMBER
1835
or
atom -> NUMBER
1835
>
atom -> NUMBER
1835
not
atom -> NUMBER
1835
>>
atom -> NUMBER
1835
(
atom -> NUMBER
1835
**
atom -> NUMBER
1835
<<
atom -> NUMBER
1835
and
atom -> NUMBER
1835
+
atom -> NUMBER
1835
%
atom -> NUMBER
1835
==
atom -> NUMBER
1835
if
atom -> NUMBER
1835
is
atom -> NUMBER
1835
*
atom -> NUMBER
1835
@
atom -> NUMBER
1835
|
atom -> NUMBER
1835
NEWLINE
atom -> NUMBER
1835
-
atom -> NUMBER
1835
.
atom -> NUMBER
1835
^
atom -> NUMBER
1835
<
atom -> NUMBER
1835
&
atom -> NUMBER
1836
and
atom -> STRING
1836
%
atom -> STRING
1836
//
atom -> STRING
1836
>>
atom -> STRING
1836
*
atom -> STRING
1836
<
atom -> STRING
1836
.
atom -> STRING
1836
in
atom -> STRING
1836
NEWLINE
atom -> STRING
1836
^
atom -> STRING
1836
=
atom -> STRING
1836
(
atom -> STRING
1836
if
atom -> STRING
1836
==
atom -> STRING
1836
-
atom -> STRING
1836
**
atom -> STRING
1836
<<
atom -> STRING
1836
<=
atom -> STRING
1836
[
atom -> STRING
1836
not
atom -> STRING
1836
or
atom -> STRING
1836
+
atom -> STRING
1836
>=
atom -> STRING
1836
@
atom -> STRING
1836
&
atom -> STRING
1836
>
atom -> STRING
1836
is
atom -> STRING
1836
|
atom -> STRING
1836
!=
atom -> STRING
1836
/
atom -> STRING
1837
&
2190
1837
^
and_expr -> shift_expr
1837
|
and_expr -> shift_expr
1837
<=
and_expr -> shift_expr
1837
=
and_expr -> shift_expr
1837
NEWLINE
and_expr -> shift_expr
1837
or
and_expr -> shift_expr
1837
>
and_expr -> shift_expr
1837
not
and_expr -> shift_expr
1837
!=
and_expr -> shift_expr
1837
and
and_expr -> shift_expr
1837
is
and_expr -> shift_expr
1837
<
and_expr -> shift_expr
1837
if
and_expr -> shift_expr
1837
in
and_expr -> shift_expr
1837
>=
and_expr -> shift_expr
1837
==
and_expr -> shift_expr
1838
(
1826
1838
NAME
1828
1838
[
1829
1838
atom
1830
1838
+
1831
1838
atom_expr
1834
1838
power
1833
1838
NUMBER
1835
1838
STRING
1836
1838
-
1838
1838
True
1840
1838
None
1843
1838
False
1845
1838
{
1850
1838
~
1848
1838
factor
2191
1839
=
yield_arg -> from test
1839
NEWLINE
yield_arg -> from test
1840
(
atom -> True
1840
[
atom -> True
1840
+
atom -> True
1840
@
atom -> True
1840
<=
atom -> True
1840
&
atom -> True
1840
=
atom -> True
1840
<<
atom -> True
1840
-
atom -> True
1840
/
atom -> True
1840
or
atom -> True
1840
>
atom -> True
1840
%
atom -> True
1840
^
atom -> True
1840
if
atom -> True
1840
!=
atom -> True
1840
is
atom -> True
1840
*
atom -> True
1840
<
atom -> True
1840
and
atom -> True
1840
.
atom -> True
1840
==
atom -> True
1840
**
atom -> True
1840
>>
atom -> True
1840
in
atom -> True
1840
|
atom -> True
1840
>=
atom -> True
1840
//
atom -> True
1840
not
atom -> True
1840
NEWLINE
atom -> True
1841
^
2192
1841
=
xor_expr -> and_expr
1841
not
xor_expr -> and_expr
1841
if
xor_expr -> and_expr
1841
<=
xor_expr -> and_expr
1841
>
xor_expr -> and_expr
1841
NEWLINE
xor_expr -> and_expr
1841
<
xor_expr -> and_expr
1841
in
xor_expr -> and_expr
1841
>=
xor_expr -> and_expr
1841
==
xor_expr -> and_expr
1841
|
xor_expr -> and_expr
1841
is
xor_expr -> and_expr
1841
and
xor_expr -> and_expr
1841
or
xor_expr -> and_expr
1841
!=
xor_expr -> and_expr
1842
|
2193
1842
>=
expr -> xor_expr
1842
==
expr -> xor_expr
1842
NEWLINE
expr -> xor_expr
1842
is
expr -> xor_expr
1842
if
expr -> xor_expr
1842
or
expr -> xor_expr
1842
>
expr -> xor_expr
1842
and
expr -> xor_expr
1842
<
expr -> xor_expr
1842
in
expr -> xor_expr
1842
<=
expr -> xor_expr
1842
=
expr -> xor_expr
1842
not
expr -> xor_expr
1842
!=
expr -> xor_expr
1843
is
atom -> None
1843
.
atom -> None
1843
==
atom -> None
1843
^
atom -> None
1843
<<
atom -> None
1843
>>
atom -> None
1843
(
atom -> None
1843
|
atom -> None
1843
=
atom -> None
1843
+
atom -> None
1843
*
atom -> None
1843
//
atom -> None
1843
@
atom -> None
1843
in
atom -> None
1843
>=
atom -> None
1843
!=
atom -> None
1843
%
atom -> None
1843
[
atom -> None
1843
and
atom -> None
1843
-
atom -> None
1843
NEWLINE
atom -> None
1843
if
atom -> None
1843
&
atom -> None
1843
<=
atom -> None
1843
<
atom -> None
1843
>
atom -> None
1843
**
atom -> None
1843
or
atom -> None
1843
/
atom -> None
1843
not
atom -> None
1844
is
215
1844
<
217
1844
!=
218
1844
in
219
1844
<=
220
1844
not
221
1844
>=
222
1844
>
223
1844
==
224
1844
comp_op
2194
1844
and
comparison -> expr
1844
or
comparison -> expr
1844
=
comparison -> expr
1844
if
comparison -> expr
1844
NEWLINE
comparison -> expr
1845
in
atom -> False
1845
>
atom -> False
1845
-
atom -> False
1845
%
atom -> False
1845
<
atom -> False
1845
NEWLINE
atom -> False
1845
|
atom -> False
1845
==
atom -> False
1845
&
atom -> False
1845
//
atom -> False
1845
and
atom -> False
1845
not
atom -> False
1845
+
atom -> False
1845
!=
atom -> False
1845
if
atom -> False
1845
@
atom -> False
1845
[
atom -> False
1845
or
atom -> False
1845
<=
atom -> False
1845
=
atom -> False
1845
*
atom -> False
1845
^
atom -> False
1845
is
atom -> False
1845
/
atom -> False
1845
.
atom -> False
1845
>=
atom -> False
1845
**
atom -> False
1845
>>
atom -> False
1845
<<
atom -> False
1845
(
atom -> False
1846
or
2195
1846
=
or_test -> and_test
1846
NEWLINE
or_test -> and_test
1846
if
or_test -> and_test
1847
:
2196
1847
varargslist
2197
1847
NAME
305
1847
vfpdef
306
1848
(
1826
1848
NAME
1828
1848
[
1829
1848
atom
1830
1848
+
1831
1848
factor
2198
1848
atom_expr
1834
1848
power
1833
1848
NUMBER
1835
1848
STRING
1836
1848
-
1838
1848
True
1840
1848
None
1843
1848
False
1845
1848
{
1850
1848
~
1848
1849
and
2199
1849
=
and_test -> not_test
1849
NEWLINE
and_test -> not_test
1849
or
and_test -> not_test
1849
if
and_test -> not_test
1850
}
2200
1851
factor
1825
1851
(
1826
1851
arith_expr
1827
1851
NAME
1828
1851
[
1829
1851
atom
1830
1851
+
1831
1851
term
1832
1851
power
1833
1851
atom_expr
1834
1851
NUMBER
1835
1851
STRING
1836
1851
shift_expr
1837
1851
-
1838
1851
not_test
2201
1851
True
1840
1851
and_expr
1841
1851
xor_expr
1842
1851
None
1843
1851
expr
1844
1851
False
1845
1851
~
1848
1851
{
1850
1851
not
1851
1851
comparison
1854
1852
NEWLINE
test -> lambdef
1852
=
test -> lambdef
1853
=
test -> or_test
1853
NEWLINE
test -> or_test
1853
if
2202
1854
=
not_test -> comparison
1854
NEWLINE
not_test -> comparison
1854
or
not_test -> comparison
1854
and
not_test -> comparison
1854
if
not_test -> comparison
1855
NEWLINE
yield_arg -> from test
1856
and
term -> factor // term
1856
if
term -> factor // term
1856
>
term -> factor // term
1856
<
term -> factor // term
1856
==
term -> factor // term
1856
+
term -> factor // term
1856
-
term -> factor // term
1856
&
term -> factor // term
1856
in
term -> factor // term
1856
!=
term -> factor // term
1856
^
term -> factor // term
1856
=
term -> factor // term
1856
or
term -> factor // term
1856
<=
term -> factor // term
1856
>=
term -> factor // term
1856
|
term -> factor // term
1856
>>
term -> factor // term
1856
not
term -> factor // term
1856
is
term -> factor // term
1856
<<
term -> factor // term
1857
^
term -> factor * term
1857
+
term -> factor * term
1857
==
term -> factor * term
1857
>>
term -> factor * term
1857
in
term -> factor * term
1857
and
term -> factor * term
1857
if
term -> factor * term
1857
is
term -> factor * term
1857
<<
term -> factor * term
1857
-
term -> factor * term
1857
!=
term -> factor * term
1857
or
term -> factor * term
1857
>
term -> factor * term
1857
&
term -> factor * term
1857
|
term -> factor * term
1857
>=
term -> factor * term
1857
<=
term -> factor * term
1857
not
term -> factor * term
1857
=
term -> factor * term
1857
<
term -> factor * term
1858
&
term -> factor % term
1858
==
term -> factor % term
1858
!=
term -> factor % term
1858
<
term -> factor % term
1858
in
term -> factor % term
1858
=
term -> factor % term
1858
>>
term -> factor % term
1858
<<
term -> factor % term
1858
-
term -> factor % term
1858
if
term -> factor % term
1858
>
term -> factor % term
1858
or
term -> factor % term
1858
^
term -> factor % term
1858
+
term -> factor % term
1858
is
term -> factor % term
1858
|
term -> factor % term
1858
>=
term -> factor % term
1858
<=
term -> factor % term
1858
and
term -> factor % term
1858
not
term -> factor % term
1859
and
term -> factor @ term
1859
in
term -> factor @ term
1859
>=
term -> factor @ term
1859
<
term -> factor @ term
1859
>
term -> factor @ term
1859
-
term -> factor @ term
1859
or
term -> factor @ term
1859
<<
term -> factor @ term
1859
is
term -> factor @ term
1859
!=
term -> factor @ term
1859
|
term -> factor @ term
1859
&
term -> factor @ term
1859
==
term -> factor @ term
1859
>>
term -> factor @ term
1859
<=
term -> factor @ term
1859
not
term -> factor @ term
1859
+
term -> factor @ term
1859
^
term -> factor @ term
1859
=
term -> factor @ term
1859
if
term -> factor @ term
1860
or
term -> factor / term
1860
<<
term -> factor / term
1860
not
term -> factor / term
1860
in
term -> factor / term
1860
!=
term -> factor / term
1860
<
term -> factor / term
1860
+
term -> factor / term
1860
and
term -> factor / term
1860
>>
term -> factor / term
1860
^
term -> factor / term
1860
<=
term -> factor / term
1860
==
term -> factor / term
1860
>
term -> factor / term
1860
&
term -> factor / term
1860
is
term -> factor / term
1860
-
term -> factor / term
1860
|
term -> factor / term
1860
>=
term -> factor / term
1860
if
term -> factor / term
1860
=
term -> factor / term
1861
+
atom -> ( test_list_comp )
1861
/
atom -> ( test_list_comp )
1861
*
atom -> ( test_list_comp )
1861
[
atom -> ( test_list_comp )
1861
&
atom -> ( test_list_comp )
1861
**
atom -> ( test_list_comp )
1861
^
atom -> ( test_list_comp )
1861
(
atom -> ( test_list_comp )
1861
and
atom -> ( test_list_comp )
1861
>
atom -> ( test_list_comp )
1861
=
atom -> ( test_list_comp )
1861
-
atom -> ( test_list_comp )
1861
%
atom -> ( test_list_comp )
1861
//
atom -> ( test_list_comp )
1861
in
atom -> ( test_list_comp )
1861
>>
atom -> ( test_list_comp )
1861
not
atom -> ( test_list_comp )
1861
>=
atom -> ( test_list_comp )
1861
or
atom -> ( test_list_comp )
1861
<
atom -> ( test_list_comp )
1861
if
atom -> ( test_list_comp )
1861
|
atom -> ( test_list_comp )
1861
<<
atom -> ( test_list_comp )
1861
@
atom -> ( test_list_comp )
1861
!=
atom -> ( test_list_comp )
1861
is
atom -> ( test_list_comp )
1861
.
atom -> ( test_list_comp )
1861
<=
atom -> ( test_list_comp )
1861
==
atom -> ( test_list_comp )
1862
>=
shift_expr -> arith_expr >> shift_expr
1862
if
shift_expr -> arith_expr >> shift_expr
1862
<=
shift_expr -> arith_expr >> shift_expr
1862
!=
shift_expr -> arith_expr >> shift_expr
1862
or
shift_expr -> arith_expr >> shift_expr
1862
|
shift_expr -> arith_expr >> shift_expr
1862
is
shift_expr -> arith_expr >> shift_expr
1862
and
shift_expr -> arith_expr >> shift_expr
1862
in
shift_expr -> arith_expr >> shift_expr
1862
^
shift_expr -> arith_expr >> shift_expr
1862
not
shift_expr -> arith_expr >> shift_expr
1862
<
shift_expr -> arith_expr >> shift_expr
1862
==
shift_expr -> arith_expr >> shift_expr
1862
=
shift_expr -> arith_expr >> shift_expr
1862
&
shift_expr -> arith_expr >> shift_expr
1862
>
shift_expr -> arith_expr >> shift_expr
1863
>
shift_expr -> arith_expr << shift_expr
1863
or
shift_expr -> arith_expr << shift_expr
1863
^
shift_expr -> arith_expr << shift_expr
1863
not
shift_expr -> arith_expr << shift_expr
1863
<
shift_expr -> arith_expr << shift_expr
1863
if
shift_expr -> arith_expr << shift_expr
1863
in
shift_expr -> arith_expr << shift_expr
1863
!=
shift_expr -> arith_expr << shift_expr
1863
==
shift_expr -> arith_expr << shift_expr
1863
|
shift_expr -> arith_expr << shift_expr
1863
>=
shift_expr -> arith_expr << shift_expr
1863
and
shift_expr -> arith_expr << shift_expr
1863
&
shift_expr -> arith_expr << shift_expr
1863
<=
shift_expr -> arith_expr << shift_expr
1863
=
shift_expr -> arith_expr << shift_expr
1863
is
shift_expr -> arith_expr << shift_expr
1864
in
atom -> [ test_list_comp ]
1864
/
atom -> [ test_list_comp ]
1864
or
atom -> [ test_list_comp ]
1864
if
atom -> [ test_list_comp ]
1864
<<
atom -> [ test_list_comp ]
1864
!=
atom -> [ test_list_comp ]
1864
=
atom -> [ test_list_comp ]
1864
<=
atom -> [ test_list_comp ]
1864
>>
atom -> [ test_list_comp ]
1864
*
atom -> [ test_list_comp ]
1864
^
atom -> [ test_list_comp ]
1864
.
atom -> [ test_list_comp ]
1864
(
atom -> [ test_list_comp ]
1864
>=
atom -> [ test_list_comp ]
1864
and
atom -> [ test_list_comp ]
1864
<
atom -> [ test_list_comp ]
1864
[
atom -> [ test_list_comp ]
1864
==
atom -> [ test_list_comp ]
1864
@
atom -> [ test_list_comp ]
1864
%
atom -> [ test_list_comp ]
1864
-
atom -> [ test_list_comp ]
1864
|
atom -> [ test_list_comp ]
1864
&
atom -> [ test_list_comp ]
1864
+
atom -> [ test_list_comp ]
1864
is
atom -> [ test_list_comp ]
1864
//
atom -> [ test_list_comp ]
1864
**
atom -> [ test_list_comp ]
1864
not
atom -> [ test_list_comp ]
1864
>
atom -> [ test_list_comp ]
1865
+
trailer_expr -> trailer trailer_expr
1865
*
trailer_expr -> trailer trailer_expr
1865
/
trailer_expr -> trailer trailer_expr
1865
not
trailer_expr -> trailer trailer_expr
1865
<<
trailer_expr -> trailer trailer_expr
1865
!=
trailer_expr -> trailer trailer_expr
1865
=
trailer_expr -> trailer trailer_expr
1865
>=
trailer_expr -> trailer trailer_expr
1865
>>
trailer_expr -> trailer trailer_expr
1865
|
trailer_expr -> trailer trailer_expr
1865
%
trailer_expr -> trailer trailer_expr
1865
>
trailer_expr -> trailer trailer_expr
1865
&
trailer_expr -> trailer trailer_expr
1865
-
trailer_expr -> trailer trailer_expr
1865
<=
trailer_expr -> trailer trailer_expr
1865
**
trailer_expr -> trailer trailer_expr
1865
@
trailer_expr -> trailer trailer_expr
1865
if
trailer_expr -> trailer trailer_expr
1865
==
trailer_expr -> trailer trailer_expr
1865
or
trailer_expr -> trailer trailer_expr
1865
<
trailer_expr -> trailer trailer_expr
1865
and
trailer_expr -> trailer trailer_expr
1865
in
trailer_expr -> trailer trailer_expr
1865
is
trailer_expr -> trailer trailer_expr
1865
^
trailer_expr -> trailer trailer_expr
1865
//
trailer_expr -> trailer trailer_expr
1866
<=
trailer -> . NAME
1866
<<
trailer -> . NAME
1866
**
trailer -> . NAME
1866
!=
trailer -> . NAME
1866
/
trailer -> . NAME
1866
&
trailer -> . NAME
1866
//
trailer -> . NAME
1866
<
trailer -> . NAME
1866
is
trailer -> . NAME
1866
-
trailer -> . NAME
1866
if
trailer -> . NAME
1866
[
trailer -> . NAME
1866
or
trailer -> . NAME
1866
>
trailer -> . NAME
1866
*
trailer -> . NAME
1866
+
trailer -> . NAME
1866
%
trailer -> . NAME
1866
.
trailer -> . NAME
1866
>=
trailer -> . NAME
1866
|
trailer -> . NAME
1866
and
trailer -> . NAME
1866
(
trailer -> . NAME
1866
==
trailer -> . NAME
1866
^
trailer -> . NAME
1866
in
trailer -> . NAME
1866
@
trailer -> . NAME
1866
not
trailer -> . NAME
1866
=
trailer -> . NAME
1866
>>
trailer -> . NAME
1867
%
trailer -> ( )
1867
<=
trailer -> ( )
1867
and
trailer -> ( )
1867
//
trailer -> ( )
1867
not
trailer -> ( )
1867
or
trailer -> ( )
1867
>>
trailer -> ( )
1867
>
trailer -> ( )
1867
<<
trailer -> ( )
1867
[
trailer -> ( )
1867
is
trailer -> ( )
1867
-
trailer -> ( )
1867
**
trailer -> ( )
1867
/
trailer -> ( )
1867
+
trailer -> ( )
1867
&
trailer -> ( )
1867
in
trailer -> ( )
1867
^
trailer -> ( )
1867
!=
trailer -> ( )
1867
*
trailer -> ( )
1867
if
trailer -> ( )
1867
>=
trailer -> ( )
1867
(
trailer -> ( )
1867
@
trailer -> ( )
1867
=
trailer -> ( )
1867
==
trailer -> ( )
1867
|
trailer -> ( )
1867
.
trailer -> ( )
1867
<
trailer -> ( )
1868
)
2203
1869
]
2204
1870
==
arith_expr -> term + arith_expr
1870
if
arith_expr -> term + arith_expr
1870
>=
arith_expr -> term + arith_expr
1870
>
arith_expr -> term + arith_expr
1870
!=
arith_expr -> term + arith_expr
1870
is
arith_expr -> term + arith_expr
1870
<<
arith_expr -> term + arith_expr
1870
|
arith_expr -> term + arith_expr
1870
and
arith_expr -> term + arith_expr
1870
^
arith_expr -> term + arith_expr
1870
>>
arith_expr -> term + arith_expr
1870
<
arith_expr -> term + arith_expr
1870
or
arith_expr -> term + arith_expr
1870
in
arith_expr -> term + arith_expr
1870
=
arith_expr -> term + arith_expr
1870
&
arith_expr -> term + arith_expr
1870
not
arith_expr -> term + arith_expr
1870
<=
arith_expr -> term + arith_expr
1871
if
arith_expr -> term - arith_expr
1871
>
arith_expr -> term - arith_expr
1871
>>
arith_expr -> term - arith_expr
1871
&
arith_expr -> term - arith_expr
1871
and
arith_expr -> term - arith_expr
1871
=
arith_expr -> term - arith_expr
1871
is
arith_expr -> term - arith_expr
1871
in
arith_expr -> term - arith_expr
1871
>=
arith_expr -> term - arith_expr
1871
!=
arith_expr -> term - arith_expr
1871
^
arith_expr -> term - arith_expr
1871
<
arith_expr -> term - arith_expr
1871
<<
arith_expr -> term - arith_expr
1871
not
arith_expr -> term - arith_expr
1871
==
arith_expr -> term - arith_expr
1871
|
arith_expr -> term - arith_expr
1871
or
arith_expr -> term - arith_expr
1871
<=
arith_expr -> term - arith_expr
1872
+
power -> atom_expr ** factor
1872
&
power -> atom_expr ** factor
1872
>>
power -> atom_expr ** factor
1872
<<
power -> atom_expr ** factor
1872
not
power -> atom_expr ** factor
1872
is
power -> atom_expr ** factor
1872
@
power -> atom_expr ** factor
1872
==
power -> atom_expr ** factor
1872
*
power -> atom_expr ** factor
1872
or
power -> atom_expr ** factor
1872
>
power -> atom_expr ** factor
1872
-
power -> atom_expr ** factor
1872
if
power -> atom_expr ** factor
1872
!=
power -> atom_expr ** factor
1872
>=
power -> atom_expr ** factor
1872
/
power -> atom_expr ** factor
1872
%
power -> atom_expr ** factor
1872
and
power -> atom_expr ** factor
1872
=
power -> atom_expr ** factor
1872
<=
power -> atom_expr ** factor
1872
<
power -> atom_expr ** factor
1872
|
power -> atom_expr ** factor
1872
^
power -> atom_expr ** factor
1872
in
power -> atom_expr ** factor
1872
//
power -> atom_expr ** factor
1873
==
and_expr -> shift_expr & and_expr
1873
in
and_expr -> shift_expr & and_expr
1873
=
and_expr -> shift_expr & and_expr
1873
!=
and_expr -> shift_expr & and_expr
1873
or
and_expr -> shift_expr & and_expr
1873
>
and_expr -> shift_expr & and_expr
1873
not
and_expr -> shift_expr & and_expr
1873
<=
and_expr -> shift_expr & and_expr
1873
|
and_expr -> shift_expr & and_expr
1873
and
and_expr -> shift_expr & and_expr
1873
^
and_expr -> shift_expr & and_expr
1873
is
and_expr -> shift_expr & and_expr
1873
>=
and_expr -> shift_expr & and_expr
1873
<
and_expr -> shift_expr & and_expr
1873
if
and_expr -> shift_expr & and_expr
1874
<=
xor_expr -> and_expr ^ xor_expr
1874
!=
xor_expr -> and_expr ^ xor_expr
1874
and
xor_expr -> and_expr ^ xor_expr
1874
=
xor_expr -> and_expr ^ xor_expr
1874
is
xor_expr -> and_expr ^ xor_expr
1874
>=
xor_expr -> and_expr ^ xor_expr
1874
not
xor_expr -> and_expr ^ xor_expr
1874
<
xor_expr -> and_expr ^ xor_expr
1874
|
xor_expr -> and_expr ^ xor_expr
1874
in
xor_expr -> and_expr ^ xor_expr
1874
==
xor_expr -> and_expr ^ xor_expr
1874
or
xor_expr -> and_expr ^ xor_expr
1874
if
xor_expr -> and_expr ^ xor_expr
1874
>
xor_expr -> and_expr ^ xor_expr
1875
not
expr -> xor_expr | expr
1875
in
expr -> xor_expr | expr
1875
if
expr -> xor_expr | expr
1875
or
expr -> xor_expr | expr
1875
<=
expr -> xor_expr | expr
1875
>
expr -> xor_expr | expr
1875
!=
expr -> xor_expr | expr
1875
==
expr -> xor_expr | expr
1875
=
expr -> xor_expr | expr
1875
>=
expr -> xor_expr | expr
1875
is
expr -> xor_expr | expr
1875
<
expr -> xor_expr | expr
1875
and
expr -> xor_expr | expr
1876
if
or_test -> and_test or or_test
1876
=
or_test -> and_test or or_test
1877
=
and_test -> not_test and and_test
1877
if
and_test -> not_test and and_test
1877
or
and_test -> not_test and and_test
1878
or
comparison -> expr comp_op comparison
1878
and
comparison -> expr comp_op comparison
1878
if
comparison -> expr comp_op comparison
1878
=
comparison -> expr comp_op comparison
1879
=
lambdef -> lambda : test
1880
factor
803
1880
(
804
1880
arith_expr
805
1880
NAME
806
1880
[
807
1880
atom
808
1880
+
809
1880
term
810
1880
power
811
1880
atom_expr
812
1880
NUMBER
813
1880
STRING
814
1880
shift_expr
815
1880
-
816
1880
True
817
1880
and_expr
818
1880
xor_expr
819
1880
None
820
1880
False
821
1880
and_test
822
1880
{
823
1880
~
824
1880
not_test
825
1880
expr
826
1880
lambdef
827
1880
lambda
828
1880
or_test
829
1880
not
830
1880
comparison
831
1880
test
2205
1881
else
2206
1882
NEWLINE
annassign -> : test = test
1883
NEWLINE
lambdef -> lambda varargslist : test
1883
from
lambdef -> lambda varargslist : test
1884
**
trailer -> ( arglist )
1884
if
trailer -> ( arglist )
1884
<
trailer -> ( arglist )
1884
//
trailer -> ( arglist )
1884
<<
trailer -> ( arglist )
1884
%
trailer -> ( arglist )
1884
&
trailer -> ( arglist )
1884
NEWLINE
trailer -> ( arglist )
1884
==
trailer -> ( arglist )
1884
from
trailer -> ( arglist )
1884
is
trailer -> ( arglist )
1884
!=
trailer -> ( arglist )
1884
and
trailer -> ( arglist )
1884
-
trailer -> ( arglist )
1884
+
trailer -> ( arglist )
1884
>=
trailer -> ( arglist )
1884
or
trailer -> ( arglist )
1884
(
trailer -> ( arglist )
1884
^
trailer -> ( arglist )
1884
.
trailer -> ( arglist )
1884
not
trailer -> ( arglist )
1884
>>
trailer -> ( arglist )
1884
/
trailer -> ( arglist )
1884
*
trailer -> ( arglist )
1884
[
trailer -> ( arglist )
1884
@
trailer -> ( arglist )
1884
>
trailer -> ( arglist )
1884
|
trailer -> ( arglist )
1884
<=
trailer -> ( arglist )
1884
in
trailer -> ( arglist )
1885
|
trailer -> [ subscriptlist ]
1885
not
trailer -> [ subscriptlist ]
1885
in
trailer -> [ subscriptlist ]
1885
==
trailer -> [ subscriptlist ]
1885
**
trailer -> [ subscriptlist ]
1885
>>
trailer -> [ subscriptlist ]
1885
!=
trailer -> [ subscriptlist ]
1885
*
trailer -> [ subscriptlist ]
1885
or
trailer -> [ subscriptlist ]
1885
>=
trailer -> [ subscriptlist ]
1885
from
trailer -> [ subscriptlist ]
1885
/
trailer -> [ subscriptlist ]
1885
[
trailer -> [ subscriptlist ]
1885
>
trailer -> [ subscriptlist ]
1885
<
trailer -> [ subscriptlist ]
1885
.
trailer -> [ subscriptlist ]
1885
and
trailer -> [ subscriptlist ]
1885
(
trailer -> [ subscriptlist ]
1885
<=
trailer -> [ subscriptlist ]
1885
-
trailer -> [ subscriptlist ]
1885
@
trailer -> [ subscriptlist ]
1885
<<
trailer -> [ subscriptlist ]
1885
&
trailer -> [ subscriptlist ]
1885
^
trailer -> [ subscriptlist ]
1885
is
trailer -> [ subscriptlist ]
1885
%
trailer -> [ subscriptlist ]
1885
+
trailer -> [ subscriptlist ]
1885
//
trailer -> [ subscriptlist ]
1885
NEWLINE
trailer -> [ subscriptlist ]
1885
if
trailer -> [ subscriptlist ]
1886
factor
340
1886
atom_expr
341
1886
(
342
1886
arith_expr
343
1886
lambda
344
1886
NAME
345
1886
[
346
1886
+
347
1886
term
348
1886
atom
349
1886
NUMBER
350
1886
shift_expr
351
1886
STRING
352
1886
-
353
1886
or_test
354
1886
True
355
1886
and_expr
356
1886
not
357
1886
xor_expr
358
1886
None
359
1886
expr
360
1886
False
361
1886
test
2207
1886
and_test
362
1886
{
363
1886
~
364
1886
power
365
1886
not_test
366
1886
comparison
367
1886
lambdef
368
1887
[
trailer -> ( arglist )
1887
**
trailer -> ( arglist )
1887
@
trailer -> ( arglist )
1887
-
trailer -> ( arglist )
1887
,
trailer -> ( arglist )
1887
&
trailer -> ( arglist )
1887
+
trailer -> ( arglist )
1887
NEWLINE
trailer -> ( arglist )
1887
^
trailer -> ( arglist )
1887
//
trailer -> ( arglist )
1887
.
trailer -> ( arglist )
1887
|
trailer -> ( arglist )
1887
>>
trailer -> ( arglist )
1887
(
trailer -> ( arglist )
1887
<<
trailer -> ( arglist )
1887
%
trailer -> ( arglist )
1887
/
trailer -> ( arglist )
1887
*
trailer -> ( arglist )
1888
,
trailer -> [ subscriptlist ]
1888
|
trailer -> [ subscriptlist ]
1888
.
trailer -> [ subscriptlist ]
1888
NEWLINE
trailer -> [ subscriptlist ]
1888
(
trailer -> [ subscriptlist ]
1888
<<
trailer -> [ subscriptlist ]
1888
^
trailer -> [ subscriptlist ]
1888
>>
trailer -> [ subscriptlist ]
1888
[
trailer -> [ subscriptlist ]
1888
-
trailer -> [ subscriptlist ]
1888
%
trailer -> [ subscriptlist ]
1888
+
trailer -> [ subscriptlist ]
1888
/
trailer -> [ subscriptlist ]
1888
@
trailer -> [ subscriptlist ]
1888
//
trailer -> [ subscriptlist ]
1888
**
trailer -> [ subscriptlist ]
1888
*
trailer -> [ subscriptlist ]
1888
&
trailer -> [ subscriptlist ]
1889
**
trailer -> ( arglist )
1889
if
trailer -> ( arglist )
1889
<
trailer -> ( arglist )
1889
//
trailer -> ( arglist )
1889
<<
trailer -> ( arglist )
1889
%
trailer -> ( arglist )
1889
&
trailer -> ( arglist )
1889
NEWLINE
trailer -> ( arglist )
1889
==
trailer -> ( arglist )
1889
is
trailer -> ( arglist )
1889
!=
trailer -> ( arglist )
1889
and
trailer -> ( arglist )
1889
-
trailer -> ( arglist )
1889
+
trailer -> ( arglist )
1889
>=
trailer -> ( arglist )
1889
or
trailer -> ( arglist )
1889
(
trailer -> ( arglist )
1889
^
trailer -> ( arglist )
1889
.
trailer -> ( arglist )
1889
not
trailer -> ( arglist )
1889
>>
trailer -> ( arglist )
1889
/
trailer -> ( arglist )
1889
*
trailer -> ( arglist )
1889
[
trailer -> ( arglist )
1889
@
trailer -> ( arglist )
1889
>
trailer -> ( arglist )
1889
|
trailer -> ( arglist )
1889
<=
trailer -> ( arglist )
1889
in
trailer -> ( arglist )
1890
|
trailer -> [ subscriptlist ]
1890
not
trailer -> [ subscriptlist ]
1890
in
trailer -> [ subscriptlist ]
1890
==
trailer -> [ subscriptlist ]
1890
**
trailer -> [ subscriptlist ]
1890
>>
trailer -> [ subscriptlist ]
1890
!=
trailer -> [ subscriptlist ]
1890
*
trailer -> [ subscriptlist ]
1890
or
trailer -> [ subscriptlist ]
1890
>=
trailer -> [ subscriptlist ]
1890
/
trailer -> [ subscriptlist ]
1890
[
trailer -> [ subscriptlist ]
1890
>
trailer -> [ subscriptlist ]
1890
<
trailer -> [ subscriptlist ]
1890
.
trailer -> [ subscriptlist ]
1890
and
trailer -> [ subscriptlist ]
1890
(
trailer -> [ subscriptlist ]
1890
<=
trailer -> [ subscriptlist ]
1890
-
trailer -> [ subscriptlist ]
1890
@
trailer -> [ subscriptlist ]
1890
<<
trailer -> [ subscriptlist ]
1890
&
trailer -> [ subscriptlist ]
1890
^
trailer -> [ subscriptlist ]
1890
is
trailer -> [ subscriptlist ]
1890
%
trailer -> [ subscriptlist ]
1890
+
trailer -> [ subscriptlist ]
1890
//
trailer -> [ subscriptlist ]
1890
NEWLINE
trailer -> [ subscriptlist ]
1890
if
trailer -> [ subscriptlist ]
1891
NEWLINE
lambdef -> lambda varargslist : test
1892
factor
396
1892
(
397
1892
arith_expr
398
1892
NAME
399
1892
[
400
1892
+
401
1892
term
402
1892
atom_expr
403
1892
atom
404
1892
NUMBER
405
1892
STRING
406
1892
shift_expr
407
1892
-
408
1892
True
409
1892
and_expr
410
1892
xor_expr
411
1892
None
412
1892
expr
413
1892
False
414
1892
and_test
415
1892
lambda
416
1892
{
417
1892
~
418
1892
power
419
1892
not_test
420
1892
not
421
1892
comparison
422
1892
or_test
423
1892
lambdef
424
1892
test
2208
1893
:
2209
1894
:
2210
1895
DEDENT
2211
1896
:
test -> or_test if or_test else test
1897
for
test -> or_test if or_test else test
1897
,
test -> or_test if or_test else test
1897
]
test -> or_test if or_test else test
1898
//
2212
1898
in
term -> factor
1898
-
term -> factor
1898
*
2213
1898
%
2214
1898
@
2215
1898
]
term -> factor
1898
>=
term -> factor
1898
/
2216
1898
<
term -> factor
1898
<=
term -> factor
1898
==
term -> factor
1898
!=
term -> factor
1898
>>
term -> factor
1898
is
term -> factor
1898
or
term -> factor
1898
and
term -> factor
1898
for
term -> factor
1898
^
term -> factor
1898
+
term -> factor
1898
&
term -> factor
1898
<<
term -> factor
1898
|
term -> factor
1898
>
term -> factor
1898
if
term -> factor
1898
not
term -> factor
1899
factor
268
1899
term
270
1899
(
271
1899
arith_expr
272
1899
NAME
273
1899
[
274
1899
+
275
1899
test_list_comp
2217
1899
atom_expr
277
1899
NUMBER
278
1899
atom
279
1899
STRING
280
1899
shift_expr
281
1899
-
282
1899
)
2218
1899
True
283
1899
not_test
284
1899
lambdef
285
1899
and_expr
286
1899
xor_expr
287
1899
False
288
1899
None
289
1899
expr
290
1899
and_test
291
1899
{
292
1899
~
293
1899
power
294
1899
lambda
295
1899
comparison
296
1899
or_test
297
1899
not
298
1899
test
299
1899
test_list
300
1900
>>
2219
1900
<<
2220
1900
&
shift_expr -> arith_expr
1900
<=
shift_expr -> arith_expr
1900
>
shift_expr -> arith_expr
1900
not
shift_expr -> arith_expr
1900
!=
shift_expr -> arith_expr
1900
^
shift_expr -> arith_expr
1900
is
shift_expr -> arith_expr
1900
|
shift_expr -> arith_expr
1900
>=
shift_expr -> arith_expr
1900
or
shift_expr -> arith_expr
1900
]
shift_expr -> arith_expr
1900
==
shift_expr -> arith_expr
1900
if
shift_expr -> arith_expr
1900
and
shift_expr -> arith_expr
1900
<
shift_expr -> arith_expr
1900
for
shift_expr -> arith_expr
1900
in
shift_expr -> arith_expr
1901
]
atom -> NAME
1901
-
atom -> NAME
1901
for
atom -> NAME
1901
or
atom -> NAME
1901
>>
atom -> NAME
1901
&
atom -> NAME
1901
[
atom -> NAME
1901
<=
atom -> NAME
1901
<
atom -> NAME
1901
.
atom -> NAME
1901
|
atom -> NAME
1901
*
atom -> NAME
1901
/
atom -> NAME
1901
<<
atom -> NAME
1901
not
atom -> NAME
1901
>
atom -> NAME
1901
is
atom -> NAME
1901
//
atom -> NAME
1901
+
atom -> NAME
1901
if
atom -> NAME
1901
in
atom -> NAME
1901
**
atom -> NAME
1901
!=
atom -> NAME
1901
>=
atom -> NAME
1901
^
atom -> NAME
1901
@
atom -> NAME
1901
(
atom -> NAME
1901
==
atom -> NAME
1901
and
atom -> NAME
1901
%
atom -> NAME
1902
factor
117
1902
or_test
118
1902
term
119
1902
(
120
1902
arith_expr
121
1902
NAME
122
1902
[
123
1902
]
2221
1902
+
125
1902
atom_expr
126
1902
NUMBER
127
1902
atom
128
1902
STRING
129
1902
shift_expr
130
1902
-
131
1902
test_list_comp
2222
1902
True
133
1902
not_test
134
1902
lambdef
135
1902
and_expr
136
1902
xor_expr
137
1902
False
138
1902
None
139
1902
expr
140
1902
and_test
141
1902
{
142
1902
~
143
1902
lambda
144
1902
power
145
1902
comparison
146
1902
test_list
147
1902
test
148
1902
not
149
1903
(
1899
1903
NAME
1901
1903
[
1902
1903
+
1903
1903
atom_expr
1905
1903
NUMBER
1906
1903
atom
1907
1903
STRING
1908
1903
-
1910
1903
factor
2223
1903
True
1911
1903
False
1914
1903
None
1916
1903
{
1919
1903
~
1920
1903
power
1921
1904
+
2224
1904
-
2225
1904
for
arith_expr -> term
1904
|
arith_expr -> term
1904
or
arith_expr -> term
1904
not
arith_expr -> term
1904
<=
arith_expr -> term
1904
!=
arith_expr -> term
1904
<
arith_expr -> term
1904
&
arith_expr -> term
1904
>=
arith_expr -> term
1904
if
arith_expr -> term
1904
==
arith_expr -> term
1904
^
arith_expr -> term
1904
in
arith_expr -> term
1904
is
arith_expr -> term
1904
<<
arith_expr -> term
1904
>
arith_expr -> term
1904
and
arith_expr -> term
1904
>>
arith_expr -> term
1904
]
arith_expr -> term
1905
!=
power -> atom_expr
1905
**
2226
1905
>
power -> atom_expr
1905
]
power -> atom_expr
1905
+
power -> atom_expr
1905
not
power -> atom_expr
1905
&
power -> atom_expr
1905
|
power -> atom_expr
1905
>>
power -> atom_expr
1905
^
power -> atom_expr
1905
==
power -> atom_expr
1905
if
power -> atom_expr
1905
in
power -> atom_expr
1905
%
power -> atom_expr
1905
for
power -> atom_expr
1905
<<
power -> atom_expr
1905
or
power -> atom_expr
1905
@
power -> atom_expr
1905
*
power -> atom_expr
1905
/
power -> atom_expr
1905
<
power -> atom_expr
1905
//
power -> atom_expr
1905
>=
power -> atom_expr
1905
-
power -> atom_expr
1905
is
power -> atom_expr
1905
<=
power -> atom_expr
1905
and
power -> atom_expr
1906
[
atom -> NUMBER
1906
>=
atom -> NUMBER
1906
<=
atom -> NUMBER
1906
!=
atom -> NUMBER
1906
//
atom -> NUMBER
1906
in
atom -> NUMBER
1906
/
atom -> NUMBER
1906
or
atom -> NUMBER
1906
>
atom -> NUMBER
1906
not
atom -> NUMBER
1906
>>
atom -> NUMBER
1906
(
atom -> NUMBER
1906
**
atom -> NUMBER
1906
<<
atom -> NUMBER
1906
and
atom -> NUMBER
1906
+
atom -> NUMBER
1906
%
atom -> NUMBER
1906
==
atom -> NUMBER
1906
for
atom -> NUMBER
1906
]
atom -> NUMBER
1906
if
atom -> NUMBER
1906
is
atom -> NUMBER
1906
*
atom -> NUMBER
1906
@
atom -> NUMBER
1906
|
atom -> NUMBER
1906
-
atom -> NUMBER
1906
.
atom -> NUMBER
1906
^
atom -> NUMBER
1906
<
atom -> NUMBER
1906
&
atom -> NUMBER
1907
trailer
2227
1907
.
2228
1907
(
2229
1907
[
2230
1907
trailer_expr
2231
1907
<<
trailer_expr -> 
1907
%
trailer_expr -> 
1907
==
trailer_expr -> 
1907
-
trailer_expr -> 
1907
<
trailer_expr -> 
1907
if
trailer_expr -> 
1907
or
trailer_expr -> 
1907
/
trailer_expr -> 
1907
**
trailer_expr -> 
1907
and
trailer_expr -> 
1907
@
trailer_expr -> 
1907
*
trailer_expr -> 
1907
|
trailer_expr -> 
1907
is
trailer_expr -> 
1907
+
trailer_expr -> 
1907
in
trailer_expr -> 
1907
for
trailer_expr -> 
1907
&
trailer_expr -> 
1907
<=
trailer_expr -> 
1907
>=
trailer_expr -> 
1907
^
trailer_expr -> 
1907
>
trailer_expr -> 
1907
!=
trailer_expr -> 
1907
not
trailer_expr -> 
1907
>>
trailer_expr -> 
1907
//
trailer_expr -> 
1907
]
trailer_expr -> 
1908
and
atom -> STRING
1908
for
atom -> STRING
1908
%
atom -> STRING
1908
//
atom -> STRING
1908
>>
atom -> STRING
1908
*
atom -> STRING
1908
<
atom -> STRING
1908
.
atom -> STRING
1908
in
atom -> STRING
1908
]
atom -> STRING
1908
^
atom -> STRING
1908
(
atom -> STRING
1908
if
atom -> STRING
1908
==
atom -> STRING
1908
-
atom -> STRING
1908
**
atom -> STRING
1908
<<
atom -> STRING
1908
<=
atom -> STRING
1908
[
atom -> STRING
1908
not
atom -> STRING
1908
or
atom -> STRING
1908
+
atom -> STRING
1908
>=
atom -> STRING
1908
@
atom -> STRING
1908
&
atom -> STRING
1908
>
atom -> STRING
1908
is
atom -> STRING
1908
|
atom -> STRING
1908
!=
atom -> STRING
1908
/
atom -> STRING
1909
&
2232
1909
^
and_expr -> shift_expr
1909
|
and_expr -> shift_expr
1909
<=
and_expr -> shift_expr
1909
for
and_expr -> shift_expr
1909
or
and_expr -> shift_expr
1909
>
and_expr -> shift_expr
1909
]
and_expr -> shift_expr
1909
not
and_expr -> shift_expr
1909
!=
and_expr -> shift_expr
1909
and
and_expr -> shift_expr
1909
is
and_expr -> shift_expr
1909
<
and_expr -> shift_expr
1909
if
and_expr -> shift_expr
1909
in
and_expr -> shift_expr
1909
>=
and_expr -> shift_expr
1909
==
and_expr -> shift_expr
1910
(
1899
1910
NAME
1901
1910
[
1902
1910
+
1903
1910
atom_expr
1905
1910
NUMBER
1906
1910
atom
1907
1910
STRING
1908
1910
-
1910
1910
True
1911
1910
False
1914
1910
None
1916
1910
{
1919
1910
~
1920
1910
power
1921
1910
factor
2233
1911
(
atom -> True
1911
for
atom -> True
1911
[
atom -> True
1911
+
atom -> True
1911
@
atom -> True
1911
<=
atom -> True
1911
&
atom -> True
1911
<<
atom -> True
1911
-
atom -> True
1911
/
atom -> True
1911
or
atom -> True
1911
>
atom -> True
1911
%
atom -> True
1911
^
atom -> True
1911
if
atom -> True
1911
!=
atom -> True
1911
is
atom -> True
1911
*
atom -> True
1911
<
atom -> True
1911
and
atom -> True
1911
.
atom -> True
1911
==
atom -> True
1911
]
atom -> True
1911
**
atom -> True
1911
>>
atom -> True
1911
in
atom -> True
1911
|
atom -> True
1911
>=
atom -> True
1911
//
atom -> True
1911
not
atom -> True
1912
^
2234
1912
not
xor_expr -> and_expr
1912
if
xor_expr -> and_expr
1912
<=
xor_expr -> and_expr
1912
>
xor_expr -> and_expr
1912
]
xor_expr -> and_expr
1912
<
xor_expr -> and_expr
1912
in
xor_expr -> and_expr
1912
>=
xor_expr -> and_expr
1912
for
xor_expr -> and_expr
1912
==
xor_expr -> and_expr
1912
|
xor_expr -> and_expr
1912
is
xor_expr -> and_expr
1912
and
xor_expr -> and_expr
1912
or
xor_expr -> and_expr
1912
!=
xor_expr -> and_expr
1913
|
2235
1913
>=
expr -> xor_expr
1913
==
expr -> xor_expr
1913
is
expr -> xor_expr
1913
if
expr -> xor_expr
1913
or
expr -> xor_expr
1913
for
expr -> xor_expr
1913
>
expr -> xor_expr
1913
and
expr -> xor_expr
1913
<
expr -> xor_expr
1913
]
expr -> xor_expr
1913
in
expr -> xor_expr
1913
<=
expr -> xor_expr
1913
not
expr -> xor_expr
1913
!=
expr -> xor_expr
1914
in
atom -> False
1914
>
atom -> False
1914
-
atom -> False
1914
%
atom -> False
1914
<
atom -> False
1914
|
atom -> False
1914
==
atom -> False
1914
&
atom -> False
1914
//
atom -> False
1914
and
atom -> False
1914
not
atom -> False
1914
+
atom -> False
1914
!=
atom -> False
1914
if
atom -> False
1914
for
atom -> False
1914
@
atom -> False
1914
]
atom -> False
1914
[
atom -> False
1914
or
atom -> False
1914
<=
atom -> False
1914
*
atom -> False
1914
^
atom -> False
1914
is
atom -> False
1914
/
atom -> False
1914
.
atom -> False
1914
>=
atom -> False
1914
**
atom -> False
1914
>>
atom -> False
1914
<<
atom -> False
1914
(
atom -> False
1915
and
2236
1915
]
and_test -> not_test
1915
or
and_test -> not_test
1915
if
and_test -> not_test
1915
for
and_test -> not_test
1916
is
atom -> None
1916
.
atom -> None
1916
==
atom -> None
1916
^
atom -> None
1916
<<
atom -> None
1916
>>
atom -> None
1916
(
atom -> None
1916
|
atom -> None
1916
+
atom -> None
1916
for
atom -> None
1916
*
atom -> None
1916
//
atom -> None
1916
@
atom -> None
1916
in
atom -> None
1916
>=
atom -> None
1916
!=
atom -> None
1916
%
atom -> None
1916
]
atom -> None
1916
[
atom -> None
1916
and
atom -> None
1916
-
atom -> None
1916
if
atom -> None
1916
&
atom -> None
1916
<=
atom -> None
1916
<
atom -> None
1916
>
atom -> None
1916
**
atom -> None
1916
or
atom -> None
1916
/
atom -> None
1916
not
atom -> None
1917
is
215
1917
<
217
1917
!=
218
1917
in
219
1917
<=
220
1917
comp_op
2237
1917
not
221
1917
>=
222
1917
>
223
1917
==
224
1917
]
comparison -> expr
1917
and
comparison -> expr
1917
or
comparison -> expr
1917
if
comparison -> expr
1917
for
comparison -> expr
1918
or
2238
1918
for
or_test -> and_test
1918
if
or_test -> and_test
1918
]
or_test -> and_test
1919
}
2239
1920
(
1899
1920
NAME
1901
1920
[
1902
1920
+
1903
1920
factor
2240
1920
atom_expr
1905
1920
NUMBER
1906
1920
atom
1907
1920
STRING
1908
1920
-
1910
1920
True
1911
1920
False
1914
1920
None
1916
1920
{
1919
1920
~
1920
1920
power
1921
1921
&
factor -> power
1921
%
factor -> power
1921
<<
factor -> power
1921
-
factor -> power
1921
<=
factor -> power
1921
not
factor -> power
1921
//
factor -> power
1921
/
factor -> power
1921
is
factor -> power
1921
for
factor -> power
1921
|
factor -> power
1921
<
factor -> power
1921
and
factor -> power
1921
>=
factor -> power
1921
>>
factor -> power
1921
>
factor -> power
1921
in
factor -> power
1921
if
factor -> power
1921
^
factor -> power
1921
==
factor -> power
1921
+
factor -> power
1921
@
factor -> power
1921
or
factor -> power
1921
*
factor -> power
1921
]
factor -> power
1921
!=
factor -> power
1922
or
not_test -> comparison
1922
and
not_test -> comparison
1922
for
not_test -> comparison
1922
if
not_test -> comparison
1922
]
not_test -> comparison
1923
factor
1898
1923
(
1899
1923
arith_expr
1900
1923
NAME
1901
1923
[
1902
1923
+
1903
1923
term
1904
1923
atom_expr
1905
1923
NUMBER
1906
1923
atom
1907
1923
STRING
1908
1923
shift_expr
1909
1923
-
1910
1923
not_test
2241
1923
True
1911
1923
and_expr
1912
1923
xor_expr
1913
1923
False
1914
1923
None
1916
1923
expr
1917
1923
{
1919
1923
~
1920
1923
power
1921
1923
comparison
1922
1923
not
1923
1924
comp_iter
2242
1924
for
497
1924
]
comp_iter -> 
1924
if
2243
1924
comp_for
2244
1924
comp_if
2245
1925
and
term -> factor // term
1925
if
term -> factor // term
1925
>
term -> factor // term
1925
<
term -> factor // term
1925
==
term -> factor // term
1925
]
term -> factor // term
1925
+
term -> factor // term
1925
-
term -> factor // term
1925
&
term -> factor // term
1925
in
term -> factor // term
1925
!=
term -> factor // term
1925
^
term -> factor // term
1925
,
term -> factor // term
1925
or
term -> factor // term
1925
<=
term -> factor // term
1925
>=
term -> factor // term
1925
|
term -> factor // term
1925
>>
term -> factor // term
1925
not
term -> factor // term
1925
is
term -> factor // term
1925
<<
term -> factor // term
1926
^
term -> factor * term
1926
+
term -> factor * term
1926
==
term -> factor * term
1926
>>
term -> factor * term
1926
in
term -> factor * term
1926
and
term -> factor * term
1926
if
term -> factor * term
1926
is
term -> factor * term
1926
]
term -> factor * term
1926
<<
term -> factor * term
1926
,
term -> factor * term
1926
-
term -> factor * term
1926
!=
term -> factor * term
1926
or
term -> factor * term
1926
>
term -> factor * term
1926
&
term -> factor * term
1926
>=
term -> factor * term
1926
|
term -> factor * term
1926
<=
term -> factor * term
1926
not
term -> factor * term
1926
<
term -> factor * term
1927
&
term -> factor % term
1927
]
term -> factor % term
1927
==
term -> factor % term
1927
!=
term -> factor % term
1927
<
term -> factor % term
1927
in
term -> factor % term
1927
>>
term -> factor % term
1927
<<
term -> factor % term
1927
-
term -> factor % term
1927
if
term -> factor % term
1927
>
term -> factor % term
1927
or
term -> factor % term
1927
^
term -> factor % term
1927
+
term -> factor % term
1927
,
term -> factor % term
1927
is
term -> factor % term
1927
|
term -> factor % term
1927
>=
term -> factor % term
1927
<=
term -> factor % term
1927
and
term -> factor % term
1927
not
term -> factor % term
1928
and
term -> factor @ term
1928
in
term -> factor @ term
1928
>=
term -> factor @ term
1928
<
term -> factor @ term
1928
,
term -> factor @ term
1928
>
term -> factor @ term
1928
-
term -> factor @ term
1928
or
term -> factor @ term
1928
<<
term -> factor @ term
1928
is
term -> factor @ term
1928
!=
term -> factor @ term
1928
|
term -> factor @ term
1928
&
term -> factor @ term
1928
==
term -> factor @ term
1928
>>
term -> factor @ term
1928
]
term -> factor @ term
1928
not
term -> factor @ term
1928
<=
term -> factor @ term
1928
+
term -> factor @ term
1928
^
term -> factor @ term
1928
if
term -> factor @ term
1929
or
term -> factor / term
1929
<<
term -> factor / term
1929
not
term -> factor / term
1929
in
term -> factor / term
1929
!=
term -> factor / term
1929
<
term -> factor / term
1929
,
term -> factor / term
1929
]
term -> factor / term
1929
+
term -> factor / term
1929
and
term -> factor / term
1929
>>
term -> factor / term
1929
^
term -> factor / term
1929
<=
term -> factor / term
1929
==
term -> factor / term
1929
>
term -> factor / term
1929
&
term -> factor / term
1929
is
term -> factor / term
1929
-
term -> factor / term
1929
|
term -> factor / term
1929
>=
term -> factor / term
1929
if
term -> factor / term
1930
else
2246
1931
==
arith_expr -> term + arith_expr
1931
]
arith_expr -> term + arith_expr
1931
!=
arith_expr -> term + arith_expr
1931
<<
arith_expr -> term + arith_expr
1931
&
arith_expr -> term + arith_expr
1931
<
arith_expr -> term + arith_expr
1931
^
arith_expr -> term + arith_expr
1931
,
arith_expr -> term + arith_expr
1931
>=
arith_expr -> term + arith_expr
1931
in
arith_expr -> term + arith_expr
1931
>>
arith_expr -> term + arith_expr
1931
not
arith_expr -> term + arith_expr
1931
<=
arith_expr -> term + arith_expr
1931
is
arith_expr -> term + arith_expr
1931
|
arith_expr -> term + arith_expr
1931
and
arith_expr -> term + arith_expr
1931
or
arith_expr -> term + arith_expr
1931
if
arith_expr -> term + arith_expr
1931
>
arith_expr -> term + arith_expr
1932
if
arith_expr -> term - arith_expr
1932
&
arith_expr -> term - arith_expr
1932
>>
arith_expr -> term - arith_expr
1932
!=
arith_expr -> term - arith_expr
1932
>=
arith_expr -> term - arith_expr
1932
|
arith_expr -> term - arith_expr
1932
>
arith_expr -> term - arith_expr
1932
<
arith_expr -> term - arith_expr
1932
==
arith_expr -> term - arith_expr
1932
,
arith_expr -> term - arith_expr
1932
and
arith_expr -> term - arith_expr
1932
]
arith_expr -> term - arith_expr
1932
is
arith_expr -> term - arith_expr
1932
in
arith_expr -> term - arith_expr
1932
^
arith_expr -> term - arith_expr
1932
<<
arith_expr -> term - arith_expr
1932
not
arith_expr -> term - arith_expr
1932
or
arith_expr -> term - arith_expr
1932
<=
arith_expr -> term - arith_expr
1933
+
atom -> ( test_list_comp )
1933
/
atom -> ( test_list_comp )
1933
*
atom -> ( test_list_comp )
1933
[
atom -> ( test_list_comp )
1933
&
atom -> ( test_list_comp )
1933
,
atom -> ( test_list_comp )
1933
**
atom -> ( test_list_comp )
1933
^
atom -> ( test_list_comp )
1933
(
atom -> ( test_list_comp )
1933
and
atom -> ( test_list_comp )
1933
>
atom -> ( test_list_comp )
1933
-
atom -> ( test_list_comp )
1933
%
atom -> ( test_list_comp )
1933
//
atom -> ( test_list_comp )
1933
]
atom -> ( test_list_comp )
1933
in
atom -> ( test_list_comp )
1933
>>
atom -> ( test_list_comp )
1933
not
atom -> ( test_list_comp )
1933
>=
atom -> ( test_list_comp )
1933
or
atom -> ( test_list_comp )
1933
<
atom -> ( test_list_comp )
1933
if
atom -> ( test_list_comp )
1933
|
atom -> ( test_list_comp )
1933
<<
atom -> ( test_list_comp )
1933
@
atom -> ( test_list_comp )
1933
!=
atom -> ( test_list_comp )
1933
is
atom -> ( test_list_comp )
1933
.
atom -> ( test_list_comp )
1933
<=
atom -> ( test_list_comp )
1933
==
atom -> ( test_list_comp )
1934
]
shift_expr -> arith_expr >> shift_expr
1934
>=
shift_expr -> arith_expr >> shift_expr
1934
,
shift_expr -> arith_expr >> shift_expr
1934
if
shift_expr -> arith_expr >> shift_expr
1934
<=
shift_expr -> arith_expr >> shift_expr
1934
!=
shift_expr -> arith_expr >> shift_expr
1934
or
shift_expr -> arith_expr >> shift_expr
1934
|
shift_expr -> arith_expr >> shift_expr
1934
is
shift_expr -> arith_expr >> shift_expr
1934
and
shift_expr -> arith_expr >> shift_expr
1934
in
shift_expr -> arith_expr >> shift_expr
1934
^
shift_expr -> arith_expr >> shift_expr
1934
not
shift_expr -> arith_expr >> shift_expr
1934
<
shift_expr -> arith_expr >> shift_expr
1934
==
shift_expr -> arith_expr >> shift_expr
1934
&
shift_expr -> arith_expr >> shift_expr
1934
>
shift_expr -> arith_expr >> shift_expr
1935
>
shift_expr -> arith_expr << shift_expr
1935
or
shift_expr -> arith_expr << shift_expr
1935
^
shift_expr -> arith_expr << shift_expr
1935
not
shift_expr -> arith_expr << shift_expr
1935
<
shift_expr -> arith_expr << shift_expr
1935
if
shift_expr -> arith_expr << shift_expr
1935
in
shift_expr -> arith_expr << shift_expr
1935
!=
shift_expr -> arith_expr << shift_expr
1935
,
shift_expr -> arith_expr << shift_expr
1935
|
shift_expr -> arith_expr << shift_expr
1935
>=
shift_expr -> arith_expr << shift_expr
1935
and
shift_expr -> arith_expr << shift_expr
1935
==
shift_expr -> arith_expr << shift_expr
1935
]
shift_expr -> arith_expr << shift_expr
1935
&
shift_expr -> arith_expr << shift_expr
1935
<=
shift_expr -> arith_expr << shift_expr
1935
is
shift_expr -> arith_expr << shift_expr
1936
in
atom -> [ test_list_comp ]
1936
/
atom -> [ test_list_comp ]
1936
or
atom -> [ test_list_comp ]
1936
if
atom -> [ test_list_comp ]
1936
<<
atom -> [ test_list_comp ]
1936
!=
atom -> [ test_list_comp ]
1936
<=
atom -> [ test_list_comp ]
1936
>>
atom -> [ test_list_comp ]
1936
*
atom -> [ test_list_comp ]
1936
^
atom -> [ test_list_comp ]
1936
.
atom -> [ test_list_comp ]
1936
(
atom -> [ test_list_comp ]
1936
>=
atom -> [ test_list_comp ]
1936
and
atom -> [ test_list_comp ]
1936
<
atom -> [ test_list_comp ]
1936
]
atom -> [ test_list_comp ]
1936
,
atom -> [ test_list_comp ]
1936
[
atom -> [ test_list_comp ]
1936
==
atom -> [ test_list_comp ]
1936
@
atom -> [ test_list_comp ]
1936
%
atom -> [ test_list_comp ]
1936
-
atom -> [ test_list_comp ]
1936
|
atom -> [ test_list_comp ]
1936
&
atom -> [ test_list_comp ]
1936
+
atom -> [ test_list_comp ]
1936
is
atom -> [ test_list_comp ]
1936
//
atom -> [ test_list_comp ]
1936
**
atom -> [ test_list_comp ]
1936
not
atom -> [ test_list_comp ]
1936
>
atom -> [ test_list_comp ]
1937
+
power -> atom_expr ** factor
1937
&
power -> atom_expr ** factor
1937
>>
power -> atom_expr ** factor
1937
<<
power -> atom_expr ** factor
1937
not
power -> atom_expr ** factor
1937
is
power -> atom_expr ** factor
1937
@
power -> atom_expr ** factor
1937
==
power -> atom_expr ** factor
1937
*
power -> atom_expr ** factor
1937
or
power -> atom_expr ** factor
1937
>
power -> atom_expr ** factor
1937
-
power -> atom_expr ** factor
1937
if
power -> atom_expr ** factor
1937
!=
power -> atom_expr ** factor
1937
>=
power -> atom_expr ** factor
1937
/
power -> atom_expr ** factor
1937
%
power -> atom_expr ** factor
1937
and
power -> atom_expr ** factor
1937
<=
power -> atom_expr ** factor
1937
]
power -> atom_expr ** factor
1937
<
power -> atom_expr ** factor
1937
|
power -> atom_expr ** factor
1937
^
power -> atom_expr ** factor
1937
in
power -> atom_expr ** factor
1937
,
power -> atom_expr ** factor
1937
//
power -> atom_expr ** factor
1938
+
trailer_expr -> trailer trailer_expr
1938
,
trailer_expr -> trailer trailer_expr
1938
*
trailer_expr -> trailer trailer_expr
1938
/
trailer_expr -> trailer trailer_expr
1938
not
trailer_expr -> trailer trailer_expr
1938
<<
trailer_expr -> trailer trailer_expr
1938
!=
trailer_expr -> trailer trailer_expr
1938
>=
trailer_expr -> trailer trailer_expr
1938
>>
trailer_expr -> trailer trailer_expr
1938
|
trailer_expr -> trailer trailer_expr
1938
%
trailer_expr -> trailer trailer_expr
1938
>
trailer_expr -> trailer trailer_expr
1938
&
trailer_expr -> trailer trailer_expr
1938
-
trailer_expr -> trailer trailer_expr
1938
<=
trailer_expr -> trailer trailer_expr
1938
**
trailer_expr -> trailer trailer_expr
1938
@
trailer_expr -> trailer trailer_expr
1938
if
trailer_expr -> trailer trailer_expr
1938
==
trailer_expr -> trailer trailer_expr
1938
or
trailer_expr -> trailer trailer_expr
1938
<
trailer_expr -> trailer trailer_expr
1938
and
trailer_expr -> trailer trailer_expr
1938
in
trailer_expr -> trailer trailer_expr
1938
is
trailer_expr -> trailer trailer_expr
1938
]
trailer_expr -> trailer trailer_expr
1938
^
trailer_expr -> trailer trailer_expr
1938
//
trailer_expr -> trailer trailer_expr
1939
<<
trailer -> . NAME
1939
<=
trailer -> . NAME
1939
**
trailer -> . NAME
1939
!=
trailer -> . NAME
1939
/
trailer -> . NAME
1939
&
trailer -> . NAME
1939
//
trailer -> . NAME
1939
<
trailer -> . NAME
1939
is
trailer -> . NAME
1939
-
trailer -> . NAME
1939
if
trailer -> . NAME
1939
[
trailer -> . NAME
1939
or
trailer -> . NAME
1939
>
trailer -> . NAME
1939
*
trailer -> . NAME
1939
+
trailer -> . NAME
1939
%
trailer -> . NAME
1939
.
trailer -> . NAME
1939
>=
trailer -> . NAME
1939
|
trailer -> . NAME
1939
and
trailer -> . NAME
1939
(
trailer -> . NAME
1939
]
trailer -> . NAME
1939
,
trailer -> . NAME
1939
==
trailer -> . NAME
1939
^
trailer -> . NAME
1939
in
trailer -> . NAME
1939
@
trailer -> . NAME
1939
not
trailer -> . NAME
1939
>>
trailer -> . NAME
1940
%
trailer -> ( )
1940
<=
trailer -> ( )
1940
and
trailer -> ( )
1940
//
trailer -> ( )
1940
not
trailer -> ( )
1940
or
trailer -> ( )
1940
]
trailer -> ( )
1940
>>
trailer -> ( )
1940
>
trailer -> ( )
1940
<<
trailer -> ( )
1940
[
trailer -> ( )
1940
is
trailer -> ( )
1940
-
trailer -> ( )
1940
**
trailer -> ( )
1940
/
trailer -> ( )
1940
,
trailer -> ( )
1940
+
trailer -> ( )
1940
&
trailer -> ( )
1940
in
trailer -> ( )
1940
^
trailer -> ( )
1940
!=
trailer -> ( )
1940
*
trailer -> ( )
1940
if
trailer -> ( )
1940
>=
trailer -> ( )
1940
(
trailer -> ( )
1940
@
trailer -> ( )
1940
==
trailer -> ( )
1940
|
trailer -> ( )
1940
.
trailer -> ( )
1940
<
trailer -> ( )
1941
)
2247
1942
]
2248
1943
==
and_expr -> shift_expr & and_expr
1943
in
and_expr -> shift_expr & and_expr
1943
!=
and_expr -> shift_expr & and_expr
1943
,
and_expr -> shift_expr & and_expr
1943
or
and_expr -> shift_expr & and_expr
1943
>
and_expr -> shift_expr & and_expr
1943
not
and_expr -> shift_expr & and_expr
1943
<=
and_expr -> shift_expr & and_expr
1943
|
and_expr -> shift_expr & and_expr
1943
and
and_expr -> shift_expr & and_expr
1943
^
and_expr -> shift_expr & and_expr
1943
is
and_expr -> shift_expr & and_expr
1943
]
and_expr -> shift_expr & and_expr
1943
>=
and_expr -> shift_expr & and_expr
1943
<
and_expr -> shift_expr & and_expr
1943
if
and_expr -> shift_expr & and_expr
1944
]
and_test -> not_test and and_test
1944
,
and_test -> not_test and and_test
1944
if
and_test -> not_test and and_test
1944
or
and_test -> not_test and and_test
1945
<=
xor_expr -> and_expr ^ xor_expr
1945
!=
xor_expr -> and_expr ^ xor_expr
1945
and
xor_expr -> and_expr ^ xor_expr
1945
is
xor_expr -> and_expr ^ xor_expr
1945
>=
xor_expr -> and_expr ^ xor_expr
1945
not
xor_expr -> and_expr ^ xor_expr
1945
<
xor_expr -> and_expr ^ xor_expr
1945
|
xor_expr -> and_expr ^ xor_expr
1945
in
xor_expr -> and_expr ^ xor_expr
1945
==
xor_expr -> and_expr ^ xor_expr
1945
or
xor_expr -> and_expr ^ xor_expr
1945
,
xor_expr -> and_expr ^ xor_expr
1945
if
xor_expr -> and_expr ^ xor_expr
1945
>
xor_expr -> and_expr ^ xor_expr
1945
]
xor_expr -> and_expr ^ xor_expr
1946
not
expr -> xor_expr | expr
1946
,
expr -> xor_expr | expr
1946
in
expr -> xor_expr | expr
1946
if
expr -> xor_expr | expr
1946
or
expr -> xor_expr | expr
1946
<=
expr -> xor_expr | expr
1946
>
expr -> xor_expr | expr
1946
!=
expr -> xor_expr | expr
1946
]
expr -> xor_expr | expr
1946
==
expr -> xor_expr | expr
1946
>=
expr -> xor_expr | expr
1946
is
expr -> xor_expr | expr
1946
<
expr -> xor_expr | expr
1946
and
expr -> xor_expr | expr
1947
,
or_test -> and_test or or_test
1947
if
or_test -> and_test or or_test
1947
]
or_test -> and_test or or_test
1948
,
lambdef -> lambda : test
1948
]
lambdef -> lambda : test
1949
factor
984
1949
or_test
985
1949
term
986
1949
(
987
1949
arith_expr
988
1949
NAME
989
1949
[
991
1949
+
992
1949
atom_expr
993
1949
NUMBER
994
1949
atom
995
1949
STRING
996
1949
shift_expr
997
1949
-
998
1949
True
999
1949
not_test
1000
1949
and_expr
1001
1949
xor_expr
1002
1949
None
1003
1949
False
1004
1949
and_test
1005
1949
{
1006
1949
~
1007
1949
lambda
1008
1949
power
1009
1949
expr
1010
1949
lambdef
1011
1949
test
2249
1949
not
1013
1949
comparison
1014
1950
and
comparison -> expr comp_op comparison
1950
]
comparison -> expr comp_op comparison
1950
if
comparison -> expr comp_op comparison
1950
or
comparison -> expr comp_op comparison
1950
,
comparison -> expr comp_op comparison
1951
factor
9
1951
arith_expr
2
1951
NAME
29
1951
term
21
1951
[
3
1951
~
45
1951
atom_expr
24
1951
expr
16
1951
power
56
1951
(
36
1951
return
13
1951
small_stmt
2250
1951
flow_stmt
15
1951
True
17
1951
not_test
18
1951
and_expr
19
1951
xor_expr
22
1951
{
52
1951
lambdef
53
1951
atom
54
1951
or_test
23
1951
suite
2251
1951
shift_expr
50
1951
False
35
1951
NEWLINE
2252
1951
-
49
1951
None
42
1951
lambda
40
1951
global
25
1951
NUMBER
27
1951
STRING
28
1951
test
48
1951
endsim
33
1951
and_test
37
1951
simple_stmt
2253
1951
comparison
39
1951
break_stmt
74
1951
+
55
1951
not
57
1951
raise
62
1951
continue
59
1951
return_stmt
75
1951
del_stmt
60
1951
test_list
61
1951
raise_stmt
63
1951
resetstats
64
1951
pass_stmt
65
1951
nonlocal
66
1951
break
76
1951
sim_stmt
77
1951
stat_stmt
78
1951
global_stmt
67
1951
yield_stmt
79
1951
assert_stmt
80
1951
pass
81
1951
yield
68
1951
continue_stmt
69
1951
assert
70
1951
nonlocal_stmt
71
1951
expr_stmt
72
1951
begsim
83
1951
del
84
1952
factor
9
1952
arith_expr
2
1952
NAME
29
1952
term
21
1952
[
3
1952
~
45
1952
atom_expr
24
1952
expr
16
1952
power
56
1952
(
36
1952
return
13
1952
small_stmt
47
1952
flow_stmt
15
1952
True
17
1952
not_test
18
1952
and_expr
19
1952
xor_expr
22
1952
{
52
1952
lambdef
53
1952
atom
54
1952
or_test
23
1952
shift_expr
50
1952
False
35
1952
NEWLINE
1022
1952
-
49
1952
None
42
1952
lambda
40
1952
global
25
1952
NUMBER
27
1952
STRING
28
1952
test
48
1952
endsim
33
1952
and_test
37
1952
simple_stmt
1023
1952
suite
2254
1952
comparison
39
1952
break_stmt
74
1952
+
55
1952
not
57
1952
raise
62
1952
continue
59
1952
return_stmt
75
1952
del_stmt
60
1952
test_list
61
1952
raise_stmt
63
1952
resetstats
64
1952
pass_stmt
65
1952
nonlocal
66
1952
break
76
1952
sim_stmt
77
1952
stat_stmt
78
1952
global_stmt
67
1952
yield_stmt
79
1952
assert_stmt
80
1952
pass
81
1952
yield
68
1952
continue_stmt
69
1952
assert
70
1952
nonlocal_stmt
71
1952
expr_stmt
72
1952
begsim
83
1952
del
84
1953
NAME
2255
1954
factor
9
1954
arith_expr
2
1954
NAME
29
1954
term
21
1954
[
3
1954
~
45
1954
atom_expr
24
1954
expr
16
1954
power
56
1954
(
36
1954
return
13
1954
small_stmt
1981
1954
flow_stmt
15
1954
True
17
1954
not_test
18
1954
suite
2256
1954
and_expr
19
1954
xor_expr
22
1954
{
52
1954
lambdef
53
1954
atom
54
1954
or_test
23
1954
shift_expr
50
1954
False
35
1954
NEWLINE
1982
1954
-
49
1954
None
42
1954
lambda
40
1954
global
25
1954
NUMBER
27
1954
STRING
28
1954
test
48
1954
endsim
33
1954
and_test
37
1954
simple_stmt
1983
1954
comparison
39
1954
break_stmt
74
1954
+
55
1954
not
57
1954
raise
62
1954
continue
59
1954
return_stmt
75
1954
del_stmt
60
1954
test_list
61
1954
raise_stmt
63
1954
resetstats
64
1954
pass_stmt
65
1954
nonlocal
66
1954
break
76
1954
sim_stmt
77
1954
stat_stmt
78
1954
global_stmt
67
1954
yield_stmt
79
1954
assert_stmt
80
1954
pass
81
1954
yield
68
1954
continue_stmt
69
1954
assert
70
1954
nonlocal_stmt
71
1954
expr_stmt
72
1954
begsim
83
1954
del
84
1955
factor
1536
1955
(
1537
1955
NAME
1539
1955
[
1541
1955
~
1542
1955
+
1543
1955
atom_expr
1546
1955
NUMBER
1549
1955
atom
1548
1955
STRING
1550
1955
-
1552
1955
term
2257
1955
True
1553
1955
False
1557
1955
{
1558
1955
None
1560
1955
power
1564
1956
factor
1536
1956
(
1537
1956
NAME
1539
1956
[
1541
1956
~
1542
1956
+
1543
1956
atom_expr
1546
1956
NUMBER
1549
1956
atom
1548
1956
term
2258
1956
STRING
1550
1956
-
1552
1956
True
1553
1956
False
1557
1956
{
1558
1956
None
1560
1956
power
1564
1957
factor
1536
1957
(
1537
1957
NAME
1539
1957
[
1541
1957
~
1542
1957
+
1543
1957
atom_expr
1546
1957
NUMBER
1549
1957
atom
1548
1957
STRING
1550
1957
-
1552
1957
True
1553
1957
False
1557
1957
{
1558
1957
None
1560
1957
term
2259
1957
power
1564
1958
factor
1536
1958
(
1537
1958
NAME
1539
1958
term
2260
1958
[
1541
1958
~
1542
1958
+
1543
1958
atom_expr
1546
1958
NUMBER
1549
1958
atom
1548
1958
STRING
1550
1958
-
1552
1958
True
1553
1958
False
1557
1958
{
1558
1958
None
1560
1958
power
1564
1959
factor
1536
1959
(
1537
1959
NAME
1539
1959
[
1541
1959
~
1542
1959
+
1543
1959
atom_expr
1546
1959
NUMBER
1549
1959
atom
1548
1959
STRING
1550
1959
-
1552
1959
term
2261
1959
True
1553
1959
False
1557
1959
{
1558
1959
None
1560
1959
power
1564
1960
)
2262
1961
or
atom -> ( )
1961
<<
atom -> ( )
1961
not
atom -> ( )
1961
&
atom -> ( )
1961
(
atom -> ( )
1961
in
atom -> ( )
1961
**
atom -> ( )
1961
@
atom -> ( )
1961
<=
atom -> ( )
1961
%
atom -> ( )
1961
as
atom -> ( )
1961
[
atom -> ( )
1961
>=
atom -> ( )
1961
/
atom -> ( )
1961
+
atom -> ( )
1961
<
atom -> ( )
1961
is
atom -> ( )
1961
:
atom -> ( )
1961
*
atom -> ( )
1961
!=
atom -> ( )
1961
-
atom -> ( )
1961
|
atom -> ( )
1961
//
atom -> ( )
1961
^
atom -> ( )
1961
and
atom -> ( )
1961
==
atom -> ( )
1961
if
atom -> ( )
1961
>
atom -> ( )
1961
.
atom -> ( )
1961
>>
atom -> ( )
1962
factor
1536
1962
(
1537
1962
arith_expr
1538
1962
NAME
1539
1962
term
1540
1962
[
1541
1962
~
1542
1962
+
1543
1962
atom_expr
1546
1962
NUMBER
1549
1962
atom
1548
1962
STRING
1550
1962
-
1552
1962
shift_expr
2263
1962
True
1553
1962
False
1557
1962
{
1558
1962
None
1560
1962
power
1564
1963
factor
1536
1963
(
1537
1963
arith_expr
1538
1963
NAME
1539
1963
term
1540
1963
[
1541
1963
~
1542
1963
+
1543
1963
atom_expr
1546
1963
NUMBER
1549
1963
atom
1548
1963
STRING
1550
1963
-
1552
1963
True
1553
1963
shift_expr
2264
1963
False
1557
1963
{
1558
1963
None
1560
1963
power
1564
1964
factor
1536
1964
(
1537
1964
NAME
1539
1964
term
1540
1964
[
1541
1964
~
1542
1964
+
1543
1964
atom_expr
1546
1964
NUMBER
1549
1964
atom
1548
1964
STRING
1550
1964
-
1552
1964
True
1553
1964
arith_expr
2265
1964
False
1557
1964
{
1558
1964
None
1560
1964
power
1564
1965
factor
1536
1965
(
1537
1965
NAME
1539
1965
term
1540
1965
[
1541
1965
~
1542
1965
+
1543
1965
atom_expr
1546
1965
NUMBER
1549
1965
atom
1548
1965
STRING
1550
1965
-
1552
1965
True
1553
1965
False
1557
1965
{
1558
1965
None
1560
1965
arith_expr
2266
1965
power
1564
1966
<=
atom -> [ ]
1966
is
atom -> [ ]
1966
-
atom -> [ ]
1966
**
atom -> [ ]
1966
^
atom -> [ ]
1966
%
atom -> [ ]
1966
/
atom -> [ ]
1966
>=
atom -> [ ]
1966
|
atom -> [ ]
1966
not
atom -> [ ]
1966
@
atom -> [ ]
1966
*
atom -> [ ]
1966
(
atom -> [ ]
1966
>>
atom -> [ ]
1966
[
atom -> [ ]
1966
:
atom -> [ ]
1966
or
atom -> [ ]
1966
!=
atom -> [ ]
1966
and
atom -> [ ]
1966
<<
atom -> [ ]
1966
if
atom -> [ ]
1966
in
atom -> [ ]
1966
as
atom -> [ ]
1966
+
atom -> [ ]
1966
.
atom -> [ ]
1966
==
atom -> [ ]
1966
>
atom -> [ ]
1966
<
atom -> [ ]
1966
&
atom -> [ ]
1966
//
atom -> [ ]
1967
]
2267
1968
or
factor -> ~ factor
1968
==
factor -> ~ factor
1968
<=
factor -> ~ factor
1968
@
factor -> ~ factor
1968
!=
factor -> ~ factor
1968
>=
factor -> ~ factor
1968
>
factor -> ~ factor
1968
and
factor -> ~ factor
1968
:
factor -> ~ factor
1968
*
factor -> ~ factor
1968
as
factor -> ~ factor
1968
&
factor -> ~ factor
1968
%
factor -> ~ factor
1968
<
factor -> ~ factor
1968
//
factor -> ~ factor
1968
if
factor -> ~ factor
1968
^
factor -> ~ factor
1968
/
factor -> ~ factor
1968
in
factor -> ~ factor
1968
+
factor -> ~ factor
1968
not
factor -> ~ factor
1968
-
factor -> ~ factor
1968
is
factor -> ~ factor
1968
>>
factor -> ~ factor
1968
<<
factor -> ~ factor
1968
|
factor -> ~ factor
1969
<
factor -> + factor
1969
if
factor -> + factor
1969
<<
factor -> + factor
1969
and
factor -> + factor
1969
>=
factor -> + factor
1969
%
factor -> + factor
1969
>>
factor -> + factor
1969
*
factor -> + factor
1969
as
factor -> + factor
1969
+
factor -> + factor
1969
/
factor -> + factor
1969
>
factor -> + factor
1969
<=
factor -> + factor
1969
^
factor -> + factor
1969
is
factor -> + factor
1969
|
factor -> + factor
1969
or
factor -> + factor
1969
-
factor -> + factor
1969
in
factor -> + factor
1969
&
factor -> + factor
1969
not
factor -> + factor
1969
//
factor -> + factor
1969
!=
factor -> + factor
1969
:
factor -> + factor
1969
==
factor -> + factor
1969
@
factor -> + factor
1970
factor
1536
1970
(
1537
1970
arith_expr
1538
1970
NAME
1539
1970
term
1540
1970
[
1541
1970
~
1542
1970
+
1543
1970
lambda
1544
1970
expr
1545
1970
atom_expr
1546
1970
shift_expr
1547
1970
atom
1548
1970
NUMBER
1549
1970
STRING
1550
1970
-
1552
1970
True
1553
1970
not_test
1554
1970
and_expr
1555
1970
xor_expr
1556
1970
False
1557
1970
{
1558
1970
or_test
1559
1970
None
1560
1970
comparison
1561
1970
and_test
1562
1970
test
2268
1970
lambdef
1563
1970
power
1564
1970
not
1565
1971
:
2269
1972
factor
1536
1972
(
1537
1972
arith_expr
1538
1972
NAME
1539
1972
term
1540
1972
[
1541
1972
~
1542
1972
+
1543
1972
expr
1545
1972
atom_expr
1546
1972
shift_expr
1547
1972
atom
1548
1972
NUMBER
1549
1972
STRING
1550
1972
-
1552
1972
True
1553
1972
and_expr
1555
1972
comparison
2270
1972
xor_expr
1556
1972
False
1557
1972
{
1558
1972
None
1560
1972
power
1564
1973
(
1537
1973
NAME
1539
1973
[
1541
1973
~
1542
1973
+
1543
1973
atom_expr
1546
1973
NUMBER
1549
1973
atom
1548
1973
STRING
1550
1973
-
1552
1973
factor
2271
1973
True
1553
1973
False
1557
1973
{
1558
1973
None
1560
1973
power
1564
1974
factor
1536
1974
(
1537
1974
arith_expr
1538
1974
NAME
1539
1974
term
1540
1974
[
1541
1974
~
1542
1974
+
1543
1974
atom_expr
1546
1974
shift_expr
1547
1974
atom
1548
1974
NUMBER
1549
1974
STRING
1550
1974
-
1552
1974
True
1553
1974
False
1557
1974
{
1558
1974
None
1560
1974
and_expr
2272
1974
power
1564
1975
trailer_expr
2273
1975
trailer
1975
1975
.
1976
1975
(
1977
1975
[
1978
1975
<<
trailer_expr -> 
1975
%
trailer_expr -> 
1975
==
trailer_expr -> 
1975
-
trailer_expr -> 
1975
<
trailer_expr -> 
1975
if
trailer_expr -> 
1975
or
trailer_expr -> 
1975
/
trailer_expr -> 
1975
**
trailer_expr -> 
1975
and
trailer_expr -> 
1975
@
trailer_expr -> 
1975
*
trailer_expr -> 
1975
|
trailer_expr -> 
1975
is
trailer_expr -> 
1975
+
trailer_expr -> 
1975
in
trailer_expr -> 
1975
&
trailer_expr -> 
1975
<=
trailer_expr -> 
1975
>=
trailer_expr -> 
1975
^
trailer_expr -> 
1975
>
trailer_expr -> 
1975
!=
trailer_expr -> 
1975
not
trailer_expr -> 
1975
>>
trailer_expr -> 
1975
//
trailer_expr -> 
1975
as
trailer_expr -> 
1975
:
trailer_expr -> 
1976
NAME
2274
1977
factor
697
1977
term
698
1977
(
699
1977
arith_expr
700
1977
NAME
701
1977
[
702
1977
atom
703
1977
+
704
1977
power
706
1977
atom_expr
707
1977
NUMBER
708
1977
STRING
709
1977
*
710
1977
shift_expr
711
1977
-
712
1977
argument
714
1977
)
2275
1977
True
715
1977
not_test
716
1977
lambdef
717
1977
and_expr
718
1977
xor_expr
719
1977
False
720
1977
test
721
1977
None
722
1977
arglist
2276
1977
expr
723
1977
and_test
724
1977
{
725
1977
~
726
1977
lambda
727
1977
comparison
728
1977
or_test
729
1977
not
730
1977
**
731
1978
factor
732
1978
or_test
733
1978
term
734
1978
(
735
1978
arith_expr
736
1978
NAME
737
1978
[
738
1978
~
739
1978
subscriptlist
2277
1978
+
741
1978
maybe_test
742
1978
expr
743
1978
atom_expr
744
1978
atom
745
1978
NUMBER
746
1978
STRING
747
1978
shift_expr
748
1978
-
749
1978
True
750
1978
not_test
751
1978
and_expr
752
1978
xor_expr
753
1978
False
754
1978
{
755
1978
None
756
1978
and_test
757
1978
lambda
758
1978
power
759
1978
subscript
760
1978
test
761
1978
lambdef
762
1978
:
maybe_test -> 
1978
comparison
763
1978
not
764
1979
>
atom_expr -> atom trailer_expr
1979
as
atom_expr -> atom trailer_expr
1979
not
atom_expr -> atom trailer_expr
1979
//
atom_expr -> atom trailer_expr
1979
>>
atom_expr -> atom trailer_expr
1979
|
atom_expr -> atom trailer_expr
1979
^
atom_expr -> atom trailer_expr
1979
/
atom_expr -> atom trailer_expr
1979
+
atom_expr -> atom trailer_expr
1979
in
atom_expr -> atom trailer_expr
1979
%
atom_expr -> atom trailer_expr
1979
and
atom_expr -> atom trailer_expr
1979
<=
atom_expr -> atom trailer_expr
1979
is
atom_expr -> atom trailer_expr
1979
<
atom_expr -> atom trailer_expr
1979
@
atom_expr -> atom trailer_expr
1979
-
atom_expr -> atom trailer_expr
1979
&
atom_expr -> atom trailer_expr
1979
:
atom_expr -> atom trailer_expr
1979
*
atom_expr -> atom trailer_expr
1979
**
atom_expr -> atom trailer_expr
1979
>=
atom_expr -> atom trailer_expr
1979
or
atom_expr -> atom trailer_expr
1979
==
atom_expr -> atom trailer_expr
1979
!=
atom_expr -> atom trailer_expr
1979
if
atom_expr -> atom trailer_expr
1979
<<
atom_expr -> atom trailer_expr
1980
except
1016
1980
maybe_except_clause
2278
1980
except_clause
2279
1980
global
maybe_except_clause -> 
1980
resetstats
maybe_except_clause -> 
1980
class
maybe_except_clause -> 
1980
def
maybe_except_clause -> 
1980
NAME
maybe_except_clause -> 
1980
NUMBER
maybe_except_clause -> 
1980
lambda
maybe_except_clause -> 
1980
True
maybe_except_clause -> 
1980
else
maybe_except_clause -> 
1980
not
maybe_except_clause -> 
1980
$
maybe_except_clause -> 
1980
-
maybe_except_clause -> 
1980
NEWLINE
maybe_except_clause -> 
1980
~
maybe_except_clause -> 
1980
del
maybe_except_clause -> 
1980
with
maybe_except_clause -> 
1980
pass
maybe_except_clause -> 
1980
if
maybe_except_clause -> 
1980
assert
maybe_except_clause -> 
1980
conf
maybe_except_clause -> 
1980
break
maybe_except_clause -> 
1980
try
maybe_except_clause -> 
1980
while
maybe_except_clause -> 
1980
False
maybe_except_clause -> 
1980
(
maybe_except_clause -> 
1980
None
maybe_except_clause -> 
1980
return
maybe_except_clause -> 
1980
nonlocal
maybe_except_clause -> 
1980
@
maybe_except_clause -> 
1980
yield
maybe_except_clause -> 
1980
finally
maybe_except_clause -> 
1980
{
maybe_except_clause -> 
1980
endsim
maybe_except_clause -> 
1980
for
maybe_except_clause -> 
1980
raise
maybe_except_clause -> 
1980
[
maybe_except_clause -> 
1980
STRING
maybe_except_clause -> 
1980
continue
maybe_except_clause -> 
1980
begsim
maybe_except_clause -> 
1980
+
maybe_except_clause -> 
1981
NEWLINE
2280
1982
INDENT
2281
1983
resetstats
suite -> simple_stmt
1983
+
suite -> simple_stmt
1983
lambda
suite -> simple_stmt
1983
try
suite -> simple_stmt
1983
begsim
suite -> simple_stmt
1983
None
suite -> simple_stmt
1983
not
suite -> simple_stmt
1983
@
suite -> simple_stmt
1983
[
suite -> simple_stmt
1983
class
suite -> simple_stmt
1983
return
suite -> simple_stmt
1983
else
suite -> simple_stmt
1983
nonlocal
suite -> simple_stmt
1983
NUMBER
suite -> simple_stmt
1983
yield
suite -> simple_stmt
1983
STRING
suite -> simple_stmt
1983
NEWLINE
suite -> simple_stmt
1983
-
suite -> simple_stmt
1983
False
suite -> simple_stmt
1983
def
suite -> simple_stmt
1983
except
suite -> simple_stmt
1983
conf
suite -> simple_stmt
1983
True
suite -> simple_stmt
1983
raise
suite -> simple_stmt
1983
endsim
suite -> simple_stmt
1983
with
suite -> simple_stmt
1983
global
suite -> simple_stmt
1983
{
suite -> simple_stmt
1983
~
suite -> simple_stmt
1983
assert
suite -> simple_stmt
1983
(
suite -> simple_stmt
1983
$
suite -> simple_stmt
1983
while
suite -> simple_stmt
1983
finally
suite -> simple_stmt
1983
del
suite -> simple_stmt
1983
pass
suite -> simple_stmt
1983
break
suite -> simple_stmt
1983
for
suite -> simple_stmt
1983
continue
suite -> simple_stmt
1983
NAME
suite -> simple_stmt
1983
if
suite -> simple_stmt
1984
and
factor -> - factor
1984
as
factor -> - factor
1984
if
factor -> - factor
1984
or
factor -> - factor
1984
>=
factor -> - factor
1984
<
factor -> - factor
1984
!=
factor -> - factor
1984
-
factor -> - factor
1984
==
factor -> - factor
1984
@
factor -> - factor
1984
|
factor -> - factor
1984
*
factor -> - factor
1984
%
factor -> - factor
1984
+
factor -> - factor
1984
<=
factor -> - factor
1984
//
factor -> - factor
1984
not
factor -> - factor
1984
>>
factor -> - factor
1984
/
factor -> - factor
1984
&
factor -> - factor
1984
^
factor -> - factor
1984
in
factor -> - factor
1984
is
factor -> - factor
1984
>
factor -> - factor
1984
:
factor -> - factor
1984
<<
factor -> - factor
1985
factor
1536
1985
(
1537
1985
arith_expr
1538
1985
NAME
1539
1985
term
1540
1985
[
1541
1985
~
1542
1985
+
1543
1985
expr
1545
1985
atom_expr
1546
1985
shift_expr
1547
1985
atom
1548
1985
NUMBER
1549
1985
STRING
1550
1985
-
1552
1985
True
1553
1985
not_test
1554
1985
and_test
2282
1985
and_expr
1555
1985
xor_expr
1556
1985
False
1557
1985
{
1558
1985
None
1560
1985
comparison
1561
1985
power
1564
1985
not
1565
1986
factor
1536
1986
(
1537
1986
arith_expr
1538
1986
NAME
1539
1986
term
1540
1986
[
1541
1986
~
1542
1986
+
1543
1986
atom_expr
1546
1986
shift_expr
1547
1986
atom
1548
1986
NUMBER
1549
1986
STRING
1550
1986
-
1552
1986
True
1553
1986
and_expr
1555
1986
False
1557
1986
{
1558
1986
None
1560
1986
xor_expr
2283
1986
power
1564
1987
factor
1536
1987
(
1537
1987
arith_expr
1538
1987
NAME
1539
1987
term
1540
1987
[
1541
1987
~
1542
1987
+
1543
1987
atom_expr
1546
1987
shift_expr
1547
1987
atom
1548
1987
NUMBER
1549
1987
STRING
1550
1987
-
1552
1987
True
1553
1987
and_expr
1555
1987
xor_expr
1556
1987
False
1557
1987
{
1558
1987
None
1560
1987
power
1564
1987
expr
2284
1988
>
atom -> { }
1988
==
atom -> { }
1988
-
atom -> { }
1988
not
atom -> { }
1988
(
atom -> { }
1988
@
atom -> { }
1988
if
atom -> { }
1988
and
atom -> { }
1988
:
atom -> { }
1988
&
atom -> { }
1988
<<
atom -> { }
1988
!=
atom -> { }
1988
or
atom -> { }
1988
>>
atom -> { }
1988
<=
atom -> { }
1988
>=
atom -> { }
1988
is
atom -> { }
1988
/
atom -> { }
1988
^
atom -> { }
1988
[
atom -> { }
1988
%
atom -> { }
1988
//
atom -> { }
1988
*
atom -> { }
1988
**
atom -> { }
1988
.
atom -> { }
1988
in
atom -> { }
1988
+
atom -> { }
1988
|
atom -> { }
1988
<
atom -> { }
1988
as
atom -> { }
1989
factor
585
1989
(
586
1989
arith_expr
587
1989
NAME
588
1989
[
589
1989
and_expr
590
1989
+
591
1989
term
592
1989
atom_expr
593
1989
NUMBER
594
1989
atom
595
1989
STRING
596
1989
shift_expr
597
1989
-
598
1989
True
599
1989
not
600
1989
xor_expr
601
1989
None
602
1989
False
603
1989
not_test
605
1989
~
606
1989
power
607
1989
{
608
1989
expr
609
1989
comparison
610
1989
and_test
611
1989
or_test
2285
1990
factor
1536
1990
(
1537
1990
arith_expr
1538
1990
NAME
1539
1990
term
1540
1990
[
1541
1990
~
1542
1990
+
1543
1990
expr
1545
1990
atom_expr
1546
1990
shift_expr
1547
1990
atom
1548
1990
NUMBER
1549
1990
STRING
1550
1990
-
1552
1990
True
1553
1990
not_test
1554
1990
and_expr
1555
1990
xor_expr
1556
1990
False
1557
1990
{
1558
1990
None
1560
1990
comparison
1561
1990
and_test
1562
1990
power
1564
1990
not
1565
1990
or_test
2286
1991
or
not_test -> not not_test
1991
and
not_test -> not not_test
1991
if
not_test -> not not_test
1991
as
not_test -> not not_test
1991
:
not_test -> not not_test
1992
:
2287
1993
factor
9
1993
arith_expr
2
1993
NAME
29
1993
term
21
1993
[
3
1993
~
45
1993
suite
2288
1993
atom_expr
24
1993
expr
16
1993
power
56
1993
(
36
1993
return
13
1993
flow_stmt
15
1993
True
17
1993
not_test
18
1993
and_expr
19
1993
xor_expr
22
1993
{
52
1993
lambdef
53
1993
atom
54
1993
or_test
23
1993
shift_expr
50
1993
False
35
1993
-
49
1993
None
42
1993
lambda
40
1993
global
25
1993
NUMBER
27
1993
STRING
28
1993
test
48
1993
endsim
33
1993
and_test
37
1993
comparison
39
1993
break_stmt
74
1993
+
55
1993
not
57
1993
small_stmt
501
1993
raise
62
1993
continue
59
1993
return_stmt
75
1993
del_stmt
60
1993
test_list
61
1993
raise_stmt
63
1993
resetstats
64
1993
pass_stmt
65
1993
nonlocal
66
1993
break
76
1993
sim_stmt
77
1993
stat_stmt
78
1993
global_stmt
67
1993
yield_stmt
79
1993
NEWLINE
502
1993
simple_stmt
503
1993
assert_stmt
80
1993
pass
81
1993
yield
68
1993
continue_stmt
69
1993
assert
70
1993
nonlocal_stmt
71
1993
expr_stmt
72
1993
begsim
83
1993
del
84
1994
(
2289
1994
:
2290
1995
in
2291
1996
assert
decorated -> decorators classdef
1996
None
decorated -> decorators classdef
1996
+
decorated -> decorators classdef
1996
resetstats
decorated -> decorators classdef
1996
return
decorated -> decorators classdef
1996
False
decorated -> decorators classdef
1996
if
decorated -> decorators classdef
1996
(
decorated -> decorators classdef
1996
nonlocal
decorated -> decorators classdef
1996
class
decorated -> decorators classdef
1996
global
decorated -> decorators classdef
1996
pass
decorated -> decorators classdef
1996
not
decorated -> decorators classdef
1996
conf
decorated -> decorators classdef
1996
break
decorated -> decorators classdef
1996
DEDENT
decorated -> decorators classdef
1996
yield
decorated -> decorators classdef
1996
begsim
decorated -> decorators classdef
1996
{
decorated -> decorators classdef
1996
NUMBER
decorated -> decorators classdef
1996
@
decorated -> decorators classdef
1996
with
decorated -> decorators classdef
1996
~
decorated -> decorators classdef
1996
lambda
decorated -> decorators classdef
1996
raise
decorated -> decorators classdef
1996
for
decorated -> decorators classdef
1996
continue
decorated -> decorators classdef
1996
endsim
decorated -> decorators classdef
1996
True
decorated -> decorators classdef
1996
def
decorated -> decorators classdef
1996
try
decorated -> decorators classdef
1996
-
decorated -> decorators classdef
1996
NAME
decorated -> decorators classdef
1996
[
decorated -> decorators classdef
1996
STRING
decorated -> decorators classdef
1996
del
decorated -> decorators classdef
1996
while
decorated -> decorators classdef
1997
(
decorated -> decorators funcdef
1997
resetstats
decorated -> decorators funcdef
1997
NAME
decorated -> decorators funcdef
1997
class
decorated -> decorators funcdef
1997
~
decorated -> decorators funcdef
1997
conf
decorated -> decorators funcdef
1997
begsim
decorated -> decorators funcdef
1997
endsim
decorated -> decorators funcdef
1997
not
decorated -> decorators funcdef
1997
assert
decorated -> decorators funcdef
1997
{
decorated -> decorators funcdef
1997
def
decorated -> decorators funcdef
1997
continue
decorated -> decorators funcdef
1997
nonlocal
decorated -> decorators funcdef
1997
None
decorated -> decorators funcdef
1997
while
decorated -> decorators funcdef
1997
break
decorated -> decorators funcdef
1997
DEDENT
decorated -> decorators funcdef
1997
return
decorated -> decorators funcdef
1997
+
decorated -> decorators funcdef
1997
STRING
decorated -> decorators funcdef
1997
False
decorated -> decorators funcdef
1997
-
decorated -> decorators funcdef
1997
if
decorated -> decorators funcdef
1997
[
decorated -> decorators funcdef
1997
global
decorated -> decorators funcdef
1997
NUMBER
decorated -> decorators funcdef
1997
yield
decorated -> decorators funcdef
1997
True
decorated -> decorators funcdef
1997
try
decorated -> decorators funcdef
1997
pass
decorated -> decorators funcdef
1997
@
decorated -> decorators funcdef
1997
lambda
decorated -> decorators funcdef
1997
raise
decorated -> decorators funcdef
1997
for
decorated -> decorators funcdef
1997
del
decorated -> decorators funcdef
1997
with
decorated -> decorators funcdef
1998
(
2292
1999
:
2293
2000
:
2294
2000
(
2295
2001
:
2296
2002
nonlocal
simple_stmt -> small_stmt NEWLINE
2002
True
simple_stmt -> small_stmt NEWLINE
2002
False
simple_stmt -> small_stmt NEWLINE
2002
(
simple_stmt -> small_stmt NEWLINE
2002
continue
simple_stmt -> small_stmt NEWLINE
2002
begsim
simple_stmt -> small_stmt NEWLINE
2002
NAME
simple_stmt -> small_stmt NEWLINE
2002
endsim
simple_stmt -> small_stmt NEWLINE
2002
DEDENT
simple_stmt -> small_stmt NEWLINE
2002
break
simple_stmt -> small_stmt NEWLINE
2002
return
simple_stmt -> small_stmt NEWLINE
2002
NUMBER
simple_stmt -> small_stmt NEWLINE
2002
[
simple_stmt -> small_stmt NEWLINE
2002
global
simple_stmt -> small_stmt NEWLINE
2002
resetstats
simple_stmt -> small_stmt NEWLINE
2002
yield
simple_stmt -> small_stmt NEWLINE
2002
conf
simple_stmt -> small_stmt NEWLINE
2002
lambda
simple_stmt -> small_stmt NEWLINE
2002
not
simple_stmt -> small_stmt NEWLINE
2002
del
simple_stmt -> small_stmt NEWLINE
2002
pass
simple_stmt -> small_stmt NEWLINE
2002
for
simple_stmt -> small_stmt NEWLINE
2002
@
simple_stmt -> small_stmt NEWLINE
2002
with
simple_stmt -> small_stmt NEWLINE
2002
class
simple_stmt -> small_stmt NEWLINE
2002
if
simple_stmt -> small_stmt NEWLINE
2002
assert
simple_stmt -> small_stmt NEWLINE
2002
None
simple_stmt -> small_stmt NEWLINE
2002
+
simple_stmt -> small_stmt NEWLINE
2002
-
simple_stmt -> small_stmt NEWLINE
2002
STRING
simple_stmt -> small_stmt NEWLINE
2002
while
simple_stmt -> small_stmt NEWLINE
2002
{
simple_stmt -> small_stmt NEWLINE
2002
raise
simple_stmt -> small_stmt NEWLINE
2002
~
simple_stmt -> small_stmt NEWLINE
2002
def
simple_stmt -> small_stmt NEWLINE
2002
try
simple_stmt -> small_stmt NEWLINE
2003
except
suite -> NEWLINE INDENT stmt_list DEDENT
2004
DEDENT
stmt_list -> stmt stmt_list
2005
factor
9
2005
arith_expr
2
2005
NAME
29
2005
term
21
2005
[
3
2005
~
45
2005
suite
2297
2005
atom_expr
24
2005
expr
16
2005
power
56
2005
(
36
2005
return
13
2005
small_stmt
47
2005
flow_stmt
15
2005
True
17
2005
not_test
18
2005
and_expr
19
2005
xor_expr
22
2005
{
52
2005
lambdef
53
2005
atom
54
2005
or_test
23
2005
shift_expr
50
2005
False
35
2005
NEWLINE
1022
2005
-
49
2005
None
42
2005
lambda
40
2005
global
25
2005
NUMBER
27
2005
STRING
28
2005
test
48
2005
endsim
33
2005
and_test
37
2005
simple_stmt
1023
2005
comparison
39
2005
break_stmt
74
2005
+
55
2005
not
57
2005
raise
62
2005
continue
59
2005
return_stmt
75
2005
del_stmt
60
2005
test_list
61
2005
raise_stmt
63
2005
resetstats
64
2005
pass_stmt
65
2005
nonlocal
66
2005
break
76
2005
sim_stmt
77
2005
stat_stmt
78
2005
global_stmt
67
2005
yield_stmt
79
2005
assert_stmt
80
2005
pass
81
2005
yield
68
2005
continue_stmt
69
2005
assert
70
2005
nonlocal_stmt
71
2005
expr_stmt
72
2005
begsim
83
2005
del
84
2006
return
classdef -> class NAME ( ) : suite
2006
def
classdef -> class NAME ( ) : suite
2006
NAME
classdef -> class NAME ( ) : suite
2006
with
classdef -> class NAME ( ) : suite
2006
NEWLINE
classdef -> class NAME ( ) : suite
2006
not
classdef -> class NAME ( ) : suite
2006
True
classdef -> class NAME ( ) : suite
2006
global
classdef -> class NAME ( ) : suite
2006
STRING
classdef -> class NAME ( ) : suite
2006
nonlocal
classdef -> class NAME ( ) : suite
2006
None
classdef -> class NAME ( ) : suite
2006
conf
classdef -> class NAME ( ) : suite
2006
~
classdef -> class NAME ( ) : suite
2006
assert
classdef -> class NAME ( ) : suite
2006
for
classdef -> class NAME ( ) : suite
2006
False
classdef -> class NAME ( ) : suite
2006
del
classdef -> class NAME ( ) : suite
2006
break
classdef -> class NAME ( ) : suite
2006
{
classdef -> class NAME ( ) : suite
2006
-
classdef -> class NAME ( ) : suite
2006
pass
classdef -> class NAME ( ) : suite
2006
raise
classdef -> class NAME ( ) : suite
2006
if
classdef -> class NAME ( ) : suite
2006
[
classdef -> class NAME ( ) : suite
2006
lambda
classdef -> class NAME ( ) : suite
2006
try
classdef -> class NAME ( ) : suite
2006
resetstats
classdef -> class NAME ( ) : suite
2006
+
classdef -> class NAME ( ) : suite
2006
@
classdef -> class NAME ( ) : suite
2006
while
classdef -> class NAME ( ) : suite
2006
$
classdef -> class NAME ( ) : suite
2006
begsim
classdef -> class NAME ( ) : suite
2006
class
classdef -> class NAME ( ) : suite
2006
yield
classdef -> class NAME ( ) : suite
2006
(
classdef -> class NAME ( ) : suite
2006
NUMBER
classdef -> class NAME ( ) : suite
2006
continue
classdef -> class NAME ( ) : suite
2006
endsim
classdef -> class NAME ( ) : suite
2007
DEDENT
2298
2008
and
term -> factor // term
2008
if
term -> factor // term
2008
>
term -> factor // term
2008
<
term -> factor // term
2008
==
term -> factor // term
2008
+
term -> factor // term
2008
-
term -> factor // term
2008
&
term -> factor // term
2008
in
term -> factor // term
2008
:
term -> factor // term
2008
!=
term -> factor // term
2008
^
term -> factor // term
2008
,
term -> factor // term
2008
or
term -> factor // term
2008
<=
term -> factor // term
2008
>=
term -> factor // term
2008
|
term -> factor // term
2008
>>
term -> factor // term
2008
not
term -> factor // term
2008
is
term -> factor // term
2008
<<
term -> factor // term
2009
or
term -> factor / term
2009
<<
term -> factor / term
2009
not
term -> factor / term
2009
in
term -> factor / term
2009
!=
term -> factor / term
2009
<
term -> factor / term
2009
,
term -> factor / term
2009
+
term -> factor / term
2009
and
term -> factor / term
2009
>>
term -> factor / term
2009
^
term -> factor / term
2009
<=
term -> factor / term
2009
==
term -> factor / term
2009
>
term -> factor / term
2009
&
term -> factor / term
2009
is
term -> factor / term
2009
-
term -> factor / term
2009
:
term -> factor / term
2009
|
term -> factor / term
2009
>=
term -> factor / term
2009
if
term -> factor / term
2010
^
term -> factor * term
2010
+
term -> factor * term
2010
==
term -> factor * term
2010
>>
term -> factor * term
2010
in
term -> factor * term
2010
and
term -> factor * term
2010
if
term -> factor * term
2010
is
term -> factor * term
2010
<<
term -> factor * term
2010
:
term -> factor * term
2010
,
term -> factor * term
2010
-
term -> factor * term
2010
!=
term -> factor * term
2010
or
term -> factor * term
2010
>
term -> factor * term
2010
&
term -> factor * term
2010
>=
term -> factor * term
2010
|
term -> factor * term
2010
<=
term -> factor * term
2010
not
term -> factor * term
2010
<
term -> factor * term
2011
&
term -> factor % term
2011
==
term -> factor % term
2011
!=
term -> factor % term
2011
<
term -> factor % term
2011
in
term -> factor % term
2011
>>
term -> factor % term
2011
<<
term -> factor % term
2011
-
term -> factor % term
2011
if
term -> factor % term
2011
>
term -> factor % term
2011
or
term -> factor % term
2011
^
term -> factor % term
2011
+
term -> factor % term
2011
,
term -> factor % term
2011
is
term -> factor % term
2011
|
term -> factor % term
2011
>=
term -> factor % term
2011
<=
term -> factor % term
2011
and
term -> factor % term
2011
not
term -> factor % term
2011
:
term -> factor % term
2012
and
term -> factor @ term
2012
in
term -> factor @ term
2012
>=
term -> factor @ term
2012
<
term -> factor @ term
2012
:
term -> factor @ term
2012
,
term -> factor @ term
2012
>
term -> factor @ term
2012
-
term -> factor @ term
2012
or
term -> factor @ term
2012
<<
term -> factor @ term
2012
is
term -> factor @ term
2012
!=
term -> factor @ term
2012
|
term -> factor @ term
2012
&
term -> factor @ term
2012
==
term -> factor @ term
2012
>>
term -> factor @ term
2012
<=
term -> factor @ term
2012
not
term -> factor @ term
2012
+
term -> factor @ term
2012
^
term -> factor @ term
2012
if
term -> factor @ term
2013
~
for_stmt -> for expr_list in test_list : suite
2013
else
2299
2013
$
for_stmt -> for expr_list in test_list : suite
2013
while
for_stmt -> for expr_list in test_list : suite
2013
return
for_stmt -> for expr_list in test_list : suite
2013
-
for_stmt -> for expr_list in test_list : suite
2013
with
for_stmt -> for expr_list in test_list : suite
2013
break
for_stmt -> for expr_list in test_list : suite
2013
[
for_stmt -> for expr_list in test_list : suite
2013
for
for_stmt -> for expr_list in test_list : suite
2013
NAME
for_stmt -> for expr_list in test_list : suite
2013
assert
for_stmt -> for expr_list in test_list : suite
2013
try
for_stmt -> for expr_list in test_list : suite
2013
if
for_stmt -> for expr_list in test_list : suite
2013
pass
for_stmt -> for expr_list in test_list : suite
2013
{
for_stmt -> for expr_list in test_list : suite
2013
not
for_stmt -> for expr_list in test_list : suite
2013
yield
for_stmt -> for expr_list in test_list : suite
2013
conf
for_stmt -> for expr_list in test_list : suite
2013
nonlocal
for_stmt -> for expr_list in test_list : suite
2013
begsim
for_stmt -> for expr_list in test_list : suite
2013
resetstats
for_stmt -> for expr_list in test_list : suite
2013
def
for_stmt -> for expr_list in test_list : suite
2013
STRING
for_stmt -> for expr_list in test_list : suite
2013
global
for_stmt -> for expr_list in test_list : suite
2013
None
for_stmt -> for expr_list in test_list : suite
2013
raise
for_stmt -> for expr_list in test_list : suite
2013
NEWLINE
for_stmt -> for expr_list in test_list : suite
2013
(
for_stmt -> for expr_list in test_list : suite
2013
del
for_stmt -> for expr_list in test_list : suite
2013
@
for_stmt -> for expr_list in test_list : suite
2013
NUMBER
for_stmt -> for expr_list in test_list : suite
2013
+
for_stmt -> for expr_list in test_list : suite
2013
class
for_stmt -> for expr_list in test_list : suite
2013
lambda
for_stmt -> for expr_list in test_list : suite
2013
endsim
for_stmt -> for expr_list in test_list : suite
2013
False
for_stmt -> for expr_list in test_list : suite
2013
continue
for_stmt -> for expr_list in test_list : suite
2013
True
for_stmt -> for expr_list in test_list : suite
2014
==
arith_expr -> term + arith_expr
2014
!=
arith_expr -> term + arith_expr
2014
<<
arith_expr -> term + arith_expr
2014
&
arith_expr -> term + arith_expr
2014
<
arith_expr -> term + arith_expr
2014
^
arith_expr -> term + arith_expr
2014
,
arith_expr -> term + arith_expr
2014
>=
arith_expr -> term + arith_expr
2014
in
arith_expr -> term + arith_expr
2014
>>
arith_expr -> term + arith_expr
2014
not
arith_expr -> term + arith_expr
2014
:
arith_expr -> term + arith_expr
2014
<=
arith_expr -> term + arith_expr
2014
is
arith_expr -> term + arith_expr
2014
|
arith_expr -> term + arith_expr
2014
and
arith_expr -> term + arith_expr
2014
or
arith_expr -> term + arith_expr
2014
if
arith_expr -> term + arith_expr
2014
>
arith_expr -> term + arith_expr
2015
if
arith_expr -> term - arith_expr
2015
&
arith_expr -> term - arith_expr
2015
>>
arith_expr -> term - arith_expr
2015
:
arith_expr -> term - arith_expr
2015
!=
arith_expr -> term - arith_expr
2015
>=
arith_expr -> term - arith_expr
2015
|
arith_expr -> term - arith_expr
2015
>
arith_expr -> term - arith_expr
2015
<
arith_expr -> term - arith_expr
2015
==
arith_expr -> term - arith_expr
2015
,
arith_expr -> term - arith_expr
2015
and
arith_expr -> term - arith_expr
2015
is
arith_expr -> term - arith_expr
2015
in
arith_expr -> term - arith_expr
2015
^
arith_expr -> term - arith_expr
2015
<<
arith_expr -> term - arith_expr
2015
not
arith_expr -> term - arith_expr
2015
or
arith_expr -> term - arith_expr
2015
<=
arith_expr -> term - arith_expr
2016
+
atom -> ( test_list_comp )
2016
/
atom -> ( test_list_comp )
2016
*
atom -> ( test_list_comp )
2016
[
atom -> ( test_list_comp )
2016
&
atom -> ( test_list_comp )
2016
,
atom -> ( test_list_comp )
2016
**
atom -> ( test_list_comp )
2016
^
atom -> ( test_list_comp )
2016
(
atom -> ( test_list_comp )
2016
and
atom -> ( test_list_comp )
2016
:
atom -> ( test_list_comp )
2016
>
atom -> ( test_list_comp )
2016
-
atom -> ( test_list_comp )
2016
%
atom -> ( test_list_comp )
2016
//
atom -> ( test_list_comp )
2016
in
atom -> ( test_list_comp )
2016
>>
atom -> ( test_list_comp )
2016
not
atom -> ( test_list_comp )
2016
>=
atom -> ( test_list_comp )
2016
or
atom -> ( test_list_comp )
2016
<
atom -> ( test_list_comp )
2016
if
atom -> ( test_list_comp )
2016
|
atom -> ( test_list_comp )
2016
<<
atom -> ( test_list_comp )
2016
@
atom -> ( test_list_comp )
2016
!=
atom -> ( test_list_comp )
2016
is
atom -> ( test_list_comp )
2016
.
atom -> ( test_list_comp )
2016
<=
atom -> ( test_list_comp )
2016
==
atom -> ( test_list_comp )
2017
>=
shift_expr -> arith_expr >> shift_expr
2017
,
shift_expr -> arith_expr >> shift_expr
2017
if
shift_expr -> arith_expr >> shift_expr
2017
<=
shift_expr -> arith_expr >> shift_expr
2017
!=
shift_expr -> arith_expr >> shift_expr
2017
or
shift_expr -> arith_expr >> shift_expr
2017
|
shift_expr -> arith_expr >> shift_expr
2017
is
shift_expr -> arith_expr >> shift_expr
2017
and
shift_expr -> arith_expr >> shift_expr
2017
in
shift_expr -> arith_expr >> shift_expr
2017
^
shift_expr -> arith_expr >> shift_expr
2017
not
shift_expr -> arith_expr >> shift_expr
2017
<
shift_expr -> arith_expr >> shift_expr
2017
==
shift_expr -> arith_expr >> shift_expr
2017
:
shift_expr -> arith_expr >> shift_expr
2017
&
shift_expr -> arith_expr >> shift_expr
2017
>
shift_expr -> arith_expr >> shift_expr
2018
>
shift_expr -> arith_expr << shift_expr
2018
or
shift_expr -> arith_expr << shift_expr
2018
^
shift_expr -> arith_expr << shift_expr
2018
not
shift_expr -> arith_expr << shift_expr
2018
<
shift_expr -> arith_expr << shift_expr
2018
if
shift_expr -> arith_expr << shift_expr
2018
in
shift_expr -> arith_expr << shift_expr
2018
!=
shift_expr -> arith_expr << shift_expr
2018
,
shift_expr -> arith_expr << shift_expr
2018
|
shift_expr -> arith_expr << shift_expr
2018
>=
shift_expr -> arith_expr << shift_expr
2018
and
shift_expr -> arith_expr << shift_expr
2018
==
shift_expr -> arith_expr << shift_expr
2018
&
shift_expr -> arith_expr << shift_expr
2018
<=
shift_expr -> arith_expr << shift_expr
2018
is
shift_expr -> arith_expr << shift_expr
2018
:
shift_expr -> arith_expr << shift_expr
2019
in
atom -> [ test_list_comp ]
2019
/
atom -> [ test_list_comp ]
2019
or
atom -> [ test_list_comp ]
2019
if
atom -> [ test_list_comp ]
2019
<<
atom -> [ test_list_comp ]
2019
!=
atom -> [ test_list_comp ]
2019
<=
atom -> [ test_list_comp ]
2019
>>
atom -> [ test_list_comp ]
2019
*
atom -> [ test_list_comp ]
2019
^
atom -> [ test_list_comp ]
2019
.
atom -> [ test_list_comp ]
2019
(
atom -> [ test_list_comp ]
2019
>=
atom -> [ test_list_comp ]
2019
and
atom -> [ test_list_comp ]
2019
<
atom -> [ test_list_comp ]
2019
,
atom -> [ test_list_comp ]
2019
[
atom -> [ test_list_comp ]
2019
==
atom -> [ test_list_comp ]
2019
@
atom -> [ test_list_comp ]
2019
%
atom -> [ test_list_comp ]
2019
-
atom -> [ test_list_comp ]
2019
|
atom -> [ test_list_comp ]
2019
&
atom -> [ test_list_comp ]
2019
:
atom -> [ test_list_comp ]
2019
+
atom -> [ test_list_comp ]
2019
is
atom -> [ test_list_comp ]
2019
//
atom -> [ test_list_comp ]
2019
**
atom -> [ test_list_comp ]
2019
not
atom -> [ test_list_comp ]
2019
>
atom -> [ test_list_comp ]
2020
and
comparison -> expr comp_op comparison
2020
:
comparison -> expr comp_op comparison
2020
if
comparison -> expr comp_op comparison
2020
or
comparison -> expr comp_op comparison
2020
,
comparison -> expr comp_op comparison
2021
+
power -> atom_expr ** factor
2021
&
power -> atom_expr ** factor
2021
>>
power -> atom_expr ** factor
2021
<<
power -> atom_expr ** factor
2021
not
power -> atom_expr ** factor
2021
is
power -> atom_expr ** factor
2021
@
power -> atom_expr ** factor
2021
:
power -> atom_expr ** factor
2021
==
power -> atom_expr ** factor
2021
*
power -> atom_expr ** factor
2021
or
power -> atom_expr ** factor
2021
>
power -> atom_expr ** factor
2021
-
power -> atom_expr ** factor
2021
if
power -> atom_expr ** factor
2021
!=
power -> atom_expr ** factor
2021
>=
power -> atom_expr ** factor
2021
/
power -> atom_expr ** factor
2021
%
power -> atom_expr ** factor
2021
and
power -> atom_expr ** factor
2021
<=
power -> atom_expr ** factor
2021
<
power -> atom_expr ** factor
2021
|
power -> atom_expr ** factor
2021
^
power -> atom_expr ** factor
2021
in
power -> atom_expr ** factor
2021
,
power -> atom_expr ** factor
2021
//
power -> atom_expr ** factor
2022
+
trailer_expr -> trailer trailer_expr
2022
,
trailer_expr -> trailer trailer_expr
2022
*
trailer_expr -> trailer trailer_expr
2022
/
trailer_expr -> trailer trailer_expr
2022
not
trailer_expr -> trailer trailer_expr
2022
<<
trailer_expr -> trailer trailer_expr
2022
!=
trailer_expr -> trailer trailer_expr
2022
>=
trailer_expr -> trailer trailer_expr
2022
>>
trailer_expr -> trailer trailer_expr
2022
|
trailer_expr -> trailer trailer_expr
2022
%
trailer_expr -> trailer trailer_expr
2022
>
trailer_expr -> trailer trailer_expr
2022
&
trailer_expr -> trailer trailer_expr
2022
-
trailer_expr -> trailer trailer_expr
2022
<=
trailer_expr -> trailer trailer_expr
2022
:
trailer_expr -> trailer trailer_expr
2022
**
trailer_expr -> trailer trailer_expr
2022
@
trailer_expr -> trailer trailer_expr
2022
if
trailer_expr -> trailer trailer_expr
2022
==
trailer_expr -> trailer trailer_expr
2022
or
trailer_expr -> trailer trailer_expr
2022
<
trailer_expr -> trailer trailer_expr
2022
and
trailer_expr -> trailer trailer_expr
2022
in
trailer_expr -> trailer trailer_expr
2022
is
trailer_expr -> trailer trailer_expr
2022
^
trailer_expr -> trailer trailer_expr
2022
//
trailer_expr -> trailer trailer_expr
2023
<=
trailer -> . NAME
2023
<<
trailer -> . NAME
2023
**
trailer -> . NAME
2023
!=
trailer -> . NAME
2023
:
trailer -> . NAME
2023
/
trailer -> . NAME
2023
&
trailer -> . NAME
2023
//
trailer -> . NAME
2023
<
trailer -> . NAME
2023
is
trailer -> . NAME
2023
-
trailer -> . NAME
2023
if
trailer -> . NAME
2023
[
trailer -> . NAME
2023
or
trailer -> . NAME
2023
>
trailer -> . NAME
2023
*
trailer -> . NAME
2023
+
trailer -> . NAME
2023
%
trailer -> . NAME
2023
.
trailer -> . NAME
2023
>=
trailer -> . NAME
2023
|
trailer -> . NAME
2023
and
trailer -> . NAME
2023
(
trailer -> . NAME
2023
,
trailer -> . NAME
2023
==
trailer -> . NAME
2023
^
trailer -> . NAME
2023
in
trailer -> . NAME
2023
@
trailer -> . NAME
2023
not
trailer -> . NAME
2023
>>
trailer -> . NAME
2024
%
trailer -> ( )
2024
<=
trailer -> ( )
2024
and
trailer -> ( )
2024
//
trailer -> ( )
2024
not
trailer -> ( )
2024
or
trailer -> ( )
2024
>>
trailer -> ( )
2024
>
trailer -> ( )
2024
<<
trailer -> ( )
2024
[
trailer -> ( )
2024
is
trailer -> ( )
2024
:
trailer -> ( )
2024
-
trailer -> ( )
2024
**
trailer -> ( )
2024
/
trailer -> ( )
2024
,
trailer -> ( )
2024
+
trailer -> ( )
2024
&
trailer -> ( )
2024
in
trailer -> ( )
2024
^
trailer -> ( )
2024
!=
trailer -> ( )
2024
*
trailer -> ( )
2024
if
trailer -> ( )
2024
>=
trailer -> ( )
2024
(
trailer -> ( )
2024
@
trailer -> ( )
2024
==
trailer -> ( )
2024
|
trailer -> ( )
2024
.
trailer -> ( )
2024
<
trailer -> ( )
2025
)
2300
2026
]
2301
2027
==
and_expr -> shift_expr & and_expr
2027
in
and_expr -> shift_expr & and_expr
2027
!=
and_expr -> shift_expr & and_expr
2027
,
and_expr -> shift_expr & and_expr
2027
or
and_expr -> shift_expr & and_expr
2027
>
and_expr -> shift_expr & and_expr
2027
not
and_expr -> shift_expr & and_expr
2027
:
and_expr -> shift_expr & and_expr
2027
|
and_expr -> shift_expr & and_expr
2027
<=
and_expr -> shift_expr & and_expr
2027
and
and_expr -> shift_expr & and_expr
2027
^
and_expr -> shift_expr & and_expr
2027
is
and_expr -> shift_expr & and_expr
2027
>=
and_expr -> shift_expr & and_expr
2027
<
and_expr -> shift_expr & and_expr
2027
if
and_expr -> shift_expr & and_expr
2028
,
and_test -> not_test and and_test
2028
:
and_test -> not_test and and_test
2028
if
and_test -> not_test and and_test
2028
or
and_test -> not_test and and_test
2029
<=
xor_expr -> and_expr ^ xor_expr
2029
!=
xor_expr -> and_expr ^ xor_expr
2029
and
xor_expr -> and_expr ^ xor_expr
2029
is
xor_expr -> and_expr ^ xor_expr
2029
>=
xor_expr -> and_expr ^ xor_expr
2029
not
xor_expr -> and_expr ^ xor_expr
2029
<
xor_expr -> and_expr ^ xor_expr
2029
:
xor_expr -> and_expr ^ xor_expr
2029
|
xor_expr -> and_expr ^ xor_expr
2029
in
xor_expr -> and_expr ^ xor_expr
2029
==
xor_expr -> and_expr ^ xor_expr
2029
or
xor_expr -> and_expr ^ xor_expr
2029
,
xor_expr -> and_expr ^ xor_expr
2029
if
xor_expr -> and_expr ^ xor_expr
2029
>
xor_expr -> and_expr ^ xor_expr
2030
not
expr -> xor_expr | expr
2030
,
expr -> xor_expr | expr
2030
in
expr -> xor_expr | expr
2030
if
expr -> xor_expr | expr
2030
:
expr -> xor_expr | expr
2030
or
expr -> xor_expr | expr
2030
<=
expr -> xor_expr | expr
2030
>
expr -> xor_expr | expr
2030
!=
expr -> xor_expr | expr
2030
==
expr -> xor_expr | expr
2030
>=
expr -> xor_expr | expr
2030
is
expr -> xor_expr | expr
2030
<
expr -> xor_expr | expr
2030
and
expr -> xor_expr | expr
2031
:
test_list -> test , test_list
2032
,
or_test -> and_test or or_test
2032
if
or_test -> and_test or or_test
2032
:
or_test -> and_test or or_test
2033
,
lambdef -> lambda : test
2033
:
lambdef -> lambda : test
2034
factor
1029
2034
term
1031
2034
(
1032
2034
arith_expr
1033
2034
NAME
1034
2034
[
1035
2034
~
1036
2034
+
1037
2034
expr
1038
2034
atom_expr
1039
2034
atom
1040
2034
NUMBER
1041
2034
STRING
1042
2034
shift_expr
1043
2034
-
1044
2034
True
1045
2034
not_test
1046
2034
and_expr
1047
2034
xor_expr
1048
2034
False
1049
2034
{
1050
2034
None
1051
2034
and_test
1053
2034
power
1054
2034
lambda
1055
2034
or_test
1056
2034
lambdef
1057
2034
comparison
1058
2034
not
1059
2034
test
2302
2035
else
2303
2036
def
decorator -> @ dotted_name ( arglist ) NEWLINE
2036
class
decorator -> @ dotted_name ( arglist ) NEWLINE
2036
@
decorator -> @ dotted_name ( arglist ) NEWLINE
2037
NEWLINE
test -> or_test if or_test else test
2037
,
test -> or_test if or_test else test
2038
endsim
funcdef -> def NAME ( ) : suite
2038
False
funcdef -> def NAME ( ) : suite
2038
-
funcdef -> def NAME ( ) : suite
2038
NAME
funcdef -> def NAME ( ) : suite
2038
assert
funcdef -> def NAME ( ) : suite
2038
def
funcdef -> def NAME ( ) : suite
2038
pass
funcdef -> def NAME ( ) : suite
2038
continue
funcdef -> def NAME ( ) : suite
2038
try
funcdef -> def NAME ( ) : suite
2038
STRING
funcdef -> def NAME ( ) : suite
2038
raise
funcdef -> def NAME ( ) : suite
2038
break
funcdef -> def NAME ( ) : suite
2038
conf
funcdef -> def NAME ( ) : suite
2038
yield
funcdef -> def NAME ( ) : suite
2038
while
funcdef -> def NAME ( ) : suite
2038
True
funcdef -> def NAME ( ) : suite
2038
nonlocal
funcdef -> def NAME ( ) : suite
2038
begsim
funcdef -> def NAME ( ) : suite
2038
NUMBER
funcdef -> def NAME ( ) : suite
2038
@
funcdef -> def NAME ( ) : suite
2038
NEWLINE
funcdef -> def NAME ( ) : suite
2038
{
funcdef -> def NAME ( ) : suite
2038
not
funcdef -> def NAME ( ) : suite
2038
for
funcdef -> def NAME ( ) : suite
2038
None
funcdef -> def NAME ( ) : suite
2038
return
funcdef -> def NAME ( ) : suite
2038
global
funcdef -> def NAME ( ) : suite
2038
(
funcdef -> def NAME ( ) : suite
2038
~
funcdef -> def NAME ( ) : suite
2038
[
funcdef -> def NAME ( ) : suite
2038
with
funcdef -> def NAME ( ) : suite
2038
+
funcdef -> def NAME ( ) : suite
2038
lambda
funcdef -> def NAME ( ) : suite
2038
$
funcdef -> def NAME ( ) : suite
2038
if
funcdef -> def NAME ( ) : suite
2038
class
funcdef -> def NAME ( ) : suite
2038
del
funcdef -> def NAME ( ) : suite
2038
resetstats
funcdef -> def NAME ( ) : suite
2039
factor
9
2039
arith_expr
2
2039
NAME
29
2039
term
21
2039
[
3
2039
~
45
2039
atom_expr
24
2039
expr
16
2039
power
56
2039
(
36
2039
suite
2304
2039
return
13
2039
small_stmt
47
2039
flow_stmt
15
2039
True
17
2039
not_test
18
2039
and_expr
19
2039
xor_expr
22
2039
{
52
2039
lambdef
53
2039
atom
54
2039
or_test
23
2039
shift_expr
50
2039
False
35
2039
NEWLINE
1022
2039
-
49
2039
None
42
2039
lambda
40
2039
global
25
2039
NUMBER
27
2039
STRING
28
2039
test
48
2039
endsim
33
2039
and_test
37
2039
simple_stmt
1023
2039
comparison
39
2039
break_stmt
74
2039
+
55
2039
not
57
2039
raise
62
2039
continue
59
2039
return_stmt
75
2039
del_stmt
60
2039
test_list
61
2039
raise_stmt
63
2039
resetstats
64
2039
pass_stmt
65
2039
nonlocal
66
2039
break
76
2039
sim_stmt
77
2039
stat_stmt
78
2039
global_stmt
67
2039
yield_stmt
79
2039
assert_stmt
80
2039
pass
81
2039
yield
68
2039
continue_stmt
69
2039
assert
70
2039
nonlocal_stmt
71
2039
expr_stmt
72
2039
begsim
83
2039
del
84
2040
,
param -> tfpdef = test
2040
)
param -> tfpdef = test
2041
factor
1221
2041
term
1222
2041
(
1223
2041
arith_expr
1224
2041
NAME
1225
2041
[
1226
2041
+
1227
2041
atom_expr
1228
2041
NUMBER
1229
2041
atom
1230
2041
STRING
1231
2041
shift_expr
1232
2041
-
1233
2041
True
1234
2041
not_test
1235
2041
and_expr
1236
2041
xor_expr
1237
2041
None
1238
2041
False
1239
2041
and_test
1240
2041
{
1241
2041
~
1242
2041
power
1243
2041
expr
1244
2041
lambda
1245
2041
comparison
1246
2041
test
2305
2041
or_test
1247
2041
not
1249
2041
lambdef
1251
2042
)
parameters -> param , parameters
2043
//
2306
2043
in
term -> factor
2043
-
term -> factor
2043
*
2307
2043
%
2308
2043
@
2309
2043
>=
term -> factor
2043
/
2310
2043
=
term -> factor
2043
<
term -> factor
2043
<=
term -> factor
2043
==
term -> factor
2043
!=
term -> factor
2043
>>
term -> factor
2043
is
term -> factor
2043
or
term -> factor
2043
and
term -> factor
2043
^
term -> factor
2043
,
term -> factor
2043
+
term -> factor
2043
&
term -> factor
2043
<<
term -> factor
2043
|
term -> factor
2043
)
term -> factor
2043
>
term -> factor
2043
if
term -> factor
2043
not
term -> factor
2044
+
2311
2044
-
2312
2044
|
arith_expr -> term
2044
)
arith_expr -> term
2044
or
arith_expr -> term
2044
not
arith_expr -> term
2044
<=
arith_expr -> term
2044
!=
arith_expr -> term
2044
<
arith_expr -> term
2044
=
arith_expr -> term
2044
&
arith_expr -> term
2044
>=
arith_expr -> term
2044
if
arith_expr -> term
2044
==
arith_expr -> term
2044
^
arith_expr -> term
2044
in
arith_expr -> term
2044
is
arith_expr -> term
2044
<<
arith_expr -> term
2044
,
arith_expr -> term
2044
>
arith_expr -> term
2044
and
arith_expr -> term
2044
>>
arith_expr -> term
2045
factor
268
2045
term
270
2045
(
271
2045
arith_expr
272
2045
NAME
273
2045
[
274
2045
+
275
2045
test_list_comp
2313
2045
atom_expr
277
2045
NUMBER
278
2045
atom
279
2045
STRING
280
2045
shift_expr
281
2045
-
282
2045
True
283
2045
not_test
284
2045
lambdef
285
2045
and_expr
286
2045
xor_expr
287
2045
False
288
2045
None
289
2045
expr
290
2045
and_test
291
2045
)
2314
2045
{
292
2045
~
293
2045
power
294
2045
lambda
295
2045
comparison
296
2045
or_test
297
2045
not
298
2045
test
299
2045
test_list
300
2046
>>
2315
2046
<<
2316
2046
&
shift_expr -> arith_expr
2046
<=
shift_expr -> arith_expr
2046
>
shift_expr -> arith_expr
2046
)
shift_expr -> arith_expr
2046
not
shift_expr -> arith_expr
2046
!=
shift_expr -> arith_expr
2046
^
shift_expr -> arith_expr
2046
is
shift_expr -> arith_expr
2046
|
shift_expr -> arith_expr
2046
=
shift_expr -> arith_expr
2046
>=
shift_expr -> arith_expr
2046
or
shift_expr -> arith_expr
2046
,
shift_expr -> arith_expr
2046
==
shift_expr -> arith_expr
2046
if
shift_expr -> arith_expr
2046
and
shift_expr -> arith_expr
2046
<
shift_expr -> arith_expr
2046
in
shift_expr -> arith_expr
2047
-
atom -> NAME
2047
,
atom -> NAME
2047
or
atom -> NAME
2047
>>
atom -> NAME
2047
&
atom -> NAME
2047
[
atom -> NAME
2047
<=
atom -> NAME
2047
<
atom -> NAME
2047
.
atom -> NAME
2047
|
atom -> NAME
2047
*
atom -> NAME
2047
/
atom -> NAME
2047
<<
atom -> NAME
2047
not
atom -> NAME
2047
>
atom -> NAME
2047
=
atom -> NAME
2047
is
atom -> NAME
2047
//
atom -> NAME
2047
+
atom -> NAME
2047
if
atom -> NAME
2047
in
atom -> NAME
2047
**
atom -> NAME
2047
!=
atom -> NAME
2047
>=
atom -> NAME
2047
)
atom -> NAME
2047
^
atom -> NAME
2047
@
atom -> NAME
2047
(
atom -> NAME
2047
==
atom -> NAME
2047
and
atom -> NAME
2047
%
atom -> NAME
2048
factor
117
2048
or_test
118
2048
term
119
2048
(
120
2048
test_list_comp
2317
2048
arith_expr
121
2048
NAME
122
2048
[
123
2048
]
2318
2048
+
125
2048
atom_expr
126
2048
NUMBER
127
2048
atom
128
2048
STRING
129
2048
shift_expr
130
2048
-
131
2048
True
133
2048
not_test
134
2048
lambdef
135
2048
and_expr
136
2048
xor_expr
137
2048
False
138
2048
None
139
2048
expr
140
2048
and_test
141
2048
{
142
2048
~
143
2048
lambda
144
2048
power
145
2048
comparison
146
2048
test_list
147
2048
test
148
2048
not
149
2049
trailer
2319
2049
.
2320
2049
(
2321
2049
[
2322
2049
trailer_expr
2323
2049
<<
trailer_expr -> 
2049
%
trailer_expr -> 
2049
==
trailer_expr -> 
2049
-
trailer_expr -> 
2049
<
trailer_expr -> 
2049
if
trailer_expr -> 
2049
or
trailer_expr -> 
2049
/
trailer_expr -> 
2049
**
trailer_expr -> 
2049
and
trailer_expr -> 
2049
@
trailer_expr -> 
2049
=
trailer_expr -> 
2049
*
trailer_expr -> 
2049
|
trailer_expr -> 
2049
is
trailer_expr -> 
2049
,
trailer_expr -> 
2049
+
trailer_expr -> 
2049
in
trailer_expr -> 
2049
&
trailer_expr -> 
2049
<=
trailer_expr -> 
2049
>=
trailer_expr -> 
2049
^
trailer_expr -> 
2049
>
trailer_expr -> 
2049
!=
trailer_expr -> 
2049
)
trailer_expr -> 
2049
not
trailer_expr -> 
2049
>>
trailer_expr -> 
2049
//
trailer_expr -> 
2050
(
2045
2050
NAME
2047
2050
[
2048
2050
atom
2049
2050
+
2050
2050
atom_expr
2052
2050
power
2051
2050
NUMBER
2053
2050
STRING
2054
2050
-
2056
2050
factor
2324
2050
True
2057
2050
None
2061
2050
False
2062
2050
{
2064
2050
~
2065
2051
&
factor -> power
2051
%
factor -> power
2051
<<
factor -> power
2051
-
factor -> power
2051
<=
factor -> power
2051
not
factor -> power
2051
//
factor -> power
2051
/
factor -> power
2051
is
factor -> power
2051
|
factor -> power
2051
<
factor -> power
2051
and
factor -> power
2051
>=
factor -> power
2051
>>
factor -> power
2051
>
factor -> power
2051
)
factor -> power
2051
in
factor -> power
2051
=
factor -> power
2051
if
factor -> power
2051
^
factor -> power
2051
==
factor -> power
2051
+
factor -> power
2051
,
factor -> power
2051
@
factor -> power
2051
or
factor -> power
2051
*
factor -> power
2051
!=
factor -> power
2052
!=
power -> atom_expr
2052
**
2325
2052
>
power -> atom_expr
2052
+
power -> atom_expr
2052
not
power -> atom_expr
2052
&
power -> atom_expr
2052
|
power -> atom_expr
2052
>>
power -> atom_expr
2052
^
power -> atom_expr
2052
==
power -> atom_expr
2052
if
power -> atom_expr
2052
in
power -> atom_expr
2052
%
power -> atom_expr
2052
<<
power -> atom_expr
2052
or
power -> atom_expr
2052
@
power -> atom_expr
2052
=
power -> atom_expr
2052
*
power -> atom_expr
2052
/
power -> atom_expr
2052
)
power -> atom_expr
2052
<
power -> atom_expr
2052
//
power -> atom_expr
2052
>=
power -> atom_expr
2052
-
power -> atom_expr
2052
is
power -> atom_expr
2052
<=
power -> atom_expr
2052
and
power -> atom_expr
2052
,
power -> atom_expr
2053
[
atom -> NUMBER
2053
=
atom -> NUMBER
2053
>=
atom -> NUMBER
2053
<=
atom -> NUMBER
2053
!=
atom -> NUMBER
2053
//
atom -> NUMBER
2053
in
atom -> NUMBER
2053
/
atom -> NUMBER
2053
or
atom -> NUMBER
2053
>
atom -> NUMBER
2053
,
atom -> NUMBER
2053
not
atom -> NUMBER
2053
>>
atom -> NUMBER
2053
(
atom -> NUMBER
2053
**
atom -> NUMBER
2053
<<
atom -> NUMBER
2053
and
atom -> NUMBER
2053
+
atom -> NUMBER
2053
%
atom -> NUMBER
2053
)
atom -> NUMBER
2053
==
atom -> NUMBER
2053
if
atom -> NUMBER
2053
is
atom -> NUMBER
2053
*
atom -> NUMBER
2053
@
atom -> NUMBER
2053
|
atom -> NUMBER
2053
-
atom -> NUMBER
2053
.
atom -> NUMBER
2053
^
atom -> NUMBER
2053
<
atom -> NUMBER
2053
&
atom -> NUMBER
2054
and
atom -> STRING
2054
%
atom -> STRING
2054
//
atom -> STRING
2054
>>
atom -> STRING
2054
*
atom -> STRING
2054
<
atom -> STRING
2054
.
atom -> STRING
2054
in
atom -> STRING
2054
^
atom -> STRING
2054
=
atom -> STRING
2054
(
atom -> STRING
2054
if
atom -> STRING
2054
==
atom -> STRING
2054
-
atom -> STRING
2054
**
atom -> STRING
2054
<<
atom -> STRING
2054
<=
atom -> STRING
2054
[
atom -> STRING
2054
not
atom -> STRING
2054
or
atom -> STRING
2054
)
atom -> STRING
2054
+
atom -> STRING
2054
>=
atom -> STRING
2054
@
atom -> STRING
2054
&
atom -> STRING
2054
>
atom -> STRING
2054
is
atom -> STRING
2054
,
atom -> STRING
2054
|
atom -> STRING
2054
!=
atom -> STRING
2054
/
atom -> STRING
2055
&
2326
2055
^
and_expr -> shift_expr
2055
|
and_expr -> shift_expr
2055
<=
and_expr -> shift_expr
2055
=
and_expr -> shift_expr
2055
)
and_expr -> shift_expr
2055
or
and_expr -> shift_expr
2055
>
and_expr -> shift_expr
2055
not
and_expr -> shift_expr
2055
,
and_expr -> shift_expr
2055
!=
and_expr -> shift_expr
2055
and
and_expr -> shift_expr
2055
is
and_expr -> shift_expr
2055
<
and_expr -> shift_expr
2055
if
and_expr -> shift_expr
2055
in
and_expr -> shift_expr
2055
>=
and_expr -> shift_expr
2055
==
and_expr -> shift_expr
2056
(
2045
2056
NAME
2047
2056
[
2048
2056
atom
2049
2056
+
2050
2056
atom_expr
2052
2056
power
2051
2056
NUMBER
2053
2056
STRING
2054
2056
-
2056
2056
True
2057
2056
None
2061
2056
False
2062
2056
{
2064
2056
~
2065
2056
factor
2327
2057
(
atom -> True
2057
[
atom -> True
2057
+
atom -> True
2057
@
atom -> True
2057
<=
atom -> True
2057
&
atom -> True
2057
=
atom -> True
2057
<<
atom -> True
2057
-
atom -> True
2057
/
atom -> True
2057
)
atom -> True
2057
or
atom -> True
2057
>
atom -> True
2057
%
atom -> True
2057
^
atom -> True
2057
if
atom -> True
2057
!=
atom -> True
2057
is
atom -> True
2057
*
atom -> True
2057
<
atom -> True
2057
,
atom -> True
2057
and
atom -> True
2057
.
atom -> True
2057
==
atom -> True
2057
**
atom -> True
2057
>>
atom -> True
2057
in
atom -> True
2057
|
atom -> True
2057
>=
atom -> True
2057
//
atom -> True
2057
not
atom -> True
2058
and
2328
2058
=
and_test -> not_test
2058
or
and_test -> not_test
2058
)
and_test -> not_test
2058
,
and_test -> not_test
2058
if
and_test -> not_test
2059
^
2329
2059
=
xor_expr -> and_expr
2059
not
xor_expr -> and_expr
2059
if
xor_expr -> and_expr
2059
<=
xor_expr -> and_expr
2059
,
xor_expr -> and_expr
2059
>
xor_expr -> and_expr
2059
<
xor_expr -> and_expr
2059
in
xor_expr -> and_expr
2059
>=
xor_expr -> and_expr
2059
==
xor_expr -> and_expr
2059
|
xor_expr -> and_expr
2059
is
xor_expr -> and_expr
2059
and
xor_expr -> and_expr
2059
or
xor_expr -> and_expr
2059
)
xor_expr -> and_expr
2059
!=
xor_expr -> and_expr
2060
|
2330
2060
>=
expr -> xor_expr
2060
,
expr -> xor_expr
2060
==
expr -> xor_expr
2060
)
expr -> xor_expr
2060
is
expr -> xor_expr
2060
if
expr -> xor_expr
2060
or
expr -> xor_expr
2060
>
expr -> xor_expr
2060
and
expr -> xor_expr
2060
<
expr -> xor_expr
2060
in
expr -> xor_expr
2060
<=
expr -> xor_expr
2060
=
expr -> xor_expr
2060
not
expr -> xor_expr
2060
!=
expr -> xor_expr
2061
is
atom -> None
2061
.
atom -> None
2061
==
atom -> None
2061
^
atom -> None
2061
<<
atom -> None
2061
>>
atom -> None
2061
(
atom -> None
2061
|
atom -> None
2061
=
atom -> None
2061
+
atom -> None
2061
*
atom -> None
2061
//
atom -> None
2061
@
atom -> None
2061
in
atom -> None
2061
>=
atom -> None
2061
!=
atom -> None
2061
%
atom -> None
2061
[
atom -> None
2061
and
atom -> None
2061
-
atom -> None
2061
)
atom -> None
2061
if
atom -> None
2061
&
atom -> None
2061
<=
atom -> None
2061
<
atom -> None
2061
>
atom -> None
2061
,
atom -> None
2061
**
atom -> None
2061
or
atom -> None
2061
/
atom -> None
2061
not
atom -> None
2062
in
atom -> False
2062
>
atom -> False
2062
-
atom -> False
2062
%
atom -> False
2062
<
atom -> False
2062
|
atom -> False
2062
==
atom -> False
2062
&
atom -> False
2062
//
atom -> False
2062
and
atom -> False
2062
not
atom -> False
2062
+
atom -> False
2062
!=
atom -> False
2062
if
atom -> False
2062
)
atom -> False
2062
@
atom -> False
2062
[
atom -> False
2062
or
atom -> False
2062
<=
atom -> False
2062
=
atom -> False
2062
*
atom -> False
2062
^
atom -> False
2062
is
atom -> False
2062
/
atom -> False
2062
.
atom -> False
2062
>=
atom -> False
2062
**
atom -> False
2062
>>
atom -> False
2062
,
atom -> False
2062
<<
atom -> False
2062
(
atom -> False
2063
,
or_test -> and_test
2063
or
2331
2063
=
or_test -> and_test
2063
)
or_test -> and_test
2063
if
or_test -> and_test
2064
}
2332
2065
(
2045
2065
NAME
2047
2065
[
2048
2065
atom
2049
2065
+
2050
2065
factor
2333
2065
atom_expr
2052
2065
power
2051
2065
NUMBER
2053
2065
STRING
2054
2065
-
2056
2065
True
2057
2065
None
2061
2065
False
2062
2065
{
2064
2065
~
2065
2066
is
215
2066
<
217
2066
!=
218
2066
in
219
2066
<=
220
2066
not
221
2066
>=
222
2066
>
223
2066
==
224
2066
comp_op
2334
2066
and
comparison -> expr
2066
or
comparison -> expr
2066
=
comparison -> expr
2066
if
comparison -> expr
2066
,
comparison -> expr
2066
)
comparison -> expr
2067
:
2335
2067
varargslist
2336
2067
NAME
305
2067
vfpdef
306
2068
=
not_test -> comparison
2068
or
not_test -> comparison
2068
and
not_test -> comparison
2068
,
not_test -> comparison
2068
if
not_test -> comparison
2068
)
not_test -> comparison
2069
)
tfpdef -> NAME : test
2069
=
tfpdef -> NAME : test
2069
,
tfpdef -> NAME : test
2070
if
2337
2070
,
test -> or_test
2070
=
test -> or_test
2070
)
test -> or_test
2071
,
test -> lambdef
2071
=
test -> lambdef
2071
)
test -> lambdef
2072
factor
2043
2072
term
2044
2072
(
2045
2072
arith_expr
2046
2072
NAME
2047
2072
[
2048
2072
atom
2049
2072
+
2050
2072
power
2051
2072
atom_expr
2052
2072
NUMBER
2053
2072
STRING
2054
2072
shift_expr
2055
2072
-
2056
2072
not_test
2338
2072
True
2057
2072
and_expr
2059
2072
xor_expr
2060
2072
None
2061
2072
False
2062
2072
{
2064
2072
~
2065
2072
expr
2066
2072
comparison
2068
2072
not
2072
2073
|
trailer -> [ subscriptlist ]
2073
not
trailer -> [ subscriptlist ]
2073
in
trailer -> [ subscriptlist ]
2073
==
trailer -> [ subscriptlist ]
2073
**
trailer -> [ subscriptlist ]
2073
*
trailer -> [ subscriptlist ]
2073
>>
trailer -> [ subscriptlist ]
2073
!=
trailer -> [ subscriptlist ]
2073
or
trailer -> [ subscriptlist ]
2073
>=
trailer -> [ subscriptlist ]
2073
else
trailer -> [ subscriptlist ]
2073
/
trailer -> [ subscriptlist ]
2073
[
trailer -> [ subscriptlist ]
2073
>
trailer -> [ subscriptlist ]
2073
<
trailer -> [ subscriptlist ]
2073
.
trailer -> [ subscriptlist ]
2073
and
trailer -> [ subscriptlist ]
2073
(
trailer -> [ subscriptlist ]
2073
<=
trailer -> [ subscriptlist ]
2073
-
trailer -> [ subscriptlist ]
2073
@
trailer -> [ subscriptlist ]
2073
<<
trailer -> [ subscriptlist ]
2073
&
trailer -> [ subscriptlist ]
2073
^
trailer -> [ subscriptlist ]
2073
is
trailer -> [ subscriptlist ]
2073
%
trailer -> [ subscriptlist ]
2073
+
trailer -> [ subscriptlist ]
2073
//
trailer -> [ subscriptlist ]
2074
**
trailer -> ( arglist )
2074
else
trailer -> ( arglist )
2074
<
trailer -> ( arglist )
2074
//
trailer -> ( arglist )
2074
<<
trailer -> ( arglist )
2074
%
trailer -> ( arglist )
2074
&
trailer -> ( arglist )
2074
==
trailer -> ( arglist )
2074
is
trailer -> ( arglist )
2074
!=
trailer -> ( arglist )
2074
and
trailer -> ( arglist )
2074
-
trailer -> ( arglist )
2074
+
trailer -> ( arglist )
2074
>=
trailer -> ( arglist )
2074
or
trailer -> ( arglist )
2074
(
trailer -> ( arglist )
2074
^
trailer -> ( arglist )
2074
.
trailer -> ( arglist )
2074
not
trailer -> ( arglist )
2074
>>
trailer -> ( arglist )
2074
/
trailer -> ( arglist )
2074
*
trailer -> ( arglist )
2074
[
trailer -> ( arglist )
2074
@
trailer -> ( arglist )
2074
>
trailer -> ( arglist )
2074
|
trailer -> ( arglist )
2074
<=
trailer -> ( arglist )
2074
in
trailer -> ( arglist )
2075
as
test -> or_test if or_test else test
2075
:
test -> or_test if or_test else test
2075
,
test -> or_test if or_test else test
2076
+
term -> factor // term
2076
,
term -> factor // term
2076
>>
term -> factor // term
2076
&
term -> factor // term
2076
-
term -> factor // term
2076
:
term -> factor // term
2076
^
term -> factor // term
2076
<<
term -> factor // term
2076
|
term -> factor // term
2077
>>
term -> factor / term
2077
+
term -> factor / term
2077
^
term -> factor / term
2077
|
term -> factor / term
2077
<<
term -> factor / term
2077
&
term -> factor / term
2077
-
term -> factor / term
2077
,
term -> factor / term
2077
:
term -> factor / term
2078
,
term -> factor @ term
2078
>>
term -> factor @ term
2078
-
term -> factor @ term
2078
|
term -> factor @ term
2078
+
term -> factor @ term
2078
<<
term -> factor @ term
2078
&
term -> factor @ term
2078
^
term -> factor @ term
2078
:
term -> factor @ term
2079
<<
term -> factor % term
2079
|
term -> factor % term
2079
&
term -> factor % term
2079
-
term -> factor % term
2079
^
term -> factor % term
2079
+
term -> factor % term
2079
,
term -> factor % term
2079
:
term -> factor % term
2079
>>
term -> factor % term
2080
:
term -> factor * term
2080
,
term -> factor * term
2080
-
term -> factor * term
2080
^
term -> factor * term
2080
+
term -> factor * term
2080
>>
term -> factor * term
2080
<<
term -> factor * term
2080
|
term -> factor * term
2080
&
term -> factor * term
2081
&
arith_expr -> term - arith_expr
2081
>>
arith_expr -> term - arith_expr
2081
:
arith_expr -> term - arith_expr
2081
^
arith_expr -> term - arith_expr
2081
<<
arith_expr -> term - arith_expr
2081
,
arith_expr -> term - arith_expr
2081
|
arith_expr -> term - arith_expr
2082
,
arith_expr -> term + arith_expr
2082
|
arith_expr -> term + arith_expr
2082
>>
arith_expr -> term + arith_expr
2082
&
arith_expr -> term + arith_expr
2082
<<
arith_expr -> term + arith_expr
2082
^
arith_expr -> term + arith_expr
2082
:
arith_expr -> term + arith_expr
2083
(
atom -> ( test_list_comp )
2083
+
atom -> ( test_list_comp )
2083
**
atom -> ( test_list_comp )
2083
>>
atom -> ( test_list_comp )
2083
.
atom -> ( test_list_comp )
2083
/
atom -> ( test_list_comp )
2083
:
atom -> ( test_list_comp )
2083
*
atom -> ( test_list_comp )
2083
-
atom -> ( test_list_comp )
2083
[
atom -> ( test_list_comp )
2083
&
atom -> ( test_list_comp )
2083
,
atom -> ( test_list_comp )
2083
|
atom -> ( test_list_comp )
2083
@
atom -> ( test_list_comp )
2083
<<
atom -> ( test_list_comp )
2083
%
atom -> ( test_list_comp )
2083
^
atom -> ( test_list_comp )
2083
//
atom -> ( test_list_comp )
2084
,
atom -> [ test_list_comp ]
2084
/
atom -> [ test_list_comp ]
2084
.
atom -> [ test_list_comp ]
2084
[
atom -> [ test_list_comp ]
2084
//
atom -> [ test_list_comp ]
2084
<<
atom -> [ test_list_comp ]
2084
(
atom -> [ test_list_comp ]
2084
-
atom -> [ test_list_comp ]
2084
%
atom -> [ test_list_comp ]
2084
**
atom -> [ test_list_comp ]
2084
*
atom -> [ test_list_comp ]
2084
>>
atom -> [ test_list_comp ]
2084
@
atom -> [ test_list_comp ]
2084
|
atom -> [ test_list_comp ]
2084
&
atom -> [ test_list_comp ]
2084
^
atom -> [ test_list_comp ]
2084
:
atom -> [ test_list_comp ]
2084
+
atom -> [ test_list_comp ]
2085
:
power -> atom_expr ** factor
2085
+
power -> atom_expr ** factor
2085
&
power -> atom_expr ** factor
2085
*
power -> atom_expr ** factor
2085
|
power -> atom_expr ** factor
2085
^
power -> atom_expr ** factor
2085
@
power -> atom_expr ** factor
2085
>>
power -> atom_expr ** factor
2085
<<
power -> atom_expr ** factor
2085
,
power -> atom_expr ** factor
2085
/
power -> atom_expr ** factor
2085
%
power -> atom_expr ** factor
2085
//
power -> atom_expr ** factor
2085
-
power -> atom_expr ** factor
2086
,
shift_expr -> arith_expr >> shift_expr
2086
|
shift_expr -> arith_expr >> shift_expr
2086
^
shift_expr -> arith_expr >> shift_expr
2086
:
shift_expr -> arith_expr >> shift_expr
2086
&
shift_expr -> arith_expr >> shift_expr
2087
^
shift_expr -> arith_expr << shift_expr
2087
,
shift_expr -> arith_expr << shift_expr
2087
|
shift_expr -> arith_expr << shift_expr
2087
&
shift_expr -> arith_expr << shift_expr
2087
:
shift_expr -> arith_expr << shift_expr
2088
,
xor_expr -> and_expr ^ xor_expr
2088
:
xor_expr -> and_expr ^ xor_expr
2088
|
xor_expr -> and_expr ^ xor_expr
2089
,
and_expr -> shift_expr & and_expr
2089
^
and_expr -> shift_expr & and_expr
2089
|
and_expr -> shift_expr & and_expr
2089
:
and_expr -> shift_expr & and_expr
2090
,
expr -> xor_expr | expr
2090
:
expr -> xor_expr | expr
2091
**
trailer_expr -> trailer trailer_expr
2091
,
trailer_expr -> trailer trailer_expr
2091
*
trailer_expr -> trailer trailer_expr
2091
+
trailer_expr -> trailer trailer_expr
2091
%
trailer_expr -> trailer trailer_expr
2091
//
trailer_expr -> trailer trailer_expr
2091
&
trailer_expr -> trailer trailer_expr
2091
-
trailer_expr -> trailer trailer_expr
2091
@
trailer_expr -> trailer trailer_expr
2091
/
trailer_expr -> trailer trailer_expr
2091
<<
trailer_expr -> trailer trailer_expr
2091
:
trailer_expr -> trailer trailer_expr
2091
^
trailer_expr -> trailer trailer_expr
2091
>>
trailer_expr -> trailer trailer_expr
2091
|
trailer_expr -> trailer trailer_expr
2092
)
2339
2093
-
trailer -> ( )
2093
%
trailer -> ( )
2093
**
trailer -> ( )
2093
/
trailer -> ( )
2093
,
trailer -> ( )
2093
+
trailer -> ( )
2093
&
trailer -> ( )
2093
^
trailer -> ( )
2093
>>
trailer -> ( )
2093
<<
trailer -> ( )
2093
//
trailer -> ( )
2093
(
trailer -> ( )
2093
@
trailer -> ( )
2093
[
trailer -> ( )
2093
|
trailer -> ( )
2093
.
trailer -> ( )
2093
:
trailer -> ( )
2093
*
trailer -> ( )
2094
-
trailer -> . NAME
2094
,
trailer -> . NAME
2094
/
trailer -> . NAME
2094
[
trailer -> . NAME
2094
+
trailer -> . NAME
2094
^
trailer -> . NAME
2094
@
trailer -> . NAME
2094
.
trailer -> . NAME
2094
%
trailer -> . NAME
2094
<<
trailer -> . NAME
2094
|
trailer -> . NAME
2094
*
trailer -> . NAME
2094
**
trailer -> . NAME
2094
:
trailer -> . NAME
2094
(
trailer -> . NAME
2094
&
trailer -> . NAME
2094
//
trailer -> . NAME
2094
>>
trailer -> . NAME
2095
]
2340
2096
for
test -> or_test if or_test else test
2096
)
test -> or_test if or_test else test
2096
,
test -> or_test if or_test else test
2097
and
term -> factor // term
2097
if
term -> factor // term
2097
>
term -> factor // term
2097
<
term -> factor // term
2097
==
term -> factor // term
2097
+
term -> factor // term
2097
-
term -> factor // term
2097
&
term -> factor // term
2097
in
term -> factor // term
2097
!=
term -> factor // term
2097
^
term -> factor // term
2097
,
term -> factor // term
2097
)
term -> factor // term
2097
or
term -> factor // term
2097
<=
term -> factor // term
2097
>=
term -> factor // term
2097
|
term -> factor // term
2097
>>
term -> factor // term
2097
not
term -> factor // term
2097
is
term -> factor // term
2097
<<
term -> factor // term
2098
^
term -> factor * term
2098
+
term -> factor * term
2098
==
term -> factor * term
2098
>>
term -> factor * term
2098
in
term -> factor * term
2098
and
term -> factor * term
2098
if
term -> factor * term
2098
is
term -> factor * term
2098
<<
term -> factor * term
2098
,
term -> factor * term
2098
-
term -> factor * term
2098
!=
term -> factor * term
2098
or
term -> factor * term
2098
>
term -> factor * term
2098
&
term -> factor * term
2098
)
term -> factor * term
2098
>=
term -> factor * term
2098
|
term -> factor * term
2098
<=
term -> factor * term
2098
not
term -> factor * term
2098
<
term -> factor * term
2099
&
term -> factor % term
2099
==
term -> factor % term
2099
!=
term -> factor % term
2099
)
term -> factor % term
2099
<
term -> factor % term
2099
in
term -> factor % term
2099
>>
term -> factor % term
2099
<<
term -> factor % term
2099
-
term -> factor % term
2099
if
term -> factor % term
2099
>
term -> factor % term
2099
or
term -> factor % term
2099
^
term -> factor % term
2099
+
term -> factor % term
2099
,
term -> factor % term
2099
is
term -> factor % term
2099
|
term -> factor % term
2099
>=
term -> factor % term
2099
<=
term -> factor % term
2099
and
term -> factor % term
2099
not
term -> factor % term
2100
and
term -> factor @ term
2100
in
term -> factor @ term
2100
>=
term -> factor @ term
2100
<
term -> factor @ term
2100
,
term -> factor @ term
2100
>
term -> factor @ term
2100
-
term -> factor @ term
2100
or
term -> factor @ term
2100
)
term -> factor @ term
2100
<<
term -> factor @ term
2100
is
term -> factor @ term
2100
!=
term -> factor @ term
2100
|
term -> factor @ term
2100
&
term -> factor @ term
2100
==
term -> factor @ term
2100
>>
term -> factor @ term
2100
<=
term -> factor @ term
2100
not
term -> factor @ term
2100
+
term -> factor @ term
2100
^
term -> factor @ term
2100
if
term -> factor @ term
2101
or
term -> factor / term
2101
<<
term -> factor / term
2101
not
term -> factor / term
2101
in
term -> factor / term
2101
!=
term -> factor / term
2101
<
term -> factor / term
2101
,
term -> factor / term
2101
+
term -> factor / term
2101
and
term -> factor / term
2101
>>
term -> factor / term
2101
^
term -> factor / term
2101
<=
term -> factor / term
2101
==
term -> factor / term
2101
>
term -> factor / term
2101
&
term -> factor / term
2101
is
term -> factor / term
2101
-
term -> factor / term
2101
)
term -> factor / term
2101
|
term -> factor / term
2101
>=
term -> factor / term
2101
if
term -> factor / term
2102
==
arith_expr -> term + arith_expr
2102
!=
arith_expr -> term + arith_expr
2102
<<
arith_expr -> term + arith_expr
2102
&
arith_expr -> term + arith_expr
2102
<
arith_expr -> term + arith_expr
2102
^
arith_expr -> term + arith_expr
2102
,
arith_expr -> term + arith_expr
2102
>=
arith_expr -> term + arith_expr
2102
in
arith_expr -> term + arith_expr
2102
)
arith_expr -> term + arith_expr
2102
>>
arith_expr -> term + arith_expr
2102
not
arith_expr -> term + arith_expr
2102
<=
arith_expr -> term + arith_expr
2102
is
arith_expr -> term + arith_expr
2102
|
arith_expr -> term + arith_expr
2102
and
arith_expr -> term + arith_expr
2102
or
arith_expr -> term + arith_expr
2102
if
arith_expr -> term + arith_expr
2102
>
arith_expr -> term + arith_expr
2103
if
arith_expr -> term - arith_expr
2103
&
arith_expr -> term - arith_expr
2103
>>
arith_expr -> term - arith_expr
2103
!=
arith_expr -> term - arith_expr
2103
)
arith_expr -> term - arith_expr
2103
>=
arith_expr -> term - arith_expr
2103
|
arith_expr -> term - arith_expr
2103
>
arith_expr -> term - arith_expr
2103
<
arith_expr -> term - arith_expr
2103
==
arith_expr -> term - arith_expr
2103
,
arith_expr -> term - arith_expr
2103
and
arith_expr -> term - arith_expr
2103
is
arith_expr -> term - arith_expr
2103
in
arith_expr -> term - arith_expr
2103
^
arith_expr -> term - arith_expr
2103
<<
arith_expr -> term - arith_expr
2103
not
arith_expr -> term - arith_expr
2103
or
arith_expr -> term - arith_expr
2103
<=
arith_expr -> term - arith_expr
2104
+
atom -> ( test_list_comp )
2104
/
atom -> ( test_list_comp )
2104
*
atom -> ( test_list_comp )
2104
[
atom -> ( test_list_comp )
2104
&
atom -> ( test_list_comp )
2104
,
atom -> ( test_list_comp )
2104
**
atom -> ( test_list_comp )
2104
^
atom -> ( test_list_comp )
2104
(
atom -> ( test_list_comp )
2104
and
atom -> ( test_list_comp )
2104
)
atom -> ( test_list_comp )
2104
>
atom -> ( test_list_comp )
2104
-
atom -> ( test_list_comp )
2104
%
atom -> ( test_list_comp )
2104
//
atom -> ( test_list_comp )
2104
in
atom -> ( test_list_comp )
2104
>>
atom -> ( test_list_comp )
2104
not
atom -> ( test_list_comp )
2104
>=
atom -> ( test_list_comp )
2104
or
atom -> ( test_list_comp )
2104
<
atom -> ( test_list_comp )
2104
if
atom -> ( test_list_comp )
2104
|
atom -> ( test_list_comp )
2104
<<
atom -> ( test_list_comp )
2104
@
atom -> ( test_list_comp )
2104
!=
atom -> ( test_list_comp )
2104
is
atom -> ( test_list_comp )
2104
.
atom -> ( test_list_comp )
2104
<=
atom -> ( test_list_comp )
2104
==
atom -> ( test_list_comp )
2105
>=
shift_expr -> arith_expr >> shift_expr
2105
,
shift_expr -> arith_expr >> shift_expr
2105
if
shift_expr -> arith_expr >> shift_expr
2105
<=
shift_expr -> arith_expr >> shift_expr
2105
!=
shift_expr -> arith_expr >> shift_expr
2105
or
shift_expr -> arith_expr >> shift_expr
2105
|
shift_expr -> arith_expr >> shift_expr
2105
is
shift_expr -> arith_expr >> shift_expr
2105
)
shift_expr -> arith_expr >> shift_expr
2105
and
shift_expr -> arith_expr >> shift_expr
2105
in
shift_expr -> arith_expr >> shift_expr
2105
^
shift_expr -> arith_expr >> shift_expr
2105
not
shift_expr -> arith_expr >> shift_expr
2105
<
shift_expr -> arith_expr >> shift_expr
2105
==
shift_expr -> arith_expr >> shift_expr
2105
&
shift_expr -> arith_expr >> shift_expr
2105
>
shift_expr -> arith_expr >> shift_expr
2106
>
shift_expr -> arith_expr << shift_expr
2106
or
shift_expr -> arith_expr << shift_expr
2106
^
shift_expr -> arith_expr << shift_expr
2106
not
shift_expr -> arith_expr << shift_expr
2106
<
shift_expr -> arith_expr << shift_expr
2106
if
shift_expr -> arith_expr << shift_expr
2106
in
shift_expr -> arith_expr << shift_expr
2106
!=
shift_expr -> arith_expr << shift_expr
2106
,
shift_expr -> arith_expr << shift_expr
2106
|
shift_expr -> arith_expr << shift_expr
2106
>=
shift_expr -> arith_expr << shift_expr
2106
)
shift_expr -> arith_expr << shift_expr
2106
and
shift_expr -> arith_expr << shift_expr
2106
==
shift_expr -> arith_expr << shift_expr
2106
&
shift_expr -> arith_expr << shift_expr
2106
<=
shift_expr -> arith_expr << shift_expr
2106
is
shift_expr -> arith_expr << shift_expr
2107
in
atom -> [ test_list_comp ]
2107
/
atom -> [ test_list_comp ]
2107
or
atom -> [ test_list_comp ]
2107
if
atom -> [ test_list_comp ]
2107
<<
atom -> [ test_list_comp ]
2107
!=
atom -> [ test_list_comp ]
2107
<=
atom -> [ test_list_comp ]
2107
)
atom -> [ test_list_comp ]
2107
>>
atom -> [ test_list_comp ]
2107
*
atom -> [ test_list_comp ]
2107
^
atom -> [ test_list_comp ]
2107
.
atom -> [ test_list_comp ]
2107
(
atom -> [ test_list_comp ]
2107
>=
atom -> [ test_list_comp ]
2107
and
atom -> [ test_list_comp ]
2107
<
atom -> [ test_list_comp ]
2107
,
atom -> [ test_list_comp ]
2107
[
atom -> [ test_list_comp ]
2107
==
atom -> [ test_list_comp ]
2107
@
atom -> [ test_list_comp ]
2107
%
atom -> [ test_list_comp ]
2107
-
atom -> [ test_list_comp ]
2107
|
atom -> [ test_list_comp ]
2107
&
atom -> [ test_list_comp ]
2107
+
atom -> [ test_list_comp ]
2107
is
atom -> [ test_list_comp ]
2107
//
atom -> [ test_list_comp ]
2107
**
atom -> [ test_list_comp ]
2107
not
atom -> [ test_list_comp ]
2107
>
atom -> [ test_list_comp ]
2108
+
power -> atom_expr ** factor
2108
&
power -> atom_expr ** factor
2108
>>
power -> atom_expr ** factor
2108
<<
power -> atom_expr ** factor
2108
not
power -> atom_expr ** factor
2108
is
power -> atom_expr ** factor
2108
@
power -> atom_expr ** factor
2108
==
power -> atom_expr ** factor
2108
*
power -> atom_expr ** factor
2108
or
power -> atom_expr ** factor
2108
>
power -> atom_expr ** factor
2108
-
power -> atom_expr ** factor
2108
)
power -> atom_expr ** factor
2108
if
power -> atom_expr ** factor
2108
!=
power -> atom_expr ** factor
2108
>=
power -> atom_expr ** factor
2108
/
power -> atom_expr ** factor
2108
%
power -> atom_expr ** factor
2108
and
power -> atom_expr ** factor
2108
<=
power -> atom_expr ** factor
2108
<
power -> atom_expr ** factor
2108
|
power -> atom_expr ** factor
2108
^
power -> atom_expr ** factor
2108
in
power -> atom_expr ** factor
2108
,
power -> atom_expr ** factor
2108
//
power -> atom_expr ** factor
2109
+
trailer_expr -> trailer trailer_expr
2109
,
trailer_expr -> trailer trailer_expr
2109
*
trailer_expr -> trailer trailer_expr
2109
/
trailer_expr -> trailer trailer_expr
2109
not
trailer_expr -> trailer trailer_expr
2109
<<
trailer_expr -> trailer trailer_expr
2109
!=
trailer_expr -> trailer trailer_expr
2109
>=
trailer_expr -> trailer trailer_expr
2109
)
trailer_expr -> trailer trailer_expr
2109
>>
trailer_expr -> trailer trailer_expr
2109
|
trailer_expr -> trailer trailer_expr
2109
%
trailer_expr -> trailer trailer_expr
2109
>
trailer_expr -> trailer trailer_expr
2109
&
trailer_expr -> trailer trailer_expr
2109
-
trailer_expr -> trailer trailer_expr
2109
<=
trailer_expr -> trailer trailer_expr
2109
**
trailer_expr -> trailer trailer_expr
2109
@
trailer_expr -> trailer trailer_expr
2109
if
trailer_expr -> trailer trailer_expr
2109
==
trailer_expr -> trailer trailer_expr
2109
or
trailer_expr -> trailer trailer_expr
2109
<
trailer_expr -> trailer trailer_expr
2109
and
trailer_expr -> trailer trailer_expr
2109
in
trailer_expr -> trailer trailer_expr
2109
is
trailer_expr -> trailer trailer_expr
2109
^
trailer_expr -> trailer trailer_expr
2109
//
trailer_expr -> trailer trailer_expr
2110
<=
trailer -> . NAME
2110
<<
trailer -> . NAME
2110
**
trailer -> . NAME
2110
!=
trailer -> . NAME
2110
/
trailer -> . NAME
2110
&
trailer -> . NAME
2110
//
trailer -> . NAME
2110
<
trailer -> . NAME
2110
is
trailer -> . NAME
2110
-
trailer -> . NAME
2110
if
trailer -> . NAME
2110
[
trailer -> . NAME
2110
or
trailer -> . NAME
2110
>
trailer -> . NAME
2110
*
trailer -> . NAME
2110
+
trailer -> . NAME
2110
)
trailer -> . NAME
2110
%
trailer -> . NAME
2110
.
trailer -> . NAME
2110
>=
trailer -> . NAME
2110
|
trailer -> . NAME
2110
and
trailer -> . NAME
2110
(
trailer -> . NAME
2110
,
trailer -> . NAME
2110
==
trailer -> . NAME
2110
^
trailer -> . NAME
2110
in
trailer -> . NAME
2110
@
trailer -> . NAME
2110
not
trailer -> . NAME
2110
>>
trailer -> . NAME
2111
%
trailer -> ( )
2111
<=
trailer -> ( )
2111
and
trailer -> ( )
2111
//
trailer -> ( )
2111
not
trailer -> ( )
2111
or
trailer -> ( )
2111
>>
trailer -> ( )
2111
>
trailer -> ( )
2111
<<
trailer -> ( )
2111
[
trailer -> ( )
2111
is
trailer -> ( )
2111
-
trailer -> ( )
2111
**
trailer -> ( )
2111
/
trailer -> ( )
2111
,
trailer -> ( )
2111
+
trailer -> ( )
2111
&
trailer -> ( )
2111
in
trailer -> ( )
2111
^
trailer -> ( )
2111
!=
trailer -> ( )
2111
*
trailer -> ( )
2111
if
trailer -> ( )
2111
>=
trailer -> ( )
2111
(
trailer -> ( )
2111
@
trailer -> ( )
2111
)
trailer -> ( )
2111
==
trailer -> ( )
2111
|
trailer -> ( )
2111
.
trailer -> ( )
2111
<
trailer -> ( )
2112
)
2341
2113
]
2342
2114
==
and_expr -> shift_expr & and_expr
2114
in
and_expr -> shift_expr & and_expr
2114
!=
and_expr -> shift_expr & and_expr
2114
,
and_expr -> shift_expr & and_expr
2114
or
and_expr -> shift_expr & and_expr
2114
>
and_expr -> shift_expr & and_expr
2114
not
and_expr -> shift_expr & and_expr
2114
<=
and_expr -> shift_expr & and_expr
2114
|
and_expr -> shift_expr & and_expr
2114
and
and_expr -> shift_expr & and_expr
2114
)
and_expr -> shift_expr & and_expr
2114
^
and_expr -> shift_expr & and_expr
2114
is
and_expr -> shift_expr & and_expr
2114
>=
and_expr -> shift_expr & and_expr
2114
<
and_expr -> shift_expr & and_expr
2114
if
and_expr -> shift_expr & and_expr
2115
)
and_test -> not_test and and_test
2115
,
and_test -> not_test and and_test
2115
if
and_test -> not_test and and_test
2115
or
and_test -> not_test and and_test
2116
<=
xor_expr -> and_expr ^ xor_expr
2116
!=
xor_expr -> and_expr ^ xor_expr
2116
and
xor_expr -> and_expr ^ xor_expr
2116
)
xor_expr -> and_expr ^ xor_expr
2116
is
xor_expr -> and_expr ^ xor_expr
2116
>=
xor_expr -> and_expr ^ xor_expr
2116
not
xor_expr -> and_expr ^ xor_expr
2116
<
xor_expr -> and_expr ^ xor_expr
2116
|
xor_expr -> and_expr ^ xor_expr
2116
in
xor_expr -> and_expr ^ xor_expr
2116
==
xor_expr -> and_expr ^ xor_expr
2116
or
xor_expr -> and_expr ^ xor_expr
2116
,
xor_expr -> and_expr ^ xor_expr
2116
if
xor_expr -> and_expr ^ xor_expr
2116
>
xor_expr -> and_expr ^ xor_expr
2117
)
expr -> xor_expr | expr
2117
not
expr -> xor_expr | expr
2117
,
expr -> xor_expr | expr
2117
in
expr -> xor_expr | expr
2117
if
expr -> xor_expr | expr
2117
or
expr -> xor_expr | expr
2117
<=
expr -> xor_expr | expr
2117
>
expr -> xor_expr | expr
2117
!=
expr -> xor_expr | expr
2117
==
expr -> xor_expr | expr
2117
>=
expr -> xor_expr | expr
2117
is
expr -> xor_expr | expr
2117
<
expr -> xor_expr | expr
2117
and
expr -> xor_expr | expr
2118
,
or_test -> and_test or or_test
2118
if
or_test -> and_test or or_test
2118
)
or_test -> and_test or or_test
2119
)
comparison -> expr comp_op comparison
2119
and
comparison -> expr comp_op comparison
2119
if
comparison -> expr comp_op comparison
2119
or
comparison -> expr comp_op comparison
2119
,
comparison -> expr comp_op comparison
2120
factor
1221
2120
term
1222
2120
(
1223
2120
arith_expr
1224
2120
NAME
1225
2120
[
1226
2120
+
1227
2120
atom_expr
1228
2120
NUMBER
1229
2120
atom
1230
2120
STRING
1231
2120
shift_expr
1232
2120
-
1233
2120
True
1234
2120
not_test
1235
2120
and_expr
1236
2120
xor_expr
1237
2120
None
1238
2120
False
1239
2120
and_test
1240
2120
{
1241
2120
~
1242
2120
power
1243
2120
test
2343
2120
expr
1244
2120
lambda
1245
2120
comparison
1246
2120
or_test
1247
2120
not
1249
2120
lambdef
1251
2121
,
lambdef -> lambda : test
2121
)
lambdef -> lambda : test
2122
else
2344
2123
//
2345
2123
in
term -> factor
2123
-
term -> factor
2123
*
2346
2123
%
2347
2123
@
2348
2123
>=
term -> factor
2123
/
2349
2123
<
term -> factor
2123
<=
term -> factor
2123
==
term -> factor
2123
!=
term -> factor
2123
>>
term -> factor
2123
is
term -> factor
2123
or
term -> factor
2123
and
term -> factor
2123
for
term -> factor
2123
^
term -> factor
2123
+
term -> factor
2123
&
term -> factor
2123
<<
term -> factor
2123
|
term -> factor
2123
)
term -> factor
2123
>
term -> factor
2123
if
term -> factor
2123
not
term -> factor
2124
factor
268
2124
term
270
2124
(
271
2124
arith_expr
272
2124
NAME
273
2124
[
274
2124
+
275
2124
test_list_comp
2350
2124
atom_expr
277
2124
NUMBER
278
2124
atom
279
2124
STRING
280
2124
shift_expr
281
2124
-
282
2124
True
283
2124
not_test
284
2124
lambdef
285
2124
and_expr
286
2124
xor_expr
287
2124
False
288
2124
None
289
2124
expr
290
2124
and_test
291
2124
)
2351
2124
{
292
2124
~
293
2124
power
294
2124
lambda
295
2124
comparison
296
2124
or_test
297
2124
not
298
2124
test
299
2124
test_list
300
2125
>>
2352
2125
<<
2353
2125
&
shift_expr -> arith_expr
2125
<=
shift_expr -> arith_expr
2125
>
shift_expr -> arith_expr
2125
)
shift_expr -> arith_expr
2125
not
shift_expr -> arith_expr
2125
!=
shift_expr -> arith_expr
2125
^
shift_expr -> arith_expr
2125
is
shift_expr -> arith_expr
2125
|
shift_expr -> arith_expr
2125
>=
shift_expr -> arith_expr
2125
or
shift_expr -> arith_expr
2125
==
shift_expr -> arith_expr
2125
if
shift_expr -> arith_expr
2125
and
shift_expr -> arith_expr
2125
<
shift_expr -> arith_expr
2125
for
shift_expr -> arith_expr
2125
in
shift_expr -> arith_expr
2126
-
atom -> NAME
2126
for
atom -> NAME
2126
or
atom -> NAME
2126
>>
atom -> NAME
2126
&
atom -> NAME
2126
[
atom -> NAME
2126
<=
atom -> NAME
2126
<
atom -> NAME
2126
.
atom -> NAME
2126
|
atom -> NAME
2126
*
atom -> NAME
2126
/
atom -> NAME
2126
<<
atom -> NAME
2126
not
atom -> NAME
2126
>
atom -> NAME
2126
is
atom -> NAME
2126
//
atom -> NAME
2126
+
atom -> NAME
2126
if
atom -> NAME
2126
in
atom -> NAME
2126
**
atom -> NAME
2126
!=
atom -> NAME
2126
>=
atom -> NAME
2126
)
atom -> NAME
2126
^
atom -> NAME
2126
@
atom -> NAME
2126
(
atom -> NAME
2126
==
atom -> NAME
2126
and
atom -> NAME
2126
%
atom -> NAME
2127
factor
117
2127
or_test
118
2127
term
119
2127
(
120
2127
test_list_comp
2354
2127
arith_expr
121
2127
NAME
122
2127
[
123
2127
]
2355
2127
+
125
2127
atom_expr
126
2127
NUMBER
127
2127
atom
128
2127
STRING
129
2127
shift_expr
130
2127
-
131
2127
True
133
2127
not_test
134
2127
lambdef
135
2127
and_expr
136
2127
xor_expr
137
2127
False
138
2127
None
139
2127
expr
140
2127
and_test
141
2127
{
142
2127
~
143
2127
lambda
144
2127
power
145
2127
comparison
146
2127
test_list
147
2127
test
148
2127
not
149
2128
(
2124
2128
NAME
2126
2128
[
2127
2128
+
2128
2128
atom_expr
2130
2128
NUMBER
2131
2128
atom
2132
2128
STRING
2133
2128
-
2135
2128
factor
2356
2128
True
2136
2128
False
2139
2128
None
2141
2128
{
2144
2128
~
2145
2128
power
2146
2129
+
2357
2129
-
2358
2129
for
arith_expr -> term
2129
|
arith_expr -> term
2129
)
arith_expr -> term
2129
or
arith_expr -> term
2129
not
arith_expr -> term
2129
<=
arith_expr -> term
2129
!=
arith_expr -> term
2129
<
arith_expr -> term
2129
&
arith_expr -> term
2129
>=
arith_expr -> term
2129
if
arith_expr -> term
2129
==
arith_expr -> term
2129
^
arith_expr -> term
2129
in
arith_expr -> term
2129
is
arith_expr -> term
2129
<<
arith_expr -> term
2129
>
arith_expr -> term
2129
and
arith_expr -> term
2129
>>
arith_expr -> term
2130
!=
power -> atom_expr
2130
**
2359
2130
>
power -> atom_expr
2130
+
power -> atom_expr
2130
not
power -> atom_expr
2130
&
power -> atom_expr
2130
|
power -> atom_expr
2130
>>
power -> atom_expr
2130
^
power -> atom_expr
2130
==
power -> atom_expr
2130
if
power -> atom_expr
2130
in
power -> atom_expr
2130
%
power -> atom_expr
2130
for
power -> atom_expr
2130
<<
power -> atom_expr
2130
or
power -> atom_expr
2130
@
power -> atom_expr
2130
*
power -> atom_expr
2130
/
power -> atom_expr
2130
)
power -> atom_expr
2130
<
power -> atom_expr
2130
//
power -> atom_expr
2130
>=
power -> atom_expr
2130
-
power -> atom_expr
2130
is
power -> atom_expr
2130
<=
power -> atom_expr
2130
and
power -> atom_expr
2131
[
atom -> NUMBER
2131
>=
atom -> NUMBER
2131
<=
atom -> NUMBER
2131
!=
atom -> NUMBER
2131
//
atom -> NUMBER
2131
in
atom -> NUMBER
2131
/
atom -> NUMBER
2131
or
atom -> NUMBER
2131
>
atom -> NUMBER
2131
not
atom -> NUMBER
2131
>>
atom -> NUMBER
2131
(
atom -> NUMBER
2131
**
atom -> NUMBER
2131
<<
atom -> NUMBER
2131
and
atom -> NUMBER
2131
+
atom -> NUMBER
2131
%
atom -> NUMBER
2131
)
atom -> NUMBER
2131
==
atom -> NUMBER
2131
for
atom -> NUMBER
2131
if
atom -> NUMBER
2131
is
atom -> NUMBER
2131
*
atom -> NUMBER
2131
@
atom -> NUMBER
2131
|
atom -> NUMBER
2131
-
atom -> NUMBER
2131
.
atom -> NUMBER
2131
^
atom -> NUMBER
2131
<
atom -> NUMBER
2131
&
atom -> NUMBER
2132
trailer
2360
2132
.
2361
2132
(
2362
2132
[
2363
2132
trailer_expr
2364
2132
<<
trailer_expr -> 
2132
%
trailer_expr -> 
2132
==
trailer_expr -> 
2132
-
trailer_expr -> 
2132
<
trailer_expr -> 
2132
if
trailer_expr -> 
2132
or
trailer_expr -> 
2132
/
trailer_expr -> 
2132
**
trailer_expr -> 
2132
and
trailer_expr -> 
2132
@
trailer_expr -> 
2132
*
trailer_expr -> 
2132
|
trailer_expr -> 
2132
is
trailer_expr -> 
2132
+
trailer_expr -> 
2132
in
trailer_expr -> 
2132
for
trailer_expr -> 
2132
&
trailer_expr -> 
2132
<=
trailer_expr -> 
2132
>=
trailer_expr -> 
2132
^
trailer_expr -> 
2132
>
trailer_expr -> 
2132
!=
trailer_expr -> 
2132
)
trailer_expr -> 
2132
not
trailer_expr -> 
2132
>>
trailer_expr -> 
2132
//
trailer_expr -> 
2133
and
atom -> STRING
2133
for
atom -> STRING
2133
%
atom -> STRING
2133
//
atom -> STRING
2133
>>
atom -> STRING
2133
*
atom -> STRING
2133
<
atom -> STRING
2133
.
atom -> STRING
2133
in
atom -> STRING
2133
^
atom -> STRING
2133
(
atom -> STRING
2133
if
atom -> STRING
2133
==
atom -> STRING
2133
-
atom -> STRING
2133
**
atom -> STRING
2133
<<
atom -> STRING
2133
<=
atom -> STRING
2133
[
atom -> STRING
2133
not
atom -> STRING
2133
or
atom -> STRING
2133
)
atom -> STRING
2133
+
atom -> STRING
2133
>=
atom -> STRING
2133
@
atom -> STRING
2133
&
atom -> STRING
2133
>
atom -> STRING
2133
is
atom -> STRING
2133
|
atom -> STRING
2133
!=
atom -> STRING
2133
/
atom -> STRING
2134
&
2365
2134
^
and_expr -> shift_expr
2134
|
and_expr -> shift_expr
2134
<=
and_expr -> shift_expr
2134
)
and_expr -> shift_expr
2134
for
and_expr -> shift_expr
2134
or
and_expr -> shift_expr
2134
>
and_expr -> shift_expr
2134
not
and_expr -> shift_expr
2134
!=
and_expr -> shift_expr
2134
and
and_expr -> shift_expr
2134
is
and_expr -> shift_expr
2134
<
and_expr -> shift_expr
2134
if
and_expr -> shift_expr
2134
in
and_expr -> shift_expr
2134
>=
and_expr -> shift_expr
2134
==
and_expr -> shift_expr
2135
(
2124
2135
NAME
2126
2135
[
2127
2135
+
2128
2135
atom_expr
2130
2135
NUMBER
2131
2135
atom
2132
2135
STRING
2133
2135
-
2135
2135
True
2136
2135
False
2139
2135
None
2141
2135
{
2144
2135
~
2145
2135
power
2146
2135
factor
2366
2136
(
atom -> True
2136
for
atom -> True
2136
[
atom -> True
2136
+
atom -> True
2136
@
atom -> True
2136
<=
atom -> True
2136
&
atom -> True
2136
<<
atom -> True
2136
-
atom -> True
2136
/
atom -> True
2136
)
atom -> True
2136
or
atom -> True
2136
>
atom -> True
2136
%
atom -> True
2136
^
atom -> True
2136
if
atom -> True
2136
!=
atom -> True
2136
is
atom -> True
2136
*
atom -> True
2136
<
atom -> True
2136
and
atom -> True
2136
.
atom -> True
2136
==
atom -> True
2136
**
atom -> True
2136
>>
atom -> True
2136
in
atom -> True
2136
|
atom -> True
2136
>=
atom -> True
2136
//
atom -> True
2136
not
atom -> True
2137
^
2367
2137
not
xor_expr -> and_expr
2137
if
xor_expr -> and_expr
2137
<=
xor_expr -> and_expr
2137
>
xor_expr -> and_expr
2137
<
xor_expr -> and_expr
2137
in
xor_expr -> and_expr
2137
>=
xor_expr -> and_expr
2137
for
xor_expr -> and_expr
2137
==
xor_expr -> and_expr
2137
|
xor_expr -> and_expr
2137
is
xor_expr -> and_expr
2137
and
xor_expr -> and_expr
2137
or
xor_expr -> and_expr
2137
)
xor_expr -> and_expr
2137
!=
xor_expr -> and_expr
2138
|
2368
2138
>=
expr -> xor_expr
2138
==
expr -> xor_expr
2138
)
expr -> xor_expr
2138
is
expr -> xor_expr
2138
if
expr -> xor_expr
2138
or
expr -> xor_expr
2138
for
expr -> xor_expr
2138
>
expr -> xor_expr
2138
and
expr -> xor_expr
2138
<
expr -> xor_expr
2138
in
expr -> xor_expr
2138
<=
expr -> xor_expr
2138
not
expr -> xor_expr
2138
!=
expr -> xor_expr
2139
in
atom -> False
2139
>
atom -> False
2139
-
atom -> False
2139
%
atom -> False
2139
<
atom -> False
2139
|
atom -> False
2139
==
atom -> False
2139
&
atom -> False
2139
//
atom -> False
2139
and
atom -> False
2139
not
atom -> False
2139
+
atom -> False
2139
!=
atom -> False
2139
if
atom -> False
2139
for
atom -> False
2139
)
atom -> False
2139
@
atom -> False
2139
[
atom -> False
2139
or
atom -> False
2139
<=
atom -> False
2139
*
atom -> False
2139
^
atom -> False
2139
is
atom -> False
2139
/
atom -> False
2139
.
atom -> False
2139
>=
atom -> False
2139
**
atom -> False
2139
>>
atom -> False
2139
<<
atom -> False
2139
(
atom -> False
2140
and
2369
2140
or
and_test -> not_test
2140
)
and_test -> not_test
2140
if
and_test -> not_test
2140
for
and_test -> not_test
2141
is
atom -> None
2141
.
atom -> None
2141
==
atom -> None
2141
^
atom -> None
2141
<<
atom -> None
2141
>>
atom -> None
2141
(
atom -> None
2141
|
atom -> None
2141
+
atom -> None
2141
for
atom -> None
2141
*
atom -> None
2141
//
atom -> None
2141
@
atom -> None
2141
in
atom -> None
2141
>=
atom -> None
2141
!=
atom -> None
2141
%
atom -> None
2141
[
atom -> None
2141
and
atom -> None
2141
-
atom -> None
2141
)
atom -> None
2141
if
atom -> None
2141
&
atom -> None
2141
<=
atom -> None
2141
<
atom -> None
2141
>
atom -> None
2141
**
atom -> None
2141
or
atom -> None
2141
/
atom -> None
2141
not
atom -> None
2142
is
215
2142
<
217
2142
!=
218
2142
in
219
2142
<=
220
2142
not
221
2142
>=
222
2142
>
223
2142
==
224
2142
comp_op
2370
2142
and
comparison -> expr
2142
or
comparison -> expr
2142
if
comparison -> expr
2142
)
comparison -> expr
2142
for
comparison -> expr
2143
or
2371
2143
for
or_test -> and_test
2143
)
or_test -> and_test
2143
if
or_test -> and_test
2144
}
2372
2145
(
2124
2145
NAME
2126
2145
[
2127
2145
+
2128
2145
factor
2373
2145
atom_expr
2130
2145
NUMBER
2131
2145
atom
2132
2145
STRING
2133
2145
-
2135
2145
True
2136
2145
False
2139
2145
None
2141
2145
{
2144
2145
~
2145
2145
power
2146
2146
&
factor -> power
2146
%
factor -> power
2146
<<
factor -> power
2146
-
factor -> power
2146
<=
factor -> power
2146
not
factor -> power
2146
//
factor -> power
2146
/
factor -> power
2146
is
factor -> power
2146
for
factor -> power
2146
|
factor -> power
2146
<
factor -> power
2146
and
factor -> power
2146
>=
factor -> power
2146
>>
factor -> power
2146
>
factor -> power
2146
)
factor -> power
2146
in
factor -> power
2146
if
factor -> power
2146
^
factor -> power
2146
==
factor -> power
2146
+
factor -> power
2146
@
factor -> power
2146
or
factor -> power
2146
*
factor -> power
2146
!=
factor -> power
2147
or
not_test -> comparison
2147
and
not_test -> comparison
2147
for
not_test -> comparison
2147
if
not_test -> comparison
2147
)
not_test -> comparison
2148
)
comp_iter -> 
2148
comp_iter
2374
2148
comp_for
2375
2148
if
2376
2148
comp_if
2377
2148
for
686
2149
factor
2123
2149
(
2124
2149
arith_expr
2125
2149
NAME
2126
2149
[
2127
2149
+
2128
2149
term
2129
2149
atom_expr
2130
2149
NUMBER
2131
2149
atom
2132
2149
STRING
2133
2149
shift_expr
2134
2149
-
2135
2149
not_test
2378
2149
True
2136
2149
and_expr
2137
2149
xor_expr
2138
2149
False
2139
2149
None
2141
2149
expr
2142
2149
{
2144
2149
~
2145
2149
power
2146
2149
comparison
2147
2149
not
2149
2150
DEDENT
2379
2151
factor
396
2151
(
397
2151
arith_expr
398
2151
NAME
399
2151
[
400
2151
+
401
2151
term
402
2151
atom_expr
403
2151
atom
404
2151
NUMBER
405
2151
STRING
406
2151
shift_expr
407
2151
-
408
2151
test
2380
2151
True
409
2151
and_expr
410
2151
xor_expr
411
2151
None
412
2151
expr
413
2151
False
414
2151
and_test
415
2151
lambda
416
2151
{
417
2151
~
418
2151
power
419
2151
not_test
420
2151
not
421
2151
comparison
422
2151
or_test
423
2151
lambdef
424
2152
NEWLINE
2381
2153
factor
9
2153
arith_expr
2
2153
NAME
29
2153
term
21
2153
[
3
2153
~
45
2153
atom_expr
24
2153
expr
16
2153
power
56
2153
(
36
2153
return
13
2153
small_stmt
47
2153
flow_stmt
15
2153
True
17
2153
not_test
18
2153
and_expr
19
2153
xor_expr
22
2153
{
52
2153
lambdef
53
2153
atom
54
2153
or_test
23
2153
shift_expr
50
2153
False
35
2153
NEWLINE
1022
2153
suite
2382
2153
-
49
2153
None
42
2153
lambda
40
2153
global
25
2153
NUMBER
27
2153
STRING
28
2153
test
48
2153
endsim
33
2153
and_test
37
2153
simple_stmt
1023
2153
comparison
39
2153
break_stmt
74
2153
+
55
2153
not
57
2153
raise
62
2153
continue
59
2153
return_stmt
75
2153
del_stmt
60
2153
test_list
61
2153
raise_stmt
63
2153
resetstats
64
2153
pass_stmt
65
2153
nonlocal
66
2153
break
76
2153
sim_stmt
77
2153
stat_stmt
78
2153
global_stmt
67
2153
yield_stmt
79
2153
assert_stmt
80
2153
pass
81
2153
yield
68
2153
continue_stmt
69
2153
assert
70
2153
nonlocal_stmt
71
2153
expr_stmt
72
2153
begsim
83
2153
del
84
2154
DEDENT
2383
2155
for
trailer -> ( arglist )
2155
**
trailer -> ( arglist )
2155
if
trailer -> ( arglist )
2155
<
trailer -> ( arglist )
2155
//
trailer -> ( arglist )
2155
<<
trailer -> ( arglist )
2155
%
trailer -> ( arglist )
2155
)
trailer -> ( arglist )
2155
&
trailer -> ( arglist )
2155
==
trailer -> ( arglist )
2155
is
trailer -> ( arglist )
2155
,
trailer -> ( arglist )
2155
!=
trailer -> ( arglist )
2155
=
trailer -> ( arglist )
2155
and
trailer -> ( arglist )
2155
-
trailer -> ( arglist )
2155
+
trailer -> ( arglist )
2155
>=
trailer -> ( arglist )
2155
or
trailer -> ( arglist )
2155
(
trailer -> ( arglist )
2155
^
trailer -> ( arglist )
2155
.
trailer -> ( arglist )
2155
not
trailer -> ( arglist )
2155
>>
trailer -> ( arglist )
2155
/
trailer -> ( arglist )
2155
*
trailer -> ( arglist )
2155
[
trailer -> ( arglist )
2155
@
trailer -> ( arglist )
2155
>
trailer -> ( arglist )
2155
|
trailer -> ( arglist )
2155
<=
trailer -> ( arglist )
2155
in
trailer -> ( arglist )
2156
|
trailer -> [ subscriptlist ]
2156
not
trailer -> [ subscriptlist ]
2156
in
trailer -> [ subscriptlist ]
2156
==
trailer -> [ subscriptlist ]
2156
**
trailer -> [ subscriptlist ]
2156
>>
trailer -> [ subscriptlist ]
2156
!=
trailer -> [ subscriptlist ]
2156
*
trailer -> [ subscriptlist ]
2156
or
trailer -> [ subscriptlist ]
2156
>=
trailer -> [ subscriptlist ]
2156
/
trailer -> [ subscriptlist ]
2156
for
trailer -> [ subscriptlist ]
2156
[
trailer -> [ subscriptlist ]
2156
>
trailer -> [ subscriptlist ]
2156
<
trailer -> [ subscriptlist ]
2156
.
trailer -> [ subscriptlist ]
2156
and
trailer -> [ subscriptlist ]
2156
(
trailer -> [ subscriptlist ]
2156
<=
trailer -> [ subscriptlist ]
2156
-
trailer -> [ subscriptlist ]
2156
@
trailer -> [ subscriptlist ]
2156
<<
trailer -> [ subscriptlist ]
2156
&
trailer -> [ subscriptlist ]
2156
,
trailer -> [ subscriptlist ]
2156
^
trailer -> [ subscriptlist ]
2156
is
trailer -> [ subscriptlist ]
2156
%
trailer -> [ subscriptlist ]
2156
+
trailer -> [ subscriptlist ]
2156
//
trailer -> [ subscriptlist ]
2156
)
trailer -> [ subscriptlist ]
2156
=
trailer -> [ subscriptlist ]
2156
if
trailer -> [ subscriptlist ]
2157
factor
268
2157
term
270
2157
(
271
2157
arith_expr
272
2157
NAME
273
2157
[
274
2157
+
275
2157
atom_expr
277
2157
NUMBER
278
2157
atom
279
2157
STRING
280
2157
shift_expr
281
2157
-
282
2157
True
283
2157
not_test
284
2157
and_expr
286
2157
xor_expr
287
2157
False
288
2157
None
289
2157
expr
290
2157
and_test
291
2157
{
292
2157
~
293
2157
power
294
2157
comparison
296
2157
or_test
2384
2157
not
298
2158
,
lambdef -> lambda varargslist : test
2158
=
lambdef -> lambda varargslist : test
2158
)
lambdef -> lambda varargslist : test
2158
for
lambdef -> lambda varargslist : test
2159
factor
697
2159
term
698
2159
(
699
2159
arith_expr
700
2159
NAME
701
2159
[
702
2159
atom
703
2159
+
704
2159
power
706
2159
atom_expr
707
2159
NUMBER
708
2159
STRING
709
2159
shift_expr
711
2159
-
712
2159
True
715
2159
not_test
716
2159
lambdef
717
2159
and_expr
718
2159
xor_expr
719
2159
False
720
2159
test
2385
2159
None
722
2159
expr
723
2159
and_test
724
2159
{
725
2159
~
726
2159
lambda
727
2159
comparison
728
2159
or_test
729
2159
not
730
2160
factor
732
2160
or_test
733
2160
term
734
2160
(
735
2160
arith_expr
736
2160
NAME
737
2160
[
738
2160
~
739
2160
+
741
2160
expr
743
2160
atom_expr
744
2160
atom
745
2160
NUMBER
746
2160
STRING
747
2160
shift_expr
748
2160
-
749
2160
True
750
2160
not_test
751
2160
and_expr
752
2160
xor_expr
753
2160
False
754
2160
{
755
2160
None
756
2160
and_test
757
2160
lambda
758
2160
power
759
2160
test
2386
2160
lambdef
762
2160
comparison
763
2160
not
764
2161
factor
984
2161
or_test
985
2161
term
986
2161
(
987
2161
arith_expr
988
2161
NAME
989
2161
[
991
2161
+
992
2161
atom_expr
993
2161
NUMBER
994
2161
atom
995
2161
STRING
996
2161
maybe_test
2387
2161
shift_expr
997
2161
-
998
2161
True
999
2161
not_test
1000
2161
and_expr
1001
2161
xor_expr
1002
2161
None
1003
2161
False
1004
2161
and_test
1005
2161
{
1006
2161
~
1007
2161
lambda
1008
2161
power
1009
2161
expr
1010
2161
lambdef
1011
2161
test
2388
2161
not
1013
2161
comparison
1014
2161
]
maybe_test -> 
2161
,
maybe_test -> 
2162
,
subscript -> maybe_test : maybe_test sliceop
2162
]
subscript -> maybe_test : maybe_test sliceop
2163
**
trailer -> ( arglist )
2163
:
trailer -> ( arglist )
2163
if
trailer -> ( arglist )
2163
<
trailer -> ( arglist )
2163
//
trailer -> ( arglist )
2163
<<
trailer -> ( arglist )
2163
%
trailer -> ( arglist )
2163
&
trailer -> ( arglist )
2163
==
trailer -> ( arglist )
2163
is
trailer -> ( arglist )
2163
,
trailer -> ( arglist )
2163
!=
trailer -> ( arglist )
2163
]
trailer -> ( arglist )
2163
and
trailer -> ( arglist )
2163
-
trailer -> ( arglist )
2163
+
trailer -> ( arglist )
2163
>=
trailer -> ( arglist )
2163
or
trailer -> ( arglist )
2163
(
trailer -> ( arglist )
2163
^
trailer -> ( arglist )
2163
.
trailer -> ( arglist )
2163
not
trailer -> ( arglist )
2163
>>
trailer -> ( arglist )
2163
/
trailer -> ( arglist )
2163
*
trailer -> ( arglist )
2163
[
trailer -> ( arglist )
2163
@
trailer -> ( arglist )
2163
>
trailer -> ( arglist )
2163
|
trailer -> ( arglist )
2163
<=
trailer -> ( arglist )
2163
in
trailer -> ( arglist )
2164
|
trailer -> [ subscriptlist ]
2164
not
trailer -> [ subscriptlist ]
2164
in
trailer -> [ subscriptlist ]
2164
==
trailer -> [ subscriptlist ]
2164
**
trailer -> [ subscriptlist ]
2164
>>
trailer -> [ subscriptlist ]
2164
!=
trailer -> [ subscriptlist ]
2164
*
trailer -> [ subscriptlist ]
2164
or
trailer -> [ subscriptlist ]
2164
>=
trailer -> [ subscriptlist ]
2164
/
trailer -> [ subscriptlist ]
2164
[
trailer -> [ subscriptlist ]
2164
]
trailer -> [ subscriptlist ]
2164
>
trailer -> [ subscriptlist ]
2164
<
trailer -> [ subscriptlist ]
2164
.
trailer -> [ subscriptlist ]
2164
and
trailer -> [ subscriptlist ]
2164
(
trailer -> [ subscriptlist ]
2164
<=
trailer -> [ subscriptlist ]
2164
-
trailer -> [ subscriptlist ]
2164
@
trailer -> [ subscriptlist ]
2164
<<
trailer -> [ subscriptlist ]
2164
&
trailer -> [ subscriptlist ]
2164
,
trailer -> [ subscriptlist ]
2164
:
trailer -> [ subscriptlist ]
2164
^
trailer -> [ subscriptlist ]
2164
is
trailer -> [ subscriptlist ]
2164
%
trailer -> [ subscriptlist ]
2164
+
trailer -> [ subscriptlist ]
2164
//
trailer -> [ subscriptlist ]
2164
if
trailer -> [ subscriptlist ]
2165
]
lambdef -> lambda varargslist : test
2165
:
lambdef -> lambda varargslist : test
2165
,
lambdef -> lambda varargslist : test
2166
**
trailer -> ( arglist )
2166
if
trailer -> ( arglist )
2166
<
trailer -> ( arglist )
2166
//
trailer -> ( arglist )
2166
<<
trailer -> ( arglist )
2166
%
trailer -> ( arglist )
2166
&
trailer -> ( arglist )
2166
NEWLINE
trailer -> ( arglist )
2166
==
trailer -> ( arglist )
2166
is
trailer -> ( arglist )
2166
,
trailer -> ( arglist )
2166
!=
trailer -> ( arglist )
2166
=
trailer -> ( arglist )
2166
and
trailer -> ( arglist )
2166
-
trailer -> ( arglist )
2166
+
trailer -> ( arglist )
2166
>=
trailer -> ( arglist )
2166
or
trailer -> ( arglist )
2166
(
trailer -> ( arglist )
2166
^
trailer -> ( arglist )
2166
.
trailer -> ( arglist )
2166
not
trailer -> ( arglist )
2166
>>
trailer -> ( arglist )
2166
/
trailer -> ( arglist )
2166
*
trailer -> ( arglist )
2166
[
trailer -> ( arglist )
2166
@
trailer -> ( arglist )
2166
>
trailer -> ( arglist )
2166
|
trailer -> ( arglist )
2166
<=
trailer -> ( arglist )
2166
in
trailer -> ( arglist )
2167
|
trailer -> [ subscriptlist ]
2167
not
trailer -> [ subscriptlist ]
2167
in
trailer -> [ subscriptlist ]
2167
==
trailer -> [ subscriptlist ]
2167
**
trailer -> [ subscriptlist ]
2167
>>
trailer -> [ subscriptlist ]
2167
!=
trailer -> [ subscriptlist ]
2167
*
trailer -> [ subscriptlist ]
2167
or
trailer -> [ subscriptlist ]
2167
>=
trailer -> [ subscriptlist ]
2167
/
trailer -> [ subscriptlist ]
2167
[
trailer -> [ subscriptlist ]
2167
>
trailer -> [ subscriptlist ]
2167
<
trailer -> [ subscriptlist ]
2167
.
trailer -> [ subscriptlist ]
2167
and
trailer -> [ subscriptlist ]
2167
(
trailer -> [ subscriptlist ]
2167
<=
trailer -> [ subscriptlist ]
2167
-
trailer -> [ subscriptlist ]
2167
@
trailer -> [ subscriptlist ]
2167
<<
trailer -> [ subscriptlist ]
2167
&
trailer -> [ subscriptlist ]
2167
,
trailer -> [ subscriptlist ]
2167
^
trailer -> [ subscriptlist ]
2167
is
trailer -> [ subscriptlist ]
2167
%
trailer -> [ subscriptlist ]
2167
+
trailer -> [ subscriptlist ]
2167
//
trailer -> [ subscriptlist ]
2167
NEWLINE
trailer -> [ subscriptlist ]
2167
=
trailer -> [ subscriptlist ]
2167
if
trailer -> [ subscriptlist ]
2168
NEWLINE
lambdef -> lambda varargslist : test
2168
=
lambdef -> lambda varargslist : test
2168
,
lambdef -> lambda varargslist : test
2169
factor
766
2169
term
767
2169
(
768
2169
arith_expr
769
2169
NAME
770
2169
[
771
2169
atom
772
2169
+
773
2169
power
774
2169
atom_expr
775
2169
NUMBER
776
2169
STRING
777
2169
shift_expr
778
2169
-
779
2169
True
780
2169
not_test
781
2169
and_expr
782
2169
xor_expr
783
2169
None
784
2169
expr
785
2169
False
786
2169
and_test
787
2169
test
2389
2169
lambda
788
2169
~
789
2169
{
790
2169
not
792
2169
or_test
793
2169
lambdef
795
2169
comparison
797
2170
factor
1825
2170
(
1826
2170
NAME
1828
2170
[
1829
2170
atom
1830
2170
+
1831
2170
atom_expr
1834
2170
power
1833
2170
NUMBER
1835
2170
STRING
1836
2170
-
1838
2170
term
2390
2170
True
1840
2170
None
1843
2170
False
1845
2170
{
1850
2170
~
1848
2171
factor
1825
2171
(
1826
2171
NAME
1828
2171
[
1829
2171
atom
1830
2171
+
1831
2171
atom_expr
1834
2171
power
1833
2171
NUMBER
1835
2171
STRING
1836
2171
-
1838
2171
True
1840
2171
None
1843
2171
term
2391
2171
False
1845
2171
{
1850
2171
~
1848
2172
factor
1825
2172
(
1826
2172
NAME
1828
2172
term
2392
2172
[
1829
2172
atom
1830
2172
+
1831
2172
atom_expr
1834
2172
power
1833
2172
NUMBER
1835
2172
STRING
1836
2172
-
1838
2172
True
1840
2172
None
1843
2172
False
1845
2172
{
1850
2172
~
1848
2173
factor
1825
2173
(
1826
2173
NAME
1828
2173
[
1829
2173
atom
1830
2173
+
1831
2173
atom_expr
1834
2173
power
1833
2173
NUMBER
1835
2173
STRING
1836
2173
-
1838
2173
term
2393
2173
True
1840
2173
None
1843
2173
False
1845
2173
{
1850
2173
~
1848
2174
factor
1825
2174
(
1826
2174
NAME
1828
2174
[
1829
2174
atom
1830
2174
+
1831
2174
atom_expr
1834
2174
power
1833
2174
NUMBER
1835
2174
term
2394
2174
STRING
1836
2174
-
1838
2174
True
1840
2174
None
1843
2174
False
1845
2174
{
1850
2174
~
1848
2175
)
2395
2176
or
atom -> ( )
2176
<<
atom -> ( )
2176
NEWLINE
atom -> ( )
2176
not
atom -> ( )
2176
&
atom -> ( )
2176
(
atom -> ( )
2176
in
atom -> ( )
2176
**
atom -> ( )
2176
@
atom -> ( )
2176
=
atom -> ( )
2176
<=
atom -> ( )
2176
%
atom -> ( )
2176
[
atom -> ( )
2176
>=
atom -> ( )
2176
/
atom -> ( )
2176
+
atom -> ( )
2176
<
atom -> ( )
2176
is
atom -> ( )
2176
*
atom -> ( )
2176
!=
atom -> ( )
2176
-
atom -> ( )
2176
|
atom -> ( )
2176
//
atom -> ( )
2176
^
atom -> ( )
2176
and
atom -> ( )
2176
==
atom -> ( )
2176
if
atom -> ( )
2176
>
atom -> ( )
2176
.
atom -> ( )
2176
>>
atom -> ( )
2177
factor
1825
2177
(
1826
2177
arith_expr
1827
2177
NAME
1828
2177
[
1829
2177
atom
1830
2177
+
1831
2177
term
1832
2177
power
1833
2177
atom_expr
1834
2177
NUMBER
1835
2177
STRING
1836
2177
-
1838
2177
shift_expr
2396
2177
True
1840
2177
None
1843
2177
False
1845
2177
{
1850
2177
~
1848
2178
factor
1825
2178
(
1826
2178
arith_expr
1827
2178
NAME
1828
2178
[
1829
2178
atom
1830
2178
+
1831
2178
term
1832
2178
power
1833
2178
atom_expr
1834
2178
NUMBER
1835
2178
STRING
1836
2178
-
1838
2178
True
1840
2178
shift_expr
2397
2178
None
1843
2178
False
1845
2178
{
1850
2178
~
1848
2179
<=
atom -> [ ]
2179
is
atom -> [ ]
2179
-
atom -> [ ]
2179
**
atom -> [ ]
2179
^
atom -> [ ]
2179
%
atom -> [ ]
2179
/
atom -> [ ]
2179
>=
atom -> [ ]
2179
|
atom -> [ ]
2179
not
atom -> [ ]
2179
@
atom -> [ ]
2179
*
atom -> [ ]
2179
(
atom -> [ ]
2179
>>
atom -> [ ]
2179
[
atom -> [ ]
2179
NEWLINE
atom -> [ ]
2179
or
atom -> [ ]
2179
!=
atom -> [ ]
2179
and
atom -> [ ]
2179
<<
atom -> [ ]
2179
if
atom -> [ ]
2179
in
atom -> [ ]
2179
+
atom -> [ ]
2179
.
atom -> [ ]
2179
==
atom -> [ ]
2179
>
atom -> [ ]
2179
=
atom -> [ ]
2179
<
atom -> [ ]
2179
&
atom -> [ ]
2179
//
atom -> [ ]
2180
]
2398
2181
trailer_expr
2399
2181
trailer
2181
2181
.
2182
2181
(
2183
2181
[
2184
2181
<<
trailer_expr -> 
2181
%
trailer_expr -> 
2181
==
trailer_expr -> 
2181
-
trailer_expr -> 
2181
<
trailer_expr -> 
2181
NEWLINE
trailer_expr -> 
2181
if
trailer_expr -> 
2181
or
trailer_expr -> 
2181
/
trailer_expr -> 
2181
**
trailer_expr -> 
2181
and
trailer_expr -> 
2181
@
trailer_expr -> 
2181
=
trailer_expr -> 
2181
*
trailer_expr -> 
2181
|
trailer_expr -> 
2181
is
trailer_expr -> 
2181
+
trailer_expr -> 
2181
in
trailer_expr -> 
2181
&
trailer_expr -> 
2181
<=
trailer_expr -> 
2181
>=
trailer_expr -> 
2181
^
trailer_expr -> 
2181
>
trailer_expr -> 
2181
!=
trailer_expr -> 
2181
not
trailer_expr -> 
2181
>>
trailer_expr -> 
2181
//
trailer_expr -> 
2182
NAME
2400
2183
factor
697
2183
term
698
2183
(
699
2183
arith_expr
700
2183
NAME
701
2183
[
702
2183
atom
703
2183
+
704
2183
power
706
2183
atom_expr
707
2183
NUMBER
708
2183
STRING
709
2183
arglist
2401
2183
*
710
2183
shift_expr
711
2183
-
712
2183
argument
714
2183
)
2402
2183
True
715
2183
not_test
716
2183
lambdef
717
2183
and_expr
718
2183
xor_expr
719
2183
False
720
2183
test
721
2183
None
722
2183
expr
723
2183
and_test
724
2183
{
725
2183
~
726
2183
lambda
727
2183
comparison
728
2183
or_test
729
2183
not
730
2183
**
731
2184
factor
732
2184
or_test
733
2184
term
734
2184
(
735
2184
arith_expr
736
2184
NAME
737
2184
[
738
2184
~
739
2184
subscriptlist
2403
2184
+
741
2184
maybe_test
742
2184
expr
743
2184
atom_expr
744
2184
atom
745
2184
NUMBER
746
2184
STRING
747
2184
shift_expr
748
2184
-
749
2184
True
750
2184
not_test
751
2184
and_expr
752
2184
xor_expr
753
2184
False
754
2184
{
755
2184
None
756
2184
and_test
757
2184
lambda
758
2184
power
759
2184
subscript
760
2184
test
761
2184
lambdef
762
2184
:
maybe_test -> 
2184
comparison
763
2184
not
764
2185
>
atom_expr -> atom trailer_expr
2185
not
atom_expr -> atom trailer_expr
2185
=
atom_expr -> atom trailer_expr
2185
//
atom_expr -> atom trailer_expr
2185
>>
atom_expr -> atom trailer_expr
2185
|
atom_expr -> atom trailer_expr
2185
^
atom_expr -> atom trailer_expr
2185
/
atom_expr -> atom trailer_expr
2185
+
atom_expr -> atom trailer_expr
2185
in
atom_expr -> atom trailer_expr
2185
%
atom_expr -> atom trailer_expr
2185
and
atom_expr -> atom trailer_expr
2185
<=
atom_expr -> atom trailer_expr
2185
is
atom_expr -> atom trailer_expr
2185
<
atom_expr -> atom trailer_expr
2185
@
atom_expr -> atom trailer_expr
2185
-
atom_expr -> atom trailer_expr
2185
NEWLINE
atom_expr -> atom trailer_expr
2185
&
atom_expr -> atom trailer_expr
2185
*
atom_expr -> atom trailer_expr
2185
**
atom_expr -> atom trailer_expr
2185
>=
atom_expr -> atom trailer_expr
2185
or
atom_expr -> atom trailer_expr
2185
==
atom_expr -> atom trailer_expr
2185
!=
atom_expr -> atom trailer_expr
2185
if
atom_expr -> atom trailer_expr
2185
<<
atom_expr -> atom trailer_expr
2186
<
factor -> + factor
2186
if
factor -> + factor
2186
<<
factor -> + factor
2186
and
factor -> + factor
2186
>=
factor -> + factor
2186
%
factor -> + factor
2186
>>
factor -> + factor
2186
*
factor -> + factor
2186
+
factor -> + factor
2186
/
factor -> + factor
2186
>
factor -> + factor
2186
<=
factor -> + factor
2186
^
factor -> + factor
2186
is
factor -> + factor
2186
|
factor -> + factor
2186
or
factor -> + factor
2186
=
factor -> + factor
2186
-
factor -> + factor
2186
in
factor -> + factor
2186
NEWLINE
factor -> + factor
2186
&
factor -> + factor
2186
not
factor -> + factor
2186
//
factor -> + factor
2186
!=
factor -> + factor
2186
==
factor -> + factor
2186
@
factor -> + factor
2187
factor
1825
2187
(
1826
2187
NAME
1828
2187
[
1829
2187
atom
1830
2187
+
1831
2187
term
1832
2187
power
1833
2187
atom_expr
1834
2187
NUMBER
1835
2187
STRING
1836
2187
-
1838
2187
True
1840
2187
arith_expr
2404
2187
None
1843
2187
False
1845
2187
{
1850
2187
~
1848
2188
factor
1825
2188
(
1826
2188
NAME
1828
2188
[
1829
2188
atom
1830
2188
+
1831
2188
term
1832
2188
power
1833
2188
atom_expr
1834
2188
NUMBER
1835
2188
STRING
1836
2188
-
1838
2188
True
1840
2188
arith_expr
2405
2188
None
1843
2188
False
1845
2188
{
1850
2188
~
1848
2189
(
1826
2189
NAME
1828
2189
[
1829
2189
atom
1830
2189
+
1831
2189
atom_expr
1834
2189
power
1833
2189
NUMBER
1835
2189
STRING
1836
2189
-
1838
2189
factor
2406
2189
True
1840
2189
None
1843
2189
False
1845
2189
{
1850
2189
~
1848
2190
factor
1825
2190
(
1826
2190
arith_expr
1827
2190
NAME
1828
2190
[
1829
2190
atom
1830
2190
+
1831
2190
term
1832
2190
power
1833
2190
atom_expr
1834
2190
NUMBER
1835
2190
STRING
1836
2190
shift_expr
1837
2190
-
1838
2190
True
1840
2190
None
1843
2190
and_expr
2407
2190
False
1845
2190
{
1850
2190
~
1848
2191
and
factor -> - factor
2191
if
factor -> - factor
2191
or
factor -> - factor
2191
>=
factor -> - factor
2191
<
factor -> - factor
2191
!=
factor -> - factor
2191
-
factor -> - factor
2191
=
factor -> - factor
2191
==
factor -> - factor
2191
@
factor -> - factor
2191
|
factor -> - factor
2191
*
factor -> - factor
2191
%
factor -> - factor
2191
+
factor -> - factor
2191
<=
factor -> - factor
2191
//
factor -> - factor
2191
not
factor -> - factor
2191
>>
factor -> - factor
2191
/
factor -> - factor
2191
&
factor -> - factor
2191
^
factor -> - factor
2191
in
factor -> - factor
2191
is
factor -> - factor
2191
>
factor -> - factor
2191
NEWLINE
factor -> - factor
2191
<<
factor -> - factor
2192
factor
1825
2192
(
1826
2192
arith_expr
1827
2192
NAME
1828
2192
[
1829
2192
atom
1830
2192
+
1831
2192
term
1832
2192
power
1833
2192
atom_expr
1834
2192
NUMBER
1835
2192
STRING
1836
2192
shift_expr
1837
2192
-
1838
2192
True
1840
2192
and_expr
1841
2192
None
1843
2192
False
1845
2192
{
1850
2192
~
1848
2192
xor_expr
2408
2193
factor
1825
2193
(
1826
2193
arith_expr
1827
2193
NAME
1828
2193
[
1829
2193
atom
1830
2193
+
1831
2193
term
1832
2193
power
1833
2193
atom_expr
1834
2193
NUMBER
1835
2193
STRING
1836
2193
shift_expr
1837
2193
-
1838
2193
True
1840
2193
and_expr
1841
2193
xor_expr
1842
2193
None
1843
2193
False
1845
2193
~
1848
2193
{
1850
2193
expr
2409
2194
factor
1825
2194
(
1826
2194
arith_expr
1827
2194
NAME
1828
2194
[
1829
2194
atom
1830
2194
+
1831
2194
term
1832
2194
power
1833
2194
atom_expr
1834
2194
NUMBER
1835
2194
STRING
1836
2194
shift_expr
1837
2194
-
1838
2194
True
1840
2194
and_expr
1841
2194
comparison
2410
2194
xor_expr
1842
2194
None
1843
2194
expr
1844
2194
False
1845
2194
~
1848
2194
{
1850
2195
factor
1825
2195
(
1826
2195
arith_expr
1827
2195
NAME
1828
2195
[
1829
2195
atom
1830
2195
+
1831
2195
or_test
2411
2195
term
1832
2195
power
1833
2195
atom_expr
1834
2195
NUMBER
1835
2195
STRING
1836
2195
shift_expr
1837
2195
-
1838
2195
True
1840
2195
and_expr
1841
2195
xor_expr
1842
2195
None
1843
2195
expr
1844
2195
False
1845
2195
and_test
1846
2195
~
1848
2195
not_test
1849
2195
{
1850
2195
not
1851
2195
comparison
1854
2196
factor
1825
2196
(
1826
2196
arith_expr
1827
2196
NAME
1828
2196
[
1829
2196
atom
1830
2196
+
1831
2196
term
1832
2196
power
1833
2196
atom_expr
1834
2196
NUMBER
1835
2196
STRING
1836
2196
shift_expr
1837
2196
-
1838
2196
True
1840
2196
and_expr
1841
2196
xor_expr
1842
2196
None
1843
2196
expr
1844
2196
False
1845
2196
and_test
1846
2196
lambda
1847
2196
~
1848
2196
not_test
1849
2196
{
1850
2196
not
1851
2196
lambdef
1852
2196
or_test
1853
2196
comparison
1854
2196
test
2412
2197
:
2413
2198
or
factor -> ~ factor
2198
==
factor -> ~ factor
2198
<=
factor -> ~ factor
2198
@
factor -> ~ factor
2198
!=
factor -> ~ factor
2198
>=
factor -> ~ factor
2198
>
factor -> ~ factor
2198
and
factor -> ~ factor
2198
*
factor -> ~ factor
2198
&
factor -> ~ factor
2198
%
factor -> ~ factor
2198
<
factor -> ~ factor
2198
//
factor -> ~ factor
2198
=
factor -> ~ factor
2198
if
factor -> ~ factor
2198
^
factor -> ~ factor
2198
/
factor -> ~ factor
2198
in
factor -> ~ factor
2198
+
factor -> ~ factor
2198
not
factor -> ~ factor
2198
-
factor -> ~ factor
2198
is
factor -> ~ factor
2198
>>
factor -> ~ factor
2198
<<
factor -> ~ factor
2198
NEWLINE
factor -> ~ factor
2198
|
factor -> ~ factor
2199
factor
1825
2199
(
1826
2199
arith_expr
1827
2199
NAME
1828
2199
[
1829
2199
atom
1830
2199
+
1831
2199
term
1832
2199
power
1833
2199
atom_expr
1834
2199
NUMBER
1835
2199
STRING
1836
2199
shift_expr
1837
2199
-
1838
2199
True
1840
2199
and_expr
1841
2199
xor_expr
1842
2199
None
1843
2199
expr
1844
2199
False
1845
2199
~
1848
2199
not_test
1849
2199
{
1850
2199
and_test
2414
2199
not
1851
2199
comparison
1854
2200
>
atom -> { }
2200
==
atom -> { }
2200
-
atom -> { }
2200
not
atom -> { }
2200
(
atom -> { }
2200
@
atom -> { }
2200
if
atom -> { }
2200
and
atom -> { }
2200
&
atom -> { }
2200
<<
atom -> { }
2200
!=
atom -> { }
2200
or
atom -> { }
2200
>>
atom -> { }
2200
<=
atom -> { }
2200
NEWLINE
atom -> { }
2200
>=
atom -> { }
2200
is
atom -> { }
2200
/
atom -> { }
2200
=
atom -> { }
2200
^
atom -> { }
2200
[
atom -> { }
2200
%
atom -> { }
2200
//
atom -> { }
2200
*
atom -> { }
2200
**
atom -> { }
2200
.
atom -> { }
2200
in
atom -> { }
2200
+
atom -> { }
2200
|
atom -> { }
2200
<
atom -> { }
2201
or
not_test -> not not_test
2201
and
not_test -> not not_test
2201
if
not_test -> not not_test
2201
NEWLINE
not_test -> not not_test
2201
=
not_test -> not not_test
2202
factor
585
2202
(
586
2202
arith_expr
587
2202
NAME
588
2202
[
589
2202
and_expr
590
2202
+
591
2202
term
592
2202
atom_expr
593
2202
NUMBER
594
2202
atom
595
2202
STRING
596
2202
shift_expr
597
2202
-
598
2202
True
599
2202
not
600
2202
xor_expr
601
2202
None
602
2202
False
603
2202
not_test
605
2202
~
606
2202
power
607
2202
{
608
2202
expr
609
2202
comparison
610
2202
and_test
611
2202
or_test
2415
2203
**
trailer -> ( arglist )
2203
if
trailer -> ( arglist )
2203
<
trailer -> ( arglist )
2203
//
trailer -> ( arglist )
2203
<<
trailer -> ( arglist )
2203
%
trailer -> ( arglist )
2203
&
trailer -> ( arglist )
2203
==
trailer -> ( arglist )
2203
is
trailer -> ( arglist )
2203
!=
trailer -> ( arglist )
2203
=
trailer -> ( arglist )
2203
and
trailer -> ( arglist )
2203
-
trailer -> ( arglist )
2203
+
trailer -> ( arglist )
2203
>=
trailer -> ( arglist )
2203
or
trailer -> ( arglist )
2203
(
trailer -> ( arglist )
2203
^
trailer -> ( arglist )
2203
.
trailer -> ( arglist )
2203
not
trailer -> ( arglist )
2203
>>
trailer -> ( arglist )
2203
/
trailer -> ( arglist )
2203
*
trailer -> ( arglist )
2203
[
trailer -> ( arglist )
2203
@
trailer -> ( arglist )
2203
>
trailer -> ( arglist )
2203
|
trailer -> ( arglist )
2203
<=
trailer -> ( arglist )
2203
in
trailer -> ( arglist )
2204
|
trailer -> [ subscriptlist ]
2204
not
trailer -> [ subscriptlist ]
2204
in
trailer -> [ subscriptlist ]
2204
==
trailer -> [ subscriptlist ]
2204
**
trailer -> [ subscriptlist ]
2204
>>
trailer -> [ subscriptlist ]
2204
!=
trailer -> [ subscriptlist ]
2204
*
trailer -> [ subscriptlist ]
2204
or
trailer -> [ subscriptlist ]
2204
>=
trailer -> [ subscriptlist ]
2204
/
trailer -> [ subscriptlist ]
2204
[
trailer -> [ subscriptlist ]
2204
>
trailer -> [ subscriptlist ]
2204
<
trailer -> [ subscriptlist ]
2204
.
trailer -> [ subscriptlist ]
2204
and
trailer -> [ subscriptlist ]
2204
(
trailer -> [ subscriptlist ]
2204
<=
trailer -> [ subscriptlist ]
2204
-
trailer -> [ subscriptlist ]
2204
@
trailer -> [ subscriptlist ]
2204
<<
trailer -> [ subscriptlist ]
2204
&
trailer -> [ subscriptlist ]
2204
^
trailer -> [ subscriptlist ]
2204
is
trailer -> [ subscriptlist ]
2204
%
trailer -> [ subscriptlist ]
2204
+
trailer -> [ subscriptlist ]
2204
//
trailer -> [ subscriptlist ]
2204
=
trailer -> [ subscriptlist ]
2204
if
trailer -> [ subscriptlist ]
2205
=
lambdef -> lambda varargslist : test
2206
factor
803
2206
(
804
2206
arith_expr
805
2206
NAME
806
2206
[
807
2206
atom
808
2206
+
809
2206
term
810
2206
power
811
2206
atom_expr
812
2206
NUMBER
813
2206
STRING
814
2206
shift_expr
815
2206
-
816
2206
True
817
2206
and_expr
818
2206
xor_expr
819
2206
None
820
2206
False
821
2206
and_test
822
2206
test
2416
2206
{
823
2206
~
824
2206
not_test
825
2206
expr
826
2206
lambdef
827
2206
lambda
828
2206
or_test
829
2206
not
830
2206
comparison
831
2207
NEWLINE
test -> or_test if or_test else test
2207
from
test -> or_test if or_test else test
2208
NEWLINE
test -> or_test if or_test else test
2209
factor
9
2209
arith_expr
2
2209
NAME
29
2209
term
21
2209
[
3
2209
~
45
2209
atom_expr
24
2209
expr
16
2209
power
56
2209
(
36
2209
return
13
2209
small_stmt
945
2209
flow_stmt
15
2209
True
17
2209
not_test
18
2209
and_expr
19
2209
suite
2417
2209
xor_expr
22
2209
{
52
2209
lambdef
53
2209
atom
54
2209
or_test
23
2209
shift_expr
50
2209
False
35
2209
NEWLINE
947
2209
-
49
2209
None
42
2209
lambda
40
2209
global
25
2209
NUMBER
27
2209
STRING
28
2209
test
48
2209
endsim
33
2209
and_test
37
2209
simple_stmt
948
2209
comparison
39
2209
break_stmt
74
2209
+
55
2209
not
57
2209
raise
62
2209
continue
59
2209
return_stmt
75
2209
del_stmt
60
2209
test_list
61
2209
raise_stmt
63
2209
resetstats
64
2209
pass_stmt
65
2209
nonlocal
66
2209
break
76
2209
sim_stmt
77
2209
stat_stmt
78
2209
global_stmt
67
2209
yield_stmt
79
2209
assert_stmt
80
2209
pass
81
2209
yield
68
2209
continue_stmt
69
2209
assert
70
2209
nonlocal_stmt
71
2209
expr_stmt
72
2209
begsim
83
2209
del
84
2210
factor
9
2210
arith_expr
2
2210
NAME
29
2210
term
21
2210
[
3
2210
~
45
2210
atom_expr
24
2210
expr
16
2210
power
56
2210
(
36
2210
return
13
2210
small_stmt
47
2210
flow_stmt
15
2210
True
17
2210
not_test
18
2210
and_expr
19
2210
xor_expr
22
2210
{
52
2210
lambdef
53
2210
atom
54
2210
or_test
23
2210
shift_expr
50
2210
False
35
2210
NEWLINE
1022
2210
-
49
2210
None
42
2210
lambda
40
2210
global
25
2210
NUMBER
27
2210
STRING
28
2210
test
48
2210
suite
2418
2210
endsim
33
2210
and_test
37
2210
simple_stmt
1023
2210
comparison
39
2210
break_stmt
74
2210
+
55
2210
not
57
2210
raise
62
2210
continue
59
2210
return_stmt
75
2210
del_stmt
60
2210
test_list
61
2210
raise_stmt
63
2210
resetstats
64
2210
pass_stmt
65
2210
nonlocal
66
2210
break
76
2210
sim_stmt
77
2210
stat_stmt
78
2210
global_stmt
67
2210
yield_stmt
79
2210
assert_stmt
80
2210
pass
81
2210
yield
68
2210
continue_stmt
69
2210
assert
70
2210
nonlocal_stmt
71
2210
expr_stmt
72
2210
begsim
83
2210
del
84
2211
not
suite -> NEWLINE INDENT stmt_list DEDENT
2211
None
suite -> NEWLINE INDENT stmt_list DEDENT
2211
{
suite -> NEWLINE INDENT stmt_list DEDENT
2211
for
suite -> NEWLINE INDENT stmt_list DEDENT
2211
try
suite -> NEWLINE INDENT stmt_list DEDENT
2211
class
suite -> NEWLINE INDENT stmt_list DEDENT
2211
while
suite -> NEWLINE INDENT stmt_list DEDENT
2211
NEWLINE
suite -> NEWLINE INDENT stmt_list DEDENT
2211
-
suite -> NEWLINE INDENT stmt_list DEDENT
2211
if
suite -> NEWLINE INDENT stmt_list DEDENT
2211
+
suite -> NEWLINE INDENT stmt_list DEDENT
2211
resetstats
suite -> NEWLINE INDENT stmt_list DEDENT
2211
return
suite -> NEWLINE INDENT stmt_list DEDENT
2211
with
suite -> NEWLINE INDENT stmt_list DEDENT
2211
NAME
suite -> NEWLINE INDENT stmt_list DEDENT
2211
else
suite -> NEWLINE INDENT stmt_list DEDENT
2211
STRING
suite -> NEWLINE INDENT stmt_list DEDENT
2211
conf
suite -> NEWLINE INDENT stmt_list DEDENT
2211
assert
suite -> NEWLINE INDENT stmt_list DEDENT
2211
def
suite -> NEWLINE INDENT stmt_list DEDENT
2211
~
suite -> NEWLINE INDENT stmt_list DEDENT
2211
yield
suite -> NEWLINE INDENT stmt_list DEDENT
2211
NUMBER
suite -> NEWLINE INDENT stmt_list DEDENT
2211
del
suite -> NEWLINE INDENT stmt_list DEDENT
2211
$
suite -> NEWLINE INDENT stmt_list DEDENT
2211
True
suite -> NEWLINE INDENT stmt_list DEDENT
2211
break
suite -> NEWLINE INDENT stmt_list DEDENT
2211
pass
suite -> NEWLINE INDENT stmt_list DEDENT
2211
endsim
suite -> NEWLINE INDENT stmt_list DEDENT
2211
continue
suite -> NEWLINE INDENT stmt_list DEDENT
2211
[
suite -> NEWLINE INDENT stmt_list DEDENT
2211
begsim
suite -> NEWLINE INDENT stmt_list DEDENT
2211
elif
suite -> NEWLINE INDENT stmt_list DEDENT
2211
lambda
suite -> NEWLINE INDENT stmt_list DEDENT
2211
global
suite -> NEWLINE INDENT stmt_list DEDENT
2211
@
suite -> NEWLINE INDENT stmt_list DEDENT
2211
False
suite -> NEWLINE INDENT stmt_list DEDENT
2211
raise
suite -> NEWLINE INDENT stmt_list DEDENT
2211
(
suite -> NEWLINE INDENT stmt_list DEDENT
2211
nonlocal
suite -> NEWLINE INDENT stmt_list DEDENT
2212
factor
1898
2212
(
1899
2212
NAME
1901
2212
[
1902
2212
+
1903
2212
atom_expr
1905
2212
NUMBER
1906
2212
atom
1907
2212
STRING
1908
2212
-
1910
2212
term
2419
2212
True
1911
2212
False
1914
2212
None
1916
2212
{
1919
2212
~
1920
2212
power
1921
2213
factor
1898
2213
(
1899
2213
NAME
1901
2213
[
1902
2213
+
1903
2213
atom_expr
1905
2213
NUMBER
1906
2213
atom
1907
2213
STRING
1908
2213
-
1910
2213
True
1911
2213
False
1914
2213
None
1916
2213
term
2420
2213
{
1919
2213
~
1920
2213
power
1921
2214
factor
1898
2214
(
1899
2214
NAME
1901
2214
term
2421
2214
[
1902
2214
+
1903
2214
atom_expr
1905
2214
NUMBER
1906
2214
atom
1907
2214
STRING
1908
2214
-
1910
2214
True
1911
2214
False
1914
2214
None
1916
2214
{
1919
2214
~
1920
2214
power
1921
2215
factor
1898
2215
(
1899
2215
NAME
1901
2215
[
1902
2215
+
1903
2215
atom_expr
1905
2215
NUMBER
1906
2215
atom
1907
2215
STRING
1908
2215
-
1910
2215
term
2422
2215
True
1911
2215
False
1914
2215
None
1916
2215
{
1919
2215
~
1920
2215
power
1921
2216
factor
1898
2216
(
1899
2216
NAME
1901
2216
[
1902
2216
+
1903
2216
atom_expr
1905
2216
NUMBER
1906
2216
atom
1907
2216
term
2423
2216
STRING
1908
2216
-
1910
2216
True
1911
2216
False
1914
2216
None
1916
2216
{
1919
2216
~
1920
2216
power
1921
2217
)
2424
2218
for
atom -> ( )
2218
or
atom -> ( )
2218
<<
atom -> ( )
2218
not
atom -> ( )
2218
&
atom -> ( )
2218
(
atom -> ( )
2218
in
atom -> ( )
2218
**
atom -> ( )
2218
@
atom -> ( )
2218
<=
atom -> ( )
2218
%
atom -> ( )
2218
[
atom -> ( )
2218
>=
atom -> ( )
2218
/
atom -> ( )
2218
+
atom -> ( )
2218
<
atom -> ( )
2218
]
atom -> ( )
2218
is
atom -> ( )
2218
*
atom -> ( )
2218
!=
atom -> ( )
2218
-
atom -> ( )
2218
|
atom -> ( )
2218
//
atom -> ( )
2218
^
atom -> ( )
2218
and
atom -> ( )
2218
==
atom -> ( )
2218
if
atom -> ( )
2218
>
atom -> ( )
2218
.
atom -> ( )
2218
>>
atom -> ( )
2219
factor
1898
2219
(
1899
2219
arith_expr
1900
2219
NAME
1901
2219
[
1902
2219
+
1903
2219
term
1904
2219
atom_expr
1905
2219
NUMBER
1906
2219
atom
1907
2219
STRING
1908
2219
-
1910
2219
shift_expr
2425
2219
True
1911
2219
False
1914
2219
None
1916
2219
{
1919
2219
~
1920
2219
power
1921
2220
factor
1898
2220
(
1899
2220
arith_expr
1900
2220
NAME
1901
2220
[
1902
2220
+
1903
2220
term
1904
2220
atom_expr
1905
2220
NUMBER
1906
2220
atom
1907
2220
STRING
1908
2220
-
1910
2220
shift_expr
2426
2220
True
1911
2220
False
1914
2220
None
1916
2220
{
1919
2220
~
1920
2220
power
1921
2221
<=
atom -> [ ]
2221
is
atom -> [ ]
2221
-
atom -> [ ]
2221
]
atom -> [ ]
2221
**
atom -> [ ]
2221
^
atom -> [ ]
2221
%
atom -> [ ]
2221
/
atom -> [ ]
2221
>=
atom -> [ ]
2221
|
atom -> [ ]
2221
not
atom -> [ ]
2221
@
atom -> [ ]
2221
*
atom -> [ ]
2221
(
atom -> [ ]
2221
>>
atom -> [ ]
2221
[
atom -> [ ]
2221
or
atom -> [ ]
2221
!=
atom -> [ ]
2221
and
atom -> [ ]
2221
<<
atom -> [ ]
2221
if
atom -> [ ]
2221
in
atom -> [ ]
2221
+
atom -> [ ]
2221
.
atom -> [ ]
2221
==
atom -> [ ]
2221
>
atom -> [ ]
2221
<
atom -> [ ]
2221
for
atom -> [ ]
2221
&
atom -> [ ]
2221
//
atom -> [ ]
2222
]
2427
2223
<
factor -> + factor
2223
if
factor -> + factor
2223
<<
factor -> + factor
2223
]
factor -> + factor
2223
and
factor -> + factor
2223
>=
factor -> + factor
2223
%
factor -> + factor
2223
>>
factor -> + factor
2223
*
factor -> + factor
2223
+
factor -> + factor
2223
/
factor -> + factor
2223
>
factor -> + factor
2223
<=
factor -> + factor
2223
^
factor -> + factor
2223
is
factor -> + factor
2223
|
factor -> + factor
2223
or
factor -> + factor
2223
-
factor -> + factor
2223
in
factor -> + factor
2223
for
factor -> + factor
2223
&
factor -> + factor
2223
not
factor -> + factor
2223
//
factor -> + factor
2223
!=
factor -> + factor
2223
==
factor -> + factor
2223
@
factor -> + factor
2224
factor
1898
2224
(
1899
2224
NAME
1901
2224
[
1902
2224
arith_expr
2428
2224
+
1903
2224
term
1904
2224
atom_expr
1905
2224
NUMBER
1906
2224
atom
1907
2224
STRING
1908
2224
-
1910
2224
True
1911
2224
False
1914
2224
None
1916
2224
{
1919
2224
~
1920
2224
power
1921
2225
factor
1898
2225
(
1899
2225
NAME
1901
2225
[
1902
2225
+
1903
2225
term
1904
2225
atom_expr
1905
2225
NUMBER
1906
2225
atom
1907
2225
STRING
1908
2225
-
1910
2225
True
1911
2225
False
1914
2225
None
1916
2225
arith_expr
2429
2225
{
1919
2225
~
1920
2225
power
1921
2226
(
1899
2226
NAME
1901
2226
[
1902
2226
+
1903
2226
atom_expr
1905
2226
NUMBER
1906
2226
atom
1907
2226
STRING
1908
2226
-
1910
2226
factor
2430
2226
True
1911
2226
False
1914
2226
None
1916
2226
{
1919
2226
~
1920
2226
power
1921
2227
trailer_expr
2431
2227
trailer
2227
2227
.
2228
2227
(
2229
2227
[
2230
2227
<<
trailer_expr -> 
2227
%
trailer_expr -> 
2227
==
trailer_expr -> 
2227
-
trailer_expr -> 
2227
<
trailer_expr -> 
2227
if
trailer_expr -> 
2227
or
trailer_expr -> 
2227
/
trailer_expr -> 
2227
**
trailer_expr -> 
2227
and
trailer_expr -> 
2227
@
trailer_expr -> 
2227
*
trailer_expr -> 
2227
|
trailer_expr -> 
2227
is
trailer_expr -> 
2227
+
trailer_expr -> 
2227
in
trailer_expr -> 
2227
for
trailer_expr -> 
2227
&
trailer_expr -> 
2227
<=
trailer_expr -> 
2227
>=
trailer_expr -> 
2227
^
trailer_expr -> 
2227
>
trailer_expr -> 
2227
!=
trailer_expr -> 
2227
not
trailer_expr -> 
2227
>>
trailer_expr -> 
2227
//
trailer_expr -> 
2227
]
trailer_expr -> 
2228
NAME
2432
2229
factor
697
2229
term
698
2229
(
699
2229
arith_expr
700
2229
NAME
701
2229
[
702
2229
atom
703
2229
+
704
2229
power
706
2229
atom_expr
707
2229
NUMBER
708
2229
STRING
709
2229
*
710
2229
shift_expr
711
2229
-
712
2229
argument
714
2229
)
2433
2229
True
715
2229
not_test
716
2229
lambdef
717
2229
and_expr
718
2229
xor_expr
719
2229
False
720
2229
test
721
2229
None
722
2229
arglist
2434
2229
expr
723
2229
and_test
724
2229
{
725
2229
~
726
2229
lambda
727
2229
comparison
728
2229
or_test
729
2229
not
730
2229
**
731
2230
factor
732
2230
or_test
733
2230
term
734
2230
(
735
2230
arith_expr
736
2230
NAME
737
2230
[
738
2230
~
739
2230
subscriptlist
2435
2230
+
741
2230
maybe_test
742
2230
expr
743
2230
atom_expr
744
2230
atom
745
2230
NUMBER
746
2230
STRING
747
2230
shift_expr
748
2230
-
749
2230
True
750
2230
not_test
751
2230
and_expr
752
2230
xor_expr
753
2230
False
754
2230
{
755
2230
None
756
2230
and_test
757
2230
lambda
758
2230
power
759
2230
subscript
760
2230
test
761
2230
lambdef
762
2230
:
maybe_test -> 
2230
comparison
763
2230
not
764
2231
>
atom_expr -> atom trailer_expr
2231
not
atom_expr -> atom trailer_expr
2231
//
atom_expr -> atom trailer_expr
2231
>>
atom_expr -> atom trailer_expr
2231
|
atom_expr -> atom trailer_expr
2231
^
atom_expr -> atom trailer_expr
2231
/
atom_expr -> atom trailer_expr
2231
+
atom_expr -> atom trailer_expr
2231
in
atom_expr -> atom trailer_expr
2231
%
atom_expr -> atom trailer_expr
2231
and
atom_expr -> atom trailer_expr
2231
<=
atom_expr -> atom trailer_expr
2231
is
atom_expr -> atom trailer_expr
2231
<
atom_expr -> atom trailer_expr
2231
@
atom_expr -> atom trailer_expr
2231
-
atom_expr -> atom trailer_expr
2231
]
atom_expr -> atom trailer_expr
2231
&
atom_expr -> atom trailer_expr
2231
*
atom_expr -> atom trailer_expr
2231
**
atom_expr -> atom trailer_expr
2231
>=
atom_expr -> atom trailer_expr
2231
for
atom_expr -> atom trailer_expr
2231
or
atom_expr -> atom trailer_expr
2231
==
atom_expr -> atom trailer_expr
2231
!=
atom_expr -> atom trailer_expr
2231
if
atom_expr -> atom trailer_expr
2231
<<
atom_expr -> atom trailer_expr
2232
factor
1898
2232
(
1899
2232
arith_expr
1900
2232
NAME
1901
2232
[
1902
2232
+
1903
2232
term
1904
2232
atom_expr
1905
2232
NUMBER
1906
2232
atom
1907
2232
STRING
1908
2232
shift_expr
1909
2232
-
1910
2232
True
1911
2232
False
1914
2232
None
1916
2232
and_expr
2436
2232
{
1919
2232
~
1920
2232
power
1921
2233
for
factor -> - factor
2233
and
factor -> - factor
2233
if
factor -> - factor
2233
or
factor -> - factor
2233
>=
factor -> - factor
2233
<
factor -> - factor
2233
!=
factor -> - factor
2233
-
factor -> - factor
2233
==
factor -> - factor
2233
]
factor -> - factor
2233
@
factor -> - factor
2233
|
factor -> - factor
2233
*
factor -> - factor
2233
%
factor -> - factor
2233
+
factor -> - factor
2233
<=
factor -> - factor
2233
//
factor -> - factor
2233
not
factor -> - factor
2233
>>
factor -> - factor
2233
/
factor -> - factor
2233
&
factor -> - factor
2233
^
factor -> - factor
2233
in
factor -> - factor
2233
is
factor -> - factor
2233
>
factor -> - factor
2233
<<
factor -> - factor
2234
factor
1898
2234
(
1899
2234
arith_expr
1900
2234
NAME
1901
2234
[
1902
2234
+
1903
2234
term
1904
2234
atom_expr
1905
2234
NUMBER
1906
2234
atom
1907
2234
STRING
1908
2234
shift_expr
1909
2234
-
1910
2234
True
1911
2234
and_expr
1912
2234
False
1914
2234
None
1916
2234
xor_expr
2437
2234
{
1919
2234
~
1920
2234
power
1921
2235
factor
1898
2235
(
1899
2235
arith_expr
1900
2235
NAME
1901
2235
[
1902
2235
+
1903
2235
term
1904
2235
atom_expr
1905
2235
NUMBER
1906
2235
atom
1907
2235
STRING
1908
2235
shift_expr
1909
2235
-
1910
2235
True
1911
2235
and_expr
1912
2235
xor_expr
1913
2235
False
1914
2235
None
1916
2235
{
1919
2235
~
1920
2235
power
1921
2235
expr
2438
2236
factor
1898
2236
(
1899
2236
arith_expr
1900
2236
NAME
1901
2236
[
1902
2236
+
1903
2236
term
1904
2236
atom_expr
1905
2236
NUMBER
1906
2236
atom
1907
2236
STRING
1908
2236
shift_expr
1909
2236
-
1910
2236
True
1911
2236
and_expr
1912
2236
xor_expr
1913
2236
False
1914
2236
not_test
1915
2236
None
1916
2236
expr
1917
2236
{
1919
2236
~
1920
2236
and_test
2439
2236
power
1921
2236
comparison
1922
2236
not
1923
2237
factor
1898
2237
(
1899
2237
arith_expr
1900
2237
NAME
1901
2237
[
1902
2237
+
1903
2237
term
1904
2237
atom_expr
1905
2237
NUMBER
1906
2237
atom
1907
2237
STRING
1908
2237
shift_expr
1909
2237
-
1910
2237
True
1911
2237
and_expr
1912
2237
comparison
2440
2237
xor_expr
1913
2237
False
1914
2237
None
1916
2237
expr
1917
2237
{
1919
2237
~
1920
2237
power
1921
2238
factor
1898
2238
(
1899
2238
arith_expr
1900
2238
NAME
1901
2238
[
1902
2238
+
1903
2238
term
1904
2238
atom_expr
1905
2238
NUMBER
1906
2238
atom
1907
2238
STRING
1908
2238
shift_expr
1909
2238
-
1910
2238
True
1911
2238
and_expr
1912
2238
xor_expr
1913
2238
False
1914
2238
not_test
1915
2238
None
1916
2238
expr
1917
2238
and_test
1918
2238
{
1919
2238
~
1920
2238
power
1921
2238
comparison
1922
2238
not
1923
2238
or_test
2441
2239
>
atom -> { }
2239
==
atom -> { }
2239
-
atom -> { }
2239
]
atom -> { }
2239
not
atom -> { }
2239
(
atom -> { }
2239
@
atom -> { }
2239
if
atom -> { }
2239
and
atom -> { }
2239
&
atom -> { }
2239
<<
atom -> { }
2239
!=
atom -> { }
2239
or
atom -> { }
2239
>>
atom -> { }
2239
<=
atom -> { }
2239
>=
atom -> { }
2239
is
atom -> { }
2239
/
atom -> { }
2239
^
atom -> { }
2239
[
atom -> { }
2239
%
atom -> { }
2239
//
atom -> { }
2239
*
atom -> { }
2239
**
atom -> { }
2239
.
atom -> { }
2239
for
atom -> { }
2239
in
atom -> { }
2239
+
atom -> { }
2239
|
atom -> { }
2239
<
atom -> { }
2240
or
factor -> ~ factor
2240
==
factor -> ~ factor
2240
<=
factor -> ~ factor
2240
@
factor -> ~ factor
2240
!=
factor -> ~ factor
2240
>=
factor -> ~ factor
2240
>
factor -> ~ factor
2240
and
factor -> ~ factor
2240
*
factor -> ~ factor
2240
&
factor -> ~ factor
2240
%
factor -> ~ factor
2240
<
factor -> ~ factor
2240
//
factor -> ~ factor
2240
if
factor -> ~ factor
2240
^
factor -> ~ factor
2240
/
factor -> ~ factor
2240
for
factor -> ~ factor
2240
in
factor -> ~ factor
2240
+
factor -> ~ factor
2240
not
factor -> ~ factor
2240
-
factor -> ~ factor
2240
is
factor -> ~ factor
2240
>>
factor -> ~ factor
2240
<<
factor -> ~ factor
2240
]
factor -> ~ factor
2240
|
factor -> ~ factor
2241
]
not_test -> not not_test
2241
or
not_test -> not not_test
2241
and
not_test -> not not_test
2241
if
not_test -> not not_test
2241
for
not_test -> not not_test
2242
]
comp_for -> for expr_list in or_test comp_iter
2243
factor
1898
2243
(
1899
2243
arith_expr
1900
2243
NAME
1901
2243
[
1902
2243
+
1903
2243
term
1904
2243
atom_expr
1905
2243
NUMBER
1906
2243
atom
1907
2243
STRING
1908
2243
shift_expr
1909
2243
-
1910
2243
True
1911
2243
and_expr
1912
2243
xor_expr
1913
2243
False
1914
2243
not_test
1915
2243
None
1916
2243
expr
1917
2243
and_test
1918
2243
{
1919
2243
~
1920
2243
power
1921
2243
lambda
2442
2243
comparison
1922
2243
lambdef_nocond
2443
2243
or_test
2444
2243
not
1923
2243
test_nocond
2445
2244
]
comp_iter -> comp_for
2245
]
comp_iter -> comp_if
2246
factor
984
2246
or_test
985
2246
term
986
2246
(
987
2246
arith_expr
988
2246
NAME
989
2246
[
991
2246
+
992
2246
atom_expr
993
2246
NUMBER
994
2246
atom
995
2246
STRING
996
2246
shift_expr
997
2246
-
998
2246
True
999
2246
not_test
1000
2246
and_expr
1001
2246
xor_expr
1002
2246
None
1003
2246
False
1004
2246
and_test
1005
2246
{
1006
2246
~
1007
2246
lambda
1008
2246
power
1009
2246
expr
1010
2246
test
2446
2246
lambdef
1011
2246
not
1013
2246
comparison
1014
2247
**
trailer -> ( arglist )
2247
if
trailer -> ( arglist )
2247
<
trailer -> ( arglist )
2247
//
trailer -> ( arglist )
2247
<<
trailer -> ( arglist )
2247
%
trailer -> ( arglist )
2247
&
trailer -> ( arglist )
2247
==
trailer -> ( arglist )
2247
is
trailer -> ( arglist )
2247
,
trailer -> ( arglist )
2247
!=
trailer -> ( arglist )
2247
]
trailer -> ( arglist )
2247
and
trailer -> ( arglist )
2247
-
trailer -> ( arglist )
2247
+
trailer -> ( arglist )
2247
>=
trailer -> ( arglist )
2247
or
trailer -> ( arglist )
2247
(
trailer -> ( arglist )
2247
^
trailer -> ( arglist )
2247
.
trailer -> ( arglist )
2247
not
trailer -> ( arglist )
2247
>>
trailer -> ( arglist )
2247
/
trailer -> ( arglist )
2247
*
trailer -> ( arglist )
2247
[
trailer -> ( arglist )
2247
@
trailer -> ( arglist )
2247
>
trailer -> ( arglist )
2247
|
trailer -> ( arglist )
2247
<=
trailer -> ( arglist )
2247
in
trailer -> ( arglist )
2248
|
trailer -> [ subscriptlist ]
2248
not
trailer -> [ subscriptlist ]
2248
in
trailer -> [ subscriptlist ]
2248
==
trailer -> [ subscriptlist ]
2248
**
trailer -> [ subscriptlist ]
2248
>>
trailer -> [ subscriptlist ]
2248
!=
trailer -> [ subscriptlist ]
2248
*
trailer -> [ subscriptlist ]
2248
or
trailer -> [ subscriptlist ]
2248
>=
trailer -> [ subscriptlist ]
2248
/
trailer -> [ subscriptlist ]
2248
[
trailer -> [ subscriptlist ]
2248
]
trailer -> [ subscriptlist ]
2248
>
trailer -> [ subscriptlist ]
2248
<
trailer -> [ subscriptlist ]
2248
.
trailer -> [ subscriptlist ]
2248
and
trailer -> [ subscriptlist ]
2248
(
trailer -> [ subscriptlist ]
2248
<=
trailer -> [ subscriptlist ]
2248
-
trailer -> [ subscriptlist ]
2248
@
trailer -> [ subscriptlist ]
2248
<<
trailer -> [ subscriptlist ]
2248
&
trailer -> [ subscriptlist ]
2248
,
trailer -> [ subscriptlist ]
2248
^
trailer -> [ subscriptlist ]
2248
is
trailer -> [ subscriptlist ]
2248
%
trailer -> [ subscriptlist ]
2248
+
trailer -> [ subscriptlist ]
2248
//
trailer -> [ subscriptlist ]
2248
if
trailer -> [ subscriptlist ]
2249
]
lambdef -> lambda varargslist : test
2249
,
lambdef -> lambda varargslist : test
2250
NEWLINE
2447
2251
finally
2448
2251
global
try_stmt -> try : suite except_clause else : suite
2251
resetstats
try_stmt -> try : suite except_clause else : suite
2251
return
try_stmt -> try : suite except_clause else : suite
2251
yield
try_stmt -> try : suite except_clause else : suite
2251
continue
try_stmt -> try : suite except_clause else : suite
2251
[
try_stmt -> try : suite except_clause else : suite
2251
endsim
try_stmt -> try : suite except_clause else : suite
2251
raise
try_stmt -> try : suite except_clause else : suite
2251
pass
try_stmt -> try : suite except_clause else : suite
2251
None
try_stmt -> try : suite except_clause else : suite
2251
lambda
try_stmt -> try : suite except_clause else : suite
2251
del
try_stmt -> try : suite except_clause else : suite
2251
def
try_stmt -> try : suite except_clause else : suite
2251
NUMBER
try_stmt -> try : suite except_clause else : suite
2251
begsim
try_stmt -> try : suite except_clause else : suite
2251
NAME
try_stmt -> try : suite except_clause else : suite
2251
@
try_stmt -> try : suite except_clause else : suite
2251
try
try_stmt -> try : suite except_clause else : suite
2251
$
try_stmt -> try : suite except_clause else : suite
2251
True
try_stmt -> try : suite except_clause else : suite
2251
False
try_stmt -> try : suite except_clause else : suite
2251
if
try_stmt -> try : suite except_clause else : suite
2251
conf
try_stmt -> try : suite except_clause else : suite
2251
NEWLINE
try_stmt -> try : suite except_clause else : suite
2251
with
try_stmt -> try : suite except_clause else : suite
2251
(
try_stmt -> try : suite except_clause else : suite
2251
~
try_stmt -> try : suite except_clause else : suite
2251
-
try_stmt -> try : suite except_clause else : suite
2251
for
try_stmt -> try : suite except_clause else : suite
2251
STRING
try_stmt -> try : suite except_clause else : suite
2251
assert
try_stmt -> try : suite except_clause else : suite
2251
break
try_stmt -> try : suite except_clause else : suite
2251
class
try_stmt -> try : suite except_clause else : suite
2251
{
try_stmt -> try : suite except_clause else : suite
2251
nonlocal
try_stmt -> try : suite except_clause else : suite
2251
+
try_stmt -> try : suite except_clause else : suite
2251
not
try_stmt -> try : suite except_clause else : suite
2251
while
try_stmt -> try : suite except_clause else : suite
2252
INDENT
2449
2253
resetstats
suite -> simple_stmt
2253
+
suite -> simple_stmt
2253
lambda
suite -> simple_stmt
2253
try
suite -> simple_stmt
2253
begsim
suite -> simple_stmt
2253
None
suite -> simple_stmt
2253
not
suite -> simple_stmt
2253
@
suite -> simple_stmt
2253
[
suite -> simple_stmt
2253
class
suite -> simple_stmt
2253
return
suite -> simple_stmt
2253
nonlocal
suite -> simple_stmt
2253
NUMBER
suite -> simple_stmt
2253
yield
suite -> simple_stmt
2253
STRING
suite -> simple_stmt
2253
NEWLINE
suite -> simple_stmt
2253
-
suite -> simple_stmt
2253
False
suite -> simple_stmt
2253
def
suite -> simple_stmt
2253
conf
suite -> simple_stmt
2253
True
suite -> simple_stmt
2253
raise
suite -> simple_stmt
2253
endsim
suite -> simple_stmt
2253
with
suite -> simple_stmt
2253
global
suite -> simple_stmt
2253
{
suite -> simple_stmt
2253
~
suite -> simple_stmt
2253
assert
suite -> simple_stmt
2253
(
suite -> simple_stmt
2253
$
suite -> simple_stmt
2253
while
suite -> simple_stmt
2253
finally
suite -> simple_stmt
2253
del
suite -> simple_stmt
2253
pass
suite -> simple_stmt
2253
break
suite -> simple_stmt
2253
for
suite -> simple_stmt
2253
continue
suite -> simple_stmt
2253
NAME
suite -> simple_stmt
2253
if
suite -> simple_stmt
2254
pass
try_stmt -> try : suite except_clause finally : suite
2254
continue
try_stmt -> try : suite except_clause finally : suite
2254
[
try_stmt -> try : suite except_clause finally : suite
2254
NUMBER
try_stmt -> try : suite except_clause finally : suite
2254
class
try_stmt -> try : suite except_clause finally : suite
2254
-
try_stmt -> try : suite except_clause finally : suite
2254
(
try_stmt -> try : suite except_clause finally : suite
2254
for
try_stmt -> try : suite except_clause finally : suite
2254
@
try_stmt -> try : suite except_clause finally : suite
2254
def
try_stmt -> try : suite except_clause finally : suite
2254
break
try_stmt -> try : suite except_clause finally : suite
2254
~
try_stmt -> try : suite except_clause finally : suite
2254
yield
try_stmt -> try : suite except_clause finally : suite
2254
begsim
try_stmt -> try : suite except_clause finally : suite
2254
nonlocal
try_stmt -> try : suite except_clause finally : suite
2254
False
try_stmt -> try : suite except_clause finally : suite
2254
NEWLINE
try_stmt -> try : suite except_clause finally : suite
2254
+
try_stmt -> try : suite except_clause finally : suite
2254
lambda
try_stmt -> try : suite except_clause finally : suite
2254
True
try_stmt -> try : suite except_clause finally : suite
2254
raise
try_stmt -> try : suite except_clause finally : suite
2254
with
try_stmt -> try : suite except_clause finally : suite
2254
$
try_stmt -> try : suite except_clause finally : suite
2254
NAME
try_stmt -> try : suite except_clause finally : suite
2254
STRING
try_stmt -> try : suite except_clause finally : suite
2254
endsim
try_stmt -> try : suite except_clause finally : suite
2254
None
try_stmt -> try : suite except_clause finally : suite
2254
while
try_stmt -> try : suite except_clause finally : suite
2254
if
try_stmt -> try : suite except_clause finally : suite
2254
not
try_stmt -> try : suite except_clause finally : suite
2254
assert
try_stmt -> try : suite except_clause finally : suite
2254
conf
try_stmt -> try : suite except_clause finally : suite
2254
try
try_stmt -> try : suite except_clause finally : suite
2254
del
try_stmt -> try : suite except_clause finally : suite
2254
global
try_stmt -> try : suite except_clause finally : suite
2254
{
try_stmt -> try : suite except_clause finally : suite
2254
return
try_stmt -> try : suite except_clause finally : suite
2254
resetstats
try_stmt -> try : suite except_clause finally : suite
2255
:
2450
2256
maybe_except_clause
2451
2256
except
1016
2256
except_clause
2279
2256
global
maybe_except_clause -> 
2256
resetstats
maybe_except_clause -> 
2256
class
maybe_except_clause -> 
2256
def
maybe_except_clause -> 
2256
NAME
maybe_except_clause -> 
2256
NUMBER
maybe_except_clause -> 
2256
lambda
maybe_except_clause -> 
2256
True
maybe_except_clause -> 
2256
else
maybe_except_clause -> 
2256
not
maybe_except_clause -> 
2256
$
maybe_except_clause -> 
2256
-
maybe_except_clause -> 
2256
NEWLINE
maybe_except_clause -> 
2256
~
maybe_except_clause -> 
2256
del
maybe_except_clause -> 
2256
with
maybe_except_clause -> 
2256
pass
maybe_except_clause -> 
2256
if
maybe_except_clause -> 
2256
assert
maybe_except_clause -> 
2256
conf
maybe_except_clause -> 
2256
break
maybe_except_clause -> 
2256
try
maybe_except_clause -> 
2256
while
maybe_except_clause -> 
2256
False
maybe_except_clause -> 
2256
(
maybe_except_clause -> 
2256
None
maybe_except_clause -> 
2256
return
maybe_except_clause -> 
2256
nonlocal
maybe_except_clause -> 
2256
@
maybe_except_clause -> 
2256
yield
maybe_except_clause -> 
2256
finally
maybe_except_clause -> 
2256
{
maybe_except_clause -> 
2256
endsim
maybe_except_clause -> 
2256
for
maybe_except_clause -> 
2256
raise
maybe_except_clause -> 
2256
[
maybe_except_clause -> 
2256
STRING
maybe_except_clause -> 
2256
continue
maybe_except_clause -> 
2256
begsim
maybe_except_clause -> 
2256
+
maybe_except_clause -> 
2257
and
term -> factor // term
2257
if
term -> factor // term
2257
>
term -> factor // term
2257
<
term -> factor // term
2257
==
term -> factor // term
2257
+
term -> factor // term
2257
-
term -> factor // term
2257
&
term -> factor // term
2257
in
term -> factor // term
2257
:
term -> factor // term
2257
!=
term -> factor // term
2257
^
term -> factor // term
2257
or
term -> factor // term
2257
<=
term -> factor // term
2257
>=
term -> factor // term
2257
|
term -> factor // term
2257
>>
term -> factor // term
2257
not
term -> factor // term
2257
is
term -> factor // term
2257
as
term -> factor // term
2257
<<
term -> factor // term
2258
or
term -> factor / term
2258
<<
term -> factor / term
2258
not
term -> factor / term
2258
in
term -> factor / term
2258
!=
term -> factor / term
2258
<
term -> factor / term
2258
as
term -> factor / term
2258
+
term -> factor / term
2258
and
term -> factor / term
2258
>>
term -> factor / term
2258
^
term -> factor / term
2258
<=
term -> factor / term
2258
==
term -> factor / term
2258
>
term -> factor / term
2258
&
term -> factor / term
2258
is
term -> factor / term
2258
-
term -> factor / term
2258
:
term -> factor / term
2258
|
term -> factor / term
2258
>=
term -> factor / term
2258
if
term -> factor / term
2259
^
term -> factor * term
2259
+
term -> factor * term
2259
==
term -> factor * term
2259
>>
term -> factor * term
2259
in
term -> factor * term
2259
and
term -> factor * term
2259
if
term -> factor * term
2259
is
term -> factor * term
2259
<<
term -> factor * term
2259
:
term -> factor * term
2259
-
term -> factor * term
2259
as
term -> factor * term
2259
!=
term -> factor * term
2259
or
term -> factor * term
2259
>
term -> factor * term
2259
&
term -> factor * term
2259
>=
term -> factor * term
2259
|
term -> factor * term
2259
<=
term -> factor * term
2259
not
term -> factor * term
2259
<
term -> factor * term
2260
&
term -> factor % term
2260
==
term -> factor % term
2260
!=
term -> factor % term
2260
<
term -> factor % term
2260
in
term -> factor % term
2260
>>
term -> factor % term
2260
<<
term -> factor % term
2260
-
term -> factor % term
2260
if
term -> factor % term
2260
>
term -> factor % term
2260
as
term -> factor % term
2260
or
term -> factor % term
2260
^
term -> factor % term
2260
+
term -> factor % term
2260
is
term -> factor % term
2260
|
term -> factor % term
2260
>=
term -> factor % term
2260
<=
term -> factor % term
2260
and
term -> factor % term
2260
not
term -> factor % term
2260
:
term -> factor % term
2261
and
term -> factor @ term
2261
in
term -> factor @ term
2261
>=
term -> factor @ term
2261
<
term -> factor @ term
2261
:
term -> factor @ term
2261
>
term -> factor @ term
2261
-
term -> factor @ term
2261
or
term -> factor @ term
2261
<<
term -> factor @ term
2261
is
term -> factor @ term
2261
!=
term -> factor @ term
2261
|
term -> factor @ term
2261
&
term -> factor @ term
2261
==
term -> factor @ term
2261
>>
term -> factor @ term
2261
<=
term -> factor @ term
2261
not
term -> factor @ term
2261
+
term -> factor @ term
2261
^
term -> factor @ term
2261
as
term -> factor @ term
2261
if
term -> factor @ term
2262
+
atom -> ( test_list_comp )
2262
/
atom -> ( test_list_comp )
2262
*
atom -> ( test_list_comp )
2262
[
atom -> ( test_list_comp )
2262
&
atom -> ( test_list_comp )
2262
**
atom -> ( test_list_comp )
2262
^
atom -> ( test_list_comp )
2262
(
atom -> ( test_list_comp )
2262
and
atom -> ( test_list_comp )
2262
:
atom -> ( test_list_comp )
2262
>
atom -> ( test_list_comp )
2262
as
atom -> ( test_list_comp )
2262
-
atom -> ( test_list_comp )
2262
%
atom -> ( test_list_comp )
2262
//
atom -> ( test_list_comp )
2262
in
atom -> ( test_list_comp )
2262
>>
atom -> ( test_list_comp )
2262
not
atom -> ( test_list_comp )
2262
>=
atom -> ( test_list_comp )
2262
or
atom -> ( test_list_comp )
2262
<
atom -> ( test_list_comp )
2262
if
atom -> ( test_list_comp )
2262
|
atom -> ( test_list_comp )
2262
<<
atom -> ( test_list_comp )
2262
@
atom -> ( test_list_comp )
2262
!=
atom -> ( test_list_comp )
2262
is
atom -> ( test_list_comp )
2262
.
atom -> ( test_list_comp )
2262
<=
atom -> ( test_list_comp )
2262
==
atom -> ( test_list_comp )
2263
as
shift_expr -> arith_expr >> shift_expr
2263
>=
shift_expr -> arith_expr >> shift_expr
2263
if
shift_expr -> arith_expr >> shift_expr
2263
<=
shift_expr -> arith_expr >> shift_expr
2263
!=
shift_expr -> arith_expr >> shift_expr
2263
or
shift_expr -> arith_expr >> shift_expr
2263
|
shift_expr -> arith_expr >> shift_expr
2263
is
shift_expr -> arith_expr >> shift_expr
2263
and
shift_expr -> arith_expr >> shift_expr
2263
in
shift_expr -> arith_expr >> shift_expr
2263
^
shift_expr -> arith_expr >> shift_expr
2263
not
shift_expr -> arith_expr >> shift_expr
2263
<
shift_expr -> arith_expr >> shift_expr
2263
==
shift_expr -> arith_expr >> shift_expr
2263
:
shift_expr -> arith_expr >> shift_expr
2263
&
shift_expr -> arith_expr >> shift_expr
2263
>
shift_expr -> arith_expr >> shift_expr
2264
>
shift_expr -> arith_expr << shift_expr
2264
or
shift_expr -> arith_expr << shift_expr
2264
^
shift_expr -> arith_expr << shift_expr
2264
as
shift_expr -> arith_expr << shift_expr
2264
not
shift_expr -> arith_expr << shift_expr
2264
<
shift_expr -> arith_expr << shift_expr
2264
if
shift_expr -> arith_expr << shift_expr
2264
in
shift_expr -> arith_expr << shift_expr
2264
!=
shift_expr -> arith_expr << shift_expr
2264
==
shift_expr -> arith_expr << shift_expr
2264
|
shift_expr -> arith_expr << shift_expr
2264
>=
shift_expr -> arith_expr << shift_expr
2264
and
shift_expr -> arith_expr << shift_expr
2264
&
shift_expr -> arith_expr << shift_expr
2264
<=
shift_expr -> arith_expr << shift_expr
2264
is
shift_expr -> arith_expr << shift_expr
2264
:
shift_expr -> arith_expr << shift_expr
2265
==
arith_expr -> term + arith_expr
2265
!=
arith_expr -> term + arith_expr
2265
<<
arith_expr -> term + arith_expr
2265
&
arith_expr -> term + arith_expr
2265
<
arith_expr -> term + arith_expr
2265
^
arith_expr -> term + arith_expr
2265
>=
arith_expr -> term + arith_expr
2265
as
arith_expr -> term + arith_expr
2265
in
arith_expr -> term + arith_expr
2265
>>
arith_expr -> term + arith_expr
2265
not
arith_expr -> term + arith_expr
2265
:
arith_expr -> term + arith_expr
2265
<=
arith_expr -> term + arith_expr
2265
is
arith_expr -> term + arith_expr
2265
|
arith_expr -> term + arith_expr
2265
and
arith_expr -> term + arith_expr
2265
or
arith_expr -> term + arith_expr
2265
if
arith_expr -> term + arith_expr
2265
>
arith_expr -> term + arith_expr
2266
if
arith_expr -> term - arith_expr
2266
&
arith_expr -> term - arith_expr
2266
>>
arith_expr -> term - arith_expr
2266
:
arith_expr -> term - arith_expr
2266
!=
arith_expr -> term - arith_expr
2266
>=
arith_expr -> term - arith_expr
2266
|
arith_expr -> term - arith_expr
2266
as
arith_expr -> term - arith_expr
2266
>
arith_expr -> term - arith_expr
2266
<
arith_expr -> term - arith_expr
2266
==
arith_expr -> term - arith_expr
2266
and
arith_expr -> term - arith_expr
2266
is
arith_expr -> term - arith_expr
2266
in
arith_expr -> term - arith_expr
2266
^
arith_expr -> term - arith_expr
2266
<<
arith_expr -> term - arith_expr
2266
not
arith_expr -> term - arith_expr
2266
or
arith_expr -> term - arith_expr
2266
<=
arith_expr -> term - arith_expr
2267
in
atom -> [ test_list_comp ]
2267
/
atom -> [ test_list_comp ]
2267
or
atom -> [ test_list_comp ]
2267
if
atom -> [ test_list_comp ]
2267
<<
atom -> [ test_list_comp ]
2267
!=
atom -> [ test_list_comp ]
2267
<=
atom -> [ test_list_comp ]
2267
>>
atom -> [ test_list_comp ]
2267
*
atom -> [ test_list_comp ]
2267
^
atom -> [ test_list_comp ]
2267
.
atom -> [ test_list_comp ]
2267
(
atom -> [ test_list_comp ]
2267
>=
atom -> [ test_list_comp ]
2267
and
atom -> [ test_list_comp ]
2267
<
atom -> [ test_list_comp ]
2267
[
atom -> [ test_list_comp ]
2267
==
atom -> [ test_list_comp ]
2267
@
atom -> [ test_list_comp ]
2267
%
atom -> [ test_list_comp ]
2267
-
atom -> [ test_list_comp ]
2267
|
atom -> [ test_list_comp ]
2267
&
atom -> [ test_list_comp ]
2267
:
atom -> [ test_list_comp ]
2267
+
atom -> [ test_list_comp ]
2267
is
atom -> [ test_list_comp ]
2267
//
atom -> [ test_list_comp ]
2267
**
atom -> [ test_list_comp ]
2267
not
atom -> [ test_list_comp ]
2267
as
atom -> [ test_list_comp ]
2267
>
atom -> [ test_list_comp ]
2268
as
lambdef -> lambda : test
2268
:
lambdef -> lambda : test
2269
factor
1536
2269
(
1537
2269
arith_expr
1538
2269
NAME
1539
2269
term
1540
2269
[
1541
2269
~
1542
2269
+
1543
2269
lambda
1544
2269
expr
1545
2269
atom_expr
1546
2269
shift_expr
1547
2269
atom
1548
2269
NUMBER
1549
2269
STRING
1550
2269
-
1552
2269
True
1553
2269
not_test
1554
2269
and_expr
1555
2269
xor_expr
1556
2269
False
1557
2269
{
1558
2269
test
2452
2269
or_test
1559
2269
None
1560
2269
comparison
1561
2269
and_test
1562
2269
lambdef
1563
2269
power
1564
2269
not
1565
2270
and
comparison -> expr comp_op comparison
2270
:
comparison -> expr comp_op comparison
2270
if
comparison -> expr comp_op comparison
2270
as
comparison -> expr comp_op comparison
2270
or
comparison -> expr comp_op comparison
2271
+
power -> atom_expr ** factor
2271
&
power -> atom_expr ** factor
2271
>>
power -> atom_expr ** factor
2271
<<
power -> atom_expr ** factor
2271
not
power -> atom_expr ** factor
2271
is
power -> atom_expr ** factor
2271
@
power -> atom_expr ** factor
2271
:
power -> atom_expr ** factor
2271
==
power -> atom_expr ** factor
2271
*
power -> atom_expr ** factor
2271
or
power -> atom_expr ** factor
2271
>
power -> atom_expr ** factor
2271
-
power -> atom_expr ** factor
2271
if
power -> atom_expr ** factor
2271
!=
power -> atom_expr ** factor
2271
>=
power -> atom_expr ** factor
2271
/
power -> atom_expr ** factor
2271
%
power -> atom_expr ** factor
2271
and
power -> atom_expr ** factor
2271
<=
power -> atom_expr ** factor
2271
<
power -> atom_expr ** factor
2271
|
power -> atom_expr ** factor
2271
^
power -> atom_expr ** factor
2271
in
power -> atom_expr ** factor
2271
as
power -> atom_expr ** factor
2271
//
power -> atom_expr ** factor
2272
==
and_expr -> shift_expr & and_expr
2272
in
and_expr -> shift_expr & and_expr
2272
!=
and_expr -> shift_expr & and_expr
2272
or
and_expr -> shift_expr & and_expr
2272
>
and_expr -> shift_expr & and_expr
2272
not
and_expr -> shift_expr & and_expr
2272
:
and_expr -> shift_expr & and_expr
2272
|
and_expr -> shift_expr & and_expr
2272
<=
and_expr -> shift_expr & and_expr
2272
and
and_expr -> shift_expr & and_expr
2272
as
and_expr -> shift_expr & and_expr
2272
^
and_expr -> shift_expr & and_expr
2272
is
and_expr -> shift_expr & and_expr
2272
>=
and_expr -> shift_expr & and_expr
2272
<
and_expr -> shift_expr & and_expr
2272
if
and_expr -> shift_expr & and_expr
2273
+
trailer_expr -> trailer trailer_expr
2273
*
trailer_expr -> trailer trailer_expr
2273
/
trailer_expr -> trailer trailer_expr
2273
not
trailer_expr -> trailer trailer_expr
2273
<<
trailer_expr -> trailer trailer_expr
2273
!=
trailer_expr -> trailer trailer_expr
2273
>=
trailer_expr -> trailer trailer_expr
2273
>>
trailer_expr -> trailer trailer_expr
2273
|
trailer_expr -> trailer trailer_expr
2273
%
trailer_expr -> trailer trailer_expr
2273
>
trailer_expr -> trailer trailer_expr
2273
&
trailer_expr -> trailer trailer_expr
2273
-
trailer_expr -> trailer trailer_expr
2273
<=
trailer_expr -> trailer trailer_expr
2273
:
trailer_expr -> trailer trailer_expr
2273
**
trailer_expr -> trailer trailer_expr
2273
@
trailer_expr -> trailer trailer_expr
2273
if
trailer_expr -> trailer trailer_expr
2273
==
trailer_expr -> trailer trailer_expr
2273
or
trailer_expr -> trailer trailer_expr
2273
<
trailer_expr -> trailer trailer_expr
2273
and
trailer_expr -> trailer trailer_expr
2273
in
trailer_expr -> trailer trailer_expr
2273
is
trailer_expr -> trailer trailer_expr
2273
^
trailer_expr -> trailer trailer_expr
2273
//
trailer_expr -> trailer trailer_expr
2273
as
trailer_expr -> trailer trailer_expr
2274
<=
trailer -> . NAME
2274
<<
trailer -> . NAME
2274
**
trailer -> . NAME
2274
!=
trailer -> . NAME
2274
:
trailer -> . NAME
2274
/
trailer -> . NAME
2274
&
trailer -> . NAME
2274
//
trailer -> . NAME
2274
<
trailer -> . NAME
2274
is
trailer -> . NAME
2274
-
trailer -> . NAME
2274
if
trailer -> . NAME
2274
as
trailer -> . NAME
2274
[
trailer -> . NAME
2274
or
trailer -> . NAME
2274
>
trailer -> . NAME
2274
*
trailer -> . NAME
2274
+
trailer -> . NAME
2274
%
trailer -> . NAME
2274
.
trailer -> . NAME
2274
>=
trailer -> . NAME
2274
|
trailer -> . NAME
2274
and
trailer -> . NAME
2274
(
trailer -> . NAME
2274
==
trailer -> . NAME
2274
^
trailer -> . NAME
2274
in
trailer -> . NAME
2274
@
trailer -> . NAME
2274
not
trailer -> . NAME
2274
>>
trailer -> . NAME
2275
%
trailer -> ( )
2275
<=
trailer -> ( )
2275
and
trailer -> ( )
2275
//
trailer -> ( )
2275
not
trailer -> ( )
2275
as
trailer -> ( )
2275
or
trailer -> ( )
2275
>>
trailer -> ( )
2275
>
trailer -> ( )
2275
<<
trailer -> ( )
2275
[
trailer -> ( )
2275
is
trailer -> ( )
2275
:
trailer -> ( )
2275
-
trailer -> ( )
2275
**
trailer -> ( )
2275
/
trailer -> ( )
2275
+
trailer -> ( )
2275
&
trailer -> ( )
2275
in
trailer -> ( )
2275
^
trailer -> ( )
2275
!=
trailer -> ( )
2275
*
trailer -> ( )
2275
if
trailer -> ( )
2275
>=
trailer -> ( )
2275
(
trailer -> ( )
2275
@
trailer -> ( )
2275
==
trailer -> ( )
2275
|
trailer -> ( )
2275
.
trailer -> ( )
2275
<
trailer -> ( )
2276
)
2453
2277
]
2454
2278
+
except_clause -> except : suite maybe_except_clause
2278
@
except_clause -> except : suite maybe_except_clause
2278
NEWLINE
except_clause -> except : suite maybe_except_clause
2278
raise
except_clause -> except : suite maybe_except_clause
2278
lambda
except_clause -> except : suite maybe_except_clause
2278
def
except_clause -> except : suite maybe_except_clause
2278
nonlocal
except_clause -> except : suite maybe_except_clause
2278
[
except_clause -> except : suite maybe_except_clause
2278
global
except_clause -> except : suite maybe_except_clause
2278
False
except_clause -> except : suite maybe_except_clause
2278
class
except_clause -> except : suite maybe_except_clause
2278
None
except_clause -> except : suite maybe_except_clause
2278
STRING
except_clause -> except : suite maybe_except_clause
2278
break
except_clause -> except : suite maybe_except_clause
2278
$
except_clause -> except : suite maybe_except_clause
2278
not
except_clause -> except : suite maybe_except_clause
2278
resetstats
except_clause -> except : suite maybe_except_clause
2278
pass
except_clause -> except : suite maybe_except_clause
2278
~
except_clause -> except : suite maybe_except_clause
2278
try
except_clause -> except : suite maybe_except_clause
2278
else
except_clause -> except : suite maybe_except_clause
2278
continue
except_clause -> except : suite maybe_except_clause
2278
yield
except_clause -> except : suite maybe_except_clause
2278
endsim
except_clause -> except : suite maybe_except_clause
2278
NUMBER
except_clause -> except : suite maybe_except_clause
2278
return
except_clause -> except : suite maybe_except_clause
2278
(
except_clause -> except : suite maybe_except_clause
2278
while
except_clause -> except : suite maybe_except_clause
2278
finally
except_clause -> except : suite maybe_except_clause
2278
del
except_clause -> except : suite maybe_except_clause
2278
if
except_clause -> except : suite maybe_except_clause
2278
{
except_clause -> except : suite maybe_except_clause
2278
with
except_clause -> except : suite maybe_except_clause
2278
for
except_clause -> except : suite maybe_except_clause
2278
True
except_clause -> except : suite maybe_except_clause
2278
begsim
except_clause -> except : suite maybe_except_clause
2278
assert
except_clause -> except : suite maybe_except_clause
2278
NAME
except_clause -> except : suite maybe_except_clause
2278
conf
except_clause -> except : suite maybe_except_clause
2278
-
except_clause -> except : suite maybe_except_clause
2279
return
maybe_except_clause -> except_clause
2279
None
maybe_except_clause -> except_clause
2279
endsim
maybe_except_clause -> except_clause
2279
NUMBER
maybe_except_clause -> except_clause
2279
(
maybe_except_clause -> except_clause
2279
{
maybe_except_clause -> except_clause
2279
raise
maybe_except_clause -> except_clause
2279
pass
maybe_except_clause -> except_clause
2279
with
maybe_except_clause -> except_clause
2279
not
maybe_except_clause -> except_clause
2279
conf
maybe_except_clause -> except_clause
2279
def
maybe_except_clause -> except_clause
2279
True
maybe_except_clause -> except_clause
2279
while
maybe_except_clause -> except_clause
2279
nonlocal
maybe_except_clause -> except_clause
2279
finally
maybe_except_clause -> except_clause
2279
assert
maybe_except_clause -> except_clause
2279
[
maybe_except_clause -> except_clause
2279
-
maybe_except_clause -> except_clause
2279
False
maybe_except_clause -> except_clause
2279
break
maybe_except_clause -> except_clause
2279
try
maybe_except_clause -> except_clause
2279
for
maybe_except_clause -> except_clause
2279
lambda
maybe_except_clause -> except_clause
2279
NEWLINE
maybe_except_clause -> except_clause
2279
continue
maybe_except_clause -> except_clause
2279
@
maybe_except_clause -> except_clause
2279
else
maybe_except_clause -> except_clause
2279
class
maybe_except_clause -> except_clause
2279
resetstats
maybe_except_clause -> except_clause
2279
begsim
maybe_except_clause -> except_clause
2279
NAME
maybe_except_clause -> except_clause
2279
global
maybe_except_clause -> except_clause
2279
yield
maybe_except_clause -> except_clause
2279
+
maybe_except_clause -> except_clause
2279
~
maybe_except_clause -> except_clause
2279
$
maybe_except_clause -> except_clause
2279
if
maybe_except_clause -> except_clause
2279
del
maybe_except_clause -> except_clause
2279
STRING
maybe_except_clause -> except_clause
2280
nonlocal
simple_stmt -> small_stmt NEWLINE
2280
True
simple_stmt -> small_stmt NEWLINE
2280
except
simple_stmt -> small_stmt NEWLINE
2280
False
simple_stmt -> small_stmt NEWLINE
2280
(
simple_stmt -> small_stmt NEWLINE
2280
continue
simple_stmt -> small_stmt NEWLINE
2280
begsim
simple_stmt -> small_stmt NEWLINE
2280
NAME
simple_stmt -> small_stmt NEWLINE
2280
endsim
simple_stmt -> small_stmt NEWLINE
2280
break
simple_stmt -> small_stmt NEWLINE
2280
return
simple_stmt -> small_stmt NEWLINE
2280
NUMBER
simple_stmt -> small_stmt NEWLINE
2280
[
simple_stmt -> small_stmt NEWLINE
2280
global
simple_stmt -> small_stmt NEWLINE
2280
resetstats
simple_stmt -> small_stmt NEWLINE
2280
yield
simple_stmt -> small_stmt NEWLINE
2280
conf
simple_stmt -> small_stmt NEWLINE
2280
$
simple_stmt -> small_stmt NEWLINE
2280
not
simple_stmt -> small_stmt NEWLINE
2280
finally
simple_stmt -> small_stmt NEWLINE
2280
lambda
simple_stmt -> small_stmt NEWLINE
2280
del
simple_stmt -> small_stmt NEWLINE
2280
pass
simple_stmt -> small_stmt NEWLINE
2280
for
simple_stmt -> small_stmt NEWLINE
2280
@
simple_stmt -> small_stmt NEWLINE
2280
with
simple_stmt -> small_stmt NEWLINE
2280
class
simple_stmt -> small_stmt NEWLINE
2280
NEWLINE
simple_stmt -> small_stmt NEWLINE
2280
if
simple_stmt -> small_stmt NEWLINE
2280
assert
simple_stmt -> small_stmt NEWLINE
2280
None
simple_stmt -> small_stmt NEWLINE
2280
else
simple_stmt -> small_stmt NEWLINE
2280
+
simple_stmt -> small_stmt NEWLINE
2280
-
simple_stmt -> small_stmt NEWLINE
2280
STRING
simple_stmt -> small_stmt NEWLINE
2280
while
simple_stmt -> small_stmt NEWLINE
2280
{
simple_stmt -> small_stmt NEWLINE
2280
raise
simple_stmt -> small_stmt NEWLINE
2280
~
simple_stmt -> small_stmt NEWLINE
2280
def
simple_stmt -> small_stmt NEWLINE
2280
try
simple_stmt -> small_stmt NEWLINE
2281
if
1566
2281
arith_expr
2
2281
try
1567
2281
[
3
2281
class
1568
2281
for
1569
2281
stmt_list
2455
2281
with_stmt
1570
2281
while_stmt
1571
2281
factor
9
2281
@
10
2281
simple_stmt
1572
2281
decorators
1573
2281
return
13
2281
confdef
1574
2281
flow_stmt
15
2281
expr
16
2281
True
17
2281
not_test
18
2281
and_expr
19
2281
def
1575
2281
term
21
2281
xor_expr
22
2281
or_test
23
2281
atom_expr
24
2281
global
25
2281
for_stmt
1576
2281
NUMBER
27
2281
STRING
28
2281
NAME
29
2281
decorator
30
2281
if_stmt
1577
2281
with
1578
2281
endsim
33
2281
classdef
1579
2281
False
35
2281
(
36
2281
and_test
37
2281
conf
1580
2281
comparison
39
2281
lambda
40
2281
while
1581
2281
None
42
2281
try_stmt
1582
2281
funcdef
1583
2281
~
45
2281
decorated
1584
2281
small_stmt
1585
2281
test
48
2281
-
49
2281
shift_expr
50
2281
{
52
2281
lambdef
53
2281
atom
54
2281
+
55
2281
power
56
2281
not
57
2281
compound_stmt
1587
2281
continue
59
2281
del_stmt
60
2281
test_list
61
2281
raise
62
2281
raise_stmt
63
2281
resetstats
64
2281
pass_stmt
65
2281
stmt
1588
2281
nonlocal
66
2281
global_stmt
67
2281
yield
68
2281
continue_stmt
69
2281
assert
70
2281
nonlocal_stmt
71
2281
expr_stmt
72
2281
break_stmt
74
2281
return_stmt
75
2281
break
76
2281
sim_stmt
77
2281
stat_stmt
78
2281
yield_stmt
79
2281
assert_stmt
80
2281
pass
81
2281
begsim
83
2281
del
84
2282
as
and_test -> not_test and and_test
2282
:
and_test -> not_test and and_test
2282
if
and_test -> not_test and and_test
2282
or
and_test -> not_test and and_test
2283
<=
xor_expr -> and_expr ^ xor_expr
2283
!=
xor_expr -> and_expr ^ xor_expr
2283
and
xor_expr -> and_expr ^ xor_expr
2283
is
xor_expr -> and_expr ^ xor_expr
2283
>=
xor_expr -> and_expr ^ xor_expr
2283
not
xor_expr -> and_expr ^ xor_expr
2283
<
xor_expr -> and_expr ^ xor_expr
2283
:
xor_expr -> and_expr ^ xor_expr
2283
|
xor_expr -> and_expr ^ xor_expr
2283
in
xor_expr -> and_expr ^ xor_expr
2283
==
xor_expr -> and_expr ^ xor_expr
2283
or
xor_expr -> and_expr ^ xor_expr
2283
if
xor_expr -> and_expr ^ xor_expr
2283
>
xor_expr -> and_expr ^ xor_expr
2283
as
xor_expr -> and_expr ^ xor_expr
2284
not
expr -> xor_expr | expr
2284
<
expr -> xor_expr | expr
2284
in
expr -> xor_expr | expr
2284
if
expr -> xor_expr | expr
2284
:
expr -> xor_expr | expr
2284
or
expr -> xor_expr | expr
2284
<=
expr -> xor_expr | expr
2284
>
expr -> xor_expr | expr
2284
!=
expr -> xor_expr | expr
2284
==
expr -> xor_expr | expr
2284
>=
expr -> xor_expr | expr
2284
is
expr -> xor_expr | expr
2284
as
expr -> xor_expr | expr
2284
and
expr -> xor_expr | expr
2285
else
2456
2286
as
or_test -> and_test or or_test
2286
if
or_test -> and_test or or_test
2286
:
or_test -> and_test or or_test
2287
factor
9
2287
arith_expr
2
2287
NAME
29
2287
term
21
2287
[
3
2287
~
45
2287
atom_expr
24
2287
expr
16
2287
power
56
2287
(
36
2287
return
13
2287
small_stmt
2457
2287
flow_stmt
15
2287
True
17
2287
not_test
18
2287
and_expr
19
2287
suite
2458
2287
xor_expr
22
2287
{
52
2287
lambdef
53
2287
atom
54
2287
or_test
23
2287
shift_expr
50
2287
False
35
2287
NEWLINE
2459
2287
-
49
2287
None
42
2287
lambda
40
2287
global
25
2287
NUMBER
27
2287
STRING
28
2287
test
48
2287
endsim
33
2287
and_test
37
2287
simple_stmt
2460
2287
comparison
39
2287
break_stmt
74
2287
+
55
2287
not
57
2287
raise
62
2287
return_stmt
75
2287
continue
59
2287
del_stmt
60
2287
test_list
61
2287
raise_stmt
63
2287
resetstats
64
2287
pass_stmt
65
2287
nonlocal
66
2287
break
76
2287
sim_stmt
77
2287
stat_stmt
78
2287
global_stmt
67
2287
yield_stmt
79
2287
assert_stmt
80
2287
pass
81
2287
yield
68
2287
continue_stmt
69
2287
assert
70
2287
nonlocal_stmt
71
2287
expr_stmt
72
2287
begsim
83
2287
del
84
2288
except_clause
2461
2288
except
2462
2289
factor
697
2289
term
698
2289
(
699
2289
arith_expr
700
2289
NAME
701
2289
[
702
2289
atom
703
2289
arglist
2463
2289
+
704
2289
power
706
2289
atom_expr
707
2289
NUMBER
708
2289
STRING
709
2289
*
710
2289
shift_expr
711
2289
-
712
2289
argument
714
2289
True
715
2289
not_test
716
2289
lambdef
717
2289
and_expr
718
2289
)
2464
2289
xor_expr
719
2289
False
720
2289
test
721
2289
None
722
2289
expr
723
2289
and_test
724
2289
{
725
2289
~
726
2289
lambda
727
2289
comparison
728
2289
or_test
729
2289
not
730
2289
**
731
2290
factor
9
2290
arith_expr
2
2290
NAME
29
2290
term
21
2290
[
3
2290
~
45
2290
atom_expr
24
2290
expr
16
2290
power
56
2290
(
36
2290
return
13
2290
small_stmt
1585
2290
flow_stmt
15
2290
True
17
2290
not_test
18
2290
and_expr
19
2290
xor_expr
22
2290
{
52
2290
lambdef
53
2290
atom
54
2290
suite
2465
2290
or_test
23
2290
shift_expr
50
2290
False
35
2290
NEWLINE
2466
2290
-
49
2290
None
42
2290
lambda
40
2290
global
25
2290
NUMBER
27
2290
STRING
28
2290
test
48
2290
endsim
33
2290
and_test
37
2290
simple_stmt
2467
2290
comparison
39
2290
break_stmt
74
2290
+
55
2290
not
57
2290
raise
62
2290
continue
59
2290
return_stmt
75
2290
del_stmt
60
2290
test_list
61
2290
raise_stmt
63
2290
resetstats
64
2290
pass_stmt
65
2290
nonlocal
66
2290
break
76
2290
sim_stmt
77
2290
stat_stmt
78
2290
global_stmt
67
2290
yield_stmt
79
2290
assert_stmt
80
2290
pass
81
2290
yield
68
2290
continue_stmt
69
2290
assert
70
2290
nonlocal_stmt
71
2290
expr_stmt
72
2290
begsim
83
2290
del
84
2291
factor
1029
2291
test_list
2468
2291
term
1031
2291
(
1032
2291
arith_expr
1033
2291
NAME
1034
2291
[
1035
2291
~
1036
2291
+
1037
2291
expr
1038
2291
atom_expr
1039
2291
atom
1040
2291
NUMBER
1041
2291
STRING
1042
2291
shift_expr
1043
2291
-
1044
2291
True
1045
2291
not_test
1046
2291
and_expr
1047
2291
xor_expr
1048
2291
False
1049
2291
{
1050
2291
None
1051
2291
test
1052
2291
and_test
1053
2291
power
1054
2291
lambda
1055
2291
or_test
1056
2291
lambdef
1057
2291
comparison
1058
2291
not
1059
2292
)
2469
2292
parameters
2470
2292
tfpdef
1108
2292
**
1109
2292
param
1110
2292
*
1111
2292
NAME
1112
2293
factor
9
2293
arith_expr
2
2293
NAME
29
2293
term
21
2293
[
3
2293
~
45
2293
suite
2471
2293
atom_expr
24
2293
expr
16
2293
power
56
2293
(
36
2293
return
13
2293
small_stmt
1585
2293
flow_stmt
15
2293
True
17
2293
not_test
18
2293
and_expr
19
2293
xor_expr
22
2293
{
52
2293
lambdef
53
2293
atom
54
2293
or_test
23
2293
shift_expr
50
2293
False
35
2293
NEWLINE
2466
2293
-
49
2293
None
42
2293
lambda
40
2293
global
25
2293
NUMBER
27
2293
STRING
28
2293
test
48
2293
endsim
33
2293
and_test
37
2293
simple_stmt
2467
2293
comparison
39
2293
break_stmt
74
2293
+
55
2293
not
57
2293
raise
62
2293
continue
59
2293
return_stmt
75
2293
del_stmt
60
2293
test_list
61
2293
raise_stmt
63
2293
resetstats
64
2293
pass_stmt
65
2293
nonlocal
66
2293
break
76
2293
sim_stmt
77
2293
stat_stmt
78
2293
global_stmt
67
2293
yield_stmt
79
2293
assert_stmt
80
2293
pass
81
2293
yield
68
2293
continue_stmt
69
2293
assert
70
2293
nonlocal_stmt
71
2293
expr_stmt
72
2293
begsim
83
2293
del
84
2294
NEWLINE
2472
2295
NAME
2473
2296
factor
9
2296
arith_expr
2
2296
NAME
29
2296
term
21
2296
[
3
2296
~
45
2296
suite
2474
2296
atom_expr
24
2296
expr
16
2296
power
56
2296
(
36
2296
return
13
2296
small_stmt
2475
2296
flow_stmt
15
2296
True
17
2296
not_test
18
2296
and_expr
19
2296
xor_expr
22
2296
{
52
2296
lambdef
53
2296
atom
54
2296
or_test
23
2296
shift_expr
50
2296
False
35
2296
NEWLINE
2476
2296
-
49
2296
None
42
2296
lambda
40
2296
global
25
2296
NUMBER
27
2296
STRING
28
2296
test
48
2296
endsim
33
2296
and_test
37
2296
simple_stmt
2477
2296
comparison
39
2296
break_stmt
74
2296
+
55
2296
not
57
2296
raise
62
2296
continue
59
2296
return_stmt
75
2296
del_stmt
60
2296
test_list
61
2296
raise_stmt
63
2296
resetstats
64
2296
pass_stmt
65
2296
nonlocal
66
2296
break
76
2296
sim_stmt
77
2296
stat_stmt
78
2296
global_stmt
67
2296
yield_stmt
79
2296
assert_stmt
80
2296
pass
81
2296
yield
68
2296
continue_stmt
69
2296
assert
70
2296
nonlocal_stmt
71
2296
expr_stmt
72
2296
begsim
83
2296
del
84
2297
class
classdef -> class NAME ( arglist ) : suite
2297
endsim
classdef -> class NAME ( arglist ) : suite
2297
raise
classdef -> class NAME ( arglist ) : suite
2297
NAME
classdef -> class NAME ( arglist ) : suite
2297
pass
classdef -> class NAME ( arglist ) : suite
2297
NUMBER
classdef -> class NAME ( arglist ) : suite
2297
assert
classdef -> class NAME ( arglist ) : suite
2297
yield
classdef -> class NAME ( arglist ) : suite
2297
def
classdef -> class NAME ( arglist ) : suite
2297
STRING
classdef -> class NAME ( arglist ) : suite
2297
if
classdef -> class NAME ( arglist ) : suite
2297
False
classdef -> class NAME ( arglist ) : suite
2297
while
classdef -> class NAME ( arglist ) : suite
2297
begsim
classdef -> class NAME ( arglist ) : suite
2297
resetstats
classdef -> class NAME ( arglist ) : suite
2297
NEWLINE
classdef -> class NAME ( arglist ) : suite
2297
del
classdef -> class NAME ( arglist ) : suite
2297
conf
classdef -> class NAME ( arglist ) : suite
2297
continue
classdef -> class NAME ( arglist ) : suite
2297
(
classdef -> class NAME ( arglist ) : suite
2297
try
classdef -> class NAME ( arglist ) : suite
2297
~
classdef -> class NAME ( arglist ) : suite
2297
return
classdef -> class NAME ( arglist ) : suite
2297
{
classdef -> class NAME ( arglist ) : suite
2297
$
classdef -> class NAME ( arglist ) : suite
2297
[
classdef -> class NAME ( arglist ) : suite
2297
+
classdef -> class NAME ( arglist ) : suite
2297
nonlocal
classdef -> class NAME ( arglist ) : suite
2297
-
classdef -> class NAME ( arglist ) : suite
2297
with
classdef -> class NAME ( arglist ) : suite
2297
not
classdef -> class NAME ( arglist ) : suite
2297
for
classdef -> class NAME ( arglist ) : suite
2297
break
classdef -> class NAME ( arglist ) : suite
2297
@
classdef -> class NAME ( arglist ) : suite
2297
lambda
classdef -> class NAME ( arglist ) : suite
2297
True
classdef -> class NAME ( arglist ) : suite
2297
global
classdef -> class NAME ( arglist ) : suite
2297
None
classdef -> class NAME ( arglist ) : suite
2298
not
suite -> NEWLINE INDENT stmt_list DEDENT
2298
None
suite -> NEWLINE INDENT stmt_list DEDENT
2298
{
suite -> NEWLINE INDENT stmt_list DEDENT
2298
for
suite -> NEWLINE INDENT stmt_list DEDENT
2298
try
suite -> NEWLINE INDENT stmt_list DEDENT
2298
class
suite -> NEWLINE INDENT stmt_list DEDENT
2298
while
suite -> NEWLINE INDENT stmt_list DEDENT
2298
NEWLINE
suite -> NEWLINE INDENT stmt_list DEDENT
2298
-
suite -> NEWLINE INDENT stmt_list DEDENT
2298
if
suite -> NEWLINE INDENT stmt_list DEDENT
2298
+
suite -> NEWLINE INDENT stmt_list DEDENT
2298
resetstats
suite -> NEWLINE INDENT stmt_list DEDENT
2298
return
suite -> NEWLINE INDENT stmt_list DEDENT
2298
with
suite -> NEWLINE INDENT stmt_list DEDENT
2298
NAME
suite -> NEWLINE INDENT stmt_list DEDENT
2298
~
suite -> NEWLINE INDENT stmt_list DEDENT
2298
STRING
suite -> NEWLINE INDENT stmt_list DEDENT
2298
conf
suite -> NEWLINE INDENT stmt_list DEDENT
2298
assert
suite -> NEWLINE INDENT stmt_list DEDENT
2298
def
suite -> NEWLINE INDENT stmt_list DEDENT
2298
yield
suite -> NEWLINE INDENT stmt_list DEDENT
2298
NUMBER
suite -> NEWLINE INDENT stmt_list DEDENT
2298
del
suite -> NEWLINE INDENT stmt_list DEDENT
2298
$
suite -> NEWLINE INDENT stmt_list DEDENT
2298
True
suite -> NEWLINE INDENT stmt_list DEDENT
2298
break
suite -> NEWLINE INDENT stmt_list DEDENT
2298
pass
suite -> NEWLINE INDENT stmt_list DEDENT
2298
endsim
suite -> NEWLINE INDENT stmt_list DEDENT
2298
continue
suite -> NEWLINE INDENT stmt_list DEDENT
2298
[
suite -> NEWLINE INDENT stmt_list DEDENT
2298
begsim
suite -> NEWLINE INDENT stmt_list DEDENT
2298
lambda
suite -> NEWLINE INDENT stmt_list DEDENT
2298
global
suite -> NEWLINE INDENT stmt_list DEDENT
2298
@
suite -> NEWLINE INDENT stmt_list DEDENT
2298
False
suite -> NEWLINE INDENT stmt_list DEDENT
2298
raise
suite -> NEWLINE INDENT stmt_list DEDENT
2298
(
suite -> NEWLINE INDENT stmt_list DEDENT
2298
nonlocal
suite -> NEWLINE INDENT stmt_list DEDENT
2299
:
2478
2300
**
trailer -> ( arglist )
2300
:
trailer -> ( arglist )
2300
if
trailer -> ( arglist )
2300
<
trailer -> ( arglist )
2300
//
trailer -> ( arglist )
2300
<<
trailer -> ( arglist )
2300
%
trailer -> ( arglist )
2300
&
trailer -> ( arglist )
2300
==
trailer -> ( arglist )
2300
is
trailer -> ( arglist )
2300
,
trailer -> ( arglist )
2300
!=
trailer -> ( arglist )
2300
and
trailer -> ( arglist )
2300
-
trailer -> ( arglist )
2300
+
trailer -> ( arglist )
2300
>=
trailer -> ( arglist )
2300
or
trailer -> ( arglist )
2300
(
trailer -> ( arglist )
2300
^
trailer -> ( arglist )
2300
.
trailer -> ( arglist )
2300
not
trailer -> ( arglist )
2300
>>
trailer -> ( arglist )
2300
/
trailer -> ( arglist )
2300
*
trailer -> ( arglist )
2300
[
trailer -> ( arglist )
2300
@
trailer -> ( arglist )
2300
>
trailer -> ( arglist )
2300
|
trailer -> ( arglist )
2300
<=
trailer -> ( arglist )
2300
in
trailer -> ( arglist )
2301
|
trailer -> [ subscriptlist ]
2301
not
trailer -> [ subscriptlist ]
2301
in
trailer -> [ subscriptlist ]
2301
==
trailer -> [ subscriptlist ]
2301
**
trailer -> [ subscriptlist ]
2301
>>
trailer -> [ subscriptlist ]
2301
!=
trailer -> [ subscriptlist ]
2301
*
trailer -> [ subscriptlist ]
2301
or
trailer -> [ subscriptlist ]
2301
>=
trailer -> [ subscriptlist ]
2301
/
trailer -> [ subscriptlist ]
2301
[
trailer -> [ subscriptlist ]
2301
>
trailer -> [ subscriptlist ]
2301
<
trailer -> [ subscriptlist ]
2301
.
trailer -> [ subscriptlist ]
2301
and
trailer -> [ subscriptlist ]
2301
(
trailer -> [ subscriptlist ]
2301
<=
trailer -> [ subscriptlist ]
2301
-
trailer -> [ subscriptlist ]
2301
@
trailer -> [ subscriptlist ]
2301
<<
trailer -> [ subscriptlist ]
2301
&
trailer -> [ subscriptlist ]
2301
,
trailer -> [ subscriptlist ]
2301
:
trailer -> [ subscriptlist ]
2301
^
trailer -> [ subscriptlist ]
2301
is
trailer -> [ subscriptlist ]
2301
%
trailer -> [ subscriptlist ]
2301
+
trailer -> [ subscriptlist ]
2301
//
trailer -> [ subscriptlist ]
2301
if
trailer -> [ subscriptlist ]
2302
:
lambdef -> lambda varargslist : test
2302
,
lambdef -> lambda varargslist : test
2303
factor
1029
2303
term
1031
2303
(
1032
2303
arith_expr
1033
2303
NAME
1034
2303
[
1035
2303
~
1036
2303
+
1037
2303
expr
1038
2303
atom_expr
1039
2303
atom
1040
2303
NUMBER
1041
2303
STRING
1042
2303
shift_expr
1043
2303
-
1044
2303
True
1045
2303
not_test
1046
2303
and_expr
1047
2303
xor_expr
1048
2303
False
1049
2303
{
1050
2303
None
1051
2303
and_test
1053
2303
power
1054
2303
lambda
1055
2303
test
2479
2303
or_test
1056
2303
lambdef
1057
2303
comparison
1058
2303
not
1059
2304
lambda
funcdef -> def NAME ( parameters ) : suite
2304
if
funcdef -> def NAME ( parameters ) : suite
2304
STRING
funcdef -> def NAME ( parameters ) : suite
2304
yield
funcdef -> def NAME ( parameters ) : suite
2304
None
funcdef -> def NAME ( parameters ) : suite
2304
for
funcdef -> def NAME ( parameters ) : suite
2304
NEWLINE
funcdef -> def NAME ( parameters ) : suite
2304
return
funcdef -> def NAME ( parameters ) : suite
2304
nonlocal
funcdef -> def NAME ( parameters ) : suite
2304
del
funcdef -> def NAME ( parameters ) : suite
2304
@
funcdef -> def NAME ( parameters ) : suite
2304
+
funcdef -> def NAME ( parameters ) : suite
2304
endsim
funcdef -> def NAME ( parameters ) : suite
2304
raise
funcdef -> def NAME ( parameters ) : suite
2304
class
funcdef -> def NAME ( parameters ) : suite
2304
False
funcdef -> def NAME ( parameters ) : suite
2304
conf
funcdef -> def NAME ( parameters ) : suite
2304
[
funcdef -> def NAME ( parameters ) : suite
2304
~
funcdef -> def NAME ( parameters ) : suite
2304
def
funcdef -> def NAME ( parameters ) : suite
2304
resetstats
funcdef -> def NAME ( parameters ) : suite
2304
begsim
funcdef -> def NAME ( parameters ) : suite
2304
True
funcdef -> def NAME ( parameters ) : suite
2304
-
funcdef -> def NAME ( parameters ) : suite
2304
try
funcdef -> def NAME ( parameters ) : suite
2304
NUMBER
funcdef -> def NAME ( parameters ) : suite
2304
NAME
funcdef -> def NAME ( parameters ) : suite
2304
with
funcdef -> def NAME ( parameters ) : suite
2304
while
funcdef -> def NAME ( parameters ) : suite
2304
break
funcdef -> def NAME ( parameters ) : suite
2304
pass
funcdef -> def NAME ( parameters ) : suite
2304
{
funcdef -> def NAME ( parameters ) : suite
2304
not
funcdef -> def NAME ( parameters ) : suite
2304
$
funcdef -> def NAME ( parameters ) : suite
2304
continue
funcdef -> def NAME ( parameters ) : suite
2304
assert
funcdef -> def NAME ( parameters ) : suite
2304
(
funcdef -> def NAME ( parameters ) : suite
2304
global
funcdef -> def NAME ( parameters ) : suite
2305
)
tfpdef -> NAME : test
2305
,
tfpdef -> NAME : test
2306
factor
2043
2306
(
2045
2306
NAME
2047
2306
[
2048
2306
atom
2049
2306
+
2050
2306
atom_expr
2052
2306
power
2051
2306
NUMBER
2053
2306
STRING
2054
2306
-
2056
2306
term
2480
2306
True
2057
2306
None
2061
2306
False
2062
2306
{
2064
2306
~
2065
2307
factor
2043
2307
(
2045
2307
NAME
2047
2307
[
2048
2307
atom
2049
2307
+
2050
2307
atom_expr
2052
2307
power
2051
2307
NUMBER
2053
2307
STRING
2054
2307
-
2056
2307
True
2057
2307
None
2061
2307
term
2481
2307
False
2062
2307
{
2064
2307
~
2065
2308
factor
2043
2308
(
2045
2308
NAME
2047
2308
term
2482
2308
[
2048
2308
atom
2049
2308
+
2050
2308
atom_expr
2052
2308
power
2051
2308
NUMBER
2053
2308
STRING
2054
2308
-
2056
2308
True
2057
2308
None
2061
2308
False
2062
2308
{
2064
2308
~
2065
2309
factor
2043
2309
(
2045
2309
NAME
2047
2309
[
2048
2309
atom
2049
2309
+
2050
2309
atom_expr
2052
2309
power
2051
2309
NUMBER
2053
2309
STRING
2054
2309
-
2056
2309
term
2483
2309
True
2057
2309
None
2061
2309
False
2062
2309
{
2064
2309
~
2065
2310
factor
2043
2310
(
2045
2310
NAME
2047
2310
[
2048
2310
atom
2049
2310
+
2050
2310
atom_expr
2052
2310
power
2051
2310
NUMBER
2053
2310
term
2484
2310
STRING
2054
2310
-
2056
2310
True
2057
2310
None
2061
2310
False
2062
2310
{
2064
2310
~
2065
2311
factor
2043
2311
term
2044
2311
(
2045
2311
NAME
2047
2311
[
2048
2311
atom
2049
2311
+
2050
2311
power
2051
2311
atom_expr
2052
2311
NUMBER
2053
2311
STRING
2054
2311
-
2056
2311
True
2057
2311
arith_expr
2485
2311
None
2061
2311
False
2062
2311
{
2064
2311
~
2065
2312
factor
2043
2312
term
2044
2312
(
2045
2312
NAME
2047
2312
[
2048
2312
atom
2049
2312
+
2050
2312
power
2051
2312
atom_expr
2052
2312
NUMBER
2053
2312
STRING
2054
2312
-
2056
2312
True
2057
2312
arith_expr
2486
2312
None
2061
2312
False
2062
2312
{
2064
2312
~
2065
2313
)
2487
2314
)
atom -> ( )
2314
or
atom -> ( )
2314
<<
atom -> ( )
2314
not
atom -> ( )
2314
&
atom -> ( )
2314
(
atom -> ( )
2314
in
atom -> ( )
2314
**
atom -> ( )
2314
@
atom -> ( )
2314
=
atom -> ( )
2314
<=
atom -> ( )
2314
%
atom -> ( )
2314
[
atom -> ( )
2314
>=
atom -> ( )
2314
/
atom -> ( )
2314
+
atom -> ( )
2314
<
atom -> ( )
2314
is
atom -> ( )
2314
*
atom -> ( )
2314
!=
atom -> ( )
2314
-
atom -> ( )
2314
|
atom -> ( )
2314
//
atom -> ( )
2314
^
atom -> ( )
2314
and
atom -> ( )
2314
==
atom -> ( )
2314
if
atom -> ( )
2314
>
atom -> ( )
2314
,
atom -> ( )
2314
.
atom -> ( )
2314
>>
atom -> ( )
2315
factor
2043
2315
term
2044
2315
(
2045
2315
arith_expr
2046
2315
NAME
2047
2315
[
2048
2315
atom
2049
2315
+
2050
2315
power
2051
2315
atom_expr
2052
2315
NUMBER
2053
2315
STRING
2054
2315
-
2056
2315
shift_expr
2488
2315
True
2057
2315
None
2061
2315
False
2062
2315
{
2064
2315
~
2065
2316
factor
2043
2316
term
2044
2316
(
2045
2316
arith_expr
2046
2316
NAME
2047
2316
[
2048
2316
atom
2049
2316
+
2050
2316
power
2051
2316
atom_expr
2052
2316
NUMBER
2053
2316
STRING
2054
2316
-
2056
2316
True
2057
2316
shift_expr
2489
2316
None
2061
2316
False
2062
2316
{
2064
2316
~
2065
2317
]
2490
2318
<=
atom -> [ ]
2318
is
atom -> [ ]
2318
-
atom -> [ ]
2318
**
atom -> [ ]
2318
)
atom -> [ ]
2318
^
atom -> [ ]
2318
%
atom -> [ ]
2318
/
atom -> [ ]
2318
>=
atom -> [ ]
2318
|
atom -> [ ]
2318
not
atom -> [ ]
2318
@
atom -> [ ]
2318
*
atom -> [ ]
2318
(
atom -> [ ]
2318
,
atom -> [ ]
2318
>>
atom -> [ ]
2318
[
atom -> [ ]
2318
or
atom -> [ ]
2318
!=
atom -> [ ]
2318
and
atom -> [ ]
2318
<<
atom -> [ ]
2318
if
atom -> [ ]
2318
in
atom -> [ ]
2318
+
atom -> [ ]
2318
.
atom -> [ ]
2318
==
atom -> [ ]
2318
>
atom -> [ ]
2318
=
atom -> [ ]
2318
<
atom -> [ ]
2318
&
atom -> [ ]
2318
//
atom -> [ ]
2319
trailer_expr
2491
2319
trailer
2319
2319
.
2320
2319
(
2321
2319
[
2322
2319
<<
trailer_expr -> 
2319
%
trailer_expr -> 
2319
==
trailer_expr -> 
2319
-
trailer_expr -> 
2319
<
trailer_expr -> 
2319
if
trailer_expr -> 
2319
or
trailer_expr -> 
2319
/
trailer_expr -> 
2319
**
trailer_expr -> 
2319
and
trailer_expr -> 
2319
@
trailer_expr -> 
2319
=
trailer_expr -> 
2319
*
trailer_expr -> 
2319
|
trailer_expr -> 
2319
is
trailer_expr -> 
2319
,
trailer_expr -> 
2319
+
trailer_expr -> 
2319
in
trailer_expr -> 
2319
&
trailer_expr -> 
2319
<=
trailer_expr -> 
2319
>=
trailer_expr -> 
2319
^
trailer_expr -> 
2319
>
trailer_expr -> 
2319
!=
trailer_expr -> 
2319
)
trailer_expr -> 
2319
not
trailer_expr -> 
2319
>>
trailer_expr -> 
2319
//
trailer_expr -> 
2320
NAME
2492
2321
factor
697
2321
term
698
2321
(
699
2321
arith_expr
700
2321
NAME
701
2321
[
702
2321
atom
703
2321
+
704
2321
power
706
2321
atom_expr
707
2321
NUMBER
708
2321
STRING
709
2321
*
710
2321
shift_expr
711
2321
-
712
2321
argument
714
2321
)
2493
2321
True
715
2321
not_test
716
2321
lambdef
717
2321
and_expr
718
2321
xor_expr
719
2321
False
720
2321
test
721
2321
None
722
2321
arglist
2494
2321
expr
723
2321
and_test
724
2321
{
725
2321
~
726
2321
lambda
727
2321
comparison
728
2321
or_test
729
2321
not
730
2321
**
731
2322
factor
732
2322
or_test
733
2322
term
734
2322
(
735
2322
arith_expr
736
2322
NAME
737
2322
[
738
2322
~
739
2322
subscriptlist
2495
2322
+
741
2322
maybe_test
742
2322
expr
743
2322
atom_expr
744
2322
atom
745
2322
NUMBER
746
2322
STRING
747
2322
shift_expr
748
2322
-
749
2322
True
750
2322
not_test
751
2322
and_expr
752
2322
xor_expr
753
2322
False
754
2322
{
755
2322
None
756
2322
and_test
757
2322
lambda
758
2322
power
759
2322
subscript
760
2322
test
761
2322
lambdef
762
2322
:
maybe_test -> 
2322
comparison
763
2322
not
764
2323
>
atom_expr -> atom trailer_expr
2323
not
atom_expr -> atom trailer_expr
2323
=
atom_expr -> atom trailer_expr
2323
//
atom_expr -> atom trailer_expr
2323
>>
atom_expr -> atom trailer_expr
2323
|
atom_expr -> atom trailer_expr
2323
^
atom_expr -> atom trailer_expr
2323
/
atom_expr -> atom trailer_expr
2323
+
atom_expr -> atom trailer_expr
2323
in
atom_expr -> atom trailer_expr
2323
%
atom_expr -> atom trailer_expr
2323
and
atom_expr -> atom trailer_expr
2323
<=
atom_expr -> atom trailer_expr
2323
is
atom_expr -> atom trailer_expr
2323
<
atom_expr -> atom trailer_expr
2323
@
atom_expr -> atom trailer_expr
2323
-
atom_expr -> atom trailer_expr
2323
&
atom_expr -> atom trailer_expr
2323
*
atom_expr -> atom trailer_expr
2323
**
atom_expr -> atom trailer_expr
2323
>=
atom_expr -> atom trailer_expr
2323
)
atom_expr -> atom trailer_expr
2323
or
atom_expr -> atom trailer_expr
2323
,
atom_expr -> atom trailer_expr
2323
==
atom_expr -> atom trailer_expr
2323
!=
atom_expr -> atom trailer_expr
2323
if
atom_expr -> atom trailer_expr
2323
<<
atom_expr -> atom trailer_expr
2324
<
factor -> + factor
2324
if
factor -> + factor
2324
<<
factor -> + factor
2324
and
factor -> + factor
2324
>=
factor -> + factor
2324
%
factor -> + factor
2324
>>
factor -> + factor
2324
*
factor -> + factor
2324
+
factor -> + factor
2324
)
factor -> + factor
2324
/
factor -> + factor
2324
>
factor -> + factor
2324
<=
factor -> + factor
2324
^
factor -> + factor
2324
is
factor -> + factor
2324
|
factor -> + factor
2324
or
factor -> + factor
2324
=
factor -> + factor
2324
-
factor -> + factor
2324
in
factor -> + factor
2324
&
factor -> + factor
2324
not
factor -> + factor
2324
//
factor -> + factor
2324
,
factor -> + factor
2324
!=
factor -> + factor
2324
==
factor -> + factor
2324
@
factor -> + factor
2325
(
2045
2325
NAME
2047
2325
[
2048
2325
atom
2049
2325
+
2050
2325
atom_expr
2052
2325
power
2051
2325
NUMBER
2053
2325
STRING
2054
2325
-
2056
2325
factor
2496
2325
True
2057
2325
None
2061
2325
False
2062
2325
{
2064
2325
~
2065
2326
factor
2043
2326
term
2044
2326
(
2045
2326
arith_expr
2046
2326
NAME
2047
2326
[
2048
2326
atom
2049
2326
+
2050
2326
power
2051
2326
atom_expr
2052
2326
NUMBER
2053
2326
STRING
2054
2326
shift_expr
2055
2326
-
2056
2326
True
2057
2326
None
2061
2326
and_expr
2497
2326
False
2062
2326
{
2064
2326
~
2065
2327
and
factor -> - factor
2327
if
factor -> - factor
2327
or
factor -> - factor
2327
>=
factor -> - factor
2327
<
factor -> - factor
2327
!=
factor -> - factor
2327
-
factor -> - factor
2327
=
factor -> - factor
2327
==
factor -> - factor
2327
@
factor -> - factor
2327
|
factor -> - factor
2327
*
factor -> - factor
2327
%
factor -> - factor
2327
+
factor -> - factor
2327
<=
factor -> - factor
2327
//
factor -> - factor
2327
not
factor -> - factor
2327
>>
factor -> - factor
2327
/
factor -> - factor
2327
&
factor -> - factor
2327
^
factor -> - factor
2327
)
factor -> - factor
2327
in
factor -> - factor
2327
is
factor -> - factor
2327
>
factor -> - factor
2327
,
factor -> - factor
2327
<<
factor -> - factor
2328
factor
2043
2328
term
2044
2328
(
2045
2328
arith_expr
2046
2328
NAME
2047
2328
[
2048
2328
atom
2049
2328
+
2050
2328
power
2051
2328
atom_expr
2052
2328
NUMBER
2053
2328
STRING
2054
2328
shift_expr
2055
2328
-
2056
2328
True
2057
2328
not_test
2058
2328
and_expr
2059
2328
xor_expr
2060
2328
None
2061
2328
False
2062
2328
{
2064
2328
~
2065
2328
and_test
2498
2328
expr
2066
2328
comparison
2068
2328
not
2072
2329
factor
2043
2329
term
2044
2329
(
2045
2329
arith_expr
2046
2329
NAME
2047
2329
[
2048
2329
atom
2049
2329
+
2050
2329
power
2051
2329
atom_expr
2052
2329
NUMBER
2053
2329
STRING
2054
2329
shift_expr
2055
2329
-
2056
2329
True
2057
2329
and_expr
2059
2329
None
2061
2329
False
2062
2329
{
2064
2329
~
2065
2329
xor_expr
2499
2330
factor
2043
2330
term
2044
2330
(
2045
2330
arith_expr
2046
2330
NAME
2047
2330
[
2048
2330
atom
2049
2330
+
2050
2330
power
2051
2330
atom_expr
2052
2330
NUMBER
2053
2330
STRING
2054
2330
shift_expr
2055
2330
-
2056
2330
True
2057
2330
and_expr
2059
2330
xor_expr
2060
2330
None
2061
2330
False
2062
2330
{
2064
2330
~
2065
2330
expr
2500
2331
factor
2043
2331
term
2044
2331
(
2045
2331
arith_expr
2046
2331
NAME
2047
2331
[
2048
2331
atom
2049
2331
+
2050
2331
power
2051
2331
atom_expr
2052
2331
NUMBER
2053
2331
STRING
2054
2331
shift_expr
2055
2331
-
2056
2331
True
2057
2331
not_test
2058
2331
and_expr
2059
2331
xor_expr
2060
2331
None
2061
2331
False
2062
2331
and_test
2063
2331
{
2064
2331
~
2065
2331
expr
2066
2331
comparison
2068
2331
or_test
2501
2331
not
2072
2332
>
atom -> { }
2332
==
atom -> { }
2332
)
atom -> { }
2332
-
atom -> { }
2332
not
atom -> { }
2332
(
atom -> { }
2332
@
atom -> { }
2332
if
atom -> { }
2332
and
atom -> { }
2332
,
atom -> { }
2332
&
atom -> { }
2332
<<
atom -> { }
2332
!=
atom -> { }
2332
or
atom -> { }
2332
>>
atom -> { }
2332
<=
atom -> { }
2332
>=
atom -> { }
2332
is
atom -> { }
2332
/
atom -> { }
2332
=
atom -> { }
2332
^
atom -> { }
2332
[
atom -> { }
2332
%
atom -> { }
2332
//
atom -> { }
2332
*
atom -> { }
2332
**
atom -> { }
2332
.
atom -> { }
2332
in
atom -> { }
2332
+
atom -> { }
2332
|
atom -> { }
2332
<
atom -> { }
2333
or
factor -> ~ factor
2333
==
factor -> ~ factor
2333
<=
factor -> ~ factor
2333
@
factor -> ~ factor
2333
!=
factor -> ~ factor
2333
>=
factor -> ~ factor
2333
>
factor -> ~ factor
2333
and
factor -> ~ factor
2333
,
factor -> ~ factor
2333
*
factor -> ~ factor
2333
&
factor -> ~ factor
2333
%
factor -> ~ factor
2333
<
factor -> ~ factor
2333
//
factor -> ~ factor
2333
=
factor -> ~ factor
2333
if
factor -> ~ factor
2333
^
factor -> ~ factor
2333
/
factor -> ~ factor
2333
in
factor -> ~ factor
2333
+
factor -> ~ factor
2333
not
factor -> ~ factor
2333
-
factor -> ~ factor
2333
is
factor -> ~ factor
2333
)
factor -> ~ factor
2333
>>
factor -> ~ factor
2333
<<
factor -> ~ factor
2333
|
factor -> ~ factor
2334
factor
2043
2334
term
2044
2334
(
2045
2334
arith_expr
2046
2334
NAME
2047
2334
[
2048
2334
atom
2049
2334
+
2050
2334
power
2051
2334
atom_expr
2052
2334
NUMBER
2053
2334
STRING
2054
2334
shift_expr
2055
2334
-
2056
2334
True
2057
2334
and_expr
2059
2334
comparison
2502
2334
xor_expr
2060
2334
None
2061
2334
False
2062
2334
{
2064
2334
~
2065
2334
expr
2066
2335
factor
2043
2335
term
2044
2335
(
2045
2335
arith_expr
2046
2335
NAME
2047
2335
[
2048
2335
atom
2049
2335
+
2050
2335
power
2051
2335
atom_expr
2052
2335
NUMBER
2053
2335
STRING
2054
2335
shift_expr
2055
2335
-
2056
2335
True
2057
2335
not_test
2058
2335
and_expr
2059
2335
xor_expr
2060
2335
None
2061
2335
False
2062
2335
and_test
2063
2335
{
2064
2335
~
2065
2335
test
2503
2335
expr
2066
2335
lambda
2067
2335
comparison
2068
2335
or_test
2070
2335
lambdef
2071
2335
not
2072
2336
:
2504
2337
factor
585
2337
(
586
2337
arith_expr
587
2337
NAME
588
2337
[
589
2337
and_expr
590
2337
+
591
2337
term
592
2337
atom_expr
593
2337
NUMBER
594
2337
atom
595
2337
STRING
596
2337
shift_expr
597
2337
-
598
2337
True
599
2337
not
600
2337
xor_expr
601
2337
None
602
2337
False
603
2337
not_test
605
2337
~
606
2337
power
607
2337
{
608
2337
expr
609
2337
or_test
2505
2337
comparison
610
2337
and_test
611
2338
)
not_test -> not not_test
2338
or
not_test -> not not_test
2338
,
not_test -> not not_test
2338
and
not_test -> not not_test
2338
if
not_test -> not not_test
2338
=
not_test -> not not_test
2339
[
trailer -> ( arglist )
2339
**
trailer -> ( arglist )
2339
:
trailer -> ( arglist )
2339
@
trailer -> ( arglist )
2339
-
trailer -> ( arglist )
2339
,
trailer -> ( arglist )
2339
&
trailer -> ( arglist )
2339
+
trailer -> ( arglist )
2339
^
trailer -> ( arglist )
2339
//
trailer -> ( arglist )
2339
.
trailer -> ( arglist )
2339
|
trailer -> ( arglist )
2339
>>
trailer -> ( arglist )
2339
(
trailer -> ( arglist )
2339
<<
trailer -> ( arglist )
2339
%
trailer -> ( arglist )
2339
/
trailer -> ( arglist )
2339
*
trailer -> ( arglist )
2340
,
trailer -> [ subscriptlist ]
2340
|
trailer -> [ subscriptlist ]
2340
.
trailer -> [ subscriptlist ]
2340
<<
trailer -> [ subscriptlist ]
2340
(
trailer -> [ subscriptlist ]
2340
:
trailer -> [ subscriptlist ]
2340
^
trailer -> [ subscriptlist ]
2340
>>
trailer -> [ subscriptlist ]
2340
[
trailer -> [ subscriptlist ]
2340
-
trailer -> [ subscriptlist ]
2340
%
trailer -> [ subscriptlist ]
2340
+
trailer -> [ subscriptlist ]
2340
//
trailer -> [ subscriptlist ]
2340
/
trailer -> [ subscriptlist ]
2340
@
trailer -> [ subscriptlist ]
2340
**
trailer -> [ subscriptlist ]
2340
*
trailer -> [ subscriptlist ]
2340
&
trailer -> [ subscriptlist ]
2341
**
trailer -> ( arglist )
2341
if
trailer -> ( arglist )
2341
<
trailer -> ( arglist )
2341
//
trailer -> ( arglist )
2341
<<
trailer -> ( arglist )
2341
%
trailer -> ( arglist )
2341
)
trailer -> ( arglist )
2341
&
trailer -> ( arglist )
2341
==
trailer -> ( arglist )
2341
is
trailer -> ( arglist )
2341
,
trailer -> ( arglist )
2341
!=
trailer -> ( arglist )
2341
and
trailer -> ( arglist )
2341
-
trailer -> ( arglist )
2341
+
trailer -> ( arglist )
2341
>=
trailer -> ( arglist )
2341
or
trailer -> ( arglist )
2341
(
trailer -> ( arglist )
2341
^
trailer -> ( arglist )
2341
.
trailer -> ( arglist )
2341
not
trailer -> ( arglist )
2341
>>
trailer -> ( arglist )
2341
/
trailer -> ( arglist )
2341
*
trailer -> ( arglist )
2341
[
trailer -> ( arglist )
2341
@
trailer -> ( arglist )
2341
>
trailer -> ( arglist )
2341
|
trailer -> ( arglist )
2341
<=
trailer -> ( arglist )
2341
in
trailer -> ( arglist )
2342
|
trailer -> [ subscriptlist ]
2342
not
trailer -> [ subscriptlist ]
2342
in
trailer -> [ subscriptlist ]
2342
==
trailer -> [ subscriptlist ]
2342
**
trailer -> [ subscriptlist ]
2342
>>
trailer -> [ subscriptlist ]
2342
!=
trailer -> [ subscriptlist ]
2342
*
trailer -> [ subscriptlist ]
2342
or
trailer -> [ subscriptlist ]
2342
>=
trailer -> [ subscriptlist ]
2342
/
trailer -> [ subscriptlist ]
2342
[
trailer -> [ subscriptlist ]
2342
>
trailer -> [ subscriptlist ]
2342
<
trailer -> [ subscriptlist ]
2342
.
trailer -> [ subscriptlist ]
2342
and
trailer -> [ subscriptlist ]
2342
(
trailer -> [ subscriptlist ]
2342
<=
trailer -> [ subscriptlist ]
2342
-
trailer -> [ subscriptlist ]
2342
@
trailer -> [ subscriptlist ]
2342
<<
trailer -> [ subscriptlist ]
2342
&
trailer -> [ subscriptlist ]
2342
,
trailer -> [ subscriptlist ]
2342
^
trailer -> [ subscriptlist ]
2342
is
trailer -> [ subscriptlist ]
2342
%
trailer -> [ subscriptlist ]
2342
+
trailer -> [ subscriptlist ]
2342
//
trailer -> [ subscriptlist ]
2342
)
trailer -> [ subscriptlist ]
2342
if
trailer -> [ subscriptlist ]
2343
,
lambdef -> lambda varargslist : test
2343
)
lambdef -> lambda varargslist : test
2344
factor
1221
2344
term
1222
2344
(
1223
2344
arith_expr
1224
2344
NAME
1225
2344
[
1226
2344
+
1227
2344
atom_expr
1228
2344
NUMBER
1229
2344
atom
1230
2344
STRING
1231
2344
shift_expr
1232
2344
-
1233
2344
True
1234
2344
not_test
1235
2344
and_expr
1236
2344
xor_expr
1237
2344
test
2506
2344
None
1238
2344
False
1239
2344
and_test
1240
2344
{
1241
2344
~
1242
2344
power
1243
2344
expr
1244
2344
lambda
1245
2344
comparison
1246
2344
or_test
1247
2344
not
1249
2344
lambdef
1251
2345
factor
2123
2345
(
2124
2345
NAME
2126
2345
[
2127
2345
+
2128
2345
atom_expr
2130
2345
NUMBER
2131
2345
atom
2132
2345
STRING
2133
2345
-
2135
2345
term
2507
2345
True
2136
2345
False
2139
2345
None
2141
2345
{
2144
2345
~
2145
2345
power
2146
2346
factor
2123
2346
(
2124
2346
NAME
2126
2346
[
2127
2346
+
2128
2346
atom_expr
2130
2346
NUMBER
2131
2346
atom
2132
2346
STRING
2133
2346
-
2135
2346
True
2136
2346
False
2139
2346
None
2141
2346
term
2508
2346
{
2144
2346
~
2145
2346
power
2146
2347
factor
2123
2347
(
2124
2347
NAME
2126
2347
term
2509
2347
[
2127
2347
+
2128
2347
atom_expr
2130
2347
NUMBER
2131
2347
atom
2132
2347
STRING
2133
2347
-
2135
2347
True
2136
2347
False
2139
2347
None
2141
2347
{
2144
2347
~
2145
2347
power
2146
2348
factor
2123
2348
(
2124
2348
NAME
2126
2348
[
2127
2348
+
2128
2348
atom_expr
2130
2348
NUMBER
2131
2348
atom
2132
2348
STRING
2133
2348
-
2135
2348
term
2510
2348
True
2136
2348
False
2139
2348
None
2141
2348
{
2144
2348
~
2145
2348
power
2146
2349
factor
2123
2349
(
2124
2349
NAME
2126
2349
[
2127
2349
+
2128
2349
atom_expr
2130
2349
NUMBER
2131
2349
atom
2132
2349
term
2511
2349
STRING
2133
2349
-
2135
2349
True
2136
2349
False
2139
2349
None
2141
2349
{
2144
2349
~
2145
2349
power
2146
2350
)
2512
2351
for
atom -> ( )
2351
)
atom -> ( )
2351
or
atom -> ( )
2351
<<
atom -> ( )
2351
not
atom -> ( )
2351
&
atom -> ( )
2351
(
atom -> ( )
2351
in
atom -> ( )
2351
**
atom -> ( )
2351
@
atom -> ( )
2351
<=
atom -> ( )
2351
%
atom -> ( )
2351
[
atom -> ( )
2351
>=
atom -> ( )
2351
/
atom -> ( )
2351
+
atom -> ( )
2351
<
atom -> ( )
2351
is
atom -> ( )
2351
*
atom -> ( )
2351
!=
atom -> ( )
2351
-
atom -> ( )
2351
|
atom -> ( )
2351
//
atom -> ( )
2351
^
atom -> ( )
2351
and
atom -> ( )
2351
==
atom -> ( )
2351
if
atom -> ( )
2351
>
atom -> ( )
2351
.
atom -> ( )
2351
>>
atom -> ( )
2352
factor
2123
2352
(
2124
2352
arith_expr
2125
2352
NAME
2126
2352
[
2127
2352
+
2128
2352
term
2129
2352
atom_expr
2130
2352
NUMBER
2131
2352
atom
2132
2352
STRING
2133
2352
-
2135
2352
shift_expr
2513
2352
True
2136
2352
False
2139
2352
None
2141
2352
{
2144
2352
~
2145
2352
power
2146
2353
factor
2123
2353
(
2124
2353
arith_expr
2125
2353
NAME
2126
2353
[
2127
2353
+
2128
2353
term
2129
2353
atom_expr
2130
2353
NUMBER
2131
2353
atom
2132
2353
STRING
2133
2353
-
2135
2353
True
2136
2353
shift_expr
2514
2353
False
2139
2353
None
2141
2353
{
2144
2353
~
2145
2353
power
2146
2354
]
2515
2355
<=
atom -> [ ]
2355
is
atom -> [ ]
2355
-
atom -> [ ]
2355
**
atom -> [ ]
2355
)
atom -> [ ]
2355
^
atom -> [ ]
2355
%
atom -> [ ]
2355
/
atom -> [ ]
2355
>=
atom -> [ ]
2355
|
atom -> [ ]
2355
not
atom -> [ ]
2355
@
atom -> [ ]
2355
*
atom -> [ ]
2355
(
atom -> [ ]
2355
>>
atom -> [ ]
2355
[
atom -> [ ]
2355
or
atom -> [ ]
2355
!=
atom -> [ ]
2355
and
atom -> [ ]
2355
<<
atom -> [ ]
2355
if
atom -> [ ]
2355
in
atom -> [ ]
2355
+
atom -> [ ]
2355
.
atom -> [ ]
2355
==
atom -> [ ]
2355
>
atom -> [ ]
2355
<
atom -> [ ]
2355
for
atom -> [ ]
2355
&
atom -> [ ]
2355
//
atom -> [ ]
2356
<
factor -> + factor
2356
if
factor -> + factor
2356
<<
factor -> + factor
2356
and
factor -> + factor
2356
>=
factor -> + factor
2356
%
factor -> + factor
2356
>>
factor -> + factor
2356
*
factor -> + factor
2356
+
factor -> + factor
2356
)
factor -> + factor
2356
/
factor -> + factor
2356
>
factor -> + factor
2356
<=
factor -> + factor
2356
^
factor -> + factor
2356
is
factor -> + factor
2356
|
factor -> + factor
2356
or
factor -> + factor
2356
-
factor -> + factor
2356
in
factor -> + factor
2356
for
factor -> + factor
2356
&
factor -> + factor
2356
not
factor -> + factor
2356
//
factor -> + factor
2356
!=
factor -> + factor
2356
==
factor -> + factor
2356
@
factor -> + factor
2357
factor
2123
2357
(
2124
2357
NAME
2126
2357
[
2127
2357
+
2128
2357
term
2129
2357
atom_expr
2130
2357
NUMBER
2131
2357
atom
2132
2357
STRING
2133
2357
-
2135
2357
True
2136
2357
arith_expr
2516
2357
False
2139
2357
None
2141
2357
{
2144
2357
~
2145
2357
power
2146
2358
factor
2123
2358
(
2124
2358
NAME
2126
2358
[
2127
2358
+
2128
2358
term
2129
2358
atom_expr
2130
2358
NUMBER
2131
2358
atom
2132
2358
STRING
2133
2358
-
2135
2358
True
2136
2358
False
2139
2358
None
2141
2358
arith_expr
2517
2358
{
2144
2358
~
2145
2358
power
2146
2359
(
2124
2359
NAME
2126
2359
[
2127
2359
+
2128
2359
atom_expr
2130
2359
NUMBER
2131
2359
atom
2132
2359
STRING
2133
2359
-
2135
2359
factor
2518
2359
True
2136
2359
False
2139
2359
None
2141
2359
{
2144
2359
~
2145
2359
power
2146
2360
trailer_expr
2519
2360
trailer
2360
2360
.
2361
2360
(
2362
2360
[
2363
2360
<<
trailer_expr -> 
2360
%
trailer_expr -> 
2360
==
trailer_expr -> 
2360
-
trailer_expr -> 
2360
<
trailer_expr -> 
2360
if
trailer_expr -> 
2360
or
trailer_expr -> 
2360
/
trailer_expr -> 
2360
**
trailer_expr -> 
2360
and
trailer_expr -> 
2360
@
trailer_expr -> 
2360
*
trailer_expr -> 
2360
|
trailer_expr -> 
2360
is
trailer_expr -> 
2360
+
trailer_expr -> 
2360
in
trailer_expr -> 
2360
for
trailer_expr -> 
2360
&
trailer_expr -> 
2360
<=
trailer_expr -> 
2360
>=
trailer_expr -> 
2360
^
trailer_expr -> 
2360
>
trailer_expr -> 
2360
!=
trailer_expr -> 
2360
)
trailer_expr -> 
2360
not
trailer_expr -> 
2360
>>
trailer_expr -> 
2360
//
trailer_expr -> 
2361
NAME
2520
2362
factor
697
2362
term
698
2362
(
699
2362
arith_expr
700
2362
NAME
701
2362
[
702
2362
atom
703
2362
+
704
2362
power
706
2362
atom_expr
707
2362
NUMBER
708
2362
STRING
709
2362
*
710
2362
shift_expr
711
2362
-
712
2362
argument
714
2362
)
2521
2362
True
715
2362
not_test
716
2362
lambdef
717
2362
and_expr
718
2362
xor_expr
719
2362
False
720
2362
test
721
2362
None
722
2362
arglist
2522
2362
expr
723
2362
and_test
724
2362
{
725
2362
~
726
2362
lambda
727
2362
comparison
728
2362
or_test
729
2362
not
730
2362
**
731
2363
factor
732
2363
or_test
733
2363
term
734
2363
(
735
2363
arith_expr
736
2363
NAME
737
2363
[
738
2363
~
739
2363
subscriptlist
2523
2363
+
741
2363
maybe_test
742
2363
expr
743
2363
atom_expr
744
2363
atom
745
2363
NUMBER
746
2363
STRING
747
2363
shift_expr
748
2363
-
749
2363
True
750
2363
not_test
751
2363
and_expr
752
2363
xor_expr
753
2363
False
754
2363
{
755
2363
None
756
2363
and_test
757
2363
lambda
758
2363
power
759
2363
subscript
760
2363
test
761
2363
lambdef
762
2363
:
maybe_test -> 
2363
comparison
763
2363
not
764
2364
>
atom_expr -> atom trailer_expr
2364
not
atom_expr -> atom trailer_expr
2364
//
atom_expr -> atom trailer_expr
2364
>>
atom_expr -> atom trailer_expr
2364
|
atom_expr -> atom trailer_expr
2364
^
atom_expr -> atom trailer_expr
2364
/
atom_expr -> atom trailer_expr
2364
+
atom_expr -> atom trailer_expr
2364
in
atom_expr -> atom trailer_expr
2364
%
atom_expr -> atom trailer_expr
2364
and
atom_expr -> atom trailer_expr
2364
<=
atom_expr -> atom trailer_expr
2364
is
atom_expr -> atom trailer_expr
2364
<
atom_expr -> atom trailer_expr
2364
@
atom_expr -> atom trailer_expr
2364
-
atom_expr -> atom trailer_expr
2364
&
atom_expr -> atom trailer_expr
2364
*
atom_expr -> atom trailer_expr
2364
**
atom_expr -> atom trailer_expr
2364
>=
atom_expr -> atom trailer_expr
2364
)
atom_expr -> atom trailer_expr
2364
for
atom_expr -> atom trailer_expr
2364
or
atom_expr -> atom trailer_expr
2364
==
atom_expr -> atom trailer_expr
2364
!=
atom_expr -> atom trailer_expr
2364
if
atom_expr -> atom trailer_expr
2364
<<
atom_expr -> atom trailer_expr
2365
factor
2123
2365
(
2124
2365
arith_expr
2125
2365
NAME
2126
2365
[
2127
2365
+
2128
2365
term
2129
2365
atom_expr
2130
2365
NUMBER
2131
2365
atom
2132
2365
STRING
2133
2365
shift_expr
2134
2365
-
2135
2365
True
2136
2365
False
2139
2365
None
2141
2365
and_expr
2524
2365
{
2144
2365
~
2145
2365
power
2146
2366
for
factor -> - factor
2366
and
factor -> - factor
2366
if
factor -> - factor
2366
or
factor -> - factor
2366
>=
factor -> - factor
2366
<
factor -> - factor
2366
!=
factor -> - factor
2366
-
factor -> - factor
2366
==
factor -> - factor
2366
@
factor -> - factor
2366
|
factor -> - factor
2366
*
factor -> - factor
2366
%
factor -> - factor
2366
+
factor -> - factor
2366
<=
factor -> - factor
2366
//
factor -> - factor
2366
not
factor -> - factor
2366
>>
factor -> - factor
2366
/
factor -> - factor
2366
&
factor -> - factor
2366
^
factor -> - factor
2366
)
factor -> - factor
2366
in
factor -> - factor
2366
is
factor -> - factor
2366
>
factor -> - factor
2366
<<
factor -> - factor
2367
factor
2123
2367
(
2124
2367
arith_expr
2125
2367
NAME
2126
2367
[
2127
2367
+
2128
2367
term
2129
2367
atom_expr
2130
2367
NUMBER
2131
2367
atom
2132
2367
STRING
2133
2367
shift_expr
2134
2367
-
2135
2367
True
2136
2367
and_expr
2137
2367
False
2139
2367
None
2141
2367
xor_expr
2525
2367
{
2144
2367
~
2145
2367
power
2146
2368
factor
2123
2368
(
2124
2368
arith_expr
2125
2368
NAME
2126
2368
[
2127
2368
+
2128
2368
term
2129
2368
atom_expr
2130
2368
NUMBER
2131
2368
atom
2132
2368
STRING
2133
2368
shift_expr
2134
2368
-
2135
2368
True
2136
2368
and_expr
2137
2368
xor_expr
2138
2368
False
2139
2368
None
2141
2368
{
2144
2368
~
2145
2368
power
2146
2368
expr
2526
2369
factor
2123
2369
(
2124
2369
arith_expr
2125
2369
NAME
2126
2369
[
2127
2369
+
2128
2369
term
2129
2369
atom_expr
2130
2369
NUMBER
2131
2369
atom
2132
2369
STRING
2133
2369
shift_expr
2134
2369
-
2135
2369
True
2136
2369
and_expr
2137
2369
xor_expr
2138
2369
False
2139
2369
not_test
2140
2369
None
2141
2369
expr
2142
2369
{
2144
2369
~
2145
2369
and_test
2527
2369
power
2146
2369
comparison
2147
2369
not
2149
2370
factor
2123
2370
(
2124
2370
arith_expr
2125
2370
NAME
2126
2370
[
2127
2370
+
2128
2370
term
2129
2370
atom_expr
2130
2370
NUMBER
2131
2370
atom
2132
2370
STRING
2133
2370
shift_expr
2134
2370
-
2135
2370
True
2136
2370
and_expr
2137
2370
comparison
2528
2370
xor_expr
2138
2370
False
2139
2370
None
2141
2370
expr
2142
2370
{
2144
2370
~
2145
2370
power
2146
2371
factor
2123
2371
(
2124
2371
arith_expr
2125
2371
NAME
2126
2371
[
2127
2371
+
2128
2371
term
2129
2371
atom_expr
2130
2371
NUMBER
2131
2371
atom
2132
2371
STRING
2133
2371
shift_expr
2134
2371
-
2135
2371
True
2136
2371
and_expr
2137
2371
xor_expr
2138
2371
False
2139
2371
not_test
2140
2371
None
2141
2371
expr
2142
2371
and_test
2143
2371
{
2144
2371
~
2145
2371
power
2146
2371
comparison
2147
2371
not
2149
2371
or_test
2529
2372
>
atom -> { }
2372
==
atom -> { }
2372
)
atom -> { }
2372
-
atom -> { }
2372
not
atom -> { }
2372
(
atom -> { }
2372
@
atom -> { }
2372
if
atom -> { }
2372
and
atom -> { }
2372
&
atom -> { }
2372
<<
atom -> { }
2372
!=
atom -> { }
2372
or
atom -> { }
2372
>>
atom -> { }
2372
<=
atom -> { }
2372
>=
atom -> { }
2372
is
atom -> { }
2372
/
atom -> { }
2372
^
atom -> { }
2372
[
atom -> { }
2372
%
atom -> { }
2372
//
atom -> { }
2372
*
atom -> { }
2372
**
atom -> { }
2372
.
atom -> { }
2372
for
atom -> { }
2372
in
atom -> { }
2372
+
atom -> { }
2372
|
atom -> { }
2372
<
atom -> { }
2373
or
factor -> ~ factor
2373
==
factor -> ~ factor
2373
<=
factor -> ~ factor
2373
@
factor -> ~ factor
2373
!=
factor -> ~ factor
2373
>=
factor -> ~ factor
2373
>
factor -> ~ factor
2373
and
factor -> ~ factor
2373
*
factor -> ~ factor
2373
&
factor -> ~ factor
2373
%
factor -> ~ factor
2373
<
factor -> ~ factor
2373
//
factor -> ~ factor
2373
if
factor -> ~ factor
2373
^
factor -> ~ factor
2373
/
factor -> ~ factor
2373
for
factor -> ~ factor
2373
in
factor -> ~ factor
2373
+
factor -> ~ factor
2373
not
factor -> ~ factor
2373
-
factor -> ~ factor
2373
is
factor -> ~ factor
2373
)
factor -> ~ factor
2373
>>
factor -> ~ factor
2373
<<
factor -> ~ factor
2373
|
factor -> ~ factor
2374
)
comp_for -> for expr_list in or_test comp_iter
2375
)
comp_iter -> comp_for
2376
factor
2123
2376
(
2124
2376
arith_expr
2125
2376
NAME
2126
2376
[
2127
2376
+
2128
2376
term
2129
2376
atom_expr
2130
2376
NUMBER
2131
2376
atom
2132
2376
STRING
2133
2376
shift_expr
2134
2376
-
2135
2376
True
2136
2376
and_expr
2137
2376
xor_expr
2138
2376
False
2139
2376
not_test
2140
2376
None
2141
2376
expr
2142
2376
and_test
2143
2376
{
2144
2376
~
2145
2376
power
2146
2376
lambda
2530
2376
comparison
2147
2376
test_nocond
2531
2376
lambdef_nocond
2532
2376
or_test
2533
2376
not
2149
2377
)
comp_iter -> comp_if
2378
)
not_test -> not not_test
2378
or
not_test -> not not_test
2378
and
not_test -> not not_test
2378
if
not_test -> not not_test
2378
for
not_test -> not not_test
2379
False
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
~
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
$
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
resetstats
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
with
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
NEWLINE
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
[
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
NAME
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
(
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
None
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
nonlocal
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
{
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
begsim
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
del
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
+
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
True
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
STRING
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
class
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
def
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
for
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
while
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
lambda
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
not
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
yield
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
try
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
if
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
raise
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
break
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
pass
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
global
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
continue
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
assert
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
endsim
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
conf
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
NUMBER
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
return
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
-
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2379
@
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2380
NEWLINE
2534
2381
INDENT
2535
2382
nonlocal
while_stmt -> while test : suite else : suite
2382
False
while_stmt -> while test : suite else : suite
2382
resetstats
while_stmt -> while test : suite else : suite
2382
None
while_stmt -> while test : suite else : suite
2382
(
while_stmt -> while test : suite else : suite
2382
del
while_stmt -> while test : suite else : suite
2382
raise
while_stmt -> while test : suite else : suite
2382
begsim
while_stmt -> while test : suite else : suite
2382
assert
while_stmt -> while test : suite else : suite
2382
return
while_stmt -> while test : suite else : suite
2382
$
while_stmt -> while test : suite else : suite
2382
while
while_stmt -> while test : suite else : suite
2382
yield
while_stmt -> while test : suite else : suite
2382
with
while_stmt -> while test : suite else : suite
2382
[
while_stmt -> while test : suite else : suite
2382
if
while_stmt -> while test : suite else : suite
2382
def
while_stmt -> while test : suite else : suite
2382
NEWLINE
while_stmt -> while test : suite else : suite
2382
STRING
while_stmt -> while test : suite else : suite
2382
break
while_stmt -> while test : suite else : suite
2382
~
while_stmt -> while test : suite else : suite
2382
@
while_stmt -> while test : suite else : suite
2382
try
while_stmt -> while test : suite else : suite
2382
{
while_stmt -> while test : suite else : suite
2382
pass
while_stmt -> while test : suite else : suite
2382
continue
while_stmt -> while test : suite else : suite
2382
True
while_stmt -> while test : suite else : suite
2382
endsim
while_stmt -> while test : suite else : suite
2382
class
while_stmt -> while test : suite else : suite
2382
+
while_stmt -> while test : suite else : suite
2382
conf
while_stmt -> while test : suite else : suite
2382
for
while_stmt -> while test : suite else : suite
2382
lambda
while_stmt -> while test : suite else : suite
2382
global
while_stmt -> while test : suite else : suite
2382
NUMBER
while_stmt -> while test : suite else : suite
2382
-
while_stmt -> while test : suite else : suite
2382
not
while_stmt -> while test : suite else : suite
2382
NAME
while_stmt -> while test : suite else : suite
2383
not
suite -> NEWLINE INDENT stmt_list DEDENT
2383
None
suite -> NEWLINE INDENT stmt_list DEDENT
2383
{
suite -> NEWLINE INDENT stmt_list DEDENT
2383
for
suite -> NEWLINE INDENT stmt_list DEDENT
2383
try
suite -> NEWLINE INDENT stmt_list DEDENT
2383
class
suite -> NEWLINE INDENT stmt_list DEDENT
2383
while
suite -> NEWLINE INDENT stmt_list DEDENT
2383
NEWLINE
suite -> NEWLINE INDENT stmt_list DEDENT
2383
-
suite -> NEWLINE INDENT stmt_list DEDENT
2383
if
suite -> NEWLINE INDENT stmt_list DEDENT
2383
+
suite -> NEWLINE INDENT stmt_list DEDENT
2383
resetstats
suite -> NEWLINE INDENT stmt_list DEDENT
2383
return
suite -> NEWLINE INDENT stmt_list DEDENT
2383
with
suite -> NEWLINE INDENT stmt_list DEDENT
2383
NAME
suite -> NEWLINE INDENT stmt_list DEDENT
2383
else
suite -> NEWLINE INDENT stmt_list DEDENT
2383
STRING
suite -> NEWLINE INDENT stmt_list DEDENT
2383
conf
suite -> NEWLINE INDENT stmt_list DEDENT
2383
assert
suite -> NEWLINE INDENT stmt_list DEDENT
2383
def
suite -> NEWLINE INDENT stmt_list DEDENT
2383
~
suite -> NEWLINE INDENT stmt_list DEDENT
2383
yield
suite -> NEWLINE INDENT stmt_list DEDENT
2383
NUMBER
suite -> NEWLINE INDENT stmt_list DEDENT
2383
del
suite -> NEWLINE INDENT stmt_list DEDENT
2383
$
suite -> NEWLINE INDENT stmt_list DEDENT
2383
True
suite -> NEWLINE INDENT stmt_list DEDENT
2383
break
suite -> NEWLINE INDENT stmt_list DEDENT
2383
pass
suite -> NEWLINE INDENT stmt_list DEDENT
2383
endsim
suite -> NEWLINE INDENT stmt_list DEDENT
2383
continue
suite -> NEWLINE INDENT stmt_list DEDENT
2383
[
suite -> NEWLINE INDENT stmt_list DEDENT
2383
begsim
suite -> NEWLINE INDENT stmt_list DEDENT
2383
lambda
suite -> NEWLINE INDENT stmt_list DEDENT
2383
global
suite -> NEWLINE INDENT stmt_list DEDENT
2383
@
suite -> NEWLINE INDENT stmt_list DEDENT
2383
False
suite -> NEWLINE INDENT stmt_list DEDENT
2383
raise
suite -> NEWLINE INDENT stmt_list DEDENT
2383
(
suite -> NEWLINE INDENT stmt_list DEDENT
2383
nonlocal
suite -> NEWLINE INDENT stmt_list DEDENT
2384
if
2536
2384
comp_for
2537
2384
comp_if
2538
2384
for
1289
2384
)
comp_iter -> 
2384
,
comp_iter -> 
2384
comp_iter
2539
2385
=
test -> or_test if or_test else test
2385
)
test -> or_test if or_test else test
2385
,
test -> or_test if or_test else test
2385
for
test -> or_test if or_test else test
2386
:
test -> or_test if or_test else test
2386
]
test -> or_test if or_test else test
2386
,
test -> or_test if or_test else test
2387
]
sliceop -> : maybe_test
2387
,
sliceop -> : maybe_test
2388
]
maybe_test -> test
2388
,
maybe_test -> test
2389
NEWLINE
test -> or_test if or_test else test
2389
=
test -> or_test if or_test else test
2389
,
test -> or_test if or_test else test
2390
and
term -> factor // term
2390
if
term -> factor // term
2390
>
term -> factor // term
2390
<
term -> factor // term
2390
==
term -> factor // term
2390
+
term -> factor // term
2390
-
term -> factor // term
2390
&
term -> factor // term
2390
in
term -> factor // term
2390
!=
term -> factor // term
2390
^
term -> factor // term
2390
=
term -> factor // term
2390
or
term -> factor // term
2390
NEWLINE
term -> factor // term
2390
<=
term -> factor // term
2390
>=
term -> factor // term
2390
|
term -> factor // term
2390
>>
term -> factor // term
2390
not
term -> factor // term
2390
is
term -> factor // term
2390
<<
term -> factor // term
2391
^
term -> factor * term
2391
+
term -> factor * term
2391
==
term -> factor * term
2391
>>
term -> factor * term
2391
in
term -> factor * term
2391
and
term -> factor * term
2391
if
term -> factor * term
2391
is
term -> factor * term
2391
<<
term -> factor * term
2391
-
term -> factor * term
2391
!=
term -> factor * term
2391
or
term -> factor * term
2391
>
term -> factor * term
2391
&
term -> factor * term
2391
NEWLINE
term -> factor * term
2391
>=
term -> factor * term
2391
|
term -> factor * term
2391
<=
term -> factor * term
2391
not
term -> factor * term
2391
=
term -> factor * term
2391
<
term -> factor * term
2392
&
term -> factor % term
2392
==
term -> factor % term
2392
!=
term -> factor % term
2392
<
term -> factor % term
2392
in
term -> factor % term
2392
=
term -> factor % term
2392
>>
term -> factor % term
2392
<<
term -> factor % term
2392
NEWLINE
term -> factor % term
2392
-
term -> factor % term
2392
if
term -> factor % term
2392
>
term -> factor % term
2392
or
term -> factor % term
2392
^
term -> factor % term
2392
+
term -> factor % term
2392
is
term -> factor % term
2392
|
term -> factor % term
2392
>=
term -> factor % term
2392
<=
term -> factor % term
2392
and
term -> factor % term
2392
not
term -> factor % term
2393
and
term -> factor @ term
2393
in
term -> factor @ term
2393
>=
term -> factor @ term
2393
<
term -> factor @ term
2393
>
term -> factor @ term
2393
-
term -> factor @ term
2393
NEWLINE
term -> factor @ term
2393
or
term -> factor @ term
2393
<<
term -> factor @ term
2393
is
term -> factor @ term
2393
!=
term -> factor @ term
2393
|
term -> factor @ term
2393
&
term -> factor @ term
2393
==
term -> factor @ term
2393
>>
term -> factor @ term
2393
<=
term -> factor @ term
2393
not
term -> factor @ term
2393
+
term -> factor @ term
2393
^
term -> factor @ term
2393
=
term -> factor @ term
2393
if
term -> factor @ term
2394
or
term -> factor / term
2394
<<
term -> factor / term
2394
not
term -> factor / term
2394
in
term -> factor / term
2394
!=
term -> factor / term
2394
<
term -> factor / term
2394
+
term -> factor / term
2394
and
term -> factor / term
2394
>>
term -> factor / term
2394
^
term -> factor / term
2394
<=
term -> factor / term
2394
==
term -> factor / term
2394
>
term -> factor / term
2394
&
term -> factor / term
2394
is
term -> factor / term
2394
-
term -> factor / term
2394
NEWLINE
term -> factor / term
2394
|
term -> factor / term
2394
>=
term -> factor / term
2394
if
term -> factor / term
2394
=
term -> factor / term
2395
+
atom -> ( test_list_comp )
2395
/
atom -> ( test_list_comp )
2395
*
atom -> ( test_list_comp )
2395
[
atom -> ( test_list_comp )
2395
&
atom -> ( test_list_comp )
2395
**
atom -> ( test_list_comp )
2395
^
atom -> ( test_list_comp )
2395
(
atom -> ( test_list_comp )
2395
and
atom -> ( test_list_comp )
2395
>
atom -> ( test_list_comp )
2395
=
atom -> ( test_list_comp )
2395
-
atom -> ( test_list_comp )
2395
%
atom -> ( test_list_comp )
2395
//
atom -> ( test_list_comp )
2395
in
atom -> ( test_list_comp )
2395
>>
atom -> ( test_list_comp )
2395
not
atom -> ( test_list_comp )
2395
>=
atom -> ( test_list_comp )
2395
or
atom -> ( test_list_comp )
2395
<
atom -> ( test_list_comp )
2395
if
atom -> ( test_list_comp )
2395
|
atom -> ( test_list_comp )
2395
<<
atom -> ( test_list_comp )
2395
@
atom -> ( test_list_comp )
2395
!=
atom -> ( test_list_comp )
2395
is
atom -> ( test_list_comp )
2395
NEWLINE
atom -> ( test_list_comp )
2395
.
atom -> ( test_list_comp )
2395
<=
atom -> ( test_list_comp )
2395
==
atom -> ( test_list_comp )
2396
>=
shift_expr -> arith_expr >> shift_expr
2396
if
shift_expr -> arith_expr >> shift_expr
2396
<=
shift_expr -> arith_expr >> shift_expr
2396
!=
shift_expr -> arith_expr >> shift_expr
2396
or
shift_expr -> arith_expr >> shift_expr
2396
|
shift_expr -> arith_expr >> shift_expr
2396
is
shift_expr -> arith_expr >> shift_expr
2396
and
shift_expr -> arith_expr >> shift_expr
2396
NEWLINE
shift_expr -> arith_expr >> shift_expr
2396
in
shift_expr -> arith_expr >> shift_expr
2396
^
shift_expr -> arith_expr >> shift_expr
2396
not
shift_expr -> arith_expr >> shift_expr
2396
<
shift_expr -> arith_expr >> shift_expr
2396
==
shift_expr -> arith_expr >> shift_expr
2396
=
shift_expr -> arith_expr >> shift_expr
2396
&
shift_expr -> arith_expr >> shift_expr
2396
>
shift_expr -> arith_expr >> shift_expr
2397
>
shift_expr -> arith_expr << shift_expr
2397
or
shift_expr -> arith_expr << shift_expr
2397
^
shift_expr -> arith_expr << shift_expr
2397
not
shift_expr -> arith_expr << shift_expr
2397
<
shift_expr -> arith_expr << shift_expr
2397
if
shift_expr -> arith_expr << shift_expr
2397
in
shift_expr -> arith_expr << shift_expr
2397
!=
shift_expr -> arith_expr << shift_expr
2397
==
shift_expr -> arith_expr << shift_expr
2397
|
shift_expr -> arith_expr << shift_expr
2397
>=
shift_expr -> arith_expr << shift_expr
2397
and
shift_expr -> arith_expr << shift_expr
2397
NEWLINE
shift_expr -> arith_expr << shift_expr
2397
&
shift_expr -> arith_expr << shift_expr
2397
<=
shift_expr -> arith_expr << shift_expr
2397
=
shift_expr -> arith_expr << shift_expr
2397
is
shift_expr -> arith_expr << shift_expr
2398
in
atom -> [ test_list_comp ]
2398
/
atom -> [ test_list_comp ]
2398
or
atom -> [ test_list_comp ]
2398
if
atom -> [ test_list_comp ]
2398
<<
atom -> [ test_list_comp ]
2398
!=
atom -> [ test_list_comp ]
2398
=
atom -> [ test_list_comp ]
2398
<=
atom -> [ test_list_comp ]
2398
>>
atom -> [ test_list_comp ]
2398
*
atom -> [ test_list_comp ]
2398
^
atom -> [ test_list_comp ]
2398
.
atom -> [ test_list_comp ]
2398
(
atom -> [ test_list_comp ]
2398
>=
atom -> [ test_list_comp ]
2398
and
atom -> [ test_list_comp ]
2398
<
atom -> [ test_list_comp ]
2398
[
atom -> [ test_list_comp ]
2398
==
atom -> [ test_list_comp ]
2398
@
atom -> [ test_list_comp ]
2398
%
atom -> [ test_list_comp ]
2398
-
atom -> [ test_list_comp ]
2398
|
atom -> [ test_list_comp ]
2398
&
atom -> [ test_list_comp ]
2398
+
atom -> [ test_list_comp ]
2398
is
atom -> [ test_list_comp ]
2398
//
atom -> [ test_list_comp ]
2398
**
atom -> [ test_list_comp ]
2398
not
atom -> [ test_list_comp ]
2398
NEWLINE
atom -> [ test_list_comp ]
2398
>
atom -> [ test_list_comp ]
2399
+
trailer_expr -> trailer trailer_expr
2399
*
trailer_expr -> trailer trailer_expr
2399
/
trailer_expr -> trailer trailer_expr
2399
not
trailer_expr -> trailer trailer_expr
2399
<<
trailer_expr -> trailer trailer_expr
2399
!=
trailer_expr -> trailer trailer_expr
2399
=
trailer_expr -> trailer trailer_expr
2399
>=
trailer_expr -> trailer trailer_expr
2399
>>
trailer_expr -> trailer trailer_expr
2399
|
trailer_expr -> trailer trailer_expr
2399
%
trailer_expr -> trailer trailer_expr
2399
>
trailer_expr -> trailer trailer_expr
2399
&
trailer_expr -> trailer trailer_expr
2399
-
trailer_expr -> trailer trailer_expr
2399
<=
trailer_expr -> trailer trailer_expr
2399
**
trailer_expr -> trailer trailer_expr
2399
@
trailer_expr -> trailer trailer_expr
2399
if
trailer_expr -> trailer trailer_expr
2399
NEWLINE
trailer_expr -> trailer trailer_expr
2399
==
trailer_expr -> trailer trailer_expr
2399
or
trailer_expr -> trailer trailer_expr
2399
<
trailer_expr -> trailer trailer_expr
2399
and
trailer_expr -> trailer trailer_expr
2399
in
trailer_expr -> trailer trailer_expr
2399
is
trailer_expr -> trailer trailer_expr
2399
^
trailer_expr -> trailer trailer_expr
2399
//
trailer_expr -> trailer trailer_expr
2400
<=
trailer -> . NAME
2400
<<
trailer -> . NAME
2400
**
trailer -> . NAME
2400
!=
trailer -> . NAME
2400
/
trailer -> . NAME
2400
&
trailer -> . NAME
2400
//
trailer -> . NAME
2400
<
trailer -> . NAME
2400
is
trailer -> . NAME
2400
-
trailer -> . NAME
2400
if
trailer -> . NAME
2400
[
trailer -> . NAME
2400
or
trailer -> . NAME
2400
>
trailer -> . NAME
2400
*
trailer -> . NAME
2400
+
trailer -> . NAME
2400
%
trailer -> . NAME
2400
.
trailer -> . NAME
2400
>=
trailer -> . NAME
2400
|
trailer -> . NAME
2400
and
trailer -> . NAME
2400
(
trailer -> . NAME
2400
NEWLINE
trailer -> . NAME
2400
==
trailer -> . NAME
2400
^
trailer -> . NAME
2400
in
trailer -> . NAME
2400
@
trailer -> . NAME
2400
not
trailer -> . NAME
2400
=
trailer -> . NAME
2400
>>
trailer -> . NAME
2401
)
2540
2402
%
trailer -> ( )
2402
<=
trailer -> ( )
2402
and
trailer -> ( )
2402
//
trailer -> ( )
2402
not
trailer -> ( )
2402
or
trailer -> ( )
2402
NEWLINE
trailer -> ( )
2402
>>
trailer -> ( )
2402
>
trailer -> ( )
2402
<<
trailer -> ( )
2402
[
trailer -> ( )
2402
is
trailer -> ( )
2402
-
trailer -> ( )
2402
**
trailer -> ( )
2402
/
trailer -> ( )
2402
+
trailer -> ( )
2402
&
trailer -> ( )
2402
in
trailer -> ( )
2402
^
trailer -> ( )
2402
!=
trailer -> ( )
2402
*
trailer -> ( )
2402
if
trailer -> ( )
2402
>=
trailer -> ( )
2402
(
trailer -> ( )
2402
@
trailer -> ( )
2402
=
trailer -> ( )
2402
==
trailer -> ( )
2402
|
trailer -> ( )
2402
.
trailer -> ( )
2402
<
trailer -> ( )
2403
]
2541
2404
==
arith_expr -> term + arith_expr
2404
!=
arith_expr -> term + arith_expr
2404
<<
arith_expr -> term + arith_expr
2404
&
arith_expr -> term + arith_expr
2404
<
arith_expr -> term + arith_expr
2404
^
arith_expr -> term + arith_expr
2404
>=
arith_expr -> term + arith_expr
2404
NEWLINE
arith_expr -> term + arith_expr
2404
in
arith_expr -> term + arith_expr
2404
>>
arith_expr -> term + arith_expr
2404
not
arith_expr -> term + arith_expr
2404
<=
arith_expr -> term + arith_expr
2404
is
arith_expr -> term + arith_expr
2404
|
arith_expr -> term + arith_expr
2404
and
arith_expr -> term + arith_expr
2404
=
arith_expr -> term + arith_expr
2404
or
arith_expr -> term + arith_expr
2404
if
arith_expr -> term + arith_expr
2404
>
arith_expr -> term + arith_expr
2405
if
arith_expr -> term - arith_expr
2405
&
arith_expr -> term - arith_expr
2405
>>
arith_expr -> term - arith_expr
2405
NEWLINE
arith_expr -> term - arith_expr
2405
!=
arith_expr -> term - arith_expr
2405
>=
arith_expr -> term - arith_expr
2405
|
arith_expr -> term - arith_expr
2405
>
arith_expr -> term - arith_expr
2405
<
arith_expr -> term - arith_expr
2405
==
arith_expr -> term - arith_expr
2405
and
arith_expr -> term - arith_expr
2405
=
arith_expr -> term - arith_expr
2405
is
arith_expr -> term - arith_expr
2405
in
arith_expr -> term - arith_expr
2405
^
arith_expr -> term - arith_expr
2405
<<
arith_expr -> term - arith_expr
2405
not
arith_expr -> term - arith_expr
2405
or
arith_expr -> term - arith_expr
2405
<=
arith_expr -> term - arith_expr
2406
+
power -> atom_expr ** factor
2406
&
power -> atom_expr ** factor
2406
>>
power -> atom_expr ** factor
2406
<<
power -> atom_expr ** factor
2406
not
power -> atom_expr ** factor
2406
is
power -> atom_expr ** factor
2406
@
power -> atom_expr ** factor
2406
==
power -> atom_expr ** factor
2406
*
power -> atom_expr ** factor
2406
or
power -> atom_expr ** factor
2406
>
power -> atom_expr ** factor
2406
-
power -> atom_expr ** factor
2406
if
power -> atom_expr ** factor
2406
!=
power -> atom_expr ** factor
2406
>=
power -> atom_expr ** factor
2406
/
power -> atom_expr ** factor
2406
%
power -> atom_expr ** factor
2406
and
power -> atom_expr ** factor
2406
=
power -> atom_expr ** factor
2406
NEWLINE
power -> atom_expr ** factor
2406
<=
power -> atom_expr ** factor
2406
<
power -> atom_expr ** factor
2406
|
power -> atom_expr ** factor
2406
^
power -> atom_expr ** factor
2406
in
power -> atom_expr ** factor
2406
//
power -> atom_expr ** factor
2407
==
and_expr -> shift_expr & and_expr
2407
in
and_expr -> shift_expr & and_expr
2407
=
and_expr -> shift_expr & and_expr
2407
!=
and_expr -> shift_expr & and_expr
2407
or
and_expr -> shift_expr & and_expr
2407
>
and_expr -> shift_expr & and_expr
2407
not
and_expr -> shift_expr & and_expr
2407
<=
and_expr -> shift_expr & and_expr
2407
|
and_expr -> shift_expr & and_expr
2407
and
and_expr -> shift_expr & and_expr
2407
NEWLINE
and_expr -> shift_expr & and_expr
2407
^
and_expr -> shift_expr & and_expr
2407
is
and_expr -> shift_expr & and_expr
2407
>=
and_expr -> shift_expr & and_expr
2407
<
and_expr -> shift_expr & and_expr
2407
if
and_expr -> shift_expr & and_expr
2408
<=
xor_expr -> and_expr ^ xor_expr
2408
!=
xor_expr -> and_expr ^ xor_expr
2408
and
xor_expr -> and_expr ^ xor_expr
2408
=
xor_expr -> and_expr ^ xor_expr
2408
is
xor_expr -> and_expr ^ xor_expr
2408
>=
xor_expr -> and_expr ^ xor_expr
2408
not
xor_expr -> and_expr ^ xor_expr
2408
<
xor_expr -> and_expr ^ xor_expr
2408
|
xor_expr -> and_expr ^ xor_expr
2408
in
xor_expr -> and_expr ^ xor_expr
2408
==
xor_expr -> and_expr ^ xor_expr
2408
or
xor_expr -> and_expr ^ xor_expr
2408
if
xor_expr -> and_expr ^ xor_expr
2408
>
xor_expr -> and_expr ^ xor_expr
2408
NEWLINE
xor_expr -> and_expr ^ xor_expr
2409
not
expr -> xor_expr | expr
2409
in
expr -> xor_expr | expr
2409
if
expr -> xor_expr | expr
2409
or
expr -> xor_expr | expr
2409
<=
expr -> xor_expr | expr
2409
>
expr -> xor_expr | expr
2409
!=
expr -> xor_expr | expr
2409
==
expr -> xor_expr | expr
2409
=
expr -> xor_expr | expr
2409
NEWLINE
expr -> xor_expr | expr
2409
>=
expr -> xor_expr | expr
2409
is
expr -> xor_expr | expr
2409
<
expr -> xor_expr | expr
2409
and
expr -> xor_expr | expr
2410
and
comparison -> expr comp_op comparison
2410
if
comparison -> expr comp_op comparison
2410
=
comparison -> expr comp_op comparison
2410
or
comparison -> expr comp_op comparison
2410
NEWLINE
comparison -> expr comp_op comparison
2411
NEWLINE
or_test -> and_test or or_test
2411
if
or_test -> and_test or or_test
2411
=
or_test -> and_test or or_test
2412
NEWLINE
lambdef -> lambda : test
2412
=
lambdef -> lambda : test
2413
factor
1825
2413
(
1826
2413
arith_expr
1827
2413
NAME
1828
2413
[
1829
2413
atom
1830
2413
+
1831
2413
term
1832
2413
power
1833
2413
atom_expr
1834
2413
NUMBER
1835
2413
STRING
1836
2413
shift_expr
1837
2413
-
1838
2413
True
1840
2413
and_expr
1841
2413
xor_expr
1842
2413
None
1843
2413
expr
1844
2413
False
1845
2413
and_test
1846
2413
lambda
1847
2413
~
1848
2413
not_test
1849
2413
{
1850
2413
not
1851
2413
lambdef
1852
2413
or_test
1853
2413
comparison
1854
2413
test
2542
2414
NEWLINE
and_test -> not_test and and_test
2414
=
and_test -> not_test and and_test
2414
if
and_test -> not_test and and_test
2414
or
and_test -> not_test and and_test
2415
else
2543
2416
=
test -> or_test if or_test else test
2417
NEWLINE
elif_clause -> 
2417
elif_clause
2544
2417
elif
1490
2417
None
elif_clause -> 
2417
nonlocal
elif_clause -> 
2417
-
elif_clause -> 
2417
NUMBER
elif_clause -> 
2417
conf
elif_clause -> 
2417
class
elif_clause -> 
2417
while
elif_clause -> 
2417
return
elif_clause -> 
2417
try
elif_clause -> 
2417
(
elif_clause -> 
2417
False
elif_clause -> 
2417
NAME
elif_clause -> 
2417
begsim
elif_clause -> 
2417
global
elif_clause -> 
2417
with
elif_clause -> 
2417
else
elif_clause -> 
2417
continue
elif_clause -> 
2417
pass
elif_clause -> 
2417
~
elif_clause -> 
2417
endsim
elif_clause -> 
2417
not
elif_clause -> 
2417
yield
elif_clause -> 
2417
{
elif_clause -> 
2417
def
elif_clause -> 
2417
lambda
elif_clause -> 
2417
@
elif_clause -> 
2417
[
elif_clause -> 
2417
if
elif_clause -> 
2417
+
elif_clause -> 
2417
break
elif_clause -> 
2417
STRING
elif_clause -> 
2417
assert
elif_clause -> 
2417
raise
elif_clause -> 
2417
$
elif_clause -> 
2417
True
elif_clause -> 
2417
resetstats
elif_clause -> 
2417
for
elif_clause -> 
2417
del
elif_clause -> 
2418
not
if_stmt -> if test : suite elif_clause else : suite
2418
+
if_stmt -> if test : suite elif_clause else : suite
2418
(
if_stmt -> if test : suite elif_clause else : suite
2418
NEWLINE
if_stmt -> if test : suite elif_clause else : suite
2418
NAME
if_stmt -> if test : suite elif_clause else : suite
2418
$
if_stmt -> if test : suite elif_clause else : suite
2418
class
if_stmt -> if test : suite elif_clause else : suite
2418
nonlocal
if_stmt -> if test : suite elif_clause else : suite
2418
conf
if_stmt -> if test : suite elif_clause else : suite
2418
try
if_stmt -> if test : suite elif_clause else : suite
2418
None
if_stmt -> if test : suite elif_clause else : suite
2418
False
if_stmt -> if test : suite elif_clause else : suite
2418
begsim
if_stmt -> if test : suite elif_clause else : suite
2418
{
if_stmt -> if test : suite elif_clause else : suite
2418
global
if_stmt -> if test : suite elif_clause else : suite
2418
endsim
if_stmt -> if test : suite elif_clause else : suite
2418
def
if_stmt -> if test : suite elif_clause else : suite
2418
STRING
if_stmt -> if test : suite elif_clause else : suite
2418
[
if_stmt -> if test : suite elif_clause else : suite
2418
raise
if_stmt -> if test : suite elif_clause else : suite
2418
-
if_stmt -> if test : suite elif_clause else : suite
2418
with
if_stmt -> if test : suite elif_clause else : suite
2418
return
if_stmt -> if test : suite elif_clause else : suite
2418
~
if_stmt -> if test : suite elif_clause else : suite
2418
if
if_stmt -> if test : suite elif_clause else : suite
2418
yield
if_stmt -> if test : suite elif_clause else : suite
2418
True
if_stmt -> if test : suite elif_clause else : suite
2418
assert
if_stmt -> if test : suite elif_clause else : suite
2418
lambda
if_stmt -> if test : suite elif_clause else : suite
2418
while
if_stmt -> if test : suite elif_clause else : suite
2418
pass
if_stmt -> if test : suite elif_clause else : suite
2418
break
if_stmt -> if test : suite elif_clause else : suite
2418
resetstats
if_stmt -> if test : suite elif_clause else : suite
2418
del
if_stmt -> if test : suite elif_clause else : suite
2418
continue
if_stmt -> if test : suite elif_clause else : suite
2418
NUMBER
if_stmt -> if test : suite elif_clause else : suite
2418
@
if_stmt -> if test : suite elif_clause else : suite
2418
for
if_stmt -> if test : suite elif_clause else : suite
2419
and
term -> factor // term
2419
if
term -> factor // term
2419
>
term -> factor // term
2419
<
term -> factor // term
2419
for
term -> factor // term
2419
==
term -> factor // term
2419
]
term -> factor // term
2419
+
term -> factor // term
2419
-
term -> factor // term
2419
&
term -> factor // term
2419
in
term -> factor // term
2419
!=
term -> factor // term
2419
^
term -> factor // term
2419
or
term -> factor // term
2419
<=
term -> factor // term
2419
>=
term -> factor // term
2419
|
term -> factor // term
2419
>>
term -> factor // term
2419
not
term -> factor // term
2419
is
term -> factor // term
2419
<<
term -> factor // term
2420
^
term -> factor * term
2420
+
term -> factor * term
2420
==
term -> factor * term
2420
>>
term -> factor * term
2420
in
term -> factor * term
2420
and
term -> factor * term
2420
if
term -> factor * term
2420
for
term -> factor * term
2420
is
term -> factor * term
2420
]
term -> factor * term
2420
<<
term -> factor * term
2420
-
term -> factor * term
2420
!=
term -> factor * term
2420
or
term -> factor * term
2420
>
term -> factor * term
2420
&
term -> factor * term
2420
>=
term -> factor * term
2420
|
term -> factor * term
2420
<=
term -> factor * term
2420
not
term -> factor * term
2420
<
term -> factor * term
2421
&
term -> factor % term
2421
]
term -> factor % term
2421
==
term -> factor % term
2421
!=
term -> factor % term
2421
<
term -> factor % term
2421
in
term -> factor % term
2421
>>
term -> factor % term
2421
<<
term -> factor % term
2421
-
term -> factor % term
2421
if
term -> factor % term
2421
>
term -> factor % term
2421
or
term -> factor % term
2421
^
term -> factor % term
2421
+
term -> factor % term
2421
is
term -> factor % term
2421
|
term -> factor % term
2421
>=
term -> factor % term
2421
<=
term -> factor % term
2421
and
term -> factor % term
2421
not
term -> factor % term
2421
for
term -> factor % term
2422
for
term -> factor @ term
2422
and
term -> factor @ term
2422
in
term -> factor @ term
2422
>=
term -> factor @ term
2422
<
term -> factor @ term
2422
>
term -> factor @ term
2422
-
term -> factor @ term
2422
or
term -> factor @ term
2422
<<
term -> factor @ term
2422
is
term -> factor @ term
2422
!=
term -> factor @ term
2422
|
term -> factor @ term
2422
&
term -> factor @ term
2422
==
term -> factor @ term
2422
>>
term -> factor @ term
2422
]
term -> factor @ term
2422
not
term -> factor @ term
2422
<=
term -> factor @ term
2422
+
term -> factor @ term
2422
^
term -> factor @ term
2422
if
term -> factor @ term
2423
or
term -> factor / term
2423
<<
term -> factor / term
2423
not
term -> factor / term
2423
in
term -> factor / term
2423
!=
term -> factor / term
2423
<
term -> factor / term
2423
]
term -> factor / term
2423
+
term -> factor / term
2423
and
term -> factor / term
2423
>>
term -> factor / term
2423
^
term -> factor / term
2423
<=
term -> factor / term
2423
==
term -> factor / term
2423
>
term -> factor / term
2423
&
term -> factor / term
2423
is
term -> factor / term
2423
-
term -> factor / term
2423
for
term -> factor / term
2423
|
term -> factor / term
2423
>=
term -> factor / term
2423
if
term -> factor / term
2424
+
atom -> ( test_list_comp )
2424
/
atom -> ( test_list_comp )
2424
*
atom -> ( test_list_comp )
2424
[
atom -> ( test_list_comp )
2424
&
atom -> ( test_list_comp )
2424
**
atom -> ( test_list_comp )
2424
^
atom -> ( test_list_comp )
2424
(
atom -> ( test_list_comp )
2424
and
atom -> ( test_list_comp )
2424
>
atom -> ( test_list_comp )
2424
-
atom -> ( test_list_comp )
2424
%
atom -> ( test_list_comp )
2424
//
atom -> ( test_list_comp )
2424
]
atom -> ( test_list_comp )
2424
in
atom -> ( test_list_comp )
2424
>>
atom -> ( test_list_comp )
2424
for
atom -> ( test_list_comp )
2424
not
atom -> ( test_list_comp )
2424
>=
atom -> ( test_list_comp )
2424
or
atom -> ( test_list_comp )
2424
<
atom -> ( test_list_comp )
2424
if
atom -> ( test_list_comp )
2424
|
atom -> ( test_list_comp )
2424
<<
atom -> ( test_list_comp )
2424
@
atom -> ( test_list_comp )
2424
!=
atom -> ( test_list_comp )
2424
is
atom -> ( test_list_comp )
2424
.
atom -> ( test_list_comp )
2424
<=
atom -> ( test_list_comp )
2424
==
atom -> ( test_list_comp )
2425
]
shift_expr -> arith_expr >> shift_expr
2425
>=
shift_expr -> arith_expr >> shift_expr
2425
if
shift_expr -> arith_expr >> shift_expr
2425
<=
shift_expr -> arith_expr >> shift_expr
2425
!=
shift_expr -> arith_expr >> shift_expr
2425
or
shift_expr -> arith_expr >> shift_expr
2425
|
shift_expr -> arith_expr >> shift_expr
2425
is
shift_expr -> arith_expr >> shift_expr
2425
and
shift_expr -> arith_expr >> shift_expr
2425
in
shift_expr -> arith_expr >> shift_expr
2425
^
shift_expr -> arith_expr >> shift_expr
2425
not
shift_expr -> arith_expr >> shift_expr
2425
<
shift_expr -> arith_expr >> shift_expr
2425
==
shift_expr -> arith_expr >> shift_expr
2425
for
shift_expr -> arith_expr >> shift_expr
2425
&
shift_expr -> arith_expr >> shift_expr
2425
>
shift_expr -> arith_expr >> shift_expr
2426
>
shift_expr -> arith_expr << shift_expr
2426
or
shift_expr -> arith_expr << shift_expr
2426
^
shift_expr -> arith_expr << shift_expr
2426
for
shift_expr -> arith_expr << shift_expr
2426
not
shift_expr -> arith_expr << shift_expr
2426
<
shift_expr -> arith_expr << shift_expr
2426
if
shift_expr -> arith_expr << shift_expr
2426
in
shift_expr -> arith_expr << shift_expr
2426
!=
shift_expr -> arith_expr << shift_expr
2426
==
shift_expr -> arith_expr << shift_expr
2426
|
shift_expr -> arith_expr << shift_expr
2426
>=
shift_expr -> arith_expr << shift_expr
2426
and
shift_expr -> arith_expr << shift_expr
2426
]
shift_expr -> arith_expr << shift_expr
2426
&
shift_expr -> arith_expr << shift_expr
2426
<=
shift_expr -> arith_expr << shift_expr
2426
is
shift_expr -> arith_expr << shift_expr
2427
in
atom -> [ test_list_comp ]
2427
/
atom -> [ test_list_comp ]
2427
or
atom -> [ test_list_comp ]
2427
if
atom -> [ test_list_comp ]
2427
<<
atom -> [ test_list_comp ]
2427
!=
atom -> [ test_list_comp ]
2427
<=
atom -> [ test_list_comp ]
2427
>>
atom -> [ test_list_comp ]
2427
*
atom -> [ test_list_comp ]
2427
^
atom -> [ test_list_comp ]
2427
.
atom -> [ test_list_comp ]
2427
(
atom -> [ test_list_comp ]
2427
>=
atom -> [ test_list_comp ]
2427
and
atom -> [ test_list_comp ]
2427
<
atom -> [ test_list_comp ]
2427
]
atom -> [ test_list_comp ]
2427
[
atom -> [ test_list_comp ]
2427
==
atom -> [ test_list_comp ]
2427
@
atom -> [ test_list_comp ]
2427
%
atom -> [ test_list_comp ]
2427
-
atom -> [ test_list_comp ]
2427
|
atom -> [ test_list_comp ]
2427
&
atom -> [ test_list_comp ]
2427
+
atom -> [ test_list_comp ]
2427
for
atom -> [ test_list_comp ]
2427
is
atom -> [ test_list_comp ]
2427
//
atom -> [ test_list_comp ]
2427
**
atom -> [ test_list_comp ]
2427
not
atom -> [ test_list_comp ]
2427
>
atom -> [ test_list_comp ]
2428
for
arith_expr -> term + arith_expr
2428
==
arith_expr -> term + arith_expr
2428
]
arith_expr -> term + arith_expr
2428
!=
arith_expr -> term + arith_expr
2428
<<
arith_expr -> term + arith_expr
2428
&
arith_expr -> term + arith_expr
2428
<
arith_expr -> term + arith_expr
2428
^
arith_expr -> term + arith_expr
2428
>=
arith_expr -> term + arith_expr
2428
in
arith_expr -> term + arith_expr
2428
>>
arith_expr -> term + arith_expr
2428
not
arith_expr -> term + arith_expr
2428
<=
arith_expr -> term + arith_expr
2428
is
arith_expr -> term + arith_expr
2428
|
arith_expr -> term + arith_expr
2428
and
arith_expr -> term + arith_expr
2428
or
arith_expr -> term + arith_expr
2428
if
arith_expr -> term + arith_expr
2428
>
arith_expr -> term + arith_expr
2429
if
arith_expr -> term - arith_expr
2429
&
arith_expr -> term - arith_expr
2429
>>
arith_expr -> term - arith_expr
2429
!=
arith_expr -> term - arith_expr
2429
>=
arith_expr -> term - arith_expr
2429
|
arith_expr -> term - arith_expr
2429
>
arith_expr -> term - arith_expr
2429
for
arith_expr -> term - arith_expr
2429
<
arith_expr -> term - arith_expr
2429
==
arith_expr -> term - arith_expr
2429
and
arith_expr -> term - arith_expr
2429
]
arith_expr -> term - arith_expr
2429
is
arith_expr -> term - arith_expr
2429
in
arith_expr -> term - arith_expr
2429
^
arith_expr -> term - arith_expr
2429
<<
arith_expr -> term - arith_expr
2429
not
arith_expr -> term - arith_expr
2429
or
arith_expr -> term - arith_expr
2429
<=
arith_expr -> term - arith_expr
2430
+
power -> atom_expr ** factor
2430
&
power -> atom_expr ** factor
2430
>>
power -> atom_expr ** factor
2430
<<
power -> atom_expr ** factor
2430
not
power -> atom_expr ** factor
2430
is
power -> atom_expr ** factor
2430
@
power -> atom_expr ** factor
2430
==
power -> atom_expr ** factor
2430
*
power -> atom_expr ** factor
2430
or
power -> atom_expr ** factor
2430
>
power -> atom_expr ** factor
2430
-
power -> atom_expr ** factor
2430
if
power -> atom_expr ** factor
2430
!=
power -> atom_expr ** factor
2430
>=
power -> atom_expr ** factor
2430
for
power -> atom_expr ** factor
2430
/
power -> atom_expr ** factor
2430
%
power -> atom_expr ** factor
2430
and
power -> atom_expr ** factor
2430
<=
power -> atom_expr ** factor
2430
]
power -> atom_expr ** factor
2430
<
power -> atom_expr ** factor
2430
|
power -> atom_expr ** factor
2430
^
power -> atom_expr ** factor
2430
in
power -> atom_expr ** factor
2430
//
power -> atom_expr ** factor
2431
+
trailer_expr -> trailer trailer_expr
2431
*
trailer_expr -> trailer trailer_expr
2431
for
trailer_expr -> trailer trailer_expr
2431
/
trailer_expr -> trailer trailer_expr
2431
not
trailer_expr -> trailer trailer_expr
2431
<<
trailer_expr -> trailer trailer_expr
2431
!=
trailer_expr -> trailer trailer_expr
2431
>=
trailer_expr -> trailer trailer_expr
2431
>>
trailer_expr -> trailer trailer_expr
2431
|
trailer_expr -> trailer trailer_expr
2431
%
trailer_expr -> trailer trailer_expr
2431
>
trailer_expr -> trailer trailer_expr
2431
&
trailer_expr -> trailer trailer_expr
2431
-
trailer_expr -> trailer trailer_expr
2431
<=
trailer_expr -> trailer trailer_expr
2431
**
trailer_expr -> trailer trailer_expr
2431
@
trailer_expr -> trailer trailer_expr
2431
if
trailer_expr -> trailer trailer_expr
2431
==
trailer_expr -> trailer trailer_expr
2431
or
trailer_expr -> trailer trailer_expr
2431
<
trailer_expr -> trailer trailer_expr
2431
and
trailer_expr -> trailer trailer_expr
2431
in
trailer_expr -> trailer trailer_expr
2431
is
trailer_expr -> trailer trailer_expr
2431
]
trailer_expr -> trailer trailer_expr
2431
^
trailer_expr -> trailer trailer_expr
2431
//
trailer_expr -> trailer trailer_expr
2432
<<
trailer -> . NAME
2432
<=
trailer -> . NAME
2432
**
trailer -> . NAME
2432
!=
trailer -> . NAME
2432
/
trailer -> . NAME
2432
&
trailer -> . NAME
2432
//
trailer -> . NAME
2432
<
trailer -> . NAME
2432
is
trailer -> . NAME
2432
-
trailer -> . NAME
2432
if
trailer -> . NAME
2432
[
trailer -> . NAME
2432
or
trailer -> . NAME
2432
>
trailer -> . NAME
2432
*
trailer -> . NAME
2432
+
trailer -> . NAME
2432
for
trailer -> . NAME
2432
%
trailer -> . NAME
2432
.
trailer -> . NAME
2432
>=
trailer -> . NAME
2432
|
trailer -> . NAME
2432
and
trailer -> . NAME
2432
(
trailer -> . NAME
2432
]
trailer -> . NAME
2432
==
trailer -> . NAME
2432
^
trailer -> . NAME
2432
in
trailer -> . NAME
2432
@
trailer -> . NAME
2432
not
trailer -> . NAME
2432
>>
trailer -> . NAME
2433
%
trailer -> ( )
2433
<=
trailer -> ( )
2433
and
trailer -> ( )
2433
//
trailer -> ( )
2433
not
trailer -> ( )
2433
or
trailer -> ( )
2433
for
trailer -> ( )
2433
]
trailer -> ( )
2433
>>
trailer -> ( )
2433
>
trailer -> ( )
2433
<<
trailer -> ( )
2433
[
trailer -> ( )
2433
is
trailer -> ( )
2433
-
trailer -> ( )
2433
**
trailer -> ( )
2433
/
trailer -> ( )
2433
+
trailer -> ( )
2433
&
trailer -> ( )
2433
in
trailer -> ( )
2433
^
trailer -> ( )
2433
!=
trailer -> ( )
2433
*
trailer -> ( )
2433
if
trailer -> ( )
2433
>=
trailer -> ( )
2433
(
trailer -> ( )
2433
@
trailer -> ( )
2433
==
trailer -> ( )
2433
|
trailer -> ( )
2433
.
trailer -> ( )
2433
<
trailer -> ( )
2434
)
2545
2435
]
2546
2436
==
and_expr -> shift_expr & and_expr
2436
in
and_expr -> shift_expr & and_expr
2436
!=
and_expr -> shift_expr & and_expr
2436
or
and_expr -> shift_expr & and_expr
2436
>
and_expr -> shift_expr & and_expr
2436
not
and_expr -> shift_expr & and_expr
2436
<=
and_expr -> shift_expr & and_expr
2436
|
and_expr -> shift_expr & and_expr
2436
and
and_expr -> shift_expr & and_expr
2436
for
and_expr -> shift_expr & and_expr
2436
^
and_expr -> shift_expr & and_expr
2436
is
and_expr -> shift_expr & and_expr
2436
]
and_expr -> shift_expr & and_expr
2436
>=
and_expr -> shift_expr & and_expr
2436
<
and_expr -> shift_expr & and_expr
2436
if
and_expr -> shift_expr & and_expr
2437
<=
xor_expr -> and_expr ^ xor_expr
2437
!=
xor_expr -> and_expr ^ xor_expr
2437
for
xor_expr -> and_expr ^ xor_expr
2437
and
xor_expr -> and_expr ^ xor_expr
2437
is
xor_expr -> and_expr ^ xor_expr
2437
>=
xor_expr -> and_expr ^ xor_expr
2437
not
xor_expr -> and_expr ^ xor_expr
2437
<
xor_expr -> and_expr ^ xor_expr
2437
|
xor_expr -> and_expr ^ xor_expr
2437
in
xor_expr -> and_expr ^ xor_expr
2437
==
xor_expr -> and_expr ^ xor_expr
2437
or
xor_expr -> and_expr ^ xor_expr
2437
if
xor_expr -> and_expr ^ xor_expr
2437
>
xor_expr -> and_expr ^ xor_expr
2437
]
xor_expr -> and_expr ^ xor_expr
2438
not
expr -> xor_expr | expr
2438
for
expr -> xor_expr | expr
2438
in
expr -> xor_expr | expr
2438
if
expr -> xor_expr | expr
2438
or
expr -> xor_expr | expr
2438
<=
expr -> xor_expr | expr
2438
>
expr -> xor_expr | expr
2438
!=
expr -> xor_expr | expr
2438
]
expr -> xor_expr | expr
2438
==
expr -> xor_expr | expr
2438
>=
expr -> xor_expr | expr
2438
is
expr -> xor_expr | expr
2438
<
expr -> xor_expr | expr
2438
and
expr -> xor_expr | expr
2439
]
and_test -> not_test and and_test
2439
for
and_test -> not_test and and_test
2439
if
and_test -> not_test and and_test
2439
or
and_test -> not_test and and_test
2440
and
comparison -> expr comp_op comparison
2440
]
comparison -> expr comp_op comparison
2440
if
comparison -> expr comp_op comparison
2440
for
comparison -> expr comp_op comparison
2440
or
comparison -> expr comp_op comparison
2441
]
or_test -> and_test or or_test
2441
if
or_test -> and_test or or_test
2441
for
or_test -> and_test or or_test
2442
:
2547
2442
NAME
305
2442
varargslist
2548
2442
vfpdef
306
2443
for
test_nocond -> lambdef_nocond
2443
]
test_nocond -> lambdef_nocond
2443
if
test_nocond -> lambdef_nocond
2444
for
test_nocond -> or_test
2444
if
test_nocond -> or_test
2444
]
test_nocond -> or_test
2445
for
497
2445
]
comp_iter -> 
2445
comp_iter
2549
2445
if
2243
2445
comp_for
2244
2445
comp_if
2245
2446
,
test -> or_test if or_test else test
2446
]
test -> or_test if or_test else test
2447
nonlocal
simple_stmt -> small_stmt NEWLINE
2447
True
simple_stmt -> small_stmt NEWLINE
2447
False
simple_stmt -> small_stmt NEWLINE
2447
(
simple_stmt -> small_stmt NEWLINE
2447
continue
simple_stmt -> small_stmt NEWLINE
2447
begsim
simple_stmt -> small_stmt NEWLINE
2447
NAME
simple_stmt -> small_stmt NEWLINE
2447
endsim
simple_stmt -> small_stmt NEWLINE
2447
break
simple_stmt -> small_stmt NEWLINE
2447
return
simple_stmt -> small_stmt NEWLINE
2447
NUMBER
simple_stmt -> small_stmt NEWLINE
2447
[
simple_stmt -> small_stmt NEWLINE
2447
global
simple_stmt -> small_stmt NEWLINE
2447
resetstats
simple_stmt -> small_stmt NEWLINE
2447
yield
simple_stmt -> small_stmt NEWLINE
2447
conf
simple_stmt -> small_stmt NEWLINE
2447
$
simple_stmt -> small_stmt NEWLINE
2447
not
simple_stmt -> small_stmt NEWLINE
2447
finally
simple_stmt -> small_stmt NEWLINE
2447
lambda
simple_stmt -> small_stmt NEWLINE
2447
del
simple_stmt -> small_stmt NEWLINE
2447
pass
simple_stmt -> small_stmt NEWLINE
2447
for
simple_stmt -> small_stmt NEWLINE
2447
@
simple_stmt -> small_stmt NEWLINE
2447
with
simple_stmt -> small_stmt NEWLINE
2447
class
simple_stmt -> small_stmt NEWLINE
2447
NEWLINE
simple_stmt -> small_stmt NEWLINE
2447
if
simple_stmt -> small_stmt NEWLINE
2447
assert
simple_stmt -> small_stmt NEWLINE
2447
None
simple_stmt -> small_stmt NEWLINE
2447
+
simple_stmt -> small_stmt NEWLINE
2447
-
simple_stmt -> small_stmt NEWLINE
2447
STRING
simple_stmt -> small_stmt NEWLINE
2447
while
simple_stmt -> small_stmt NEWLINE
2447
{
simple_stmt -> small_stmt NEWLINE
2447
raise
simple_stmt -> small_stmt NEWLINE
2447
~
simple_stmt -> small_stmt NEWLINE
2447
def
simple_stmt -> small_stmt NEWLINE
2447
try
simple_stmt -> small_stmt NEWLINE
2448
:
2550
2449
if
1566
2449
arith_expr
2
2449
try
1567
2449
[
3
2449
class
1568
2449
for
1569
2449
stmt_list
2551
2449
with_stmt
1570
2449
while_stmt
1571
2449
factor
9
2449
@
10
2449
simple_stmt
1572
2449
decorators
1573
2449
return
13
2449
confdef
1574
2449
flow_stmt
15
2449
expr
16
2449
True
17
2449
not_test
18
2449
and_expr
19
2449
def
1575
2449
term
21
2449
xor_expr
22
2449
or_test
23
2449
atom_expr
24
2449
global
25
2449
for_stmt
1576
2449
NUMBER
27
2449
STRING
28
2449
NAME
29
2449
decorator
30
2449
if_stmt
1577
2449
with
1578
2449
endsim
33
2449
classdef
1579
2449
False
35
2449
(
36
2449
and_test
37
2449
conf
1580
2449
comparison
39
2449
lambda
40
2449
while
1581
2449
None
42
2449
try_stmt
1582
2449
funcdef
1583
2449
~
45
2449
decorated
1584
2449
small_stmt
1585
2449
test
48
2449
-
49
2449
shift_expr
50
2449
{
52
2449
lambdef
53
2449
atom
54
2449
+
55
2449
power
56
2449
not
57
2449
compound_stmt
1587
2449
continue
59
2449
del_stmt
60
2449
test_list
61
2449
raise
62
2449
raise_stmt
63
2449
resetstats
64
2449
pass_stmt
65
2449
stmt
1588
2449
nonlocal
66
2449
global_stmt
67
2449
yield
68
2449
continue_stmt
69
2449
assert
70
2449
nonlocal_stmt
71
2449
expr_stmt
72
2449
break_stmt
74
2449
return_stmt
75
2449
break
76
2449
sim_stmt
77
2449
stat_stmt
78
2449
yield_stmt
79
2449
assert_stmt
80
2449
pass
81
2449
begsim
83
2449
del
84
2450
factor
9
2450
arith_expr
2
2450
NAME
29
2450
term
21
2450
[
3
2450
~
45
2450
atom_expr
24
2450
expr
16
2450
power
56
2450
(
36
2450
suite
2552
2450
return
13
2450
small_stmt
1981
2450
flow_stmt
15
2450
True
17
2450
not_test
18
2450
and_expr
19
2450
xor_expr
22
2450
{
52
2450
lambdef
53
2450
atom
54
2450
or_test
23
2450
shift_expr
50
2450
False
35
2450
NEWLINE
1982
2450
-
49
2450
None
42
2450
lambda
40
2450
global
25
2450
NUMBER
27
2450
STRING
28
2450
test
48
2450
endsim
33
2450
and_test
37
2450
simple_stmt
1983
2450
comparison
39
2450
break_stmt
74
2450
+
55
2450
not
57
2450
raise
62
2450
continue
59
2450
return_stmt
75
2450
del_stmt
60
2450
test_list
61
2450
raise_stmt
63
2450
resetstats
64
2450
pass_stmt
65
2450
nonlocal
66
2450
break
76
2450
sim_stmt
77
2450
stat_stmt
78
2450
global_stmt
67
2450
yield_stmt
79
2450
assert_stmt
80
2450
pass
81
2450
yield
68
2450
continue_stmt
69
2450
assert
70
2450
nonlocal_stmt
71
2450
expr_stmt
72
2450
begsim
83
2450
del
84
2451
for
except_clause -> except test : suite maybe_except_clause
2451
@
except_clause -> except test : suite maybe_except_clause
2451
resetstats
except_clause -> except test : suite maybe_except_clause
2451
lambda
except_clause -> except test : suite maybe_except_clause
2451
{
except_clause -> except test : suite maybe_except_clause
2451
NUMBER
except_clause -> except test : suite maybe_except_clause
2451
del
except_clause -> except test : suite maybe_except_clause
2451
begsim
except_clause -> except test : suite maybe_except_clause
2451
+
except_clause -> except test : suite maybe_except_clause
2451
break
except_clause -> except test : suite maybe_except_clause
2451
continue
except_clause -> except test : suite maybe_except_clause
2451
assert
except_clause -> except test : suite maybe_except_clause
2451
else
except_clause -> except test : suite maybe_except_clause
2451
NAME
except_clause -> except test : suite maybe_except_clause
2451
None
except_clause -> except test : suite maybe_except_clause
2451
not
except_clause -> except test : suite maybe_except_clause
2451
$
except_clause -> except test : suite maybe_except_clause
2451
with
except_clause -> except test : suite maybe_except_clause
2451
global
except_clause -> except test : suite maybe_except_clause
2451
return
except_clause -> except test : suite maybe_except_clause
2451
True
except_clause -> except test : suite maybe_except_clause
2451
class
except_clause -> except test : suite maybe_except_clause
2451
conf
except_clause -> except test : suite maybe_except_clause
2451
while
except_clause -> except test : suite maybe_except_clause
2451
raise
except_clause -> except test : suite maybe_except_clause
2451
try
except_clause -> except test : suite maybe_except_clause
2451
False
except_clause -> except test : suite maybe_except_clause
2451
~
except_clause -> except test : suite maybe_except_clause
2451
finally
except_clause -> except test : suite maybe_except_clause
2451
[
except_clause -> except test : suite maybe_except_clause
2451
nonlocal
except_clause -> except test : suite maybe_except_clause
2451
STRING
except_clause -> except test : suite maybe_except_clause
2451
pass
except_clause -> except test : suite maybe_except_clause
2451
def
except_clause -> except test : suite maybe_except_clause
2451
NEWLINE
except_clause -> except test : suite maybe_except_clause
2451
if
except_clause -> except test : suite maybe_except_clause
2451
(
except_clause -> except test : suite maybe_except_clause
2451
-
except_clause -> except test : suite maybe_except_clause
2451
endsim
except_clause -> except test : suite maybe_except_clause
2451
yield
except_clause -> except test : suite maybe_except_clause
2452
:
lambdef -> lambda varargslist : test
2452
as
lambdef -> lambda varargslist : test
2453
**
trailer -> ( arglist )
2453
:
trailer -> ( arglist )
2453
if
trailer -> ( arglist )
2453
<
trailer -> ( arglist )
2453
//
trailer -> ( arglist )
2453
<<
trailer -> ( arglist )
2453
%
trailer -> ( arglist )
2453
&
trailer -> ( arglist )
2453
==
trailer -> ( arglist )
2453
is
trailer -> ( arglist )
2453
as
trailer -> ( arglist )
2453
!=
trailer -> ( arglist )
2453
and
trailer -> ( arglist )
2453
-
trailer -> ( arglist )
2453
+
trailer -> ( arglist )
2453
>=
trailer -> ( arglist )
2453
or
trailer -> ( arglist )
2453
(
trailer -> ( arglist )
2453
^
trailer -> ( arglist )
2453
.
trailer -> ( arglist )
2453
not
trailer -> ( arglist )
2453
>>
trailer -> ( arglist )
2453
/
trailer -> ( arglist )
2453
*
trailer -> ( arglist )
2453
[
trailer -> ( arglist )
2453
@
trailer -> ( arglist )
2453
>
trailer -> ( arglist )
2453
|
trailer -> ( arglist )
2453
<=
trailer -> ( arglist )
2453
in
trailer -> ( arglist )
2454
|
trailer -> [ subscriptlist ]
2454
not
trailer -> [ subscriptlist ]
2454
in
trailer -> [ subscriptlist ]
2454
==
trailer -> [ subscriptlist ]
2454
**
trailer -> [ subscriptlist ]
2454
>>
trailer -> [ subscriptlist ]
2454
!=
trailer -> [ subscriptlist ]
2454
*
trailer -> [ subscriptlist ]
2454
or
trailer -> [ subscriptlist ]
2454
>=
trailer -> [ subscriptlist ]
2454
as
trailer -> [ subscriptlist ]
2454
/
trailer -> [ subscriptlist ]
2454
[
trailer -> [ subscriptlist ]
2454
>
trailer -> [ subscriptlist ]
2454
<
trailer -> [ subscriptlist ]
2454
.
trailer -> [ subscriptlist ]
2454
and
trailer -> [ subscriptlist ]
2454
(
trailer -> [ subscriptlist ]
2454
<=
trailer -> [ subscriptlist ]
2454
-
trailer -> [ subscriptlist ]
2454
@
trailer -> [ subscriptlist ]
2454
<<
trailer -> [ subscriptlist ]
2454
&
trailer -> [ subscriptlist ]
2454
:
trailer -> [ subscriptlist ]
2454
^
trailer -> [ subscriptlist ]
2454
is
trailer -> [ subscriptlist ]
2454
%
trailer -> [ subscriptlist ]
2454
+
trailer -> [ subscriptlist ]
2454
//
trailer -> [ subscriptlist ]
2454
if
trailer -> [ subscriptlist ]
2455
DEDENT
2553
2456
factor
1536
2456
(
1537
2456
arith_expr
1538
2456
NAME
1539
2456
term
1540
2456
[
1541
2456
~
1542
2456
+
1543
2456
lambda
1544
2456
expr
1545
2456
atom_expr
1546
2456
shift_expr
1547
2456
atom
1548
2456
NUMBER
1549
2456
STRING
1550
2456
-
1552
2456
True
1553
2456
not_test
1554
2456
and_expr
1555
2456
xor_expr
1556
2456
False
1557
2456
{
1558
2456
or_test
1559
2456
None
1560
2456
comparison
1561
2456
and_test
1562
2456
lambdef
1563
2456
power
1564
2456
not
1565
2456
test
2554
2457
NEWLINE
2555
2458
-
elif_clause -> 
2458
elif
2556
2458
elif_clause
2557
2458
NUMBER
elif_clause -> 
2458
class
elif_clause -> 
2458
(
elif_clause -> 
2458
NAME
elif_clause -> 
2458
else
elif_clause -> 
2458
pass
elif_clause -> 
2458
~
elif_clause -> 
2458
not
elif_clause -> 
2458
{
elif_clause -> 
2458
yield
elif_clause -> 
2458
endsim
elif_clause -> 
2458
lambda
elif_clause -> 
2458
def
elif_clause -> 
2458
@
elif_clause -> 
2458
[
elif_clause -> 
2458
+
elif_clause -> 
2458
raise
elif_clause -> 
2458
True
elif_clause -> 
2458
DEDENT
elif_clause -> 
2458
del
elif_clause -> 
2458
None
elif_clause -> 
2458
nonlocal
elif_clause -> 
2458
while
elif_clause -> 
2458
return
elif_clause -> 
2458
try
elif_clause -> 
2458
False
elif_clause -> 
2458
begsim
elif_clause -> 
2458
global
elif_clause -> 
2458
continue
elif_clause -> 
2458
with
elif_clause -> 
2458
if
elif_clause -> 
2458
break
elif_clause -> 
2458
STRING
elif_clause -> 
2458
assert
elif_clause -> 
2458
resetstats
elif_clause -> 
2458
for
elif_clause -> 
2458
conf
elif_clause -> 
2459
INDENT
2558
2460
resetstats
suite -> simple_stmt
2460
+
suite -> simple_stmt
2460
lambda
suite -> simple_stmt
2460
try
suite -> simple_stmt
2460
begsim
suite -> simple_stmt
2460
None
suite -> simple_stmt
2460
not
suite -> simple_stmt
2460
@
suite -> simple_stmt
2460
[
suite -> simple_stmt
2460
class
suite -> simple_stmt
2460
return
suite -> simple_stmt
2460
else
suite -> simple_stmt
2460
nonlocal
suite -> simple_stmt
2460
NUMBER
suite -> simple_stmt
2460
yield
suite -> simple_stmt
2460
STRING
suite -> simple_stmt
2460
-
suite -> simple_stmt
2460
False
suite -> simple_stmt
2460
def
suite -> simple_stmt
2460
conf
suite -> simple_stmt
2460
elif
suite -> simple_stmt
2460
True
suite -> simple_stmt
2460
raise
suite -> simple_stmt
2460
endsim
suite -> simple_stmt
2460
with
suite -> simple_stmt
2460
global
suite -> simple_stmt
2460
{
suite -> simple_stmt
2460
~
suite -> simple_stmt
2460
assert
suite -> simple_stmt
2460
DEDENT
suite -> simple_stmt
2460
(
suite -> simple_stmt
2460
while
suite -> simple_stmt
2460
del
suite -> simple_stmt
2460
pass
suite -> simple_stmt
2460
break
suite -> simple_stmt
2460
for
suite -> simple_stmt
2460
continue
suite -> simple_stmt
2460
NAME
suite -> simple_stmt
2460
if
suite -> simple_stmt
2461
else
2559
2461
finally
2560
2461
pass
try_stmt -> try : suite except_clause
2461
if
try_stmt -> try : suite except_clause
2461
resetstats
try_stmt -> try : suite except_clause
2461
raise
try_stmt -> try : suite except_clause
2461
with
try_stmt -> try : suite except_clause
2461
yield
try_stmt -> try : suite except_clause
2461
conf
try_stmt -> try : suite except_clause
2461
return
try_stmt -> try : suite except_clause
2461
del
try_stmt -> try : suite except_clause
2461
def
try_stmt -> try : suite except_clause
2461
(
try_stmt -> try : suite except_clause
2461
not
try_stmt -> try : suite except_clause
2461
break
try_stmt -> try : suite except_clause
2461
DEDENT
try_stmt -> try : suite except_clause
2461
class
try_stmt -> try : suite except_clause
2461
[
try_stmt -> try : suite except_clause
2461
~
try_stmt -> try : suite except_clause
2461
endsim
try_stmt -> try : suite except_clause
2461
nonlocal
try_stmt -> try : suite except_clause
2461
for
try_stmt -> try : suite except_clause
2461
try
try_stmt -> try : suite except_clause
2461
@
try_stmt -> try : suite except_clause
2461
NUMBER
try_stmt -> try : suite except_clause
2461
STRING
try_stmt -> try : suite except_clause
2461
begsim
try_stmt -> try : suite except_clause
2461
assert
try_stmt -> try : suite except_clause
2461
continue
try_stmt -> try : suite except_clause
2461
False
try_stmt -> try : suite except_clause
2461
None
try_stmt -> try : suite except_clause
2461
global
try_stmt -> try : suite except_clause
2461
+
try_stmt -> try : suite except_clause
2461
lambda
try_stmt -> try : suite except_clause
2461
while
try_stmt -> try : suite except_clause
2461
-
try_stmt -> try : suite except_clause
2461
{
try_stmt -> try : suite except_clause
2461
True
try_stmt -> try : suite except_clause
2461
NAME
try_stmt -> try : suite except_clause
2462
test
2561
2462
factor
1536
2462
(
1537
2462
arith_expr
1538
2462
NAME
1539
2462
term
1540
2462
[
1541
2462
~
1542
2462
+
1543
2462
lambda
1544
2462
expr
1545
2462
atom_expr
1546
2462
shift_expr
1547
2462
atom
1548
2462
NUMBER
1549
2462
STRING
1550
2462
:
2562
2462
-
1552
2462
True
1553
2462
not_test
1554
2462
and_expr
1555
2462
xor_expr
1556
2462
False
1557
2462
{
1558
2462
or_test
1559
2462
None
1560
2462
comparison
1561
2462
and_test
1562
2462
lambdef
1563
2462
power
1564
2462
not
1565
2463
)
2563
2464
:
2564
2465
[
classdef -> class NAME : suite
2465
with
classdef -> class NAME : suite
2465
pass
classdef -> class NAME : suite
2465
-
classdef -> class NAME : suite
2465
lambda
classdef -> class NAME : suite
2465
assert
classdef -> class NAME : suite
2465
STRING
classdef -> class NAME : suite
2465
global
classdef -> class NAME : suite
2465
return
classdef -> class NAME : suite
2465
NUMBER
classdef -> class NAME : suite
2465
DEDENT
classdef -> class NAME : suite
2465
@
classdef -> class NAME : suite
2465
begsim
classdef -> class NAME : suite
2465
+
classdef -> class NAME : suite
2465
while
classdef -> class NAME : suite
2465
True
classdef -> class NAME : suite
2465
break
classdef -> class NAME : suite
2465
yield
classdef -> class NAME : suite
2465
continue
classdef -> class NAME : suite
2465
resetstats
classdef -> class NAME : suite
2465
{
classdef -> class NAME : suite
2465
def
classdef -> class NAME : suite
2465
try
classdef -> class NAME : suite
2465
raise
classdef -> class NAME : suite
2465
endsim
classdef -> class NAME : suite
2465
del
classdef -> class NAME : suite
2465
for
classdef -> class NAME : suite
2465
None
classdef -> class NAME : suite
2465
nonlocal
classdef -> class NAME : suite
2465
~
classdef -> class NAME : suite
2465
not
classdef -> class NAME : suite
2465
NAME
classdef -> class NAME : suite
2465
if
classdef -> class NAME : suite
2465
(
classdef -> class NAME : suite
2465
conf
classdef -> class NAME : suite
2465
class
classdef -> class NAME : suite
2465
False
classdef -> class NAME : suite
2466
INDENT
2565
2467
resetstats
suite -> simple_stmt
2467
+
suite -> simple_stmt
2467
lambda
suite -> simple_stmt
2467
try
suite -> simple_stmt
2467
begsim
suite -> simple_stmt
2467
None
suite -> simple_stmt
2467
not
suite -> simple_stmt
2467
@
suite -> simple_stmt
2467
[
suite -> simple_stmt
2467
class
suite -> simple_stmt
2467
return
suite -> simple_stmt
2467
nonlocal
suite -> simple_stmt
2467
NUMBER
suite -> simple_stmt
2467
yield
suite -> simple_stmt
2467
STRING
suite -> simple_stmt
2467
-
suite -> simple_stmt
2467
False
suite -> simple_stmt
2467
def
suite -> simple_stmt
2467
conf
suite -> simple_stmt
2467
True
suite -> simple_stmt
2467
raise
suite -> simple_stmt
2467
endsim
suite -> simple_stmt
2467
with
suite -> simple_stmt
2467
global
suite -> simple_stmt
2467
{
suite -> simple_stmt
2467
~
suite -> simple_stmt
2467
assert
suite -> simple_stmt
2467
DEDENT
suite -> simple_stmt
2467
(
suite -> simple_stmt
2467
while
suite -> simple_stmt
2467
del
suite -> simple_stmt
2467
pass
suite -> simple_stmt
2467
break
suite -> simple_stmt
2467
for
suite -> simple_stmt
2467
continue
suite -> simple_stmt
2467
NAME
suite -> simple_stmt
2467
if
suite -> simple_stmt
2468
:
2566
2469
:
2567
2470
)
2568
2471
begsim
with_stmt -> with with_items : suite
2471
nonlocal
with_stmt -> with with_items : suite
2471
return
with_stmt -> with with_items : suite
2471
False
with_stmt -> with with_items : suite
2471
assert
with_stmt -> with with_items : suite
2471
not
with_stmt -> with with_items : suite
2471
try
with_stmt -> with with_items : suite
2471
class
with_stmt -> with with_items : suite
2471
raise
with_stmt -> with with_items : suite
2471
if
with_stmt -> with with_items : suite
2471
while
with_stmt -> with with_items : suite
2471
resetstats
with_stmt -> with with_items : suite
2471
with
with_stmt -> with with_items : suite
2471
None
with_stmt -> with with_items : suite
2471
~
with_stmt -> with with_items : suite
2471
@
with_stmt -> with with_items : suite
2471
{
with_stmt -> with with_items : suite
2471
endsim
with_stmt -> with with_items : suite
2471
for
with_stmt -> with with_items : suite
2471
(
with_stmt -> with with_items : suite
2471
def
with_stmt -> with with_items : suite
2471
global
with_stmt -> with with_items : suite
2471
lambda
with_stmt -> with with_items : suite
2471
pass
with_stmt -> with with_items : suite
2471
[
with_stmt -> with with_items : suite
2471
STRING
with_stmt -> with with_items : suite
2471
DEDENT
with_stmt -> with with_items : suite
2471
del
with_stmt -> with with_items : suite
2471
continue
with_stmt -> with with_items : suite
2471
yield
with_stmt -> with with_items : suite
2471
-
with_stmt -> with with_items : suite
2471
NUMBER
with_stmt -> with with_items : suite
2471
break
with_stmt -> with with_items : suite
2471
True
with_stmt -> with with_items : suite
2471
NAME
with_stmt -> with with_items : suite
2471
+
with_stmt -> with with_items : suite
2471
conf
with_stmt -> with with_items : suite
2472
INDENT
2569
2473
)
2570
2474
else
2571
2474
begsim
while_stmt -> while test : suite
2474
with
while_stmt -> while test : suite
2474
break
while_stmt -> while test : suite
2474
lambda
while_stmt -> while test : suite
2474
NAME
while_stmt -> while test : suite
2474
STRING
while_stmt -> while test : suite
2474
try
while_stmt -> while test : suite
2474
not
while_stmt -> while test : suite
2474
continue
while_stmt -> while test : suite
2474
global
while_stmt -> while test : suite
2474
(
while_stmt -> while test : suite
2474
{
while_stmt -> while test : suite
2474
nonlocal
while_stmt -> while test : suite
2474
raise
while_stmt -> while test : suite
2474
for
while_stmt -> while test : suite
2474
~
while_stmt -> while test : suite
2474
-
while_stmt -> while test : suite
2474
DEDENT
while_stmt -> while test : suite
2474
if
while_stmt -> while test : suite
2474
return
while_stmt -> while test : suite
2474
class
while_stmt -> while test : suite
2474
+
while_stmt -> while test : suite
2474
False
while_stmt -> while test : suite
2474
assert
while_stmt -> while test : suite
2474
conf
while_stmt -> while test : suite
2474
yield
while_stmt -> while test : suite
2474
def
while_stmt -> while test : suite
2474
resetstats
while_stmt -> while test : suite
2474
endsim
while_stmt -> while test : suite
2474
NUMBER
while_stmt -> while test : suite
2474
True
while_stmt -> while test : suite
2474
del
while_stmt -> while test : suite
2474
@
while_stmt -> while test : suite
2474
[
while_stmt -> while test : suite
2474
pass
while_stmt -> while test : suite
2474
None
while_stmt -> while test : suite
2474
while
while_stmt -> while test : suite
2475
NEWLINE
2572
2476
INDENT
2573
2477
resetstats
suite -> simple_stmt
2477
+
suite -> simple_stmt
2477
lambda
suite -> simple_stmt
2477
try
suite -> simple_stmt
2477
begsim
suite -> simple_stmt
2477
None
suite -> simple_stmt
2477
not
suite -> simple_stmt
2477
@
suite -> simple_stmt
2477
[
suite -> simple_stmt
2477
class
suite -> simple_stmt
2477
return
suite -> simple_stmt
2477
else
suite -> simple_stmt
2477
nonlocal
suite -> simple_stmt
2477
NUMBER
suite -> simple_stmt
2477
yield
suite -> simple_stmt
2477
STRING
suite -> simple_stmt
2477
-
suite -> simple_stmt
2477
False
suite -> simple_stmt
2477
def
suite -> simple_stmt
2477
conf
suite -> simple_stmt
2477
True
suite -> simple_stmt
2477
raise
suite -> simple_stmt
2477
endsim
suite -> simple_stmt
2477
with
suite -> simple_stmt
2477
global
suite -> simple_stmt
2477
{
suite -> simple_stmt
2477
~
suite -> simple_stmt
2477
assert
suite -> simple_stmt
2477
DEDENT
suite -> simple_stmt
2477
(
suite -> simple_stmt
2477
while
suite -> simple_stmt
2477
del
suite -> simple_stmt
2477
pass
suite -> simple_stmt
2477
break
suite -> simple_stmt
2477
for
suite -> simple_stmt
2477
continue
suite -> simple_stmt
2477
NAME
suite -> simple_stmt
2477
if
suite -> simple_stmt
2478
factor
9
2478
arith_expr
2
2478
NAME
29
2478
term
21
2478
[
3
2478
~
45
2478
atom_expr
24
2478
expr
16
2478
power
56
2478
(
36
2478
return
13
2478
small_stmt
47
2478
flow_stmt
15
2478
True
17
2478
not_test
18
2478
and_expr
19
2478
xor_expr
22
2478
{
52
2478
lambdef
53
2478
atom
54
2478
or_test
23
2478
shift_expr
50
2478
False
35
2478
NEWLINE
1022
2478
-
49
2478
None
42
2478
lambda
40
2478
global
25
2478
NUMBER
27
2478
STRING
28
2478
test
48
2478
endsim
33
2478
and_test
37
2478
simple_stmt
1023
2478
comparison
39
2478
suite
2574
2478
break_stmt
74
2478
+
55
2478
not
57
2478
raise
62
2478
continue
59
2478
return_stmt
75
2478
del_stmt
60
2478
test_list
61
2478
raise_stmt
63
2478
resetstats
64
2478
pass_stmt
65
2478
nonlocal
66
2478
break
76
2478
sim_stmt
77
2478
stat_stmt
78
2478
global_stmt
67
2478
yield_stmt
79
2478
assert_stmt
80
2478
pass
81
2478
yield
68
2478
continue_stmt
69
2478
assert
70
2478
nonlocal_stmt
71
2478
expr_stmt
72
2478
begsim
83
2478
del
84
2479
:
test -> or_test if or_test else test
2479
,
test -> or_test if or_test else test
2480
and
term -> factor // term
2480
if
term -> factor // term
2480
>
term -> factor // term
2480
<
term -> factor // term
2480
==
term -> factor // term
2480
+
term -> factor // term
2480
-
term -> factor // term
2480
&
term -> factor // term
2480
in
term -> factor // term
2480
!=
term -> factor // term
2480
^
term -> factor // term
2480
,
term -> factor // term
2480
)
term -> factor // term
2480
=
term -> factor // term
2480
or
term -> factor // term
2480
<=
term -> factor // term
2480
>=
term -> factor // term
2480
|
term -> factor // term
2480
>>
term -> factor // term
2480
not
term -> factor // term
2480
is
term -> factor // term
2480
<<
term -> factor // term
2481
^
term -> factor * term
2481
+
term -> factor * term
2481
==
term -> factor * term
2481
>>
term -> factor * term
2481
in
term -> factor * term
2481
and
term -> factor * term
2481
if
term -> factor * term
2481
is
term -> factor * term
2481
<<
term -> factor * term
2481
,
term -> factor * term
2481
-
term -> factor * term
2481
!=
term -> factor * term
2481
or
term -> factor * term
2481
>
term -> factor * term
2481
&
term -> factor * term
2481
)
term -> factor * term
2481
>=
term -> factor * term
2481
|
term -> factor * term
2481
<=
term -> factor * term
2481
not
term -> factor * term
2481
=
term -> factor * term
2481
<
term -> factor * term
2482
&
term -> factor % term
2482
==
term -> factor % term
2482
!=
term -> factor % term
2482
)
term -> factor % term
2482
<
term -> factor % term
2482
in
term -> factor % term
2482
=
term -> factor % term
2482
>>
term -> factor % term
2482
<<
term -> factor % term
2482
-
term -> factor % term
2482
if
term -> factor % term
2482
>
term -> factor % term
2482
or
term -> factor % term
2482
^
term -> factor % term
2482
+
term -> factor % term
2482
,
term -> factor % term
2482
is
term -> factor % term
2482
|
term -> factor % term
2482
>=
term -> factor % term
2482
<=
term -> factor % term
2482
and
term -> factor % term
2482
not
term -> factor % term
2483
and
term -> factor @ term
2483
in
term -> factor @ term
2483
>=
term -> factor @ term
2483
<
term -> factor @ term
2483
,
term -> factor @ term
2483
>
term -> factor @ term
2483
-
term -> factor @ term
2483
or
term -> factor @ term
2483
)
term -> factor @ term
2483
<<
term -> factor @ term
2483
is
term -> factor @ term
2483
!=
term -> factor @ term
2483
|
term -> factor @ term
2483
&
term -> factor @ term
2483
==
term -> factor @ term
2483
>>
term -> factor @ term
2483
<=
term -> factor @ term
2483
not
term -> factor @ term
2483
+
term -> factor @ term
2483
^
term -> factor @ term
2483
=
term -> factor @ term
2483
if
term -> factor @ term
2484
or
term -> factor / term
2484
<<
term -> factor / term
2484
not
term -> factor / term
2484
in
term -> factor / term
2484
!=
term -> factor / term
2484
<
term -> factor / term
2484
,
term -> factor / term
2484
+
term -> factor / term
2484
and
term -> factor / term
2484
>>
term -> factor / term
2484
^
term -> factor / term
2484
<=
term -> factor / term
2484
==
term -> factor / term
2484
>
term -> factor / term
2484
&
term -> factor / term
2484
is
term -> factor / term
2484
-
term -> factor / term
2484
)
term -> factor / term
2484
|
term -> factor / term
2484
>=
term -> factor / term
2484
if
term -> factor / term
2484
=
term -> factor / term
2485
==
arith_expr -> term + arith_expr
2485
!=
arith_expr -> term + arith_expr
2485
<<
arith_expr -> term + arith_expr
2485
&
arith_expr -> term + arith_expr
2485
<
arith_expr -> term + arith_expr
2485
^
arith_expr -> term + arith_expr
2485
,
arith_expr -> term + arith_expr
2485
>=
arith_expr -> term + arith_expr
2485
in
arith_expr -> term + arith_expr
2485
)
arith_expr -> term + arith_expr
2485
>>
arith_expr -> term + arith_expr
2485
not
arith_expr -> term + arith_expr
2485
<=
arith_expr -> term + arith_expr
2485
is
arith_expr -> term + arith_expr
2485
|
arith_expr -> term + arith_expr
2485
and
arith_expr -> term + arith_expr
2485
=
arith_expr -> term + arith_expr
2485
or
arith_expr -> term + arith_expr
2485
if
arith_expr -> term + arith_expr
2485
>
arith_expr -> term + arith_expr
2486
if
arith_expr -> term - arith_expr
2486
&
arith_expr -> term - arith_expr
2486
>>
arith_expr -> term - arith_expr
2486
!=
arith_expr -> term - arith_expr
2486
)
arith_expr -> term - arith_expr
2486
>=
arith_expr -> term - arith_expr
2486
|
arith_expr -> term - arith_expr
2486
>
arith_expr -> term - arith_expr
2486
<
arith_expr -> term - arith_expr
2486
==
arith_expr -> term - arith_expr
2486
,
arith_expr -> term - arith_expr
2486
and
arith_expr -> term - arith_expr
2486
=
arith_expr -> term - arith_expr
2486
is
arith_expr -> term - arith_expr
2486
in
arith_expr -> term - arith_expr
2486
^
arith_expr -> term - arith_expr
2486
<<
arith_expr -> term - arith_expr
2486
not
arith_expr -> term - arith_expr
2486
or
arith_expr -> term - arith_expr
2486
<=
arith_expr -> term - arith_expr
2487
+
atom -> ( test_list_comp )
2487
/
atom -> ( test_list_comp )
2487
*
atom -> ( test_list_comp )
2487
[
atom -> ( test_list_comp )
2487
&
atom -> ( test_list_comp )
2487
,
atom -> ( test_list_comp )
2487
**
atom -> ( test_list_comp )
2487
^
atom -> ( test_list_comp )
2487
(
atom -> ( test_list_comp )
2487
and
atom -> ( test_list_comp )
2487
)
atom -> ( test_list_comp )
2487
>
atom -> ( test_list_comp )
2487
=
atom -> ( test_list_comp )
2487
-
atom -> ( test_list_comp )
2487
%
atom -> ( test_list_comp )
2487
//
atom -> ( test_list_comp )
2487
in
atom -> ( test_list_comp )
2487
>>
atom -> ( test_list_comp )
2487
not
atom -> ( test_list_comp )
2487
>=
atom -> ( test_list_comp )
2487
or
atom -> ( test_list_comp )
2487
<
atom -> ( test_list_comp )
2487
if
atom -> ( test_list_comp )
2487
|
atom -> ( test_list_comp )
2487
<<
atom -> ( test_list_comp )
2487
@
atom -> ( test_list_comp )
2487
!=
atom -> ( test_list_comp )
2487
is
atom -> ( test_list_comp )
2487
.
atom -> ( test_list_comp )
2487
<=
atom -> ( test_list_comp )
2487
==
atom -> ( test_list_comp )
2488
>=
shift_expr -> arith_expr >> shift_expr
2488
,
shift_expr -> arith_expr >> shift_expr
2488
if
shift_expr -> arith_expr >> shift_expr
2488
<=
shift_expr -> arith_expr >> shift_expr
2488
!=
shift_expr -> arith_expr >> shift_expr
2488
or
shift_expr -> arith_expr >> shift_expr
2488
|
shift_expr -> arith_expr >> shift_expr
2488
is
shift_expr -> arith_expr >> shift_expr
2488
)
shift_expr -> arith_expr >> shift_expr
2488
and
shift_expr -> arith_expr >> shift_expr
2488
in
shift_expr -> arith_expr >> shift_expr
2488
^
shift_expr -> arith_expr >> shift_expr
2488
not
shift_expr -> arith_expr >> shift_expr
2488
<
shift_expr -> arith_expr >> shift_expr
2488
==
shift_expr -> arith_expr >> shift_expr
2488
=
shift_expr -> arith_expr >> shift_expr
2488
&
shift_expr -> arith_expr >> shift_expr
2488
>
shift_expr -> arith_expr >> shift_expr
2489
>
shift_expr -> arith_expr << shift_expr
2489
or
shift_expr -> arith_expr << shift_expr
2489
^
shift_expr -> arith_expr << shift_expr
2489
not
shift_expr -> arith_expr << shift_expr
2489
<
shift_expr -> arith_expr << shift_expr
2489
if
shift_expr -> arith_expr << shift_expr
2489
in
shift_expr -> arith_expr << shift_expr
2489
!=
shift_expr -> arith_expr << shift_expr
2489
,
shift_expr -> arith_expr << shift_expr
2489
|
shift_expr -> arith_expr << shift_expr
2489
>=
shift_expr -> arith_expr << shift_expr
2489
)
shift_expr -> arith_expr << shift_expr
2489
and
shift_expr -> arith_expr << shift_expr
2489
==
shift_expr -> arith_expr << shift_expr
2489
&
shift_expr -> arith_expr << shift_expr
2489
<=
shift_expr -> arith_expr << shift_expr
2489
=
shift_expr -> arith_expr << shift_expr
2489
is
shift_expr -> arith_expr << shift_expr
2490
in
atom -> [ test_list_comp ]
2490
/
atom -> [ test_list_comp ]
2490
or
atom -> [ test_list_comp ]
2490
if
atom -> [ test_list_comp ]
2490
<<
atom -> [ test_list_comp ]
2490
!=
atom -> [ test_list_comp ]
2490
=
atom -> [ test_list_comp ]
2490
<=
atom -> [ test_list_comp ]
2490
)
atom -> [ test_list_comp ]
2490
>>
atom -> [ test_list_comp ]
2490
*
atom -> [ test_list_comp ]
2490
^
atom -> [ test_list_comp ]
2490
.
atom -> [ test_list_comp ]
2490
(
atom -> [ test_list_comp ]
2490
>=
atom -> [ test_list_comp ]
2490
and
atom -> [ test_list_comp ]
2490
<
atom -> [ test_list_comp ]
2490
,
atom -> [ test_list_comp ]
2490
[
atom -> [ test_list_comp ]
2490
==
atom -> [ test_list_comp ]
2490
@
atom -> [ test_list_comp ]
2490
%
atom -> [ test_list_comp ]
2490
-
atom -> [ test_list_comp ]
2490
|
atom -> [ test_list_comp ]
2490
&
atom -> [ test_list_comp ]
2490
+
atom -> [ test_list_comp ]
2490
is
atom -> [ test_list_comp ]
2490
//
atom -> [ test_list_comp ]
2490
**
atom -> [ test_list_comp ]
2490
not
atom -> [ test_list_comp ]
2490
>
atom -> [ test_list_comp ]
2491
+
trailer_expr -> trailer trailer_expr
2491
,
trailer_expr -> trailer trailer_expr
2491
*
trailer_expr -> trailer trailer_expr
2491
/
trailer_expr -> trailer trailer_expr
2491
not
trailer_expr -> trailer trailer_expr
2491
<<
trailer_expr -> trailer trailer_expr
2491
!=
trailer_expr -> trailer trailer_expr
2491
=
trailer_expr -> trailer trailer_expr
2491
>=
trailer_expr -> trailer trailer_expr
2491
)
trailer_expr -> trailer trailer_expr
2491
>>
trailer_expr -> trailer trailer_expr
2491
|
trailer_expr -> trailer trailer_expr
2491
%
trailer_expr -> trailer trailer_expr
2491
>
trailer_expr -> trailer trailer_expr
2491
&
trailer_expr -> trailer trailer_expr
2491
-
trailer_expr -> trailer trailer_expr
2491
<=
trailer_expr -> trailer trailer_expr
2491
**
trailer_expr -> trailer trailer_expr
2491
@
trailer_expr -> trailer trailer_expr
2491
if
trailer_expr -> trailer trailer_expr
2491
==
trailer_expr -> trailer trailer_expr
2491
or
trailer_expr -> trailer trailer_expr
2491
<
trailer_expr -> trailer trailer_expr
2491
and
trailer_expr -> trailer trailer_expr
2491
in
trailer_expr -> trailer trailer_expr
2491
is
trailer_expr -> trailer trailer_expr
2491
^
trailer_expr -> trailer trailer_expr
2491
//
trailer_expr -> trailer trailer_expr
2492
<=
trailer -> . NAME
2492
<<
trailer -> . NAME
2492
**
trailer -> . NAME
2492
!=
trailer -> . NAME
2492
/
trailer -> . NAME
2492
&
trailer -> . NAME
2492
//
trailer -> . NAME
2492
<
trailer -> . NAME
2492
is
trailer -> . NAME
2492
-
trailer -> . NAME
2492
if
trailer -> . NAME
2492
[
trailer -> . NAME
2492
or
trailer -> . NAME
2492
>
trailer -> . NAME
2492
*
trailer -> . NAME
2492
+
trailer -> . NAME
2492
)
trailer -> . NAME
2492
%
trailer -> . NAME
2492
.
trailer -> . NAME
2492
>=
trailer -> . NAME
2492
|
trailer -> . NAME
2492
and
trailer -> . NAME
2492
(
trailer -> . NAME
2492
,
trailer -> . NAME
2492
==
trailer -> . NAME
2492
^
trailer -> . NAME
2492
in
trailer -> . NAME
2492
@
trailer -> . NAME
2492
not
trailer -> . NAME
2492
=
trailer -> . NAME
2492
>>
trailer -> . NAME
2493
%
trailer -> ( )
2493
<=
trailer -> ( )
2493
and
trailer -> ( )
2493
//
trailer -> ( )
2493
not
trailer -> ( )
2493
or
trailer -> ( )
2493
>>
trailer -> ( )
2493
>
trailer -> ( )
2493
<<
trailer -> ( )
2493
[
trailer -> ( )
2493
is
trailer -> ( )
2493
-
trailer -> ( )
2493
**
trailer -> ( )
2493
/
trailer -> ( )
2493
,
trailer -> ( )
2493
+
trailer -> ( )
2493
&
trailer -> ( )
2493
in
trailer -> ( )
2493
^
trailer -> ( )
2493
!=
trailer -> ( )
2493
*
trailer -> ( )
2493
if
trailer -> ( )
2493
>=
trailer -> ( )
2493
(
trailer -> ( )
2493
@
trailer -> ( )
2493
)
trailer -> ( )
2493
=
trailer -> ( )
2493
==
trailer -> ( )
2493
|
trailer -> ( )
2493
.
trailer -> ( )
2493
<
trailer -> ( )
2494
)
2575
2495
]
2576
2496
+
power -> atom_expr ** factor
2496
&
power -> atom_expr ** factor
2496
>>
power -> atom_expr ** factor
2496
<<
power -> atom_expr ** factor
2496
not
power -> atom_expr ** factor
2496
is
power -> atom_expr ** factor
2496
@
power -> atom_expr ** factor
2496
==
power -> atom_expr ** factor
2496
*
power -> atom_expr ** factor
2496
or
power -> atom_expr ** factor
2496
>
power -> atom_expr ** factor
2496
-
power -> atom_expr ** factor
2496
)
power -> atom_expr ** factor
2496
if
power -> atom_expr ** factor
2496
!=
power -> atom_expr ** factor
2496
>=
power -> atom_expr ** factor
2496
/
power -> atom_expr ** factor
2496
%
power -> atom_expr ** factor
2496
and
power -> atom_expr ** factor
2496
=
power -> atom_expr ** factor
2496
<=
power -> atom_expr ** factor
2496
<
power -> atom_expr ** factor
2496
|
power -> atom_expr ** factor
2496
^
power -> atom_expr ** factor
2496
in
power -> atom_expr ** factor
2496
,
power -> atom_expr ** factor
2496
//
power -> atom_expr ** factor
2497
==
and_expr -> shift_expr & and_expr
2497
in
and_expr -> shift_expr & and_expr
2497
=
and_expr -> shift_expr & and_expr
2497
!=
and_expr -> shift_expr & and_expr
2497
,
and_expr -> shift_expr & and_expr
2497
or
and_expr -> shift_expr & and_expr
2497
>
and_expr -> shift_expr & and_expr
2497
not
and_expr -> shift_expr & and_expr
2497
<=
and_expr -> shift_expr & and_expr
2497
|
and_expr -> shift_expr & and_expr
2497
and
and_expr -> shift_expr & and_expr
2497
)
and_expr -> shift_expr & and_expr
2497
^
and_expr -> shift_expr & and_expr
2497
is
and_expr -> shift_expr & and_expr
2497
>=
and_expr -> shift_expr & and_expr
2497
<
and_expr -> shift_expr & and_expr
2497
if
and_expr -> shift_expr & and_expr
2498
=
and_test -> not_test and and_test
2498
,
and_test -> not_test and and_test
2498
or
and_test -> not_test and and_test
2498
if
and_test -> not_test and and_test
2498
)
and_test -> not_test and and_test
2499
<=
xor_expr -> and_expr ^ xor_expr
2499
!=
xor_expr -> and_expr ^ xor_expr
2499
and
xor_expr -> and_expr ^ xor_expr
2499
)
xor_expr -> and_expr ^ xor_expr
2499
=
xor_expr -> and_expr ^ xor_expr
2499
is
xor_expr -> and_expr ^ xor_expr
2499
>=
xor_expr -> and_expr ^ xor_expr
2499
not
xor_expr -> and_expr ^ xor_expr
2499
<
xor_expr -> and_expr ^ xor_expr
2499
|
xor_expr -> and_expr ^ xor_expr
2499
in
xor_expr -> and_expr ^ xor_expr
2499
==
xor_expr -> and_expr ^ xor_expr
2499
or
xor_expr -> and_expr ^ xor_expr
2499
,
xor_expr -> and_expr ^ xor_expr
2499
if
xor_expr -> and_expr ^ xor_expr
2499
>
xor_expr -> and_expr ^ xor_expr
2500
)
expr -> xor_expr | expr
2500
not
expr -> xor_expr | expr
2500
,
expr -> xor_expr | expr
2500
in
expr -> xor_expr | expr
2500
if
expr -> xor_expr | expr
2500
or
expr -> xor_expr | expr
2500
<=
expr -> xor_expr | expr
2500
>
expr -> xor_expr | expr
2500
!=
expr -> xor_expr | expr
2500
==
expr -> xor_expr | expr
2500
=
expr -> xor_expr | expr
2500
>=
expr -> xor_expr | expr
2500
is
expr -> xor_expr | expr
2500
<
expr -> xor_expr | expr
2500
and
expr -> xor_expr | expr
2501
,
or_test -> and_test or or_test
2501
if
or_test -> and_test or or_test
2501
=
or_test -> and_test or or_test
2501
)
or_test -> and_test or or_test
2502
)
comparison -> expr comp_op comparison
2502
and
comparison -> expr comp_op comparison
2502
if
comparison -> expr comp_op comparison
2502
=
comparison -> expr comp_op comparison
2502
or
comparison -> expr comp_op comparison
2502
,
comparison -> expr comp_op comparison
2503
,
lambdef -> lambda : test
2503
=
lambdef -> lambda : test
2503
)
lambdef -> lambda : test
2504
factor
2043
2504
term
2044
2504
(
2045
2504
arith_expr
2046
2504
NAME
2047
2504
[
2048
2504
atom
2049
2504
+
2050
2504
power
2051
2504
atom_expr
2052
2504
NUMBER
2053
2504
STRING
2054
2504
shift_expr
2055
2504
-
2056
2504
True
2057
2504
not_test
2058
2504
and_expr
2059
2504
xor_expr
2060
2504
None
2061
2504
False
2062
2504
and_test
2063
2504
{
2064
2504
~
2065
2504
test
2577
2504
expr
2066
2504
lambda
2067
2504
comparison
2068
2504
or_test
2070
2504
lambdef
2071
2504
not
2072
2505
else
2578
2506
)
test -> or_test if or_test else test
2506
,
test -> or_test if or_test else test
2507
and
term -> factor // term
2507
if
term -> factor // term
2507
>
term -> factor // term
2507
<
term -> factor // term
2507
for
term -> factor // term
2507
==
term -> factor // term
2507
+
term -> factor // term
2507
-
term -> factor // term
2507
&
term -> factor // term
2507
in
term -> factor // term
2507
!=
term -> factor // term
2507
^
term -> factor // term
2507
)
term -> factor // term
2507
or
term -> factor // term
2507
<=
term -> factor // term
2507
>=
term -> factor // term
2507
|
term -> factor // term
2507
>>
term -> factor // term
2507
not
term -> factor // term
2507
is
term -> factor // term
2507
<<
term -> factor // term
2508
^
term -> factor * term
2508
+
term -> factor * term
2508
==
term -> factor * term
2508
>>
term -> factor * term
2508
in
term -> factor * term
2508
and
term -> factor * term
2508
if
term -> factor * term
2508
for
term -> factor * term
2508
is
term -> factor * term
2508
<<
term -> factor * term
2508
-
term -> factor * term
2508
!=
term -> factor * term
2508
or
term -> factor * term
2508
>
term -> factor * term
2508
&
term -> factor * term
2508
)
term -> factor * term
2508
>=
term -> factor * term
2508
|
term -> factor * term
2508
<=
term -> factor * term
2508
not
term -> factor * term
2508
<
term -> factor * term
2509
&
term -> factor % term
2509
==
term -> factor % term
2509
!=
term -> factor % term
2509
)
term -> factor % term
2509
<
term -> factor % term
2509
in
term -> factor % term
2509
>>
term -> factor % term
2509
<<
term -> factor % term
2509
-
term -> factor % term
2509
if
term -> factor % term
2509
>
term -> factor % term
2509
or
term -> factor % term
2509
^
term -> factor % term
2509
+
term -> factor % term
2509
is
term -> factor % term
2509
|
term -> factor % term
2509
>=
term -> factor % term
2509
<=
term -> factor % term
2509
and
term -> factor % term
2509
not
term -> factor % term
2509
for
term -> factor % term
2510
for
term -> factor @ term
2510
and
term -> factor @ term
2510
in
term -> factor @ term
2510
>=
term -> factor @ term
2510
<
term -> factor @ term
2510
>
term -> factor @ term
2510
-
term -> factor @ term
2510
or
term -> factor @ term
2510
)
term -> factor @ term
2510
<<
term -> factor @ term
2510
is
term -> factor @ term
2510
!=
term -> factor @ term
2510
|
term -> factor @ term
2510
&
term -> factor @ term
2510
==
term -> factor @ term
2510
>>
term -> factor @ term
2510
<=
term -> factor @ term
2510
not
term -> factor @ term
2510
+
term -> factor @ term
2510
^
term -> factor @ term
2510
if
term -> factor @ term
2511
or
term -> factor / term
2511
<<
term -> factor / term
2511
not
term -> factor / term
2511
in
term -> factor / term
2511
!=
term -> factor / term
2511
<
term -> factor / term
2511
+
term -> factor / term
2511
and
term -> factor / term
2511
>>
term -> factor / term
2511
^
term -> factor / term
2511
<=
term -> factor / term
2511
==
term -> factor / term
2511
>
term -> factor / term
2511
&
term -> factor / term
2511
is
term -> factor / term
2511
-
term -> factor / term
2511
for
term -> factor / term
2511
)
term -> factor / term
2511
|
term -> factor / term
2511
>=
term -> factor / term
2511
if
term -> factor / term
2512
+
atom -> ( test_list_comp )
2512
/
atom -> ( test_list_comp )
2512
*
atom -> ( test_list_comp )
2512
[
atom -> ( test_list_comp )
2512
&
atom -> ( test_list_comp )
2512
**
atom -> ( test_list_comp )
2512
^
atom -> ( test_list_comp )
2512
(
atom -> ( test_list_comp )
2512
and
atom -> ( test_list_comp )
2512
)
atom -> ( test_list_comp )
2512
>
atom -> ( test_list_comp )
2512
-
atom -> ( test_list_comp )
2512
%
atom -> ( test_list_comp )
2512
//
atom -> ( test_list_comp )
2512
in
atom -> ( test_list_comp )
2512
>>
atom -> ( test_list_comp )
2512
for
atom -> ( test_list_comp )
2512
not
atom -> ( test_list_comp )
2512
>=
atom -> ( test_list_comp )
2512
or
atom -> ( test_list_comp )
2512
<
atom -> ( test_list_comp )
2512
if
atom -> ( test_list_comp )
2512
|
atom -> ( test_list_comp )
2512
<<
atom -> ( test_list_comp )
2512
@
atom -> ( test_list_comp )
2512
!=
atom -> ( test_list_comp )
2512
is
atom -> ( test_list_comp )
2512
.
atom -> ( test_list_comp )
2512
<=
atom -> ( test_list_comp )
2512
==
atom -> ( test_list_comp )
2513
>=
shift_expr -> arith_expr >> shift_expr
2513
if
shift_expr -> arith_expr >> shift_expr
2513
<=
shift_expr -> arith_expr >> shift_expr
2513
!=
shift_expr -> arith_expr >> shift_expr
2513
or
shift_expr -> arith_expr >> shift_expr
2513
|
shift_expr -> arith_expr >> shift_expr
2513
is
shift_expr -> arith_expr >> shift_expr
2513
)
shift_expr -> arith_expr >> shift_expr
2513
and
shift_expr -> arith_expr >> shift_expr
2513
in
shift_expr -> arith_expr >> shift_expr
2513
^
shift_expr -> arith_expr >> shift_expr
2513
not
shift_expr -> arith_expr >> shift_expr
2513
<
shift_expr -> arith_expr >> shift_expr
2513
==
shift_expr -> arith_expr >> shift_expr
2513
for
shift_expr -> arith_expr >> shift_expr
2513
&
shift_expr -> arith_expr >> shift_expr
2513
>
shift_expr -> arith_expr >> shift_expr
2514
>
shift_expr -> arith_expr << shift_expr
2514
or
shift_expr -> arith_expr << shift_expr
2514
^
shift_expr -> arith_expr << shift_expr
2514
for
shift_expr -> arith_expr << shift_expr
2514
not
shift_expr -> arith_expr << shift_expr
2514
<
shift_expr -> arith_expr << shift_expr
2514
if
shift_expr -> arith_expr << shift_expr
2514
in
shift_expr -> arith_expr << shift_expr
2514
!=
shift_expr -> arith_expr << shift_expr
2514
==
shift_expr -> arith_expr << shift_expr
2514
|
shift_expr -> arith_expr << shift_expr
2514
>=
shift_expr -> arith_expr << shift_expr
2514
)
shift_expr -> arith_expr << shift_expr
2514
and
shift_expr -> arith_expr << shift_expr
2514
&
shift_expr -> arith_expr << shift_expr
2514
<=
shift_expr -> arith_expr << shift_expr
2514
is
shift_expr -> arith_expr << shift_expr
2515
in
atom -> [ test_list_comp ]
2515
/
atom -> [ test_list_comp ]
2515
or
atom -> [ test_list_comp ]
2515
if
atom -> [ test_list_comp ]
2515
<<
atom -> [ test_list_comp ]
2515
!=
atom -> [ test_list_comp ]
2515
<=
atom -> [ test_list_comp ]
2515
)
atom -> [ test_list_comp ]
2515
>>
atom -> [ test_list_comp ]
2515
*
atom -> [ test_list_comp ]
2515
^
atom -> [ test_list_comp ]
2515
.
atom -> [ test_list_comp ]
2515
(
atom -> [ test_list_comp ]
2515
>=
atom -> [ test_list_comp ]
2515
and
atom -> [ test_list_comp ]
2515
<
atom -> [ test_list_comp ]
2515
[
atom -> [ test_list_comp ]
2515
==
atom -> [ test_list_comp ]
2515
@
atom -> [ test_list_comp ]
2515
%
atom -> [ test_list_comp ]
2515
-
atom -> [ test_list_comp ]
2515
|
atom -> [ test_list_comp ]
2515
&
atom -> [ test_list_comp ]
2515
+
atom -> [ test_list_comp ]
2515
for
atom -> [ test_list_comp ]
2515
is
atom -> [ test_list_comp ]
2515
//
atom -> [ test_list_comp ]
2515
**
atom -> [ test_list_comp ]
2515
not
atom -> [ test_list_comp ]
2515
>
atom -> [ test_list_comp ]
2516
for
arith_expr -> term + arith_expr
2516
==
arith_expr -> term + arith_expr
2516
!=
arith_expr -> term + arith_expr
2516
<<
arith_expr -> term + arith_expr
2516
&
arith_expr -> term + arith_expr
2516
<
arith_expr -> term + arith_expr
2516
^
arith_expr -> term + arith_expr
2516
>=
arith_expr -> term + arith_expr
2516
in
arith_expr -> term + arith_expr
2516
)
arith_expr -> term + arith_expr
2516
>>
arith_expr -> term + arith_expr
2516
not
arith_expr -> term + arith_expr
2516
<=
arith_expr -> term + arith_expr
2516
is
arith_expr -> term + arith_expr
2516
|
arith_expr -> term + arith_expr
2516
and
arith_expr -> term + arith_expr
2516
or
arith_expr -> term + arith_expr
2516
if
arith_expr -> term + arith_expr
2516
>
arith_expr -> term + arith_expr
2517
if
arith_expr -> term - arith_expr
2517
&
arith_expr -> term - arith_expr
2517
>>
arith_expr -> term - arith_expr
2517
!=
arith_expr -> term - arith_expr
2517
)
arith_expr -> term - arith_expr
2517
>=
arith_expr -> term - arith_expr
2517
|
arith_expr -> term - arith_expr
2517
>
arith_expr -> term - arith_expr
2517
for
arith_expr -> term - arith_expr
2517
<
arith_expr -> term - arith_expr
2517
==
arith_expr -> term - arith_expr
2517
and
arith_expr -> term - arith_expr
2517
is
arith_expr -> term - arith_expr
2517
in
arith_expr -> term - arith_expr
2517
^
arith_expr -> term - arith_expr
2517
<<
arith_expr -> term - arith_expr
2517
not
arith_expr -> term - arith_expr
2517
or
arith_expr -> term - arith_expr
2517
<=
arith_expr -> term - arith_expr
2518
+
power -> atom_expr ** factor
2518
&
power -> atom_expr ** factor
2518
>>
power -> atom_expr ** factor
2518
<<
power -> atom_expr ** factor
2518
not
power -> atom_expr ** factor
2518
is
power -> atom_expr ** factor
2518
@
power -> atom_expr ** factor
2518
==
power -> atom_expr ** factor
2518
*
power -> atom_expr ** factor
2518
or
power -> atom_expr ** factor
2518
>
power -> atom_expr ** factor
2518
-
power -> atom_expr ** factor
2518
)
power -> atom_expr ** factor
2518
if
power -> atom_expr ** factor
2518
!=
power -> atom_expr ** factor
2518
>=
power -> atom_expr ** factor
2518
for
power -> atom_expr ** factor
2518
/
power -> atom_expr ** factor
2518
%
power -> atom_expr ** factor
2518
and
power -> atom_expr ** factor
2518
<=
power -> atom_expr ** factor
2518
<
power -> atom_expr ** factor
2518
|
power -> atom_expr ** factor
2518
^
power -> atom_expr ** factor
2518
in
power -> atom_expr ** factor
2518
//
power -> atom_expr ** factor
2519
+
trailer_expr -> trailer trailer_expr
2519
*
trailer_expr -> trailer trailer_expr
2519
for
trailer_expr -> trailer trailer_expr
2519
/
trailer_expr -> trailer trailer_expr
2519
not
trailer_expr -> trailer trailer_expr
2519
<<
trailer_expr -> trailer trailer_expr
2519
!=
trailer_expr -> trailer trailer_expr
2519
>=
trailer_expr -> trailer trailer_expr
2519
)
trailer_expr -> trailer trailer_expr
2519
>>
trailer_expr -> trailer trailer_expr
2519
|
trailer_expr -> trailer trailer_expr
2519
%
trailer_expr -> trailer trailer_expr
2519
>
trailer_expr -> trailer trailer_expr
2519
&
trailer_expr -> trailer trailer_expr
2519
-
trailer_expr -> trailer trailer_expr
2519
<=
trailer_expr -> trailer trailer_expr
2519
**
trailer_expr -> trailer trailer_expr
2519
@
trailer_expr -> trailer trailer_expr
2519
if
trailer_expr -> trailer trailer_expr
2519
==
trailer_expr -> trailer trailer_expr
2519
or
trailer_expr -> trailer trailer_expr
2519
<
trailer_expr -> trailer trailer_expr
2519
and
trailer_expr -> trailer trailer_expr
2519
in
trailer_expr -> trailer trailer_expr
2519
is
trailer_expr -> trailer trailer_expr
2519
^
trailer_expr -> trailer trailer_expr
2519
//
trailer_expr -> trailer trailer_expr
2520
<=
trailer -> . NAME
2520
<<
trailer -> . NAME
2520
**
trailer -> . NAME
2520
!=
trailer -> . NAME
2520
/
trailer -> . NAME
2520
&
trailer -> . NAME
2520
//
trailer -> . NAME
2520
<
trailer -> . NAME
2520
is
trailer -> . NAME
2520
-
trailer -> . NAME
2520
if
trailer -> . NAME
2520
[
trailer -> . NAME
2520
or
trailer -> . NAME
2520
>
trailer -> . NAME
2520
*
trailer -> . NAME
2520
+
trailer -> . NAME
2520
for
trailer -> . NAME
2520
)
trailer -> . NAME
2520
%
trailer -> . NAME
2520
.
trailer -> . NAME
2520
>=
trailer -> . NAME
2520
|
trailer -> . NAME
2520
and
trailer -> . NAME
2520
(
trailer -> . NAME
2520
==
trailer -> . NAME
2520
^
trailer -> . NAME
2520
in
trailer -> . NAME
2520
@
trailer -> . NAME
2520
not
trailer -> . NAME
2520
>>
trailer -> . NAME
2521
%
trailer -> ( )
2521
<=
trailer -> ( )
2521
and
trailer -> ( )
2521
//
trailer -> ( )
2521
not
trailer -> ( )
2521
or
trailer -> ( )
2521
for
trailer -> ( )
2521
>>
trailer -> ( )
2521
>
trailer -> ( )
2521
<<
trailer -> ( )
2521
[
trailer -> ( )
2521
is
trailer -> ( )
2521
-
trailer -> ( )
2521
**
trailer -> ( )
2521
/
trailer -> ( )
2521
+
trailer -> ( )
2521
&
trailer -> ( )
2521
in
trailer -> ( )
2521
^
trailer -> ( )
2521
!=
trailer -> ( )
2521
*
trailer -> ( )
2521
if
trailer -> ( )
2521
>=
trailer -> ( )
2521
(
trailer -> ( )
2521
@
trailer -> ( )
2521
)
trailer -> ( )
2521
==
trailer -> ( )
2521
|
trailer -> ( )
2521
.
trailer -> ( )
2521
<
trailer -> ( )
2522
)
2579
2523
]
2580
2524
==
and_expr -> shift_expr & and_expr
2524
in
and_expr -> shift_expr & and_expr
2524
!=
and_expr -> shift_expr & and_expr
2524
or
and_expr -> shift_expr & and_expr
2524
>
and_expr -> shift_expr & and_expr
2524
not
and_expr -> shift_expr & and_expr
2524
<=
and_expr -> shift_expr & and_expr
2524
|
and_expr -> shift_expr & and_expr
2524
and
and_expr -> shift_expr & and_expr
2524
for
and_expr -> shift_expr & and_expr
2524
)
and_expr -> shift_expr & and_expr
2524
^
and_expr -> shift_expr & and_expr
2524
is
and_expr -> shift_expr & and_expr
2524
>=
and_expr -> shift_expr & and_expr
2524
<
and_expr -> shift_expr & and_expr
2524
if
and_expr -> shift_expr & and_expr
2525
<=
xor_expr -> and_expr ^ xor_expr
2525
!=
xor_expr -> and_expr ^ xor_expr
2525
for
xor_expr -> and_expr ^ xor_expr
2525
and
xor_expr -> and_expr ^ xor_expr
2525
)
xor_expr -> and_expr ^ xor_expr
2525
is
xor_expr -> and_expr ^ xor_expr
2525
>=
xor_expr -> and_expr ^ xor_expr
2525
not
xor_expr -> and_expr ^ xor_expr
2525
<
xor_expr -> and_expr ^ xor_expr
2525
|
xor_expr -> and_expr ^ xor_expr
2525
in
xor_expr -> and_expr ^ xor_expr
2525
==
xor_expr -> and_expr ^ xor_expr
2525
or
xor_expr -> and_expr ^ xor_expr
2525
if
xor_expr -> and_expr ^ xor_expr
2525
>
xor_expr -> and_expr ^ xor_expr
2526
)
expr -> xor_expr | expr
2526
not
expr -> xor_expr | expr
2526
for
expr -> xor_expr | expr
2526
in
expr -> xor_expr | expr
2526
if
expr -> xor_expr | expr
2526
or
expr -> xor_expr | expr
2526
<=
expr -> xor_expr | expr
2526
>
expr -> xor_expr | expr
2526
!=
expr -> xor_expr | expr
2526
==
expr -> xor_expr | expr
2526
>=
expr -> xor_expr | expr
2526
is
expr -> xor_expr | expr
2526
<
expr -> xor_expr | expr
2526
and
expr -> xor_expr | expr
2527
for
and_test -> not_test and and_test
2527
)
and_test -> not_test and and_test
2527
if
and_test -> not_test and and_test
2527
or
and_test -> not_test and and_test
2528
)
comparison -> expr comp_op comparison
2528
and
comparison -> expr comp_op comparison
2528
if
comparison -> expr comp_op comparison
2528
for
comparison -> expr comp_op comparison
2528
or
comparison -> expr comp_op comparison
2529
for
or_test -> and_test or or_test
2529
if
or_test -> and_test or or_test
2529
)
or_test -> and_test or or_test
2530
NAME
305
2530
varargslist
2581
2530
:
2582
2530
vfpdef
306
2531
)
comp_iter -> 
2531
comp_for
2375
2531
if
2376
2531
comp_if
2377
2531
comp_iter
2583
2531
for
686
2532
)
test_nocond -> lambdef_nocond
2532
for
test_nocond -> lambdef_nocond
2532
if
test_nocond -> lambdef_nocond
2533
for
test_nocond -> or_test
2533
if
test_nocond -> or_test
2533
)
test_nocond -> or_test
2534
DEDENT
confbody -> NAME test NEWLINE
2534
NAME
2151
2534
confbody
2584
2535
confbody
2585
2535
NAME
2151
2536
factor
268
2536
term
270
2536
(
271
2536
arith_expr
272
2536
NAME
273
2536
[
274
2536
+
275
2536
atom_expr
277
2536
NUMBER
278
2536
atom
279
2536
STRING
280
2536
shift_expr
281
2536
-
282
2536
True
283
2536
not_test
284
2536
and_expr
286
2536
xor_expr
287
2536
False
288
2536
None
289
2536
expr
290
2536
and_test
291
2536
{
292
2536
~
293
2536
power
294
2536
lambda
2586
2536
comparison
296
2536
test_nocond
2587
2536
lambdef_nocond
2588
2536
or_test
2589
2536
not
298
2537
)
comp_iter -> comp_for
2537
,
comp_iter -> comp_for
2538
,
comp_iter -> comp_if
2538
)
comp_iter -> comp_if
2539
)
comp_for -> for expr_list in or_test comp_iter
2539
,
comp_for -> for expr_list in or_test comp_iter
2540
**
trailer -> ( arglist )
2540
if
trailer -> ( arglist )
2540
<
trailer -> ( arglist )
2540
//
trailer -> ( arglist )
2540
<<
trailer -> ( arglist )
2540
%
trailer -> ( arglist )
2540
&
trailer -> ( arglist )
2540
NEWLINE
trailer -> ( arglist )
2540
==
trailer -> ( arglist )
2540
is
trailer -> ( arglist )
2540
!=
trailer -> ( arglist )
2540
=
trailer -> ( arglist )
2540
and
trailer -> ( arglist )
2540
-
trailer -> ( arglist )
2540
+
trailer -> ( arglist )
2540
>=
trailer -> ( arglist )
2540
or
trailer -> ( arglist )
2540
(
trailer -> ( arglist )
2540
^
trailer -> ( arglist )
2540
.
trailer -> ( arglist )
2540
not
trailer -> ( arglist )
2540
>>
trailer -> ( arglist )
2540
/
trailer -> ( arglist )
2540
*
trailer -> ( arglist )
2540
[
trailer -> ( arglist )
2540
@
trailer -> ( arglist )
2540
>
trailer -> ( arglist )
2540
|
trailer -> ( arglist )
2540
<=
trailer -> ( arglist )
2540
in
trailer -> ( arglist )
2541
|
trailer -> [ subscriptlist ]
2541
not
trailer -> [ subscriptlist ]
2541
in
trailer -> [ subscriptlist ]
2541
==
trailer -> [ subscriptlist ]
2541
**
trailer -> [ subscriptlist ]
2541
>>
trailer -> [ subscriptlist ]
2541
!=
trailer -> [ subscriptlist ]
2541
*
trailer -> [ subscriptlist ]
2541
or
trailer -> [ subscriptlist ]
2541
>=
trailer -> [ subscriptlist ]
2541
/
trailer -> [ subscriptlist ]
2541
[
trailer -> [ subscriptlist ]
2541
>
trailer -> [ subscriptlist ]
2541
<
trailer -> [ subscriptlist ]
2541
.
trailer -> [ subscriptlist ]
2541
and
trailer -> [ subscriptlist ]
2541
(
trailer -> [ subscriptlist ]
2541
<=
trailer -> [ subscriptlist ]
2541
-
trailer -> [ subscriptlist ]
2541
@
trailer -> [ subscriptlist ]
2541
<<
trailer -> [ subscriptlist ]
2541
&
trailer -> [ subscriptlist ]
2541
^
trailer -> [ subscriptlist ]
2541
is
trailer -> [ subscriptlist ]
2541
%
trailer -> [ subscriptlist ]
2541
+
trailer -> [ subscriptlist ]
2541
//
trailer -> [ subscriptlist ]
2541
NEWLINE
trailer -> [ subscriptlist ]
2541
=
trailer -> [ subscriptlist ]
2541
if
trailer -> [ subscriptlist ]
2542
NEWLINE
lambdef -> lambda varargslist : test
2542
=
lambdef -> lambda varargslist : test
2543
factor
1825
2543
(
1826
2543
arith_expr
1827
2543
NAME
1828
2543
[
1829
2543
atom
1830
2543
+
1831
2543
term
1832
2543
power
1833
2543
atom_expr
1834
2543
NUMBER
1835
2543
STRING
1836
2543
shift_expr
1837
2543
-
1838
2543
True
1840
2543
and_expr
1841
2543
xor_expr
1842
2543
None
1843
2543
expr
1844
2543
False
1845
2543
and_test
1846
2543
test
2590
2543
lambda
1847
2543
~
1848
2543
not_test
1849
2543
{
1850
2543
not
1851
2543
lambdef
1852
2543
or_test
1853
2543
comparison
1854
2544
NEWLINE
elif_clause -> elif test : suite elif_clause
2544
+
elif_clause -> elif test : suite elif_clause
2544
nonlocal
elif_clause -> elif test : suite elif_clause
2544
STRING
elif_clause -> elif test : suite elif_clause
2544
lambda
elif_clause -> elif test : suite elif_clause
2544
for
elif_clause -> elif test : suite elif_clause
2544
NUMBER
elif_clause -> elif test : suite elif_clause
2544
if
elif_clause -> elif test : suite elif_clause
2544
NAME
elif_clause -> elif test : suite elif_clause
2544
resetstats
elif_clause -> elif test : suite elif_clause
2544
assert
elif_clause -> elif test : suite elif_clause
2544
raise
elif_clause -> elif test : suite elif_clause
2544
with
elif_clause -> elif test : suite elif_clause
2544
conf
elif_clause -> elif test : suite elif_clause
2544
(
elif_clause -> elif test : suite elif_clause
2544
def
elif_clause -> elif test : suite elif_clause
2544
pass
elif_clause -> elif test : suite elif_clause
2544
return
elif_clause -> elif test : suite elif_clause
2544
-
elif_clause -> elif test : suite elif_clause
2544
class
elif_clause -> elif test : suite elif_clause
2544
not
elif_clause -> elif test : suite elif_clause
2544
[
elif_clause -> elif test : suite elif_clause
2544
False
elif_clause -> elif test : suite elif_clause
2544
endsim
elif_clause -> elif test : suite elif_clause
2544
while
elif_clause -> elif test : suite elif_clause
2544
del
elif_clause -> elif test : suite elif_clause
2544
continue
elif_clause -> elif test : suite elif_clause
2544
break
elif_clause -> elif test : suite elif_clause
2544
yield
elif_clause -> elif test : suite elif_clause
2544
{
elif_clause -> elif test : suite elif_clause
2544
@
elif_clause -> elif test : suite elif_clause
2544
try
elif_clause -> elif test : suite elif_clause
2544
global
elif_clause -> elif test : suite elif_clause
2544
else
elif_clause -> elif test : suite elif_clause
2544
~
elif_clause -> elif test : suite elif_clause
2544
True
elif_clause -> elif test : suite elif_clause
2544
begsim
elif_clause -> elif test : suite elif_clause
2544
$
elif_clause -> elif test : suite elif_clause
2544
None
elif_clause -> elif test : suite elif_clause
2545
for
trailer -> ( arglist )
2545
**
trailer -> ( arglist )
2545
if
trailer -> ( arglist )
2545
<
trailer -> ( arglist )
2545
//
trailer -> ( arglist )
2545
<<
trailer -> ( arglist )
2545
%
trailer -> ( arglist )
2545
&
trailer -> ( arglist )
2545
==
trailer -> ( arglist )
2545
is
trailer -> ( arglist )
2545
!=
trailer -> ( arglist )
2545
]
trailer -> ( arglist )
2545
and
trailer -> ( arglist )
2545
-
trailer -> ( arglist )
2545
+
trailer -> ( arglist )
2545
>=
trailer -> ( arglist )
2545
or
trailer -> ( arglist )
2545
(
trailer -> ( arglist )
2545
^
trailer -> ( arglist )
2545
.
trailer -> ( arglist )
2545
not
trailer -> ( arglist )
2545
>>
trailer -> ( arglist )
2545
/
trailer -> ( arglist )
2545
*
trailer -> ( arglist )
2545
[
trailer -> ( arglist )
2545
@
trailer -> ( arglist )
2545
>
trailer -> ( arglist )
2545
|
trailer -> ( arglist )
2545
<=
trailer -> ( arglist )
2545
in
trailer -> ( arglist )
2546
|
trailer -> [ subscriptlist ]
2546
not
trailer -> [ subscriptlist ]
2546
in
trailer -> [ subscriptlist ]
2546
==
trailer -> [ subscriptlist ]
2546
**
trailer -> [ subscriptlist ]
2546
>>
trailer -> [ subscriptlist ]
2546
!=
trailer -> [ subscriptlist ]
2546
*
trailer -> [ subscriptlist ]
2546
or
trailer -> [ subscriptlist ]
2546
>=
trailer -> [ subscriptlist ]
2546
/
trailer -> [ subscriptlist ]
2546
for
trailer -> [ subscriptlist ]
2546
[
trailer -> [ subscriptlist ]
2546
]
trailer -> [ subscriptlist ]
2546
>
trailer -> [ subscriptlist ]
2546
<
trailer -> [ subscriptlist ]
2546
.
trailer -> [ subscriptlist ]
2546
and
trailer -> [ subscriptlist ]
2546
(
trailer -> [ subscriptlist ]
2546
<=
trailer -> [ subscriptlist ]
2546
-
trailer -> [ subscriptlist ]
2546
@
trailer -> [ subscriptlist ]
2546
<<
trailer -> [ subscriptlist ]
2546
&
trailer -> [ subscriptlist ]
2546
^
trailer -> [ subscriptlist ]
2546
is
trailer -> [ subscriptlist ]
2546
%
trailer -> [ subscriptlist ]
2546
+
trailer -> [ subscriptlist ]
2546
//
trailer -> [ subscriptlist ]
2546
if
trailer -> [ subscriptlist ]
2547
factor
1898
2547
(
1899
2547
arith_expr
1900
2547
NAME
1901
2547
[
1902
2547
+
1903
2547
term
1904
2547
atom_expr
1905
2547
NUMBER
1906
2547
atom
1907
2547
STRING
1908
2547
shift_expr
1909
2547
-
1910
2547
True
1911
2547
and_expr
1912
2547
xor_expr
1913
2547
False
1914
2547
not_test
1915
2547
None
1916
2547
expr
1917
2547
and_test
1918
2547
{
1919
2547
~
1920
2547
power
1921
2547
lambda
2442
2547
comparison
1922
2547
lambdef_nocond
2443
2547
or_test
2444
2547
test_nocond
2591
2547
not
1923
2548
:
2592
2549
]
comp_if -> if test_nocond comp_iter
2550
factor
9
2550
arith_expr
2
2550
NAME
29
2550
term
21
2550
[
3
2550
~
45
2550
suite
2593
2550
atom_expr
24
2550
expr
16
2550
power
56
2550
(
36
2550
return
13
2550
small_stmt
47
2550
flow_stmt
15
2550
True
17
2550
not_test
18
2550
and_expr
19
2550
xor_expr
22
2550
{
52
2550
lambdef
53
2550
atom
54
2550
or_test
23
2550
shift_expr
50
2550
False
35
2550
NEWLINE
1022
2550
-
49
2550
None
42
2550
lambda
40
2550
global
25
2550
NUMBER
27
2550
STRING
28
2550
test
48
2550
endsim
33
2550
and_test
37
2550
simple_stmt
1023
2550
comparison
39
2550
break_stmt
74
2550
+
55
2550
not
57
2550
raise
62
2550
continue
59
2550
return_stmt
75
2550
del_stmt
60
2550
test_list
61
2550
raise_stmt
63
2550
resetstats
64
2550
pass_stmt
65
2550
nonlocal
66
2550
break
76
2550
sim_stmt
77
2550
stat_stmt
78
2550
global_stmt
67
2550
yield_stmt
79
2550
assert_stmt
80
2550
pass
81
2550
yield
68
2550
continue_stmt
69
2550
assert
70
2550
nonlocal_stmt
71
2550
expr_stmt
72
2550
begsim
83
2550
del
84
2551
DEDENT
2594
2552
except
1016
2552
maybe_except_clause
2595
2552
except_clause
2279
2552
global
maybe_except_clause -> 
2552
resetstats
maybe_except_clause -> 
2552
class
maybe_except_clause -> 
2552
def
maybe_except_clause -> 
2552
NAME
maybe_except_clause -> 
2552
NUMBER
maybe_except_clause -> 
2552
lambda
maybe_except_clause -> 
2552
True
maybe_except_clause -> 
2552
else
maybe_except_clause -> 
2552
not
maybe_except_clause -> 
2552
$
maybe_except_clause -> 
2552
-
maybe_except_clause -> 
2552
NEWLINE
maybe_except_clause -> 
2552
~
maybe_except_clause -> 
2552
del
maybe_except_clause -> 
2552
with
maybe_except_clause -> 
2552
pass
maybe_except_clause -> 
2552
if
maybe_except_clause -> 
2552
assert
maybe_except_clause -> 
2552
conf
maybe_except_clause -> 
2552
break
maybe_except_clause -> 
2552
try
maybe_except_clause -> 
2552
while
maybe_except_clause -> 
2552
False
maybe_except_clause -> 
2552
(
maybe_except_clause -> 
2552
None
maybe_except_clause -> 
2552
return
maybe_except_clause -> 
2552
nonlocal
maybe_except_clause -> 
2552
@
maybe_except_clause -> 
2552
yield
maybe_except_clause -> 
2552
finally
maybe_except_clause -> 
2552
{
maybe_except_clause -> 
2552
endsim
maybe_except_clause -> 
2552
for
maybe_except_clause -> 
2552
raise
maybe_except_clause -> 
2552
[
maybe_except_clause -> 
2552
STRING
maybe_except_clause -> 
2552
begsim
maybe_except_clause -> 
2552
+
maybe_except_clause -> 
2552
continue
maybe_except_clause -> 
2553
not
suite -> NEWLINE INDENT stmt_list DEDENT
2553
None
suite -> NEWLINE INDENT stmt_list DEDENT
2553
{
suite -> NEWLINE INDENT stmt_list DEDENT
2553
for
suite -> NEWLINE INDENT stmt_list DEDENT
2553
finally
suite -> NEWLINE INDENT stmt_list DEDENT
2553
try
suite -> NEWLINE INDENT stmt_list DEDENT
2553
class
suite -> NEWLINE INDENT stmt_list DEDENT
2553
while
suite -> NEWLINE INDENT stmt_list DEDENT
2553
NEWLINE
suite -> NEWLINE INDENT stmt_list DEDENT
2553
-
suite -> NEWLINE INDENT stmt_list DEDENT
2553
if
suite -> NEWLINE INDENT stmt_list DEDENT
2553
+
suite -> NEWLINE INDENT stmt_list DEDENT
2553
resetstats
suite -> NEWLINE INDENT stmt_list DEDENT
2553
return
suite -> NEWLINE INDENT stmt_list DEDENT
2553
with
suite -> NEWLINE INDENT stmt_list DEDENT
2553
else
suite -> NEWLINE INDENT stmt_list DEDENT
2553
except
suite -> NEWLINE INDENT stmt_list DEDENT
2553
STRING
suite -> NEWLINE INDENT stmt_list DEDENT
2553
conf
suite -> NEWLINE INDENT stmt_list DEDENT
2553
assert
suite -> NEWLINE INDENT stmt_list DEDENT
2553
def
suite -> NEWLINE INDENT stmt_list DEDENT
2553
NAME
suite -> NEWLINE INDENT stmt_list DEDENT
2553
~
suite -> NEWLINE INDENT stmt_list DEDENT
2553
yield
suite -> NEWLINE INDENT stmt_list DEDENT
2553
NUMBER
suite -> NEWLINE INDENT stmt_list DEDENT
2553
del
suite -> NEWLINE INDENT stmt_list DEDENT
2553
$
suite -> NEWLINE INDENT stmt_list DEDENT
2553
True
suite -> NEWLINE INDENT stmt_list DEDENT
2553
break
suite -> NEWLINE INDENT stmt_list DEDENT
2553
pass
suite -> NEWLINE INDENT stmt_list DEDENT
2553
endsim
suite -> NEWLINE INDENT stmt_list DEDENT
2553
continue
suite -> NEWLINE INDENT stmt_list DEDENT
2553
[
suite -> NEWLINE INDENT stmt_list DEDENT
2553
begsim
suite -> NEWLINE INDENT stmt_list DEDENT
2553
lambda
suite -> NEWLINE INDENT stmt_list DEDENT
2553
global
suite -> NEWLINE INDENT stmt_list DEDENT
2553
@
suite -> NEWLINE INDENT stmt_list DEDENT
2553
False
suite -> NEWLINE INDENT stmt_list DEDENT
2553
raise
suite -> NEWLINE INDENT stmt_list DEDENT
2553
(
suite -> NEWLINE INDENT stmt_list DEDENT
2553
nonlocal
suite -> NEWLINE INDENT stmt_list DEDENT
2554
as
test -> or_test if or_test else test
2554
:
test -> or_test if or_test else test
2555
nonlocal
simple_stmt -> small_stmt NEWLINE
2555
True
simple_stmt -> small_stmt NEWLINE
2555
False
simple_stmt -> small_stmt NEWLINE
2555
(
simple_stmt -> small_stmt NEWLINE
2555
continue
simple_stmt -> small_stmt NEWLINE
2555
begsim
simple_stmt -> small_stmt NEWLINE
2555
NAME
simple_stmt -> small_stmt NEWLINE
2555
endsim
simple_stmt -> small_stmt NEWLINE
2555
DEDENT
simple_stmt -> small_stmt NEWLINE
2555
break
simple_stmt -> small_stmt NEWLINE
2555
return
simple_stmt -> small_stmt NEWLINE
2555
NUMBER
simple_stmt -> small_stmt NEWLINE
2555
[
simple_stmt -> small_stmt NEWLINE
2555
global
simple_stmt -> small_stmt NEWLINE
2555
resetstats
simple_stmt -> small_stmt NEWLINE
2555
yield
simple_stmt -> small_stmt NEWLINE
2555
conf
simple_stmt -> small_stmt NEWLINE
2555
lambda
simple_stmt -> small_stmt NEWLINE
2555
not
simple_stmt -> small_stmt NEWLINE
2555
del
simple_stmt -> small_stmt NEWLINE
2555
pass
simple_stmt -> small_stmt NEWLINE
2555
for
simple_stmt -> small_stmt NEWLINE
2555
@
simple_stmt -> small_stmt NEWLINE
2555
with
simple_stmt -> small_stmt NEWLINE
2555
class
simple_stmt -> small_stmt NEWLINE
2555
if
simple_stmt -> small_stmt NEWLINE
2555
assert
simple_stmt -> small_stmt NEWLINE
2555
None
simple_stmt -> small_stmt NEWLINE
2555
else
simple_stmt -> small_stmt NEWLINE
2555
+
simple_stmt -> small_stmt NEWLINE
2555
-
simple_stmt -> small_stmt NEWLINE
2555
STRING
simple_stmt -> small_stmt NEWLINE
2555
while
simple_stmt -> small_stmt NEWLINE
2555
{
simple_stmt -> small_stmt NEWLINE
2555
raise
simple_stmt -> small_stmt NEWLINE
2555
~
simple_stmt -> small_stmt NEWLINE
2555
elif
simple_stmt -> small_stmt NEWLINE
2555
def
simple_stmt -> small_stmt NEWLINE
2555
try
simple_stmt -> small_stmt NEWLINE
2556
factor
85
2556
(
86
2556
arith_expr
87
2556
NAME
88
2556
term
89
2556
[
90
2556
~
91
2556
test
2596
2556
+
92
2556
expr
93
2556
atom_expr
94
2556
atom
95
2556
NUMBER
96
2556
STRING
97
2556
shift_expr
99
2556
-
100
2556
True
101
2556
and_expr
102
2556
xor_expr
103
2556
False
104
2556
{
105
2556
None
106
2556
and_test
107
2556
power
108
2556
not_test
109
2556
lambdef
110
2556
or_test
111
2556
comparison
112
2556
not
113
2556
lambda
114
2557
else
2597
2557
pass
if_stmt -> if test : suite elif_clause
2557
lambda
if_stmt -> if test : suite elif_clause
2557
True
if_stmt -> if test : suite elif_clause
2557
begsim
if_stmt -> if test : suite elif_clause
2557
~
if_stmt -> if test : suite elif_clause
2557
assert
if_stmt -> if test : suite elif_clause
2557
raise
if_stmt -> if test : suite elif_clause
2557
nonlocal
if_stmt -> if test : suite elif_clause
2557
{
if_stmt -> if test : suite elif_clause
2557
with
if_stmt -> if test : suite elif_clause
2557
conf
if_stmt -> if test : suite elif_clause
2557
while
if_stmt -> if test : suite elif_clause
2557
yield
if_stmt -> if test : suite elif_clause
2557
return
if_stmt -> if test : suite elif_clause
2557
continue
if_stmt -> if test : suite elif_clause
2557
if
if_stmt -> if test : suite elif_clause
2557
NAME
if_stmt -> if test : suite elif_clause
2557
for
if_stmt -> if test : suite elif_clause
2557
del
if_stmt -> if test : suite elif_clause
2557
STRING
if_stmt -> if test : suite elif_clause
2557
+
if_stmt -> if test : suite elif_clause
2557
def
if_stmt -> if test : suite elif_clause
2557
break
if_stmt -> if test : suite elif_clause
2557
global
if_stmt -> if test : suite elif_clause
2557
None
if_stmt -> if test : suite elif_clause
2557
resetstats
if_stmt -> if test : suite elif_clause
2557
class
if_stmt -> if test : suite elif_clause
2557
@
if_stmt -> if test : suite elif_clause
2557
False
if_stmt -> if test : suite elif_clause
2557
endsim
if_stmt -> if test : suite elif_clause
2557
DEDENT
if_stmt -> if test : suite elif_clause
2557
-
if_stmt -> if test : suite elif_clause
2557
[
if_stmt -> if test : suite elif_clause
2557
try
if_stmt -> if test : suite elif_clause
2557
not
if_stmt -> if test : suite elif_clause
2557
NUMBER
if_stmt -> if test : suite elif_clause
2557
(
if_stmt -> if test : suite elif_clause
2558
if
1566
2558
arith_expr
2
2558
try
1567
2558
[
3
2558
class
1568
2558
for
1569
2558
stmt_list
2598
2558
with_stmt
1570
2558
while_stmt
1571
2558
factor
9
2558
@
10
2558
simple_stmt
1572
2558
decorators
1573
2558
return
13
2558
confdef
1574
2558
flow_stmt
15
2558
expr
16
2558
True
17
2558
not_test
18
2558
and_expr
19
2558
def
1575
2558
term
21
2558
xor_expr
22
2558
or_test
23
2558
atom_expr
24
2558
global
25
2558
for_stmt
1576
2558
NUMBER
27
2558
STRING
28
2558
NAME
29
2558
decorator
30
2558
if_stmt
1577
2558
with
1578
2558
endsim
33
2558
classdef
1579
2558
False
35
2558
(
36
2558
and_test
37
2558
conf
1580
2558
comparison
39
2558
lambda
40
2558
while
1581
2558
None
42
2558
try_stmt
1582
2558
funcdef
1583
2558
~
45
2558
decorated
1584
2558
small_stmt
1585
2558
test
48
2558
-
49
2558
shift_expr
50
2558
{
52
2558
lambdef
53
2558
atom
54
2558
+
55
2558
power
56
2558
not
57
2558
compound_stmt
1587
2558
continue
59
2558
del_stmt
60
2558
test_list
61
2558
raise
62
2558
raise_stmt
63
2558
resetstats
64
2558
pass_stmt
65
2558
stmt
1588
2558
nonlocal
66
2558
global_stmt
67
2558
yield
68
2558
continue_stmt
69
2558
assert
70
2558
nonlocal_stmt
71
2558
expr_stmt
72
2558
break_stmt
74
2558
return_stmt
75
2558
break
76
2558
sim_stmt
77
2558
stat_stmt
78
2558
yield_stmt
79
2558
assert_stmt
80
2558
pass
81
2558
begsim
83
2558
del
84
2559
:
2599
2560
:
2600
2561
as
2601
2561
:
2602
2562
factor
9
2562
arith_expr
2
2562
NAME
29
2562
term
21
2562
[
3
2562
~
45
2562
suite
2603
2562
atom_expr
24
2562
expr
16
2562
power
56
2562
(
36
2562
return
13
2562
small_stmt
2604
2562
flow_stmt
15
2562
True
17
2562
not_test
18
2562
and_expr
19
2562
xor_expr
22
2562
{
52
2562
lambdef
53
2562
atom
54
2562
or_test
23
2562
shift_expr
50
2562
False
35
2562
NEWLINE
2605
2562
-
49
2562
None
42
2562
lambda
40
2562
global
25
2562
NUMBER
27
2562
STRING
28
2562
test
48
2562
endsim
33
2562
and_test
37
2562
simple_stmt
2606
2562
comparison
39
2562
break_stmt
74
2562
+
55
2562
not
57
2562
raise
62
2562
continue
59
2562
return_stmt
75
2562
del_stmt
60
2562
test_list
61
2562
raise_stmt
63
2562
resetstats
64
2562
pass_stmt
65
2562
nonlocal
66
2562
break
76
2562
sim_stmt
77
2562
stat_stmt
78
2562
global_stmt
67
2562
yield_stmt
79
2562
assert_stmt
80
2562
pass
81
2562
yield
68
2562
continue_stmt
69
2562
assert
70
2562
nonlocal_stmt
71
2562
expr_stmt
72
2562
begsim
83
2562
del
84
2563
:
2607
2564
factor
9
2564
arith_expr
2
2564
NAME
29
2564
term
21
2564
[
3
2564
~
45
2564
atom_expr
24
2564
expr
16
2564
power
56
2564
(
36
2564
return
13
2564
small_stmt
1585
2564
flow_stmt
15
2564
True
17
2564
not_test
18
2564
and_expr
19
2564
xor_expr
22
2564
{
52
2564
lambdef
53
2564
atom
54
2564
or_test
23
2564
shift_expr
50
2564
False
35
2564
NEWLINE
2466
2564
-
49
2564
None
42
2564
lambda
40
2564
global
25
2564
NUMBER
27
2564
STRING
28
2564
test
48
2564
endsim
33
2564
and_test
37
2564
simple_stmt
2467
2564
comparison
39
2564
suite
2608
2564
break_stmt
74
2564
+
55
2564
not
57
2564
raise
62
2564
continue
59
2564
return_stmt
75
2564
del_stmt
60
2564
test_list
61
2564
raise_stmt
63
2564
resetstats
64
2564
pass_stmt
65
2564
nonlocal
66
2564
break
76
2564
sim_stmt
77
2564
stat_stmt
78
2564
global_stmt
67
2564
yield_stmt
79
2564
assert_stmt
80
2564
pass
81
2564
yield
68
2564
continue_stmt
69
2564
assert
70
2564
nonlocal_stmt
71
2564
expr_stmt
72
2564
begsim
83
2564
del
84
2565
if
1566
2565
arith_expr
2
2565
try
1567
2565
[
3
2565
class
1568
2565
for
1569
2565
stmt_list
2609
2565
with_stmt
1570
2565
while_stmt
1571
2565
factor
9
2565
@
10
2565
simple_stmt
1572
2565
decorators
1573
2565
return
13
2565
confdef
1574
2565
flow_stmt
15
2565
expr
16
2565
True
17
2565
not_test
18
2565
and_expr
19
2565
def
1575
2565
term
21
2565
xor_expr
22
2565
or_test
23
2565
atom_expr
24
2565
global
25
2565
for_stmt
1576
2565
NUMBER
27
2565
STRING
28
2565
NAME
29
2565
decorator
30
2565
if_stmt
1577
2565
with
1578
2565
endsim
33
2565
classdef
1579
2565
False
35
2565
(
36
2565
and_test
37
2565
conf
1580
2565
comparison
39
2565
lambda
40
2565
while
1581
2565
None
42
2565
try_stmt
1582
2565
funcdef
1583
2565
~
45
2565
decorated
1584
2565
small_stmt
1585
2565
test
48
2565
-
49
2565
shift_expr
50
2565
{
52
2565
lambdef
53
2565
atom
54
2565
+
55
2565
power
56
2565
not
57
2565
compound_stmt
1587
2565
continue
59
2565
del_stmt
60
2565
test_list
61
2565
raise
62
2565
raise_stmt
63
2565
resetstats
64
2565
pass_stmt
65
2565
stmt
1588
2565
nonlocal
66
2565
global_stmt
67
2565
yield
68
2565
continue_stmt
69
2565
assert
70
2565
nonlocal_stmt
71
2565
expr_stmt
72
2565
break_stmt
74
2565
return_stmt
75
2565
break
76
2565
sim_stmt
77
2565
stat_stmt
78
2565
yield_stmt
79
2565
assert_stmt
80
2565
pass
81
2565
begsim
83
2565
del
84
2566
factor
9
2566
arith_expr
2
2566
NAME
29
2566
suite
2610
2566
term
21
2566
[
3
2566
~
45
2566
atom_expr
24
2566
expr
16
2566
power
56
2566
(
36
2566
return
13
2566
small_stmt
2475
2566
flow_stmt
15
2566
True
17
2566
not_test
18
2566
and_expr
19
2566
xor_expr
22
2566
{
52
2566
lambdef
53
2566
atom
54
2566
or_test
23
2566
shift_expr
50
2566
False
35
2566
NEWLINE
2476
2566
-
49
2566
lambda
40
2566
None
42
2566
global
25
2566
NUMBER
27
2566
STRING
28
2566
test
48
2566
endsim
33
2566
and_test
37
2566
simple_stmt
2477
2566
comparison
39
2566
break_stmt
74
2566
+
55
2566
not
57
2566
raise
62
2566
continue
59
2566
return_stmt
75
2566
del_stmt
60
2566
test_list
61
2566
raise_stmt
63
2566
resetstats
64
2566
pass_stmt
65
2566
nonlocal
66
2566
break
76
2566
sim_stmt
77
2566
stat_stmt
78
2566
global_stmt
67
2566
yield_stmt
79
2566
assert_stmt
80
2566
pass
81
2566
yield
68
2566
continue_stmt
69
2566
assert
70
2566
nonlocal_stmt
71
2566
expr_stmt
72
2566
begsim
83
2566
del
84
2567
factor
9
2567
arith_expr
2
2567
NAME
29
2567
term
21
2567
[
3
2567
~
45
2567
atom_expr
24
2567
expr
16
2567
power
56
2567
(
36
2567
return
13
2567
small_stmt
1585
2567
flow_stmt
15
2567
True
17
2567
not_test
18
2567
and_expr
19
2567
xor_expr
22
2567
{
52
2567
lambdef
53
2567
atom
54
2567
or_test
23
2567
shift_expr
50
2567
False
35
2567
suite
2611
2567
NEWLINE
2466
2567
-
49
2567
None
42
2567
lambda
40
2567
global
25
2567
NUMBER
27
2567
STRING
28
2567
test
48
2567
endsim
33
2567
and_test
37
2567
simple_stmt
2467
2567
comparison
39
2567
break_stmt
74
2567
+
55
2567
not
57
2567
raise
62
2567
continue
59
2567
return_stmt
75
2567
del_stmt
60
2567
test_list
61
2567
raise_stmt
63
2567
resetstats
64
2567
pass_stmt
65
2567
nonlocal
66
2567
break
76
2567
sim_stmt
77
2567
stat_stmt
78
2567
global_stmt
67
2567
yield_stmt
79
2567
assert_stmt
80
2567
pass
81
2567
yield
68
2567
continue_stmt
69
2567
assert
70
2567
nonlocal_stmt
71
2567
expr_stmt
72
2567
begsim
83
2567
del
84
2568
:
2612
2569
confbody
2613
2569
NAME
2151
2570
:
2614
2571
:
2615
2572
nonlocal
simple_stmt -> small_stmt NEWLINE
2572
True
simple_stmt -> small_stmt NEWLINE
2572
False
simple_stmt -> small_stmt NEWLINE
2572
(
simple_stmt -> small_stmt NEWLINE
2572
continue
simple_stmt -> small_stmt NEWLINE
2572
begsim
simple_stmt -> small_stmt NEWLINE
2572
NAME
simple_stmt -> small_stmt NEWLINE
2572
endsim
simple_stmt -> small_stmt NEWLINE
2572
DEDENT
simple_stmt -> small_stmt NEWLINE
2572
break
simple_stmt -> small_stmt NEWLINE
2572
return
simple_stmt -> small_stmt NEWLINE
2572
NUMBER
simple_stmt -> small_stmt NEWLINE
2572
[
simple_stmt -> small_stmt NEWLINE
2572
global
simple_stmt -> small_stmt NEWLINE
2572
resetstats
simple_stmt -> small_stmt NEWLINE
2572
yield
simple_stmt -> small_stmt NEWLINE
2572
conf
simple_stmt -> small_stmt NEWLINE
2572
lambda
simple_stmt -> small_stmt NEWLINE
2572
not
simple_stmt -> small_stmt NEWLINE
2572
del
simple_stmt -> small_stmt NEWLINE
2572
pass
simple_stmt -> small_stmt NEWLINE
2572
for
simple_stmt -> small_stmt NEWLINE
2572
@
simple_stmt -> small_stmt NEWLINE
2572
with
simple_stmt -> small_stmt NEWLINE
2572
class
simple_stmt -> small_stmt NEWLINE
2572
if
simple_stmt -> small_stmt NEWLINE
2572
assert
simple_stmt -> small_stmt NEWLINE
2572
None
simple_stmt -> small_stmt NEWLINE
2572
else
simple_stmt -> small_stmt NEWLINE
2572
+
simple_stmt -> small_stmt NEWLINE
2572
-
simple_stmt -> small_stmt NEWLINE
2572
STRING
simple_stmt -> small_stmt NEWLINE
2572
while
simple_stmt -> small_stmt NEWLINE
2572
{
simple_stmt -> small_stmt NEWLINE
2572
raise
simple_stmt -> small_stmt NEWLINE
2572
~
simple_stmt -> small_stmt NEWLINE
2572
def
simple_stmt -> small_stmt NEWLINE
2572
try
simple_stmt -> small_stmt NEWLINE
2573
if
1566
2573
arith_expr
2
2573
try
1567
2573
[
3
2573
class
1568
2573
for
1569
2573
stmt_list
2616
2573
with_stmt
1570
2573
while_stmt
1571
2573
factor
9
2573
@
10
2573
simple_stmt
1572
2573
decorators
1573
2573
return
13
2573
confdef
1574
2573
flow_stmt
15
2573
expr
16
2573
True
17
2573
not_test
18
2573
and_expr
19
2573
def
1575
2573
term
21
2573
xor_expr
22
2573
or_test
23
2573
atom_expr
24
2573
global
25
2573
for_stmt
1576
2573
NUMBER
27
2573
STRING
28
2573
NAME
29
2573
decorator
30
2573
if_stmt
1577
2573
with
1578
2573
endsim
33
2573
classdef
1579
2573
False
35
2573
(
36
2573
and_test
37
2573
conf
1580
2573
comparison
39
2573
lambda
40
2573
while
1581
2573
None
42
2573
try_stmt
1582
2573
funcdef
1583
2573
~
45
2573
decorated
1584
2573
small_stmt
1585
2573
test
48
2573
-
49
2573
shift_expr
50
2573
{
52
2573
lambdef
53
2573
atom
54
2573
+
55
2573
power
56
2573
not
57
2573
compound_stmt
1587
2573
continue
59
2573
del_stmt
60
2573
test_list
61
2573
raise
62
2573
raise_stmt
63
2573
resetstats
64
2573
pass_stmt
65
2573
stmt
1588
2573
nonlocal
66
2573
global_stmt
67
2573
yield
68
2573
continue_stmt
69
2573
assert
70
2573
nonlocal_stmt
71
2573
expr_stmt
72
2573
break_stmt
74
2573
return_stmt
75
2573
break
76
2573
sim_stmt
77
2573
stat_stmt
78
2573
yield_stmt
79
2573
assert_stmt
80
2573
pass
81
2573
begsim
83
2573
del
84
2574
while
for_stmt -> for expr_list in test_list : suite else : suite
2574
lambda
for_stmt -> for expr_list in test_list : suite else : suite
2574
return
for_stmt -> for expr_list in test_list : suite else : suite
2574
[
for_stmt -> for expr_list in test_list : suite else : suite
2574
nonlocal
for_stmt -> for expr_list in test_list : suite else : suite
2574
assert
for_stmt -> for expr_list in test_list : suite else : suite
2574
$
for_stmt -> for expr_list in test_list : suite else : suite
2574
with
for_stmt -> for expr_list in test_list : suite else : suite
2574
~
for_stmt -> for expr_list in test_list : suite else : suite
2574
STRING
for_stmt -> for expr_list in test_list : suite else : suite
2574
endsim
for_stmt -> for expr_list in test_list : suite else : suite
2574
try
for_stmt -> for expr_list in test_list : suite else : suite
2574
None
for_stmt -> for expr_list in test_list : suite else : suite
2574
not
for_stmt -> for expr_list in test_list : suite else : suite
2574
True
for_stmt -> for expr_list in test_list : suite else : suite
2574
continue
for_stmt -> for expr_list in test_list : suite else : suite
2574
+
for_stmt -> for expr_list in test_list : suite else : suite
2574
begsim
for_stmt -> for expr_list in test_list : suite else : suite
2574
del
for_stmt -> for expr_list in test_list : suite else : suite
2574
break
for_stmt -> for expr_list in test_list : suite else : suite
2574
-
for_stmt -> for expr_list in test_list : suite else : suite
2574
class
for_stmt -> for expr_list in test_list : suite else : suite
2574
pass
for_stmt -> for expr_list in test_list : suite else : suite
2574
@
for_stmt -> for expr_list in test_list : suite else : suite
2574
raise
for_stmt -> for expr_list in test_list : suite else : suite
2574
{
for_stmt -> for expr_list in test_list : suite else : suite
2574
NUMBER
for_stmt -> for expr_list in test_list : suite else : suite
2574
for
for_stmt -> for expr_list in test_list : suite else : suite
2574
def
for_stmt -> for expr_list in test_list : suite else : suite
2574
NEWLINE
for_stmt -> for expr_list in test_list : suite else : suite
2574
global
for_stmt -> for expr_list in test_list : suite else : suite
2574
resetstats
for_stmt -> for expr_list in test_list : suite else : suite
2574
yield
for_stmt -> for expr_list in test_list : suite else : suite
2574
False
for_stmt -> for expr_list in test_list : suite else : suite
2574
(
for_stmt -> for expr_list in test_list : suite else : suite
2574
if
for_stmt -> for expr_list in test_list : suite else : suite
2574
NAME
for_stmt -> for expr_list in test_list : suite else : suite
2574
conf
for_stmt -> for expr_list in test_list : suite else : suite
2575
**
trailer -> ( arglist )
2575
if
trailer -> ( arglist )
2575
<
trailer -> ( arglist )
2575
//
trailer -> ( arglist )
2575
<<
trailer -> ( arglist )
2575
%
trailer -> ( arglist )
2575
)
trailer -> ( arglist )
2575
&
trailer -> ( arglist )
2575
==
trailer -> ( arglist )
2575
is
trailer -> ( arglist )
2575
,
trailer -> ( arglist )
2575
!=
trailer -> ( arglist )
2575
=
trailer -> ( arglist )
2575
and
trailer -> ( arglist )
2575
-
trailer -> ( arglist )
2575
+
trailer -> ( arglist )
2575
>=
trailer -> ( arglist )
2575
or
trailer -> ( arglist )
2575
(
trailer -> ( arglist )
2575
^
trailer -> ( arglist )
2575
.
trailer -> ( arglist )
2575
not
trailer -> ( arglist )
2575
>>
trailer -> ( arglist )
2575
/
trailer -> ( arglist )
2575
*
trailer -> ( arglist )
2575
[
trailer -> ( arglist )
2575
@
trailer -> ( arglist )
2575
>
trailer -> ( arglist )
2575
|
trailer -> ( arglist )
2575
<=
trailer -> ( arglist )
2575
in
trailer -> ( arglist )
2576
|
trailer -> [ subscriptlist ]
2576
not
trailer -> [ subscriptlist ]
2576
in
trailer -> [ subscriptlist ]
2576
==
trailer -> [ subscriptlist ]
2576
**
trailer -> [ subscriptlist ]
2576
>>
trailer -> [ subscriptlist ]
2576
!=
trailer -> [ subscriptlist ]
2576
*
trailer -> [ subscriptlist ]
2576
or
trailer -> [ subscriptlist ]
2576
>=
trailer -> [ subscriptlist ]
2576
/
trailer -> [ subscriptlist ]
2576
[
trailer -> [ subscriptlist ]
2576
>
trailer -> [ subscriptlist ]
2576
<
trailer -> [ subscriptlist ]
2576
.
trailer -> [ subscriptlist ]
2576
and
trailer -> [ subscriptlist ]
2576
(
trailer -> [ subscriptlist ]
2576
<=
trailer -> [ subscriptlist ]
2576
-
trailer -> [ subscriptlist ]
2576
@
trailer -> [ subscriptlist ]
2576
<<
trailer -> [ subscriptlist ]
2576
&
trailer -> [ subscriptlist ]
2576
,
trailer -> [ subscriptlist ]
2576
^
trailer -> [ subscriptlist ]
2576
is
trailer -> [ subscriptlist ]
2576
%
trailer -> [ subscriptlist ]
2576
+
trailer -> [ subscriptlist ]
2576
//
trailer -> [ subscriptlist ]
2576
)
trailer -> [ subscriptlist ]
2576
=
trailer -> [ subscriptlist ]
2576
if
trailer -> [ subscriptlist ]
2577
,
lambdef -> lambda varargslist : test
2577
=
lambdef -> lambda varargslist : test
2577
)
lambdef -> lambda varargslist : test
2578
factor
2043
2578
term
2044
2578
(
2045
2578
arith_expr
2046
2578
NAME
2047
2578
[
2048
2578
atom
2049
2578
+
2050
2578
power
2051
2578
atom_expr
2052
2578
NUMBER
2053
2578
STRING
2054
2578
shift_expr
2055
2578
-
2056
2578
True
2057
2578
not_test
2058
2578
and_expr
2059
2578
xor_expr
2060
2578
test
2617
2578
None
2061
2578
False
2062
2578
and_test
2063
2578
{
2064
2578
~
2065
2578
expr
2066
2578
lambda
2067
2578
comparison
2068
2578
or_test
2070
2578
lambdef
2071
2578
not
2072
2579
for
trailer -> ( arglist )
2579
**
trailer -> ( arglist )
2579
if
trailer -> ( arglist )
2579
<
trailer -> ( arglist )
2579
//
trailer -> ( arglist )
2579
<<
trailer -> ( arglist )
2579
%
trailer -> ( arglist )
2579
)
trailer -> ( arglist )
2579
&
trailer -> ( arglist )
2579
==
trailer -> ( arglist )
2579
is
trailer -> ( arglist )
2579
!=
trailer -> ( arglist )
2579
and
trailer -> ( arglist )
2579
-
trailer -> ( arglist )
2579
+
trailer -> ( arglist )
2579
>=
trailer -> ( arglist )
2579
or
trailer -> ( arglist )
2579
(
trailer -> ( arglist )
2579
^
trailer -> ( arglist )
2579
.
trailer -> ( arglist )
2579
not
trailer -> ( arglist )
2579
>>
trailer -> ( arglist )
2579
/
trailer -> ( arglist )
2579
*
trailer -> ( arglist )
2579
[
trailer -> ( arglist )
2579
@
trailer -> ( arglist )
2579
>
trailer -> ( arglist )
2579
|
trailer -> ( arglist )
2579
<=
trailer -> ( arglist )
2579
in
trailer -> ( arglist )
2580
|
trailer -> [ subscriptlist ]
2580
not
trailer -> [ subscriptlist ]
2580
in
trailer -> [ subscriptlist ]
2580
==
trailer -> [ subscriptlist ]
2580
**
trailer -> [ subscriptlist ]
2580
>>
trailer -> [ subscriptlist ]
2580
!=
trailer -> [ subscriptlist ]
2580
*
trailer -> [ subscriptlist ]
2580
or
trailer -> [ subscriptlist ]
2580
>=
trailer -> [ subscriptlist ]
2580
/
trailer -> [ subscriptlist ]
2580
for
trailer -> [ subscriptlist ]
2580
[
trailer -> [ subscriptlist ]
2580
>
trailer -> [ subscriptlist ]
2580
<
trailer -> [ subscriptlist ]
2580
.
trailer -> [ subscriptlist ]
2580
and
trailer -> [ subscriptlist ]
2580
(
trailer -> [ subscriptlist ]
2580
<=
trailer -> [ subscriptlist ]
2580
-
trailer -> [ subscriptlist ]
2580
@
trailer -> [ subscriptlist ]
2580
<<
trailer -> [ subscriptlist ]
2580
&
trailer -> [ subscriptlist ]
2580
^
trailer -> [ subscriptlist ]
2580
is
trailer -> [ subscriptlist ]
2580
%
trailer -> [ subscriptlist ]
2580
+
trailer -> [ subscriptlist ]
2580
//
trailer -> [ subscriptlist ]
2580
)
trailer -> [ subscriptlist ]
2580
if
trailer -> [ subscriptlist ]
2581
:
2618
2582
factor
2123
2582
(
2124
2582
arith_expr
2125
2582
NAME
2126
2582
[
2127
2582
+
2128
2582
term
2129
2582
atom_expr
2130
2582
NUMBER
2131
2582
atom
2132
2582
STRING
2133
2582
shift_expr
2134
2582
-
2135
2582
True
2136
2582
and_expr
2137
2582
xor_expr
2138
2582
False
2139
2582
not_test
2140
2582
None
2141
2582
expr
2142
2582
and_test
2143
2582
{
2144
2582
~
2145
2582
power
2146
2582
lambda
2530
2582
comparison
2147
2582
test_nocond
2619
2582
lambdef_nocond
2532
2582
or_test
2533
2582
not
2149
2583
)
comp_if -> if test_nocond comp_iter
2584
DEDENT
confbody -> NAME test NEWLINE confbody
2585
DEDENT
2620
2586
varargslist
2621
2586
NAME
305
2586
:
2622
2586
vfpdef
306
2587
if
2536
2587
comp_for
2537
2587
comp_if
2538
2587
comp_iter
2623
2587
for
1289
2587
)
comp_iter -> 
2587
,
comp_iter -> 
2588
)
test_nocond -> lambdef_nocond
2588
if
test_nocond -> lambdef_nocond
2588
for
test_nocond -> lambdef_nocond
2588
,
test_nocond -> lambdef_nocond
2589
,
test_nocond -> or_test
2589
for
test_nocond -> or_test
2589
if
test_nocond -> or_test
2589
)
test_nocond -> or_test
2590
NEWLINE
test -> or_test if or_test else test
2590
=
test -> or_test if or_test else test
2591
for
lambdef_nocond -> lambda : test_nocond
2591
if
lambdef_nocond -> lambda : test_nocond
2591
]
lambdef_nocond -> lambda : test_nocond
2592
factor
1898
2592
(
1899
2592
arith_expr
1900
2592
NAME
1901
2592
[
1902
2592
+
1903
2592
term
1904
2592
atom_expr
1905
2592
NUMBER
1906
2592
atom
1907
2592
STRING
1908
2592
shift_expr
1909
2592
-
1910
2592
True
1911
2592
and_expr
1912
2592
xor_expr
1913
2592
False
1914
2592
not_test
1915
2592
None
1916
2592
expr
1917
2592
and_test
1918
2592
{
1919
2592
~
1920
2592
power
1921
2592
lambda
2442
2592
comparison
1922
2592
lambdef_nocond
2443
2592
test_nocond
2624
2592
or_test
2444
2592
not
1923
2593
-
try_stmt -> try : suite except_clause else : suite finally : suite
2593
assert
try_stmt -> try : suite except_clause else : suite finally : suite
2593
raise
try_stmt -> try : suite except_clause else : suite finally : suite
2593
+
try_stmt -> try : suite except_clause else : suite finally : suite
2593
class
try_stmt -> try : suite except_clause else : suite finally : suite
2593
(
try_stmt -> try : suite except_clause else : suite finally : suite
2593
nonlocal
try_stmt -> try : suite except_clause else : suite finally : suite
2593
return
try_stmt -> try : suite except_clause else : suite finally : suite
2593
try
try_stmt -> try : suite except_clause else : suite finally : suite
2593
if
try_stmt -> try : suite except_clause else : suite finally : suite
2593
True
try_stmt -> try : suite except_clause else : suite finally : suite
2593
continue
try_stmt -> try : suite except_clause else : suite finally : suite
2593
pass
try_stmt -> try : suite except_clause else : suite finally : suite
2593
[
try_stmt -> try : suite except_clause else : suite finally : suite
2593
@
try_stmt -> try : suite except_clause else : suite finally : suite
2593
with
try_stmt -> try : suite except_clause else : suite finally : suite
2593
conf
try_stmt -> try : suite except_clause else : suite finally : suite
2593
while
try_stmt -> try : suite except_clause else : suite finally : suite
2593
yield
try_stmt -> try : suite except_clause else : suite finally : suite
2593
for
try_stmt -> try : suite except_clause else : suite finally : suite
2593
break
try_stmt -> try : suite except_clause else : suite finally : suite
2593
resetstats
try_stmt -> try : suite except_clause else : suite finally : suite
2593
STRING
try_stmt -> try : suite except_clause else : suite finally : suite
2593
global
try_stmt -> try : suite except_clause else : suite finally : suite
2593
{
try_stmt -> try : suite except_clause else : suite finally : suite
2593
$
try_stmt -> try : suite except_clause else : suite finally : suite
2593
def
try_stmt -> try : suite except_clause else : suite finally : suite
2593
not
try_stmt -> try : suite except_clause else : suite finally : suite
2593
NEWLINE
try_stmt -> try : suite except_clause else : suite finally : suite
2593
NAME
try_stmt -> try : suite except_clause else : suite finally : suite
2593
begsim
try_stmt -> try : suite except_clause else : suite finally : suite
2593
~
try_stmt -> try : suite except_clause else : suite finally : suite
2593
del
try_stmt -> try : suite except_clause else : suite finally : suite
2593
lambda
try_stmt -> try : suite except_clause else : suite finally : suite
2593
endsim
try_stmt -> try : suite except_clause else : suite finally : suite
2593
False
try_stmt -> try : suite except_clause else : suite finally : suite
2593
None
try_stmt -> try : suite except_clause else : suite finally : suite
2593
NUMBER
try_stmt -> try : suite except_clause else : suite finally : suite
2594
not
suite -> NEWLINE INDENT stmt_list DEDENT
2594
None
suite -> NEWLINE INDENT stmt_list DEDENT
2594
{
suite -> NEWLINE INDENT stmt_list DEDENT
2594
for
suite -> NEWLINE INDENT stmt_list DEDENT
2594
finally
suite -> NEWLINE INDENT stmt_list DEDENT
2594
try
suite -> NEWLINE INDENT stmt_list DEDENT
2594
class
suite -> NEWLINE INDENT stmt_list DEDENT
2594
while
suite -> NEWLINE INDENT stmt_list DEDENT
2594
NEWLINE
suite -> NEWLINE INDENT stmt_list DEDENT
2594
-
suite -> NEWLINE INDENT stmt_list DEDENT
2594
if
suite -> NEWLINE INDENT stmt_list DEDENT
2594
+
suite -> NEWLINE INDENT stmt_list DEDENT
2594
resetstats
suite -> NEWLINE INDENT stmt_list DEDENT
2594
return
suite -> NEWLINE INDENT stmt_list DEDENT
2594
with
suite -> NEWLINE INDENT stmt_list DEDENT
2594
NAME
suite -> NEWLINE INDENT stmt_list DEDENT
2594
~
suite -> NEWLINE INDENT stmt_list DEDENT
2594
STRING
suite -> NEWLINE INDENT stmt_list DEDENT
2594
conf
suite -> NEWLINE INDENT stmt_list DEDENT
2594
assert
suite -> NEWLINE INDENT stmt_list DEDENT
2594
def
suite -> NEWLINE INDENT stmt_list DEDENT
2594
yield
suite -> NEWLINE INDENT stmt_list DEDENT
2594
NUMBER
suite -> NEWLINE INDENT stmt_list DEDENT
2594
del
suite -> NEWLINE INDENT stmt_list DEDENT
2594
$
suite -> NEWLINE INDENT stmt_list DEDENT
2594
True
suite -> NEWLINE INDENT stmt_list DEDENT
2594
break
suite -> NEWLINE INDENT stmt_list DEDENT
2594
pass
suite -> NEWLINE INDENT stmt_list DEDENT
2594
endsim
suite -> NEWLINE INDENT stmt_list DEDENT
2594
continue
suite -> NEWLINE INDENT stmt_list DEDENT
2594
[
suite -> NEWLINE INDENT stmt_list DEDENT
2594
begsim
suite -> NEWLINE INDENT stmt_list DEDENT
2594
lambda
suite -> NEWLINE INDENT stmt_list DEDENT
2594
global
suite -> NEWLINE INDENT stmt_list DEDENT
2594
@
suite -> NEWLINE INDENT stmt_list DEDENT
2594
False
suite -> NEWLINE INDENT stmt_list DEDENT
2594
raise
suite -> NEWLINE INDENT stmt_list DEDENT
2594
(
suite -> NEWLINE INDENT stmt_list DEDENT
2594
nonlocal
suite -> NEWLINE INDENT stmt_list DEDENT
2595
for
except_clause -> except test as NAME : suite maybe_except_clause
2595
+
except_clause -> except test as NAME : suite maybe_except_clause
2595
break
except_clause -> except test as NAME : suite maybe_except_clause
2595
def
except_clause -> except test as NAME : suite maybe_except_clause
2595
NAME
except_clause -> except test as NAME : suite maybe_except_clause
2595
while
except_clause -> except test as NAME : suite maybe_except_clause
2595
(
except_clause -> except test as NAME : suite maybe_except_clause
2595
None
except_clause -> except test as NAME : suite maybe_except_clause
2595
[
except_clause -> except test as NAME : suite maybe_except_clause
2595
$
except_clause -> except test as NAME : suite maybe_except_clause
2595
else
except_clause -> except test as NAME : suite maybe_except_clause
2595
conf
except_clause -> except test as NAME : suite maybe_except_clause
2595
NUMBER
except_clause -> except test as NAME : suite maybe_except_clause
2595
begsim
except_clause -> except test as NAME : suite maybe_except_clause
2595
@
except_clause -> except test as NAME : suite maybe_except_clause
2595
STRING
except_clause -> except test as NAME : suite maybe_except_clause
2595
global
except_clause -> except test as NAME : suite maybe_except_clause
2595
assert
except_clause -> except test as NAME : suite maybe_except_clause
2595
pass
except_clause -> except test as NAME : suite maybe_except_clause
2595
lambda
except_clause -> except test as NAME : suite maybe_except_clause
2595
{
except_clause -> except test as NAME : suite maybe_except_clause
2595
finally
except_clause -> except test as NAME : suite maybe_except_clause
2595
resetstats
except_clause -> except test as NAME : suite maybe_except_clause
2595
endsim
except_clause -> except test as NAME : suite maybe_except_clause
2595
try
except_clause -> except test as NAME : suite maybe_except_clause
2595
continue
except_clause -> except test as NAME : suite maybe_except_clause
2595
raise
except_clause -> except test as NAME : suite maybe_except_clause
2595
~
except_clause -> except test as NAME : suite maybe_except_clause
2595
-
except_clause -> except test as NAME : suite maybe_except_clause
2595
NEWLINE
except_clause -> except test as NAME : suite maybe_except_clause
2595
not
except_clause -> except test as NAME : suite maybe_except_clause
2595
class
except_clause -> except test as NAME : suite maybe_except_clause
2595
nonlocal
except_clause -> except test as NAME : suite maybe_except_clause
2595
return
except_clause -> except test as NAME : suite maybe_except_clause
2595
del
except_clause -> except test as NAME : suite maybe_except_clause
2595
if
except_clause -> except test as NAME : suite maybe_except_clause
2595
with
except_clause -> except test as NAME : suite maybe_except_clause
2595
yield
except_clause -> except test as NAME : suite maybe_except_clause
2595
False
except_clause -> except test as NAME : suite maybe_except_clause
2595
True
except_clause -> except test as NAME : suite maybe_except_clause
2596
:
2625
2597
:
2626
2598
DEDENT
2627
2599
factor
9
2599
arith_expr
2
2599
NAME
29
2599
term
21
2599
[
3
2599
~
45
2599
atom_expr
24
2599
expr
16
2599
power
56
2599
(
36
2599
return
13
2599
small_stmt
2628
2599
flow_stmt
15
2599
True
17
2599
not_test
18
2599
and_expr
19
2599
xor_expr
22
2599
{
52
2599
lambdef
53
2599
atom
54
2599
or_test
23
2599
suite
2629
2599
shift_expr
50
2599
False
35
2599
NEWLINE
2630
2599
-
49
2599
None
42
2599
lambda
40
2599
global
25
2599
NUMBER
27
2599
STRING
28
2599
test
48
2599
endsim
33
2599
and_test
37
2599
simple_stmt
2631
2599
comparison
39
2599
break_stmt
74
2599
+
55
2599
not
57
2599
raise
62
2599
continue
59
2599
return_stmt
75
2599
del_stmt
60
2599
test_list
61
2599
raise_stmt
63
2599
resetstats
64
2599
pass_stmt
65
2599
nonlocal
66
2599
break
76
2599
sim_stmt
77
2599
stat_stmt
78
2599
global_stmt
67
2599
yield_stmt
79
2599
assert_stmt
80
2599
pass
81
2599
yield
68
2599
continue_stmt
69
2599
assert
70
2599
nonlocal_stmt
71
2599
expr_stmt
72
2599
begsim
83
2599
del
84
2600
factor
9
2600
arith_expr
2
2600
NAME
29
2600
term
21
2600
[
3
2600
~
45
2600
atom_expr
24
2600
expr
16
2600
power
56
2600
(
36
2600
return
13
2600
small_stmt
1585
2600
flow_stmt
15
2600
True
17
2600
not_test
18
2600
and_expr
19
2600
xor_expr
22
2600
{
52
2600
lambdef
53
2600
atom
54
2600
or_test
23
2600
shift_expr
50
2600
False
35
2600
NEWLINE
2466
2600
-
49
2600
None
42
2600
lambda
40
2600
global
25
2600
NUMBER
27
2600
STRING
28
2600
test
48
2600
endsim
33
2600
and_test
37
2600
simple_stmt
2467
2600
suite
2632
2600
comparison
39
2600
break_stmt
74
2600
+
55
2600
not
57
2600
raise
62
2600
continue
59
2600
return_stmt
75
2600
del_stmt
60
2600
test_list
61
2600
raise_stmt
63
2600
resetstats
64
2600
pass_stmt
65
2600
nonlocal
66
2600
break
76
2600
sim_stmt
77
2600
stat_stmt
78
2600
global_stmt
67
2600
yield_stmt
79
2600
assert_stmt
80
2600
pass
81
2600
yield
68
2600
continue_stmt
69
2600
assert
70
2600
nonlocal_stmt
71
2600
expr_stmt
72
2600
begsim
83
2600
del
84
2601
NAME
2633
2602
factor
9
2602
arith_expr
2
2602
NAME
29
2602
term
21
2602
[
3
2602
~
45
2602
atom_expr
24
2602
expr
16
2602
power
56
2602
(
36
2602
return
13
2602
small_stmt
2604
2602
flow_stmt
15
2602
True
17
2602
not_test
18
2602
suite
2634
2602
and_expr
19
2602
xor_expr
22
2602
{
52
2602
lambdef
53
2602
atom
54
2602
or_test
23
2602
shift_expr
50
2602
False
35
2602
NEWLINE
2605
2602
-
49
2602
None
42
2602
lambda
40
2602
global
25
2602
NUMBER
27
2602
STRING
28
2602
test
48
2602
endsim
33
2602
and_test
37
2602
simple_stmt
2606
2602
comparison
39
2602
break_stmt
74
2602
+
55
2602
not
57
2602
raise
62
2602
continue
59
2602
return_stmt
75
2602
del_stmt
60
2602
test_list
61
2602
raise_stmt
63
2602
resetstats
64
2602
pass_stmt
65
2602
nonlocal
66
2602
break
76
2602
sim_stmt
77
2602
stat_stmt
78
2602
global_stmt
67
2602
yield_stmt
79
2602
assert_stmt
80
2602
pass
81
2602
yield
68
2602
continue_stmt
69
2602
assert
70
2602
nonlocal_stmt
71
2602
expr_stmt
72
2602
begsim
83
2602
del
84
2603
except
2462
2603
maybe_except_clause
2635
2603
except_clause
2636
2603
global
maybe_except_clause -> 
2603
resetstats
maybe_except_clause -> 
2603
class
maybe_except_clause -> 
2603
def
maybe_except_clause -> 
2603
NAME
maybe_except_clause -> 
2603
DEDENT
maybe_except_clause -> 
2603
NUMBER
maybe_except_clause -> 
2603
lambda
maybe_except_clause -> 
2603
True
maybe_except_clause -> 
2603
else
maybe_except_clause -> 
2603
not
maybe_except_clause -> 
2603
-
maybe_except_clause -> 
2603
~
maybe_except_clause -> 
2603
del
maybe_except_clause -> 
2603
with
maybe_except_clause -> 
2603
pass
maybe_except_clause -> 
2603
if
maybe_except_clause -> 
2603
assert
maybe_except_clause -> 
2603
conf
maybe_except_clause -> 
2603
break
maybe_except_clause -> 
2603
try
maybe_except_clause -> 
2603
while
maybe_except_clause -> 
2603
False
maybe_except_clause -> 
2603
(
maybe_except_clause -> 
2603
None
maybe_except_clause -> 
2603
return
maybe_except_clause -> 
2603
nonlocal
maybe_except_clause -> 
2603
@
maybe_except_clause -> 
2603
yield
maybe_except_clause -> 
2603
finally
maybe_except_clause -> 
2603
{
maybe_except_clause -> 
2603
endsim
maybe_except_clause -> 
2603
for
maybe_except_clause -> 
2603
raise
maybe_except_clause -> 
2603
[
maybe_except_clause -> 
2603
STRING
maybe_except_clause -> 
2603
begsim
maybe_except_clause -> 
2603
+
maybe_except_clause -> 
2603
continue
maybe_except_clause -> 
2604
NEWLINE
2637
2605
INDENT
2638
2606
resetstats
suite -> simple_stmt
2606
+
suite -> simple_stmt
2606
lambda
suite -> simple_stmt
2606
try
suite -> simple_stmt
2606
begsim
suite -> simple_stmt
2606
None
suite -> simple_stmt
2606
not
suite -> simple_stmt
2606
@
suite -> simple_stmt
2606
[
suite -> simple_stmt
2606
class
suite -> simple_stmt
2606
return
suite -> simple_stmt
2606
else
suite -> simple_stmt
2606
nonlocal
suite -> simple_stmt
2606
NUMBER
suite -> simple_stmt
2606
yield
suite -> simple_stmt
2606
STRING
suite -> simple_stmt
2606
-
suite -> simple_stmt
2606
False
suite -> simple_stmt
2606
def
suite -> simple_stmt
2606
except
suite -> simple_stmt
2606
conf
suite -> simple_stmt
2606
True
suite -> simple_stmt
2606
raise
suite -> simple_stmt
2606
endsim
suite -> simple_stmt
2606
with
suite -> simple_stmt
2606
global
suite -> simple_stmt
2606
{
suite -> simple_stmt
2606
~
suite -> simple_stmt
2606
assert
suite -> simple_stmt
2606
DEDENT
suite -> simple_stmt
2606
(
suite -> simple_stmt
2606
while
suite -> simple_stmt
2606
finally
suite -> simple_stmt
2606
del
suite -> simple_stmt
2606
pass
suite -> simple_stmt
2606
break
suite -> simple_stmt
2606
for
suite -> simple_stmt
2606
continue
suite -> simple_stmt
2606
NAME
suite -> simple_stmt
2606
if
suite -> simple_stmt
2607
factor
9
2607
arith_expr
2
2607
NAME
29
2607
term
21
2607
[
3
2607
~
45
2607
suite
2639
2607
atom_expr
24
2607
expr
16
2607
power
56
2607
(
36
2607
return
13
2607
small_stmt
1585
2607
flow_stmt
15
2607
True
17
2607
not_test
18
2607
and_expr
19
2607
xor_expr
22
2607
{
52
2607
lambdef
53
2607
atom
54
2607
or_test
23
2607
shift_expr
50
2607
False
35
2607
NEWLINE
2466
2607
-
49
2607
None
42
2607
lambda
40
2607
global
25
2607
NUMBER
27
2607
STRING
28
2607
test
48
2607
endsim
33
2607
and_test
37
2607
simple_stmt
2467
2607
comparison
39
2607
break_stmt
74
2607
+
55
2607
not
57
2607
raise
62
2607
continue
59
2607
return_stmt
75
2607
del_stmt
60
2607
test_list
61
2607
raise_stmt
63
2607
resetstats
64
2607
pass_stmt
65
2607
nonlocal
66
2607
break
76
2607
sim_stmt
77
2607
stat_stmt
78
2607
global_stmt
67
2607
yield_stmt
79
2607
assert_stmt
80
2607
pass
81
2607
yield
68
2607
continue_stmt
69
2607
assert
70
2607
nonlocal_stmt
71
2607
expr_stmt
72
2607
begsim
83
2607
del
84
2608
return
classdef -> class NAME ( ) : suite
2608
def
classdef -> class NAME ( ) : suite
2608
NAME
classdef -> class NAME ( ) : suite
2608
with
classdef -> class NAME ( ) : suite
2608
conf
classdef -> class NAME ( ) : suite
2608
not
classdef -> class NAME ( ) : suite
2608
True
classdef -> class NAME ( ) : suite
2608
global
classdef -> class NAME ( ) : suite
2608
STRING
classdef -> class NAME ( ) : suite
2608
nonlocal
classdef -> class NAME ( ) : suite
2608
None
classdef -> class NAME ( ) : suite
2608
~
classdef -> class NAME ( ) : suite
2608
assert
classdef -> class NAME ( ) : suite
2608
for
classdef -> class NAME ( ) : suite
2608
False
classdef -> class NAME ( ) : suite
2608
del
classdef -> class NAME ( ) : suite
2608
break
classdef -> class NAME ( ) : suite
2608
{
classdef -> class NAME ( ) : suite
2608
-
classdef -> class NAME ( ) : suite
2608
pass
classdef -> class NAME ( ) : suite
2608
raise
classdef -> class NAME ( ) : suite
2608
if
classdef -> class NAME ( ) : suite
2608
DEDENT
classdef -> class NAME ( ) : suite
2608
[
classdef -> class NAME ( ) : suite
2608
lambda
classdef -> class NAME ( ) : suite
2608
try
classdef -> class NAME ( ) : suite
2608
resetstats
classdef -> class NAME ( ) : suite
2608
+
classdef -> class NAME ( ) : suite
2608
@
classdef -> class NAME ( ) : suite
2608
while
classdef -> class NAME ( ) : suite
2608
begsim
classdef -> class NAME ( ) : suite
2608
class
classdef -> class NAME ( ) : suite
2608
yield
classdef -> class NAME ( ) : suite
2608
(
classdef -> class NAME ( ) : suite
2608
NUMBER
classdef -> class NAME ( ) : suite
2608
continue
classdef -> class NAME ( ) : suite
2608
endsim
classdef -> class NAME ( ) : suite
2609
DEDENT
2640
2610
~
for_stmt -> for expr_list in test_list : suite
2610
else
2641
2610
while
for_stmt -> for expr_list in test_list : suite
2610
return
for_stmt -> for expr_list in test_list : suite
2610
-
for_stmt -> for expr_list in test_list : suite
2610
with
for_stmt -> for expr_list in test_list : suite
2610
break
for_stmt -> for expr_list in test_list : suite
2610
[
for_stmt -> for expr_list in test_list : suite
2610
NAME
for_stmt -> for expr_list in test_list : suite
2610
for
for_stmt -> for expr_list in test_list : suite
2610
assert
for_stmt -> for expr_list in test_list : suite
2610
DEDENT
for_stmt -> for expr_list in test_list : suite
2610
try
for_stmt -> for expr_list in test_list : suite
2610
if
for_stmt -> for expr_list in test_list : suite
2610
pass
for_stmt -> for expr_list in test_list : suite
2610
{
for_stmt -> for expr_list in test_list : suite
2610
not
for_stmt -> for expr_list in test_list : suite
2610
yield
for_stmt -> for expr_list in test_list : suite
2610
conf
for_stmt -> for expr_list in test_list : suite
2610
nonlocal
for_stmt -> for expr_list in test_list : suite
2610
begsim
for_stmt -> for expr_list in test_list : suite
2610
resetstats
for_stmt -> for expr_list in test_list : suite
2610
def
for_stmt -> for expr_list in test_list : suite
2610
STRING
for_stmt -> for expr_list in test_list : suite
2610
global
for_stmt -> for expr_list in test_list : suite
2610
None
for_stmt -> for expr_list in test_list : suite
2610
raise
for_stmt -> for expr_list in test_list : suite
2610
(
for_stmt -> for expr_list in test_list : suite
2610
del
for_stmt -> for expr_list in test_list : suite
2610
@
for_stmt -> for expr_list in test_list : suite
2610
NUMBER
for_stmt -> for expr_list in test_list : suite
2610
+
for_stmt -> for expr_list in test_list : suite
2610
class
for_stmt -> for expr_list in test_list : suite
2610
lambda
for_stmt -> for expr_list in test_list : suite
2610
endsim
for_stmt -> for expr_list in test_list : suite
2610
False
for_stmt -> for expr_list in test_list : suite
2610
continue
for_stmt -> for expr_list in test_list : suite
2610
True
for_stmt -> for expr_list in test_list : suite
2611
endsim
funcdef -> def NAME ( ) : suite
2611
False
funcdef -> def NAME ( ) : suite
2611
-
funcdef -> def NAME ( ) : suite
2611
NAME
funcdef -> def NAME ( ) : suite
2611
assert
funcdef -> def NAME ( ) : suite
2611
def
funcdef -> def NAME ( ) : suite
2611
pass
funcdef -> def NAME ( ) : suite
2611
DEDENT
funcdef -> def NAME ( ) : suite
2611
continue
funcdef -> def NAME ( ) : suite
2611
try
funcdef -> def NAME ( ) : suite
2611
STRING
funcdef -> def NAME ( ) : suite
2611
raise
funcdef -> def NAME ( ) : suite
2611
break
funcdef -> def NAME ( ) : suite
2611
conf
funcdef -> def NAME ( ) : suite
2611
yield
funcdef -> def NAME ( ) : suite
2611
while
funcdef -> def NAME ( ) : suite
2611
True
funcdef -> def NAME ( ) : suite
2611
nonlocal
funcdef -> def NAME ( ) : suite
2611
begsim
funcdef -> def NAME ( ) : suite
2611
NUMBER
funcdef -> def NAME ( ) : suite
2611
@
funcdef -> def NAME ( ) : suite
2611
{
funcdef -> def NAME ( ) : suite
2611
not
funcdef -> def NAME ( ) : suite
2611
for
funcdef -> def NAME ( ) : suite
2611
None
funcdef -> def NAME ( ) : suite
2611
return
funcdef -> def NAME ( ) : suite
2611
global
funcdef -> def NAME ( ) : suite
2611
(
funcdef -> def NAME ( ) : suite
2611
~
funcdef -> def NAME ( ) : suite
2611
[
funcdef -> def NAME ( ) : suite
2611
with
funcdef -> def NAME ( ) : suite
2611
+
funcdef -> def NAME ( ) : suite
2611
lambda
funcdef -> def NAME ( ) : suite
2611
if
funcdef -> def NAME ( ) : suite
2611
class
funcdef -> def NAME ( ) : suite
2611
del
funcdef -> def NAME ( ) : suite
2611
resetstats
funcdef -> def NAME ( ) : suite
2612
factor
9
2612
arith_expr
2
2612
NAME
29
2612
term
21
2612
[
3
2612
~
45
2612
atom_expr
24
2612
expr
16
2612
power
56
2612
(
36
2612
suite
2642
2612
return
13
2612
small_stmt
1585
2612
flow_stmt
15
2612
True
17
2612
not_test
18
2612
and_expr
19
2612
xor_expr
22
2612
{
52
2612
lambdef
53
2612
atom
54
2612
or_test
23
2612
shift_expr
50
2612
False
35
2612
NEWLINE
2466
2612
-
49
2612
None
42
2612
lambda
40
2612
global
25
2612
NUMBER
27
2612
STRING
28
2612
test
48
2612
endsim
33
2612
and_test
37
2612
simple_stmt
2467
2612
comparison
39
2612
break_stmt
74
2612
+
55
2612
not
57
2612
raise
62
2612
continue
59
2612
return_stmt
75
2612
del_stmt
60
2612
test_list
61
2612
raise_stmt
63
2612
resetstats
64
2612
pass_stmt
65
2612
nonlocal
66
2612
break
76
2612
sim_stmt
77
2612
stat_stmt
78
2612
global_stmt
67
2612
yield_stmt
79
2612
assert_stmt
80
2612
pass
81
2612
yield
68
2612
continue_stmt
69
2612
assert
70
2612
nonlocal_stmt
71
2612
expr_stmt
72
2612
begsim
83
2612
del
84
2613
DEDENT
2643
2614
NEWLINE
2644
2615
factor
9
2615
arith_expr
2
2615
NAME
29
2615
term
21
2615
[
3
2615
~
45
2615
atom_expr
24
2615
expr
16
2615
power
56
2615
(
36
2615
return
13
2615
small_stmt
1585
2615
flow_stmt
15
2615
True
17
2615
not_test
18
2615
and_expr
19
2615
xor_expr
22
2615
{
52
2615
lambdef
53
2615
atom
54
2615
or_test
23
2615
shift_expr
50
2615
False
35
2615
NEWLINE
2466
2615
suite
2645
2615
-
49
2615
None
42
2615
lambda
40
2615
global
25
2615
NUMBER
27
2615
STRING
28
2615
test
48
2615
endsim
33
2615
and_test
37
2615
simple_stmt
2467
2615
comparison
39
2615
break_stmt
74
2615
+
55
2615
not
57
2615
raise
62
2615
continue
59
2615
return_stmt
75
2615
del_stmt
60
2615
test_list
61
2615
raise_stmt
63
2615
resetstats
64
2615
pass_stmt
65
2615
nonlocal
66
2615
break
76
2615
sim_stmt
77
2615
stat_stmt
78
2615
global_stmt
67
2615
yield_stmt
79
2615
assert_stmt
80
2615
pass
81
2615
yield
68
2615
continue_stmt
69
2615
assert
70
2615
nonlocal_stmt
71
2615
expr_stmt
72
2615
begsim
83
2615
del
84
2616
DEDENT
2646
2617
=
test -> or_test if or_test else test
2617
)
test -> or_test if or_test else test
2617
,
test -> or_test if or_test else test
2618
factor
2123
2618
(
2124
2618
arith_expr
2125
2618
NAME
2126
2618
[
2127
2618
+
2128
2618
term
2129
2618
atom_expr
2130
2618
NUMBER
2131
2618
atom
2132
2618
STRING
2133
2618
shift_expr
2134
2618
-
2135
2618
True
2136
2618
and_expr
2137
2618
xor_expr
2138
2618
False
2139
2618
not_test
2140
2618
None
2141
2618
expr
2142
2618
and_test
2143
2618
{
2144
2618
~
2145
2618
power
2146
2618
lambda
2530
2618
comparison
2147
2618
lambdef_nocond
2532
2618
test_nocond
2647
2618
or_test
2533
2618
not
2149
2619
)
lambdef_nocond -> lambda : test_nocond
2619
for
lambdef_nocond -> lambda : test_nocond
2619
if
lambdef_nocond -> lambda : test_nocond
2620
not
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
resetstats
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
(
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
global
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
try
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
+
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
~
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
nonlocal
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
del
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
assert
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
False
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
lambda
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
$
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
conf
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
NEWLINE
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
STRING
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
[
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
NAME
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
@
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
continue
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
begsim
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
with
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
for
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
endsim
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
while
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
return
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
yield
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
pass
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
raise
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
break
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
def
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
-
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
{
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
None
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
if
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
NUMBER
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
True
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2620
class
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2621
:
2648
2622
factor
268
2622
term
270
2622
(
271
2622
arith_expr
272
2622
NAME
273
2622
[
274
2622
+
275
2622
atom_expr
277
2622
NUMBER
278
2622
atom
279
2622
STRING
280
2622
shift_expr
281
2622
-
282
2622
True
283
2622
test_nocond
2649
2622
not_test
284
2622
and_expr
286
2622
xor_expr
287
2622
False
288
2622
None
289
2622
expr
290
2622
and_test
291
2622
{
292
2622
~
293
2622
power
294
2622
lambda
2586
2622
comparison
296
2622
lambdef_nocond
2588
2622
or_test
2589
2622
not
298
2623
)
comp_if -> if test_nocond comp_iter
2623
,
comp_if -> if test_nocond comp_iter
2624
if
lambdef_nocond -> lambda varargslist : test_nocond
2624
]
lambdef_nocond -> lambda varargslist : test_nocond
2624
for
lambdef_nocond -> lambda varargslist : test_nocond
2625
factor
9
2625
arith_expr
2
2625
NAME
29
2625
term
21
2625
[
3
2625
~
45
2625
atom_expr
24
2625
expr
16
2625
power
56
2625
(
36
2625
return
13
2625
small_stmt
2457
2625
flow_stmt
15
2625
True
17
2625
not_test
18
2625
and_expr
19
2625
suite
2650
2625
xor_expr
22
2625
{
52
2625
lambdef
53
2625
atom
54
2625
or_test
23
2625
shift_expr
50
2625
False
35
2625
NEWLINE
2459
2625
-
49
2625
None
42
2625
lambda
40
2625
global
25
2625
NUMBER
27
2625
STRING
28
2625
test
48
2625
endsim
33
2625
and_test
37
2625
simple_stmt
2460
2625
comparison
39
2625
break_stmt
74
2625
+
55
2625
not
57
2625
raise
62
2625
continue
59
2625
return_stmt
75
2625
del_stmt
60
2625
test_list
61
2625
raise_stmt
63
2625
resetstats
64
2625
pass_stmt
65
2625
nonlocal
66
2625
break
76
2625
sim_stmt
77
2625
stat_stmt
78
2625
global_stmt
67
2625
yield_stmt
79
2625
assert_stmt
80
2625
pass
81
2625
yield
68
2625
continue_stmt
69
2625
assert
70
2625
nonlocal_stmt
71
2625
expr_stmt
72
2625
begsim
83
2625
del
84
2626
factor
9
2626
arith_expr
2
2626
NAME
29
2626
term
21
2626
[
3
2626
~
45
2626
atom_expr
24
2626
expr
16
2626
power
56
2626
(
36
2626
return
13
2626
small_stmt
1585
2626
flow_stmt
15
2626
True
17
2626
not_test
18
2626
and_expr
19
2626
xor_expr
22
2626
{
52
2626
lambdef
53
2626
atom
54
2626
or_test
23
2626
shift_expr
50
2626
False
35
2626
NEWLINE
2466
2626
-
49
2626
None
42
2626
lambda
40
2626
global
25
2626
NUMBER
27
2626
STRING
28
2626
test
48
2626
suite
2651
2626
endsim
33
2626
and_test
37
2626
simple_stmt
2467
2626
comparison
39
2626
break_stmt
74
2626
+
55
2626
not
57
2626
raise
62
2626
continue
59
2626
return_stmt
75
2626
del_stmt
60
2626
test_list
61
2626
raise_stmt
63
2626
resetstats
64
2626
pass_stmt
65
2626
nonlocal
66
2626
break
76
2626
sim_stmt
77
2626
stat_stmt
78
2626
global_stmt
67
2626
yield_stmt
79
2626
assert_stmt
80
2626
pass
81
2626
yield
68
2626
continue_stmt
69
2626
assert
70
2626
nonlocal_stmt
71
2626
expr_stmt
72
2626
begsim
83
2626
del
84
2627
not
suite -> NEWLINE INDENT stmt_list DEDENT
2627
None
suite -> NEWLINE INDENT stmt_list DEDENT
2627
{
suite -> NEWLINE INDENT stmt_list DEDENT
2627
for
suite -> NEWLINE INDENT stmt_list DEDENT
2627
try
suite -> NEWLINE INDENT stmt_list DEDENT
2627
class
suite -> NEWLINE INDENT stmt_list DEDENT
2627
while
suite -> NEWLINE INDENT stmt_list DEDENT
2627
-
suite -> NEWLINE INDENT stmt_list DEDENT
2627
if
suite -> NEWLINE INDENT stmt_list DEDENT
2627
+
suite -> NEWLINE INDENT stmt_list DEDENT
2627
resetstats
suite -> NEWLINE INDENT stmt_list DEDENT
2627
return
suite -> NEWLINE INDENT stmt_list DEDENT
2627
with
suite -> NEWLINE INDENT stmt_list DEDENT
2627
else
suite -> NEWLINE INDENT stmt_list DEDENT
2627
NAME
suite -> NEWLINE INDENT stmt_list DEDENT
2627
STRING
suite -> NEWLINE INDENT stmt_list DEDENT
2627
conf
suite -> NEWLINE INDENT stmt_list DEDENT
2627
assert
suite -> NEWLINE INDENT stmt_list DEDENT
2627
def
suite -> NEWLINE INDENT stmt_list DEDENT
2627
~
suite -> NEWLINE INDENT stmt_list DEDENT
2627
yield
suite -> NEWLINE INDENT stmt_list DEDENT
2627
NUMBER
suite -> NEWLINE INDENT stmt_list DEDENT
2627
del
suite -> NEWLINE INDENT stmt_list DEDENT
2627
True
suite -> NEWLINE INDENT stmt_list DEDENT
2627
break
suite -> NEWLINE INDENT stmt_list DEDENT
2627
pass
suite -> NEWLINE INDENT stmt_list DEDENT
2627
endsim
suite -> NEWLINE INDENT stmt_list DEDENT
2627
continue
suite -> NEWLINE INDENT stmt_list DEDENT
2627
[
suite -> NEWLINE INDENT stmt_list DEDENT
2627
begsim
suite -> NEWLINE INDENT stmt_list DEDENT
2627
elif
suite -> NEWLINE INDENT stmt_list DEDENT
2627
DEDENT
suite -> NEWLINE INDENT stmt_list DEDENT
2627
lambda
suite -> NEWLINE INDENT stmt_list DEDENT
2627
global
suite -> NEWLINE INDENT stmt_list DEDENT
2627
@
suite -> NEWLINE INDENT stmt_list DEDENT
2627
False
suite -> NEWLINE INDENT stmt_list DEDENT
2627
raise
suite -> NEWLINE INDENT stmt_list DEDENT
2627
(
suite -> NEWLINE INDENT stmt_list DEDENT
2627
nonlocal
suite -> NEWLINE INDENT stmt_list DEDENT
2628
NEWLINE
2652
2629
finally
2653
2629
global
try_stmt -> try : suite except_clause else : suite
2629
resetstats
try_stmt -> try : suite except_clause else : suite
2629
return
try_stmt -> try : suite except_clause else : suite
2629
yield
try_stmt -> try : suite except_clause else : suite
2629
continue
try_stmt -> try : suite except_clause else : suite
2629
[
try_stmt -> try : suite except_clause else : suite
2629
endsim
try_stmt -> try : suite except_clause else : suite
2629
raise
try_stmt -> try : suite except_clause else : suite
2629
pass
try_stmt -> try : suite except_clause else : suite
2629
None
try_stmt -> try : suite except_clause else : suite
2629
lambda
try_stmt -> try : suite except_clause else : suite
2629
del
try_stmt -> try : suite except_clause else : suite
2629
def
try_stmt -> try : suite except_clause else : suite
2629
NUMBER
try_stmt -> try : suite except_clause else : suite
2629
begsim
try_stmt -> try : suite except_clause else : suite
2629
NAME
try_stmt -> try : suite except_clause else : suite
2629
@
try_stmt -> try : suite except_clause else : suite
2629
try
try_stmt -> try : suite except_clause else : suite
2629
True
try_stmt -> try : suite except_clause else : suite
2629
False
try_stmt -> try : suite except_clause else : suite
2629
if
try_stmt -> try : suite except_clause else : suite
2629
conf
try_stmt -> try : suite except_clause else : suite
2629
with
try_stmt -> try : suite except_clause else : suite
2629
(
try_stmt -> try : suite except_clause else : suite
2629
~
try_stmt -> try : suite except_clause else : suite
2629
-
try_stmt -> try : suite except_clause else : suite
2629
for
try_stmt -> try : suite except_clause else : suite
2629
STRING
try_stmt -> try : suite except_clause else : suite
2629
assert
try_stmt -> try : suite except_clause else : suite
2629
break
try_stmt -> try : suite except_clause else : suite
2629
class
try_stmt -> try : suite except_clause else : suite
2629
{
try_stmt -> try : suite except_clause else : suite
2629
nonlocal
try_stmt -> try : suite except_clause else : suite
2629
+
try_stmt -> try : suite except_clause else : suite
2629
not
try_stmt -> try : suite except_clause else : suite
2629
DEDENT
try_stmt -> try : suite except_clause else : suite
2629
while
try_stmt -> try : suite except_clause else : suite
2630
INDENT
2654
2631
resetstats
suite -> simple_stmt
2631
+
suite -> simple_stmt
2631
lambda
suite -> simple_stmt
2631
try
suite -> simple_stmt
2631
begsim
suite -> simple_stmt
2631
None
suite -> simple_stmt
2631
not
suite -> simple_stmt
2631
@
suite -> simple_stmt
2631
[
suite -> simple_stmt
2631
class
suite -> simple_stmt
2631
return
suite -> simple_stmt
2631
nonlocal
suite -> simple_stmt
2631
NUMBER
suite -> simple_stmt
2631
yield
suite -> simple_stmt
2631
STRING
suite -> simple_stmt
2631
-
suite -> simple_stmt
2631
False
suite -> simple_stmt
2631
def
suite -> simple_stmt
2631
conf
suite -> simple_stmt
2631
True
suite -> simple_stmt
2631
raise
suite -> simple_stmt
2631
endsim
suite -> simple_stmt
2631
with
suite -> simple_stmt
2631
global
suite -> simple_stmt
2631
{
suite -> simple_stmt
2631
~
suite -> simple_stmt
2631
assert
suite -> simple_stmt
2631
DEDENT
suite -> simple_stmt
2631
(
suite -> simple_stmt
2631
while
suite -> simple_stmt
2631
finally
suite -> simple_stmt
2631
del
suite -> simple_stmt
2631
pass
suite -> simple_stmt
2631
break
suite -> simple_stmt
2631
for
suite -> simple_stmt
2631
continue
suite -> simple_stmt
2631
NAME
suite -> simple_stmt
2631
if
suite -> simple_stmt
2632
pass
try_stmt -> try : suite except_clause finally : suite
2632
continue
try_stmt -> try : suite except_clause finally : suite
2632
[
try_stmt -> try : suite except_clause finally : suite
2632
NUMBER
try_stmt -> try : suite except_clause finally : suite
2632
class
try_stmt -> try : suite except_clause finally : suite
2632
-
try_stmt -> try : suite except_clause finally : suite
2632
(
try_stmt -> try : suite except_clause finally : suite
2632
for
try_stmt -> try : suite except_clause finally : suite
2632
@
try_stmt -> try : suite except_clause finally : suite
2632
def
try_stmt -> try : suite except_clause finally : suite
2632
break
try_stmt -> try : suite except_clause finally : suite
2632
~
try_stmt -> try : suite except_clause finally : suite
2632
yield
try_stmt -> try : suite except_clause finally : suite
2632
begsim
try_stmt -> try : suite except_clause finally : suite
2632
nonlocal
try_stmt -> try : suite except_clause finally : suite
2632
False
try_stmt -> try : suite except_clause finally : suite
2632
+
try_stmt -> try : suite except_clause finally : suite
2632
lambda
try_stmt -> try : suite except_clause finally : suite
2632
True
try_stmt -> try : suite except_clause finally : suite
2632
raise
try_stmt -> try : suite except_clause finally : suite
2632
with
try_stmt -> try : suite except_clause finally : suite
2632
NAME
try_stmt -> try : suite except_clause finally : suite
2632
STRING
try_stmt -> try : suite except_clause finally : suite
2632
endsim
try_stmt -> try : suite except_clause finally : suite
2632
None
try_stmt -> try : suite except_clause finally : suite
2632
while
try_stmt -> try : suite except_clause finally : suite
2632
if
try_stmt -> try : suite except_clause finally : suite
2632
not
try_stmt -> try : suite except_clause finally : suite
2632
assert
try_stmt -> try : suite except_clause finally : suite
2632
conf
try_stmt -> try : suite except_clause finally : suite
2632
try
try_stmt -> try : suite except_clause finally : suite
2632
del
try_stmt -> try : suite except_clause finally : suite
2632
global
try_stmt -> try : suite except_clause finally : suite
2632
{
try_stmt -> try : suite except_clause finally : suite
2632
DEDENT
try_stmt -> try : suite except_clause finally : suite
2632
return
try_stmt -> try : suite except_clause finally : suite
2632
resetstats
try_stmt -> try : suite except_clause finally : suite
2633
:
2655
2634
except
2462
2634
maybe_except_clause
2656
2634
except_clause
2636
2634
global
maybe_except_clause -> 
2634
resetstats
maybe_except_clause -> 
2634
class
maybe_except_clause -> 
2634
def
maybe_except_clause -> 
2634
NAME
maybe_except_clause -> 
2634
DEDENT
maybe_except_clause -> 
2634
NUMBER
maybe_except_clause -> 
2634
lambda
maybe_except_clause -> 
2634
True
maybe_except_clause -> 
2634
else
maybe_except_clause -> 
2634
not
maybe_except_clause -> 
2634
-
maybe_except_clause -> 
2634
~
maybe_except_clause -> 
2634
del
maybe_except_clause -> 
2634
with
maybe_except_clause -> 
2634
pass
maybe_except_clause -> 
2634
if
maybe_except_clause -> 
2634
assert
maybe_except_clause -> 
2634
conf
maybe_except_clause -> 
2634
break
maybe_except_clause -> 
2634
try
maybe_except_clause -> 
2634
while
maybe_except_clause -> 
2634
False
maybe_except_clause -> 
2634
(
maybe_except_clause -> 
2634
None
maybe_except_clause -> 
2634
return
maybe_except_clause -> 
2634
nonlocal
maybe_except_clause -> 
2634
@
maybe_except_clause -> 
2634
yield
maybe_except_clause -> 
2634
finally
maybe_except_clause -> 
2634
{
maybe_except_clause -> 
2634
endsim
maybe_except_clause -> 
2634
for
maybe_except_clause -> 
2634
raise
maybe_except_clause -> 
2634
[
maybe_except_clause -> 
2634
STRING
maybe_except_clause -> 
2634
begsim
maybe_except_clause -> 
2634
+
maybe_except_clause -> 
2634
continue
maybe_except_clause -> 
2635
+
except_clause -> except : suite maybe_except_clause
2635
@
except_clause -> except : suite maybe_except_clause
2635
raise
except_clause -> except : suite maybe_except_clause
2635
lambda
except_clause -> except : suite maybe_except_clause
2635
def
except_clause -> except : suite maybe_except_clause
2635
nonlocal
except_clause -> except : suite maybe_except_clause
2635
[
except_clause -> except : suite maybe_except_clause
2635
global
except_clause -> except : suite maybe_except_clause
2635
False
except_clause -> except : suite maybe_except_clause
2635
class
except_clause -> except : suite maybe_except_clause
2635
None
except_clause -> except : suite maybe_except_clause
2635
STRING
except_clause -> except : suite maybe_except_clause
2635
break
except_clause -> except : suite maybe_except_clause
2635
not
except_clause -> except : suite maybe_except_clause
2635
resetstats
except_clause -> except : suite maybe_except_clause
2635
pass
except_clause -> except : suite maybe_except_clause
2635
~
except_clause -> except : suite maybe_except_clause
2635
DEDENT
except_clause -> except : suite maybe_except_clause
2635
try
except_clause -> except : suite maybe_except_clause
2635
else
except_clause -> except : suite maybe_except_clause
2635
continue
except_clause -> except : suite maybe_except_clause
2635
yield
except_clause -> except : suite maybe_except_clause
2635
endsim
except_clause -> except : suite maybe_except_clause
2635
NUMBER
except_clause -> except : suite maybe_except_clause
2635
return
except_clause -> except : suite maybe_except_clause
2635
(
except_clause -> except : suite maybe_except_clause
2635
while
except_clause -> except : suite maybe_except_clause
2635
finally
except_clause -> except : suite maybe_except_clause
2635
del
except_clause -> except : suite maybe_except_clause
2635
if
except_clause -> except : suite maybe_except_clause
2635
{
except_clause -> except : suite maybe_except_clause
2635
with
except_clause -> except : suite maybe_except_clause
2635
for
except_clause -> except : suite maybe_except_clause
2635
True
except_clause -> except : suite maybe_except_clause
2635
begsim
except_clause -> except : suite maybe_except_clause
2635
assert
except_clause -> except : suite maybe_except_clause
2635
NAME
except_clause -> except : suite maybe_except_clause
2635
conf
except_clause -> except : suite maybe_except_clause
2635
-
except_clause -> except : suite maybe_except_clause
2636
return
maybe_except_clause -> except_clause
2636
None
maybe_except_clause -> except_clause
2636
endsim
maybe_except_clause -> except_clause
2636
NUMBER
maybe_except_clause -> except_clause
2636
(
maybe_except_clause -> except_clause
2636
{
maybe_except_clause -> except_clause
2636
raise
maybe_except_clause -> except_clause
2636
pass
maybe_except_clause -> except_clause
2636
with
maybe_except_clause -> except_clause
2636
not
maybe_except_clause -> except_clause
2636
conf
maybe_except_clause -> except_clause
2636
def
maybe_except_clause -> except_clause
2636
True
maybe_except_clause -> except_clause
2636
while
maybe_except_clause -> except_clause
2636
nonlocal
maybe_except_clause -> except_clause
2636
finally
maybe_except_clause -> except_clause
2636
assert
maybe_except_clause -> except_clause
2636
[
maybe_except_clause -> except_clause
2636
-
maybe_except_clause -> except_clause
2636
False
maybe_except_clause -> except_clause
2636
break
maybe_except_clause -> except_clause
2636
try
maybe_except_clause -> except_clause
2636
for
maybe_except_clause -> except_clause
2636
lambda
maybe_except_clause -> except_clause
2636
continue
maybe_except_clause -> except_clause
2636
@
maybe_except_clause -> except_clause
2636
else
maybe_except_clause -> except_clause
2636
class
maybe_except_clause -> except_clause
2636
resetstats
maybe_except_clause -> except_clause
2636
begsim
maybe_except_clause -> except_clause
2636
NAME
maybe_except_clause -> except_clause
2636
global
maybe_except_clause -> except_clause
2636
yield
maybe_except_clause -> except_clause
2636
DEDENT
maybe_except_clause -> except_clause
2636
+
maybe_except_clause -> except_clause
2636
~
maybe_except_clause -> except_clause
2636
if
maybe_except_clause -> except_clause
2636
del
maybe_except_clause -> except_clause
2636
STRING
maybe_except_clause -> except_clause
2637
nonlocal
simple_stmt -> small_stmt NEWLINE
2637
True
simple_stmt -> small_stmt NEWLINE
2637
except
simple_stmt -> small_stmt NEWLINE
2637
False
simple_stmt -> small_stmt NEWLINE
2637
(
simple_stmt -> small_stmt NEWLINE
2637
continue
simple_stmt -> small_stmt NEWLINE
2637
begsim
simple_stmt -> small_stmt NEWLINE
2637
NAME
simple_stmt -> small_stmt NEWLINE
2637
endsim
simple_stmt -> small_stmt NEWLINE
2637
DEDENT
simple_stmt -> small_stmt NEWLINE
2637
break
simple_stmt -> small_stmt NEWLINE
2637
return
simple_stmt -> small_stmt NEWLINE
2637
NUMBER
simple_stmt -> small_stmt NEWLINE
2637
[
simple_stmt -> small_stmt NEWLINE
2637
global
simple_stmt -> small_stmt NEWLINE
2637
resetstats
simple_stmt -> small_stmt NEWLINE
2637
yield
simple_stmt -> small_stmt NEWLINE
2637
conf
simple_stmt -> small_stmt NEWLINE
2637
lambda
simple_stmt -> small_stmt NEWLINE
2637
not
simple_stmt -> small_stmt NEWLINE
2637
finally
simple_stmt -> small_stmt NEWLINE
2637
del
simple_stmt -> small_stmt NEWLINE
2637
pass
simple_stmt -> small_stmt NEWLINE
2637
for
simple_stmt -> small_stmt NEWLINE
2637
@
simple_stmt -> small_stmt NEWLINE
2637
with
simple_stmt -> small_stmt NEWLINE
2637
class
simple_stmt -> small_stmt NEWLINE
2637
if
simple_stmt -> small_stmt NEWLINE
2637
assert
simple_stmt -> small_stmt NEWLINE
2637
None
simple_stmt -> small_stmt NEWLINE
2637
else
simple_stmt -> small_stmt NEWLINE
2637
+
simple_stmt -> small_stmt NEWLINE
2637
-
simple_stmt -> small_stmt NEWLINE
2637
STRING
simple_stmt -> small_stmt NEWLINE
2637
while
simple_stmt -> small_stmt NEWLINE
2637
{
simple_stmt -> small_stmt NEWLINE
2637
raise
simple_stmt -> small_stmt NEWLINE
2637
~
simple_stmt -> small_stmt NEWLINE
2637
def
simple_stmt -> small_stmt NEWLINE
2637
try
simple_stmt -> small_stmt NEWLINE
2638
if
1566
2638
arith_expr
2
2638
try
1567
2638
[
3
2638
class
1568
2638
for
1569
2638
stmt_list
2657
2638
with_stmt
1570
2638
while_stmt
1571
2638
factor
9
2638
@
10
2638
simple_stmt
1572
2638
decorators
1573
2638
return
13
2638
confdef
1574
2638
flow_stmt
15
2638
expr
16
2638
True
17
2638
not_test
18
2638
and_expr
19
2638
def
1575
2638
term
21
2638
xor_expr
22
2638
or_test
23
2638
atom_expr
24
2638
global
25
2638
for_stmt
1576
2638
NUMBER
27
2638
STRING
28
2638
NAME
29
2638
decorator
30
2638
if_stmt
1577
2638
with
1578
2638
endsim
33
2638
classdef
1579
2638
False
35
2638
(
36
2638
and_test
37
2638
conf
1580
2638
comparison
39
2638
lambda
40
2638
while
1581
2638
None
42
2638
try_stmt
1582
2638
funcdef
1583
2638
~
45
2638
decorated
1584
2638
small_stmt
1585
2638
test
48
2638
-
49
2638
shift_expr
50
2638
{
52
2638
lambdef
53
2638
atom
54
2638
+
55
2638
power
56
2638
not
57
2638
compound_stmt
1587
2638
continue
59
2638
del_stmt
60
2638
test_list
61
2638
raise
62
2638
raise_stmt
63
2638
resetstats
64
2638
pass_stmt
65
2638
stmt
1588
2638
nonlocal
66
2638
global_stmt
67
2638
yield
68
2638
continue_stmt
69
2638
assert
70
2638
nonlocal_stmt
71
2638
expr_stmt
72
2638
break_stmt
74
2638
return_stmt
75
2638
break
76
2638
sim_stmt
77
2638
stat_stmt
78
2638
yield_stmt
79
2638
assert_stmt
80
2638
pass
81
2638
begsim
83
2638
del
84
2639
class
classdef -> class NAME ( arglist ) : suite
2639
endsim
classdef -> class NAME ( arglist ) : suite
2639
raise
classdef -> class NAME ( arglist ) : suite
2639
NAME
classdef -> class NAME ( arglist ) : suite
2639
pass
classdef -> class NAME ( arglist ) : suite
2639
NUMBER
classdef -> class NAME ( arglist ) : suite
2639
assert
classdef -> class NAME ( arglist ) : suite
2639
yield
classdef -> class NAME ( arglist ) : suite
2639
def
classdef -> class NAME ( arglist ) : suite
2639
STRING
classdef -> class NAME ( arglist ) : suite
2639
if
classdef -> class NAME ( arglist ) : suite
2639
False
classdef -> class NAME ( arglist ) : suite
2639
while
classdef -> class NAME ( arglist ) : suite
2639
begsim
classdef -> class NAME ( arglist ) : suite
2639
resetstats
classdef -> class NAME ( arglist ) : suite
2639
del
classdef -> class NAME ( arglist ) : suite
2639
conf
classdef -> class NAME ( arglist ) : suite
2639
continue
classdef -> class NAME ( arglist ) : suite
2639
(
classdef -> class NAME ( arglist ) : suite
2639
DEDENT
classdef -> class NAME ( arglist ) : suite
2639
try
classdef -> class NAME ( arglist ) : suite
2639
~
classdef -> class NAME ( arglist ) : suite
2639
return
classdef -> class NAME ( arglist ) : suite
2639
{
classdef -> class NAME ( arglist ) : suite
2639
[
classdef -> class NAME ( arglist ) : suite
2639
+
classdef -> class NAME ( arglist ) : suite
2639
nonlocal
classdef -> class NAME ( arglist ) : suite
2639
-
classdef -> class NAME ( arglist ) : suite
2639
with
classdef -> class NAME ( arglist ) : suite
2639
not
classdef -> class NAME ( arglist ) : suite
2639
for
classdef -> class NAME ( arglist ) : suite
2639
break
classdef -> class NAME ( arglist ) : suite
2639
@
classdef -> class NAME ( arglist ) : suite
2639
lambda
classdef -> class NAME ( arglist ) : suite
2639
True
classdef -> class NAME ( arglist ) : suite
2639
global
classdef -> class NAME ( arglist ) : suite
2639
None
classdef -> class NAME ( arglist ) : suite
2640
not
suite -> NEWLINE INDENT stmt_list DEDENT
2640
None
suite -> NEWLINE INDENT stmt_list DEDENT
2640
{
suite -> NEWLINE INDENT stmt_list DEDENT
2640
for
suite -> NEWLINE INDENT stmt_list DEDENT
2640
try
suite -> NEWLINE INDENT stmt_list DEDENT
2640
class
suite -> NEWLINE INDENT stmt_list DEDENT
2640
while
suite -> NEWLINE INDENT stmt_list DEDENT
2640
-
suite -> NEWLINE INDENT stmt_list DEDENT
2640
if
suite -> NEWLINE INDENT stmt_list DEDENT
2640
+
suite -> NEWLINE INDENT stmt_list DEDENT
2640
resetstats
suite -> NEWLINE INDENT stmt_list DEDENT
2640
return
suite -> NEWLINE INDENT stmt_list DEDENT
2640
with
suite -> NEWLINE INDENT stmt_list DEDENT
2640
NAME
suite -> NEWLINE INDENT stmt_list DEDENT
2640
~
suite -> NEWLINE INDENT stmt_list DEDENT
2640
STRING
suite -> NEWLINE INDENT stmt_list DEDENT
2640
conf
suite -> NEWLINE INDENT stmt_list DEDENT
2640
assert
suite -> NEWLINE INDENT stmt_list DEDENT
2640
def
suite -> NEWLINE INDENT stmt_list DEDENT
2640
yield
suite -> NEWLINE INDENT stmt_list DEDENT
2640
NUMBER
suite -> NEWLINE INDENT stmt_list DEDENT
2640
del
suite -> NEWLINE INDENT stmt_list DEDENT
2640
True
suite -> NEWLINE INDENT stmt_list DEDENT
2640
break
suite -> NEWLINE INDENT stmt_list DEDENT
2640
pass
suite -> NEWLINE INDENT stmt_list DEDENT
2640
endsim
suite -> NEWLINE INDENT stmt_list DEDENT
2640
continue
suite -> NEWLINE INDENT stmt_list DEDENT
2640
[
suite -> NEWLINE INDENT stmt_list DEDENT
2640
begsim
suite -> NEWLINE INDENT stmt_list DEDENT
2640
DEDENT
suite -> NEWLINE INDENT stmt_list DEDENT
2640
lambda
suite -> NEWLINE INDENT stmt_list DEDENT
2640
global
suite -> NEWLINE INDENT stmt_list DEDENT
2640
@
suite -> NEWLINE INDENT stmt_list DEDENT
2640
False
suite -> NEWLINE INDENT stmt_list DEDENT
2640
raise
suite -> NEWLINE INDENT stmt_list DEDENT
2640
(
suite -> NEWLINE INDENT stmt_list DEDENT
2640
nonlocal
suite -> NEWLINE INDENT stmt_list DEDENT
2641
:
2658
2642
lambda
funcdef -> def NAME ( parameters ) : suite
2642
if
funcdef -> def NAME ( parameters ) : suite
2642
STRING
funcdef -> def NAME ( parameters ) : suite
2642
yield
funcdef -> def NAME ( parameters ) : suite
2642
None
funcdef -> def NAME ( parameters ) : suite
2642
for
funcdef -> def NAME ( parameters ) : suite
2642
return
funcdef -> def NAME ( parameters ) : suite
2642
nonlocal
funcdef -> def NAME ( parameters ) : suite
2642
del
funcdef -> def NAME ( parameters ) : suite
2642
@
funcdef -> def NAME ( parameters ) : suite
2642
+
funcdef -> def NAME ( parameters ) : suite
2642
endsim
funcdef -> def NAME ( parameters ) : suite
2642
raise
funcdef -> def NAME ( parameters ) : suite
2642
class
funcdef -> def NAME ( parameters ) : suite
2642
False
funcdef -> def NAME ( parameters ) : suite
2642
conf
funcdef -> def NAME ( parameters ) : suite
2642
[
funcdef -> def NAME ( parameters ) : suite
2642
~
funcdef -> def NAME ( parameters ) : suite
2642
def
funcdef -> def NAME ( parameters ) : suite
2642
resetstats
funcdef -> def NAME ( parameters ) : suite
2642
begsim
funcdef -> def NAME ( parameters ) : suite
2642
True
funcdef -> def NAME ( parameters ) : suite
2642
-
funcdef -> def NAME ( parameters ) : suite
2642
try
funcdef -> def NAME ( parameters ) : suite
2642
NUMBER
funcdef -> def NAME ( parameters ) : suite
2642
NAME
funcdef -> def NAME ( parameters ) : suite
2642
with
funcdef -> def NAME ( parameters ) : suite
2642
while
funcdef -> def NAME ( parameters ) : suite
2642
break
funcdef -> def NAME ( parameters ) : suite
2642
pass
funcdef -> def NAME ( parameters ) : suite
2642
{
funcdef -> def NAME ( parameters ) : suite
2642
not
funcdef -> def NAME ( parameters ) : suite
2642
continue
funcdef -> def NAME ( parameters ) : suite
2642
DEDENT
funcdef -> def NAME ( parameters ) : suite
2642
assert
funcdef -> def NAME ( parameters ) : suite
2642
(
funcdef -> def NAME ( parameters ) : suite
2642
global
funcdef -> def NAME ( parameters ) : suite
2643
False
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
~
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
resetstats
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
with
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
NAME
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
[
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
(
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
None
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
nonlocal
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
{
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
begsim
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
del
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
+
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
True
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
STRING
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
class
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
def
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
for
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
while
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
lambda
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
not
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
DEDENT
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
yield
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
try
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
if
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
raise
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
break
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
pass
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
global
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
continue
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
assert
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
endsim
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
conf
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
NUMBER
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
return
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
-
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2643
@
confdef -> conf NAME : NEWLINE INDENT confbody DEDENT
2644
INDENT
2659
2645
nonlocal
while_stmt -> while test : suite else : suite
2645
False
while_stmt -> while test : suite else : suite
2645
resetstats
while_stmt -> while test : suite else : suite
2645
None
while_stmt -> while test : suite else : suite
2645
(
while_stmt -> while test : suite else : suite
2645
del
while_stmt -> while test : suite else : suite
2645
raise
while_stmt -> while test : suite else : suite
2645
begsim
while_stmt -> while test : suite else : suite
2645
assert
while_stmt -> while test : suite else : suite
2645
return
while_stmt -> while test : suite else : suite
2645
while
while_stmt -> while test : suite else : suite
2645
yield
while_stmt -> while test : suite else : suite
2645
with
while_stmt -> while test : suite else : suite
2645
[
while_stmt -> while test : suite else : suite
2645
if
while_stmt -> while test : suite else : suite
2645
def
while_stmt -> while test : suite else : suite
2645
STRING
while_stmt -> while test : suite else : suite
2645
break
while_stmt -> while test : suite else : suite
2645
~
while_stmt -> while test : suite else : suite
2645
@
while_stmt -> while test : suite else : suite
2645
try
while_stmt -> while test : suite else : suite
2645
{
while_stmt -> while test : suite else : suite
2645
pass
while_stmt -> while test : suite else : suite
2645
DEDENT
while_stmt -> while test : suite else : suite
2645
continue
while_stmt -> while test : suite else : suite
2645
True
while_stmt -> while test : suite else : suite
2645
endsim
while_stmt -> while test : suite else : suite
2645
class
while_stmt -> while test : suite else : suite
2645
+
while_stmt -> while test : suite else : suite
2645
conf
while_stmt -> while test : suite else : suite
2645
for
while_stmt -> while test : suite else : suite
2645
lambda
while_stmt -> while test : suite else : suite
2645
global
while_stmt -> while test : suite else : suite
2645
NUMBER
while_stmt -> while test : suite else : suite
2645
-
while_stmt -> while test : suite else : suite
2645
not
while_stmt -> while test : suite else : suite
2645
NAME
while_stmt -> while test : suite else : suite
2646
not
suite -> NEWLINE INDENT stmt_list DEDENT
2646
None
suite -> NEWLINE INDENT stmt_list DEDENT
2646
{
suite -> NEWLINE INDENT stmt_list DEDENT
2646
for
suite -> NEWLINE INDENT stmt_list DEDENT
2646
try
suite -> NEWLINE INDENT stmt_list DEDENT
2646
class
suite -> NEWLINE INDENT stmt_list DEDENT
2646
while
suite -> NEWLINE INDENT stmt_list DEDENT
2646
-
suite -> NEWLINE INDENT stmt_list DEDENT
2646
if
suite -> NEWLINE INDENT stmt_list DEDENT
2646
+
suite -> NEWLINE INDENT stmt_list DEDENT
2646
resetstats
suite -> NEWLINE INDENT stmt_list DEDENT
2646
return
suite -> NEWLINE INDENT stmt_list DEDENT
2646
with
suite -> NEWLINE INDENT stmt_list DEDENT
2646
else
suite -> NEWLINE INDENT stmt_list DEDENT
2646
NAME
suite -> NEWLINE INDENT stmt_list DEDENT
2646
STRING
suite -> NEWLINE INDENT stmt_list DEDENT
2646
conf
suite -> NEWLINE INDENT stmt_list DEDENT
2646
assert
suite -> NEWLINE INDENT stmt_list DEDENT
2646
def
suite -> NEWLINE INDENT stmt_list DEDENT
2646
~
suite -> NEWLINE INDENT stmt_list DEDENT
2646
yield
suite -> NEWLINE INDENT stmt_list DEDENT
2646
NUMBER
suite -> NEWLINE INDENT stmt_list DEDENT
2646
del
suite -> NEWLINE INDENT stmt_list DEDENT
2646
True
suite -> NEWLINE INDENT stmt_list DEDENT
2646
break
suite -> NEWLINE INDENT stmt_list DEDENT
2646
pass
suite -> NEWLINE INDENT stmt_list DEDENT
2646
endsim
suite -> NEWLINE INDENT stmt_list DEDENT
2646
continue
suite -> NEWLINE INDENT stmt_list DEDENT
2646
[
suite -> NEWLINE INDENT stmt_list DEDENT
2646
begsim
suite -> NEWLINE INDENT stmt_list DEDENT
2646
DEDENT
suite -> NEWLINE INDENT stmt_list DEDENT
2646
lambda
suite -> NEWLINE INDENT stmt_list DEDENT
2646
global
suite -> NEWLINE INDENT stmt_list DEDENT
2646
@
suite -> NEWLINE INDENT stmt_list DEDENT
2646
False
suite -> NEWLINE INDENT stmt_list DEDENT
2646
raise
suite -> NEWLINE INDENT stmt_list DEDENT
2646
(
suite -> NEWLINE INDENT stmt_list DEDENT
2646
nonlocal
suite -> NEWLINE INDENT stmt_list DEDENT
2647
if
lambdef_nocond -> lambda varargslist : test_nocond
2647
)
lambdef_nocond -> lambda varargslist : test_nocond
2647
for
lambdef_nocond -> lambda varargslist : test_nocond
2648
factor
268
2648
term
270
2648
(
271
2648
arith_expr
272
2648
NAME
273
2648
[
274
2648
+
275
2648
atom_expr
277
2648
NUMBER
278
2648
atom
279
2648
STRING
280
2648
shift_expr
281
2648
-
282
2648
True
283
2648
not_test
284
2648
and_expr
286
2648
xor_expr
287
2648
False
288
2648
None
289
2648
expr
290
2648
and_test
291
2648
{
292
2648
~
293
2648
power
294
2648
lambda
2586
2648
comparison
296
2648
lambdef_nocond
2588
2648
test_nocond
2660
2648
or_test
2589
2648
not
298
2649
)
lambdef_nocond -> lambda : test_nocond
2649
for
lambdef_nocond -> lambda : test_nocond
2649
if
lambdef_nocond -> lambda : test_nocond
2649
,
lambdef_nocond -> lambda : test_nocond
2650
elif
2556
2650
None
elif_clause -> 
2650
elif_clause
2661
2650
nonlocal
elif_clause -> 
2650
-
elif_clause -> 
2650
NUMBER
elif_clause -> 
2650
class
elif_clause -> 
2650
while
elif_clause -> 
2650
return
elif_clause -> 
2650
try
elif_clause -> 
2650
False
elif_clause -> 
2650
(
elif_clause -> 
2650
NAME
elif_clause -> 
2650
begsim
elif_clause -> 
2650
global
elif_clause -> 
2650
with
elif_clause -> 
2650
continue
elif_clause -> 
2650
else
elif_clause -> 
2650
del
elif_clause -> 
2650
pass
elif_clause -> 
2650
~
elif_clause -> 
2650
endsim
elif_clause -> 
2650
not
elif_clause -> 
2650
yield
elif_clause -> 
2650
{
elif_clause -> 
2650
def
elif_clause -> 
2650
lambda
elif_clause -> 
2650
@
elif_clause -> 
2650
[
elif_clause -> 
2650
if
elif_clause -> 
2650
+
elif_clause -> 
2650
break
elif_clause -> 
2650
STRING
elif_clause -> 
2650
assert
elif_clause -> 
2650
raise
elif_clause -> 
2650
True
elif_clause -> 
2650
resetstats
elif_clause -> 
2650
DEDENT
elif_clause -> 
2650
for
elif_clause -> 
2650
conf
elif_clause -> 
2651
not
if_stmt -> if test : suite elif_clause else : suite
2651
+
if_stmt -> if test : suite elif_clause else : suite
2651
(
if_stmt -> if test : suite elif_clause else : suite
2651
NAME
if_stmt -> if test : suite elif_clause else : suite
2651
class
if_stmt -> if test : suite elif_clause else : suite
2651
nonlocal
if_stmt -> if test : suite elif_clause else : suite
2651
conf
if_stmt -> if test : suite elif_clause else : suite
2651
try
if_stmt -> if test : suite elif_clause else : suite
2651
None
if_stmt -> if test : suite elif_clause else : suite
2651
False
if_stmt -> if test : suite elif_clause else : suite
2651
begsim
if_stmt -> if test : suite elif_clause else : suite
2651
{
if_stmt -> if test : suite elif_clause else : suite
2651
global
if_stmt -> if test : suite elif_clause else : suite
2651
endsim
if_stmt -> if test : suite elif_clause else : suite
2651
DEDENT
if_stmt -> if test : suite elif_clause else : suite
2651
def
if_stmt -> if test : suite elif_clause else : suite
2651
STRING
if_stmt -> if test : suite elif_clause else : suite
2651
[
if_stmt -> if test : suite elif_clause else : suite
2651
raise
if_stmt -> if test : suite elif_clause else : suite
2651
-
if_stmt -> if test : suite elif_clause else : suite
2651
with
if_stmt -> if test : suite elif_clause else : suite
2651
return
if_stmt -> if test : suite elif_clause else : suite
2651
~
if_stmt -> if test : suite elif_clause else : suite
2651
if
if_stmt -> if test : suite elif_clause else : suite
2651
yield
if_stmt -> if test : suite elif_clause else : suite
2651
True
if_stmt -> if test : suite elif_clause else : suite
2651
assert
if_stmt -> if test : suite elif_clause else : suite
2651
lambda
if_stmt -> if test : suite elif_clause else : suite
2651
while
if_stmt -> if test : suite elif_clause else : suite
2651
pass
if_stmt -> if test : suite elif_clause else : suite
2651
break
if_stmt -> if test : suite elif_clause else : suite
2651
resetstats
if_stmt -> if test : suite elif_clause else : suite
2651
del
if_stmt -> if test : suite elif_clause else : suite
2651
continue
if_stmt -> if test : suite elif_clause else : suite
2651
NUMBER
if_stmt -> if test : suite elif_clause else : suite
2651
@
if_stmt -> if test : suite elif_clause else : suite
2651
for
if_stmt -> if test : suite elif_clause else : suite
2652
nonlocal
simple_stmt -> small_stmt NEWLINE
2652
True
simple_stmt -> small_stmt NEWLINE
2652
False
simple_stmt -> small_stmt NEWLINE
2652
(
simple_stmt -> small_stmt NEWLINE
2652
continue
simple_stmt -> small_stmt NEWLINE
2652
begsim
simple_stmt -> small_stmt NEWLINE
2652
NAME
simple_stmt -> small_stmt NEWLINE
2652
endsim
simple_stmt -> small_stmt NEWLINE
2652
DEDENT
simple_stmt -> small_stmt NEWLINE
2652
break
simple_stmt -> small_stmt NEWLINE
2652
return
simple_stmt -> small_stmt NEWLINE
2652
NUMBER
simple_stmt -> small_stmt NEWLINE
2652
[
simple_stmt -> small_stmt NEWLINE
2652
global
simple_stmt -> small_stmt NEWLINE
2652
resetstats
simple_stmt -> small_stmt NEWLINE
2652
yield
simple_stmt -> small_stmt NEWLINE
2652
conf
simple_stmt -> small_stmt NEWLINE
2652
lambda
simple_stmt -> small_stmt NEWLINE
2652
not
simple_stmt -> small_stmt NEWLINE
2652
finally
simple_stmt -> small_stmt NEWLINE
2652
del
simple_stmt -> small_stmt NEWLINE
2652
pass
simple_stmt -> small_stmt NEWLINE
2652
for
simple_stmt -> small_stmt NEWLINE
2652
@
simple_stmt -> small_stmt NEWLINE
2652
with
simple_stmt -> small_stmt NEWLINE
2652
class
simple_stmt -> small_stmt NEWLINE
2652
if
simple_stmt -> small_stmt NEWLINE
2652
assert
simple_stmt -> small_stmt NEWLINE
2652
None
simple_stmt -> small_stmt NEWLINE
2652
+
simple_stmt -> small_stmt NEWLINE
2652
-
simple_stmt -> small_stmt NEWLINE
2652
STRING
simple_stmt -> small_stmt NEWLINE
2652
while
simple_stmt -> small_stmt NEWLINE
2652
{
simple_stmt -> small_stmt NEWLINE
2652
raise
simple_stmt -> small_stmt NEWLINE
2652
~
simple_stmt -> small_stmt NEWLINE
2652
def
simple_stmt -> small_stmt NEWLINE
2652
try
simple_stmt -> small_stmt NEWLINE
2653
:
2662
2654
if
1566
2654
arith_expr
2
2654
try
1567
2654
[
3
2654
class
1568
2654
for
1569
2654
stmt_list
2663
2654
with_stmt
1570
2654
while_stmt
1571
2654
factor
9
2654
@
10
2654
simple_stmt
1572
2654
decorators
1573
2654
return
13
2654
confdef
1574
2654
flow_stmt
15
2654
expr
16
2654
True
17
2654
not_test
18
2654
and_expr
19
2654
def
1575
2654
term
21
2654
xor_expr
22
2654
or_test
23
2654
atom_expr
24
2654
global
25
2654
for_stmt
1576
2654
NUMBER
27
2654
STRING
28
2654
NAME
29
2654
decorator
30
2654
if_stmt
1577
2654
with
1578
2654
endsim
33
2654
classdef
1579
2654
False
35
2654
(
36
2654
and_test
37
2654
conf
1580
2654
comparison
39
2654
lambda
40
2654
while
1581
2654
None
42
2654
try_stmt
1582
2654
funcdef
1583
2654
~
45
2654
decorated
1584
2654
small_stmt
1585
2654
test
48
2654
-
49
2654
shift_expr
50
2654
{
52
2654
lambdef
53
2654
atom
54
2654
+
55
2654
power
56
2654
not
57
2654
compound_stmt
1587
2654
continue
59
2654
del_stmt
60
2654
test_list
61
2654
raise
62
2654
raise_stmt
63
2654
resetstats
64
2654
pass_stmt
65
2654
stmt
1588
2654
nonlocal
66
2654
global_stmt
67
2654
yield
68
2654
continue_stmt
69
2654
assert
70
2654
nonlocal_stmt
71
2654
expr_stmt
72
2654
break_stmt
74
2654
return_stmt
75
2654
break
76
2654
sim_stmt
77
2654
stat_stmt
78
2654
yield_stmt
79
2654
assert_stmt
80
2654
pass
81
2654
begsim
83
2654
del
84
2655
factor
9
2655
arith_expr
2
2655
NAME
29
2655
term
21
2655
[
3
2655
~
45
2655
atom_expr
24
2655
expr
16
2655
power
56
2655
(
36
2655
suite
2664
2655
return
13
2655
small_stmt
2604
2655
flow_stmt
15
2655
True
17
2655
not_test
18
2655
and_expr
19
2655
xor_expr
22
2655
{
52
2655
lambdef
53
2655
atom
54
2655
or_test
23
2655
shift_expr
50
2655
False
35
2655
NEWLINE
2605
2655
-
49
2655
None
42
2655
lambda
40
2655
global
25
2655
NUMBER
27
2655
STRING
28
2655
test
48
2655
endsim
33
2655
and_test
37
2655
simple_stmt
2606
2655
comparison
39
2655
break_stmt
74
2655
+
55
2655
not
57
2655
raise
62
2655
continue
59
2655
return_stmt
75
2655
del_stmt
60
2655
test_list
61
2655
raise_stmt
63
2655
resetstats
64
2655
pass_stmt
65
2655
nonlocal
66
2655
break
76
2655
sim_stmt
77
2655
stat_stmt
78
2655
global_stmt
67
2655
yield_stmt
79
2655
assert_stmt
80
2655
pass
81
2655
yield
68
2655
continue_stmt
69
2655
assert
70
2655
nonlocal_stmt
71
2655
expr_stmt
72
2655
begsim
83
2655
del
84
2656
for
except_clause -> except test : suite maybe_except_clause
2656
DEDENT
except_clause -> except test : suite maybe_except_clause
2656
@
except_clause -> except test : suite maybe_except_clause
2656
resetstats
except_clause -> except test : suite maybe_except_clause
2656
lambda
except_clause -> except test : suite maybe_except_clause
2656
{
except_clause -> except test : suite maybe_except_clause
2656
NUMBER
except_clause -> except test : suite maybe_except_clause
2656
del
except_clause -> except test : suite maybe_except_clause
2656
begsim
except_clause -> except test : suite maybe_except_clause
2656
+
except_clause -> except test : suite maybe_except_clause
2656
break
except_clause -> except test : suite maybe_except_clause
2656
continue
except_clause -> except test : suite maybe_except_clause
2656
assert
except_clause -> except test : suite maybe_except_clause
2656
else
except_clause -> except test : suite maybe_except_clause
2656
NAME
except_clause -> except test : suite maybe_except_clause
2656
None
except_clause -> except test : suite maybe_except_clause
2656
not
except_clause -> except test : suite maybe_except_clause
2656
with
except_clause -> except test : suite maybe_except_clause
2656
global
except_clause -> except test : suite maybe_except_clause
2656
return
except_clause -> except test : suite maybe_except_clause
2656
True
except_clause -> except test : suite maybe_except_clause
2656
class
except_clause -> except test : suite maybe_except_clause
2656
conf
except_clause -> except test : suite maybe_except_clause
2656
while
except_clause -> except test : suite maybe_except_clause
2656
raise
except_clause -> except test : suite maybe_except_clause
2656
try
except_clause -> except test : suite maybe_except_clause
2656
False
except_clause -> except test : suite maybe_except_clause
2656
~
except_clause -> except test : suite maybe_except_clause
2656
finally
except_clause -> except test : suite maybe_except_clause
2656
[
except_clause -> except test : suite maybe_except_clause
2656
nonlocal
except_clause -> except test : suite maybe_except_clause
2656
STRING
except_clause -> except test : suite maybe_except_clause
2656
pass
except_clause -> except test : suite maybe_except_clause
2656
def
except_clause -> except test : suite maybe_except_clause
2656
if
except_clause -> except test : suite maybe_except_clause
2656
(
except_clause -> except test : suite maybe_except_clause
2656
-
except_clause -> except test : suite maybe_except_clause
2656
endsim
except_clause -> except test : suite maybe_except_clause
2656
yield
except_clause -> except test : suite maybe_except_clause
2657
DEDENT
2665
2658
factor
9
2658
arith_expr
2
2658
NAME
29
2658
term
21
2658
[
3
2658
~
45
2658
atom_expr
24
2658
expr
16
2658
power
56
2658
(
36
2658
return
13
2658
small_stmt
1585
2658
flow_stmt
15
2658
True
17
2658
not_test
18
2658
and_expr
19
2658
xor_expr
22
2658
{
52
2658
lambdef
53
2658
atom
54
2658
or_test
23
2658
shift_expr
50
2658
False
35
2658
NEWLINE
2466
2658
-
49
2658
None
42
2658
lambda
40
2658
global
25
2658
NUMBER
27
2658
STRING
28
2658
test
48
2658
endsim
33
2658
and_test
37
2658
simple_stmt
2467
2658
comparison
39
2658
suite
2666
2658
break_stmt
74
2658
+
55
2658
not
57
2658
raise
62
2658
continue
59
2658
return_stmt
75
2658
del_stmt
60
2658
test_list
61
2658
raise_stmt
63
2658
resetstats
64
2658
pass_stmt
65
2658
nonlocal
66
2658
break
76
2658
sim_stmt
77
2658
stat_stmt
78
2658
global_stmt
67
2658
yield_stmt
79
2658
assert_stmt
80
2658
pass
81
2658
yield
68
2658
continue_stmt
69
2658
assert
70
2658
nonlocal_stmt
71
2658
expr_stmt
72
2658
begsim
83
2658
del
84
2659
confbody
2667
2659
NAME
2151
2660
if
lambdef_nocond -> lambda varargslist : test_nocond
2660
)
lambdef_nocond -> lambda varargslist : test_nocond
2660
,
lambdef_nocond -> lambda varargslist : test_nocond
2660
for
lambdef_nocond -> lambda varargslist : test_nocond
2661
+
elif_clause -> elif test : suite elif_clause
2661
nonlocal
elif_clause -> elif test : suite elif_clause
2661
STRING
elif_clause -> elif test : suite elif_clause
2661
lambda
elif_clause -> elif test : suite elif_clause
2661
for
elif_clause -> elif test : suite elif_clause
2661
NUMBER
elif_clause -> elif test : suite elif_clause
2661
if
elif_clause -> elif test : suite elif_clause
2661
NAME
elif_clause -> elif test : suite elif_clause
2661
resetstats
elif_clause -> elif test : suite elif_clause
2661
assert
elif_clause -> elif test : suite elif_clause
2661
raise
elif_clause -> elif test : suite elif_clause
2661
with
elif_clause -> elif test : suite elif_clause
2661
conf
elif_clause -> elif test : suite elif_clause
2661
(
elif_clause -> elif test : suite elif_clause
2661
def
elif_clause -> elif test : suite elif_clause
2661
pass
elif_clause -> elif test : suite elif_clause
2661
return
elif_clause -> elif test : suite elif_clause
2661
-
elif_clause -> elif test : suite elif_clause
2661
class
elif_clause -> elif test : suite elif_clause
2661
not
elif_clause -> elif test : suite elif_clause
2661
[
elif_clause -> elif test : suite elif_clause
2661
False
elif_clause -> elif test : suite elif_clause
2661
endsim
elif_clause -> elif test : suite elif_clause
2661
while
elif_clause -> elif test : suite elif_clause
2661
del
elif_clause -> elif test : suite elif_clause
2661
continue
elif_clause -> elif test : suite elif_clause
2661
break
elif_clause -> elif test : suite elif_clause
2661
yield
elif_clause -> elif test : suite elif_clause
2661
{
elif_clause -> elif test : suite elif_clause
2661
@
elif_clause -> elif test : suite elif_clause
2661
try
elif_clause -> elif test : suite elif_clause
2661
global
elif_clause -> elif test : suite elif_clause
2661
else
elif_clause -> elif test : suite elif_clause
2661
~
elif_clause -> elif test : suite elif_clause
2661
True
elif_clause -> elif test : suite elif_clause
2661
DEDENT
elif_clause -> elif test : suite elif_clause
2661
begsim
elif_clause -> elif test : suite elif_clause
2661
None
elif_clause -> elif test : suite elif_clause
2662
factor
9
2662
arith_expr
2
2662
NAME
29
2662
term
21
2662
[
3
2662
~
45
2662
suite
2668
2662
atom_expr
24
2662
expr
16
2662
power
56
2662
(
36
2662
return
13
2662
small_stmt
1585
2662
flow_stmt
15
2662
True
17
2662
not_test
18
2662
and_expr
19
2662
xor_expr
22
2662
{
52
2662
lambdef
53
2662
atom
54
2662
or_test
23
2662
shift_expr
50
2662
False
35
2662
NEWLINE
2466
2662
-
49
2662
None
42
2662
lambda
40
2662
global
25
2662
NUMBER
27
2662
STRING
28
2662
test
48
2662
endsim
33
2662
and_test
37
2662
simple_stmt
2467
2662
comparison
39
2662
break_stmt
74
2662
+
55
2662
not
57
2662
raise
62
2662
continue
59
2662
return_stmt
75
2662
del_stmt
60
2662
test_list
61
2662
raise_stmt
63
2662
resetstats
64
2662
pass_stmt
65
2662
nonlocal
66
2662
break
76
2662
sim_stmt
77
2662
stat_stmt
78
2662
global_stmt
67
2662
yield_stmt
79
2662
assert_stmt
80
2662
pass
81
2662
yield
68
2662
continue_stmt
69
2662
assert
70
2662
nonlocal_stmt
71
2662
expr_stmt
72
2662
begsim
83
2662
del
84
2663
DEDENT
2669
2664
except
2462
2664
maybe_except_clause
2670
2664
except_clause
2636
2664
global
maybe_except_clause -> 
2664
resetstats
maybe_except_clause -> 
2664
class
maybe_except_clause -> 
2664
def
maybe_except_clause -> 
2664
NAME
maybe_except_clause -> 
2664
DEDENT
maybe_except_clause -> 
2664
NUMBER
maybe_except_clause -> 
2664
lambda
maybe_except_clause -> 
2664
True
maybe_except_clause -> 
2664
else
maybe_except_clause -> 
2664
not
maybe_except_clause -> 
2664
-
maybe_except_clause -> 
2664
~
maybe_except_clause -> 
2664
del
maybe_except_clause -> 
2664
with
maybe_except_clause -> 
2664
pass
maybe_except_clause -> 
2664
if
maybe_except_clause -> 
2664
assert
maybe_except_clause -> 
2664
conf
maybe_except_clause -> 
2664
break
maybe_except_clause -> 
2664
try
maybe_except_clause -> 
2664
while
maybe_except_clause -> 
2664
False
maybe_except_clause -> 
2664
(
maybe_except_clause -> 
2664
None
maybe_except_clause -> 
2664
return
maybe_except_clause -> 
2664
nonlocal
maybe_except_clause -> 
2664
@
maybe_except_clause -> 
2664
yield
maybe_except_clause -> 
2664
finally
maybe_except_clause -> 
2664
{
maybe_except_clause -> 
2664
endsim
maybe_except_clause -> 
2664
for
maybe_except_clause -> 
2664
raise
maybe_except_clause -> 
2664
[
maybe_except_clause -> 
2664
STRING
maybe_except_clause -> 
2664
begsim
maybe_except_clause -> 
2664
+
maybe_except_clause -> 
2664
continue
maybe_except_clause -> 
2665
not
suite -> NEWLINE INDENT stmt_list DEDENT
2665
None
suite -> NEWLINE INDENT stmt_list DEDENT
2665
{
suite -> NEWLINE INDENT stmt_list DEDENT
2665
for
suite -> NEWLINE INDENT stmt_list DEDENT
2665
finally
suite -> NEWLINE INDENT stmt_list DEDENT
2665
try
suite -> NEWLINE INDENT stmt_list DEDENT
2665
class
suite -> NEWLINE INDENT stmt_list DEDENT
2665
while
suite -> NEWLINE INDENT stmt_list DEDENT
2665
-
suite -> NEWLINE INDENT stmt_list DEDENT
2665
if
suite -> NEWLINE INDENT stmt_list DEDENT
2665
+
suite -> NEWLINE INDENT stmt_list DEDENT
2665
resetstats
suite -> NEWLINE INDENT stmt_list DEDENT
2665
return
suite -> NEWLINE INDENT stmt_list DEDENT
2665
with
suite -> NEWLINE INDENT stmt_list DEDENT
2665
else
suite -> NEWLINE INDENT stmt_list DEDENT
2665
except
suite -> NEWLINE INDENT stmt_list DEDENT
2665
STRING
suite -> NEWLINE INDENT stmt_list DEDENT
2665
conf
suite -> NEWLINE INDENT stmt_list DEDENT
2665
assert
suite -> NEWLINE INDENT stmt_list DEDENT
2665
def
suite -> NEWLINE INDENT stmt_list DEDENT
2665
NAME
suite -> NEWLINE INDENT stmt_list DEDENT
2665
~
suite -> NEWLINE INDENT stmt_list DEDENT
2665
yield
suite -> NEWLINE INDENT stmt_list DEDENT
2665
NUMBER
suite -> NEWLINE INDENT stmt_list DEDENT
2665
del
suite -> NEWLINE INDENT stmt_list DEDENT
2665
True
suite -> NEWLINE INDENT stmt_list DEDENT
2665
break
suite -> NEWLINE INDENT stmt_list DEDENT
2665
pass
suite -> NEWLINE INDENT stmt_list DEDENT
2665
endsim
suite -> NEWLINE INDENT stmt_list DEDENT
2665
continue
suite -> NEWLINE INDENT stmt_list DEDENT
2665
[
suite -> NEWLINE INDENT stmt_list DEDENT
2665
begsim
suite -> NEWLINE INDENT stmt_list DEDENT
2665
DEDENT
suite -> NEWLINE INDENT stmt_list DEDENT
2665
lambda
suite -> NEWLINE INDENT stmt_list DEDENT
2665
global
suite -> NEWLINE INDENT stmt_list DEDENT
2665
@
suite -> NEWLINE INDENT stmt_list DEDENT
2665
False
suite -> NEWLINE INDENT stmt_list DEDENT
2665
raise
suite -> NEWLINE INDENT stmt_list DEDENT
2665
(
suite -> NEWLINE INDENT stmt_list DEDENT
2665
nonlocal
suite -> NEWLINE INDENT stmt_list DEDENT
2666
while
for_stmt -> for expr_list in test_list : suite else : suite
2666
lambda
for_stmt -> for expr_list in test_list : suite else : suite
2666
return
for_stmt -> for expr_list in test_list : suite else : suite
2666
[
for_stmt -> for expr_list in test_list : suite else : suite
2666
nonlocal
for_stmt -> for expr_list in test_list : suite else : suite
2666
assert
for_stmt -> for expr_list in test_list : suite else : suite
2666
~
for_stmt -> for expr_list in test_list : suite else : suite
2666
with
for_stmt -> for expr_list in test_list : suite else : suite
2666
STRING
for_stmt -> for expr_list in test_list : suite else : suite
2666
endsim
for_stmt -> for expr_list in test_list : suite else : suite
2666
try
for_stmt -> for expr_list in test_list : suite else : suite
2666
None
for_stmt -> for expr_list in test_list : suite else : suite
2666
not
for_stmt -> for expr_list in test_list : suite else : suite
2666
True
for_stmt -> for expr_list in test_list : suite else : suite
2666
continue
for_stmt -> for expr_list in test_list : suite else : suite
2666
+
for_stmt -> for expr_list in test_list : suite else : suite
2666
begsim
for_stmt -> for expr_list in test_list : suite else : suite
2666
del
for_stmt -> for expr_list in test_list : suite else : suite
2666
break
for_stmt -> for expr_list in test_list : suite else : suite
2666
-
for_stmt -> for expr_list in test_list : suite else : suite
2666
class
for_stmt -> for expr_list in test_list : suite else : suite
2666
pass
for_stmt -> for expr_list in test_list : suite else : suite
2666
@
for_stmt -> for expr_list in test_list : suite else : suite
2666
raise
for_stmt -> for expr_list in test_list : suite else : suite
2666
{
for_stmt -> for expr_list in test_list : suite else : suite
2666
NUMBER
for_stmt -> for expr_list in test_list : suite else : suite
2666
for
for_stmt -> for expr_list in test_list : suite else : suite
2666
def
for_stmt -> for expr_list in test_list : suite else : suite
2666
DEDENT
for_stmt -> for expr_list in test_list : suite else : suite
2666
global
for_stmt -> for expr_list in test_list : suite else : suite
2666
resetstats
for_stmt -> for expr_list in test_list : suite else : suite
2666
yield
for_stmt -> for expr_list in test_list : suite else : suite
2666
False
for_stmt -> for expr_list in test_list : suite else : suite
2666
(
for_stmt -> for expr_list in test_list : suite else : suite
2666
if
for_stmt -> for expr_list in test_list : suite else : suite
2666
NAME
for_stmt -> for expr_list in test_list : suite else : suite
2666
conf
for_stmt -> for expr_list in test_list : suite else : suite
2667
DEDENT
2671
2668
-
try_stmt -> try : suite except_clause else : suite finally : suite
2668
assert
try_stmt -> try : suite except_clause else : suite finally : suite
2668
raise
try_stmt -> try : suite except_clause else : suite finally : suite
2668
+
try_stmt -> try : suite except_clause else : suite finally : suite
2668
class
try_stmt -> try : suite except_clause else : suite finally : suite
2668
DEDENT
try_stmt -> try : suite except_clause else : suite finally : suite
2668
(
try_stmt -> try : suite except_clause else : suite finally : suite
2668
nonlocal
try_stmt -> try : suite except_clause else : suite finally : suite
2668
return
try_stmt -> try : suite except_clause else : suite finally : suite
2668
try
try_stmt -> try : suite except_clause else : suite finally : suite
2668
if
try_stmt -> try : suite except_clause else : suite finally : suite
2668
True
try_stmt -> try : suite except_clause else : suite finally : suite
2668
continue
try_stmt -> try : suite except_clause else : suite finally : suite
2668
pass
try_stmt -> try : suite except_clause else : suite finally : suite
2668
[
try_stmt -> try : suite except_clause else : suite finally : suite
2668
@
try_stmt -> try : suite except_clause else : suite finally : suite
2668
with
try_stmt -> try : suite except_clause else : suite finally : suite
2668
conf
try_stmt -> try : suite except_clause else : suite finally : suite
2668
while
try_stmt -> try : suite except_clause else : suite finally : suite
2668
yield
try_stmt -> try : suite except_clause else : suite finally : suite
2668
for
try_stmt -> try : suite except_clause else : suite finally : suite
2668
break
try_stmt -> try : suite except_clause else : suite finally : suite
2668
resetstats
try_stmt -> try : suite except_clause else : suite finally : suite
2668
STRING
try_stmt -> try : suite except_clause else : suite finally : suite
2668
global
try_stmt -> try : suite except_clause else : suite finally : suite
2668
{
try_stmt -> try : suite except_clause else : suite finally : suite
2668
def
try_stmt -> try : suite except_clause else : suite finally : suite
2668
not
try_stmt -> try : suite except_clause else : suite finally : suite
2668
NAME
try_stmt -> try : suite except_clause else : suite finally : suite
2668
begsim
try_stmt -> try : suite except_clause else : suite finally : suite
2668
~
try_stmt -> try : suite except_clause else : suite finally : suite
2668
del
try_stmt -> try : suite except_clause else : suite finally : suite
2668
lambda
try_stmt -> try : suite except_clause else : suite finally : suite
2668
endsim
try_stmt -> try : suite except_clause else : suite finally : suite
2668
False
try_stmt -> try : suite except_clause else : suite finally : suite
2668
None
try_stmt -> try : suite except_clause else : suite finally : suite
2668
NUMBER
try_stmt -> try : suite except_clause else : suite finally : suite
2669
not
suite -> NEWLINE INDENT stmt_list DEDENT
2669
None
suite -> NEWLINE INDENT stmt_list DEDENT
2669
{
suite -> NEWLINE INDENT stmt_list DEDENT
2669
for
suite -> NEWLINE INDENT stmt_list DEDENT
2669
finally
suite -> NEWLINE INDENT stmt_list DEDENT
2669
try
suite -> NEWLINE INDENT stmt_list DEDENT
2669
class
suite -> NEWLINE INDENT stmt_list DEDENT
2669
while
suite -> NEWLINE INDENT stmt_list DEDENT
2669
-
suite -> NEWLINE INDENT stmt_list DEDENT
2669
if
suite -> NEWLINE INDENT stmt_list DEDENT
2669
+
suite -> NEWLINE INDENT stmt_list DEDENT
2669
resetstats
suite -> NEWLINE INDENT stmt_list DEDENT
2669
return
suite -> NEWLINE INDENT stmt_list DEDENT
2669
with
suite -> NEWLINE INDENT stmt_list DEDENT
2669
NAME
suite -> NEWLINE INDENT stmt_list DEDENT
2669
~
suite -> NEWLINE INDENT stmt_list DEDENT
2669
STRING
suite -> NEWLINE INDENT stmt_list DEDENT
2669
conf
suite -> NEWLINE INDENT stmt_list DEDENT
2669
assert
suite -> NEWLINE INDENT stmt_list DEDENT
2669
def
suite -> NEWLINE INDENT stmt_list DEDENT
2669
yield
suite -> NEWLINE INDENT stmt_list DEDENT
2669
NUMBER
suite -> NEWLINE INDENT stmt_list DEDENT
2669
del
suite -> NEWLINE INDENT stmt_list DEDENT
2669
True
suite -> NEWLINE INDENT stmt_list DEDENT
2669
break
suite -> NEWLINE INDENT stmt_list DEDENT
2669
pass
suite -> NEWLINE INDENT stmt_list DEDENT
2669
endsim
suite -> NEWLINE INDENT stmt_list DEDENT
2669
continue
suite -> NEWLINE INDENT stmt_list DEDENT
2669
[
suite -> NEWLINE INDENT stmt_list DEDENT
2669
begsim
suite -> NEWLINE INDENT stmt_list DEDENT
2669
DEDENT
suite -> NEWLINE INDENT stmt_list DEDENT
2669
lambda
suite -> NEWLINE INDENT stmt_list DEDENT
2669
global
suite -> NEWLINE INDENT stmt_list DEDENT
2669
@
suite -> NEWLINE INDENT stmt_list DEDENT
2669
False
suite -> NEWLINE INDENT stmt_list DEDENT
2669
raise
suite -> NEWLINE INDENT stmt_list DEDENT
2669
(
suite -> NEWLINE INDENT stmt_list DEDENT
2669
nonlocal
suite -> NEWLINE INDENT stmt_list DEDENT
2670
for
except_clause -> except test as NAME : suite maybe_except_clause
2670
+
except_clause -> except test as NAME : suite maybe_except_clause
2670
break
except_clause -> except test as NAME : suite maybe_except_clause
2670
def
except_clause -> except test as NAME : suite maybe_except_clause
2670
NAME
except_clause -> except test as NAME : suite maybe_except_clause
2670
while
except_clause -> except test as NAME : suite maybe_except_clause
2670
(
except_clause -> except test as NAME : suite maybe_except_clause
2670
None
except_clause -> except test as NAME : suite maybe_except_clause
2670
[
except_clause -> except test as NAME : suite maybe_except_clause
2670
else
except_clause -> except test as NAME : suite maybe_except_clause
2670
conf
except_clause -> except test as NAME : suite maybe_except_clause
2670
NUMBER
except_clause -> except test as NAME : suite maybe_except_clause
2670
begsim
except_clause -> except test as NAME : suite maybe_except_clause
2670
@
except_clause -> except test as NAME : suite maybe_except_clause
2670
STRING
except_clause -> except test as NAME : suite maybe_except_clause
2670
global
except_clause -> except test as NAME : suite maybe_except_clause
2670
assert
except_clause -> except test as NAME : suite maybe_except_clause
2670
pass
except_clause -> except test as NAME : suite maybe_except_clause
2670
lambda
except_clause -> except test as NAME : suite maybe_except_clause
2670
{
except_clause -> except test as NAME : suite maybe_except_clause
2670
finally
except_clause -> except test as NAME : suite maybe_except_clause
2670
resetstats
except_clause -> except test as NAME : suite maybe_except_clause
2670
endsim
except_clause -> except test as NAME : suite maybe_except_clause
2670
try
except_clause -> except test as NAME : suite maybe_except_clause
2670
continue
except_clause -> except test as NAME : suite maybe_except_clause
2670
raise
except_clause -> except test as NAME : suite maybe_except_clause
2670
~
except_clause -> except test as NAME : suite maybe_except_clause
2670
-
except_clause -> except test as NAME : suite maybe_except_clause
2670
not
except_clause -> except test as NAME : suite maybe_except_clause
2670
class
except_clause -> except test as NAME : suite maybe_except_clause
2670
DEDENT
except_clause -> except test as NAME : suite maybe_except_clause
2670
nonlocal
except_clause -> except test as NAME : suite maybe_except_clause
2670
return
except_clause -> except test as NAME : suite maybe_except_clause
2670
del
except_clause -> except test as NAME : suite maybe_except_clause
2670
if
except_clause -> except test as NAME : suite maybe_except_clause
2670
with
except_clause -> except test as NAME : suite maybe_except_clause
2670
yield
except_clause -> except test as NAME : suite maybe_except_clause
2670
False
except_clause -> except test as NAME : suite maybe_except_clause
2670
True
except_clause -> except test as NAME : suite maybe_except_clause
2671
not
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
resetstats
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
(
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
global
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
try
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
+
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
~
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
nonlocal
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
del
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
assert
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
False
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
lambda
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
conf
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
STRING
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
[
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
NAME
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
@
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
continue
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
begsim
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
with
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
DEDENT
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
for
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
endsim
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
while
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
return
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
yield
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
pass
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
raise
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
break
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
def
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
-
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
{
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
None
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
if
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
NUMBER
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
True
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
2671
class
confdef -> conf NAME ( NAME ) : NEWLINE INDENT confbody DEDENT
